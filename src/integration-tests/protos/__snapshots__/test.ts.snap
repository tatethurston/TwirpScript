// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`TwirpScript Compiler generates JavaScript 1`] = `
{
  "array": [
    ,
    1,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    [
      [
        "twirpscript/services.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: twirpscript/services.proto
/* eslint-disable */

import { BinaryReader, BinaryWriter } from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";

//========================================//
//      Haberdasher Protobuf Client       //
//========================================//

/**
 * MakeHat produces a hat of mysterious, randomly-selected color!
 */
export async function MakeHat(makeHat, config) {
  const response = await PBrequest(
    "/Haberdasher/MakeHat",
    Req.MakeHat.encode(makeHat),
    config
  );
  return Hat.decode(response);
}

//========================================//
//        Haberdasher JSON Client         //
//========================================//

/**
 * MakeHat produces a hat of mysterious, randomly-selected color!
 */
export async function MakeHatJSON(makeHat, config) {
  const response = await JSONrequest(
    "/Haberdasher/MakeHat",
    ReqJSON.MakeHat.encode(makeHat),
    config
  );
  return HatJSON.decode(response);
}

export function createHaberdasher(service) {
  return {
    name: "Haberdasher",
    methods: {
      MakeHat: {
        name: "MakeHat",
        handler: service.MakeHat,
        input: { protobuf: Req.MakeHat, json: ReqJSON.MakeHat },
        output: { protobuf: Hat, json: HatJSON },
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Req = {
  /**
   * Serializes Req to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes Req from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },

  MakeHat: {
    /**
     * Serializes Req.MakeHat to protobuf.
     */
    encode: function (msg) {
      return Req.MakeHat._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.MakeHat from protobuf.
     */
    decode: function (bytes) {
      return Req.MakeHat._readMessage(
        Req.MakeHat.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.MakeHat with all fields set to their default value.
     */
    initialize: function () {
      return {
        inches: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.inches) {
        writer.writeInt32(1, msg.inches);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.inches = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Hat = {
  /**
   * Serializes Hat to protobuf.
   */
  encode: function (msg) {
    return Hat._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Hat from protobuf.
   */
  decode: function (bytes) {
    return Hat._readMessage(Hat.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Hat with all fields set to their default value.
   */
  initialize: function () {
    return {
      inches: 0,
      color: "",
      name: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.inches) {
      writer.writeInt32(1, msg.inches);
    }
    if (msg.color) {
      writer.writeString(2, msg.color);
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.inches = reader.readInt32();
          break;
        }
        case 2: {
          msg.color = reader.readString();
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ReqJSON = {
  /**
   * Serializes Req to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes Req from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },

  MakeHat: {
    /**
     * Serializes Req.MakeHat to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(ReqJSON.MakeHat._writeMessage(msg));
    },

    /**
     * Deserializes Req.MakeHat from JSON.
     */
    decode: function (json) {
      return ReqJSON.MakeHat._readMessage(
        ReqJSON.MakeHat.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.MakeHat with all fields set to their default value.
     */
    initialize: function () {
      return {
        inches: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.inches) {
        json["inches"] = msg.inches;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _inches_ = json["inches"];
      if (_inches_) {
        msg.inches = _inches_;
      }
      return msg;
    },
  },
};

export const HatJSON = {
  /**
   * Serializes Hat to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(HatJSON._writeMessage(msg));
  },

  /**
   * Deserializes Hat from JSON.
   */
  decode: function (json) {
    return HatJSON._readMessage(HatJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Hat with all fields set to their default value.
   */
  initialize: function () {
    return {
      inches: 0,
      color: "",
      name: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.inches) {
      json["inches"] = msg.inches;
    }
    if (msg.color) {
      json["color"] = msg.color;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _inches_ = json["inches"];
    if (_inches_) {
      msg.inches = _inches_;
    }
    const _color_ = json["color"];
    if (_color_) {
      msg.color = _color_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    return msg;
  },
};
",
      ],
      [
        "twirpscript/empty.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: twirpscript/empty.proto
/* eslint-disable */

import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";

import * as protoscript from "protoscript";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(empty, config) {
  const response = await PBrequest(
    "/Foo/Bar",
    protoscript.Empty.encode(empty),
    config
  );
  return protoscript.Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(empty, config) {
  const response = await JSONrequest(
    "/Foo/Bar",
    protoscript.EmptyJSON.encode(empty),
    config
  );
  return protoscript.EmptyJSON.decode(response);
}

export function createFoo(service) {
  return {
    name: "Foo",
    methods: {
      Bar: {
        name: "Bar",
        handler: service.Bar,
        input: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
        output: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
      },
    },
  };
}
",
      ],
      [
        "google/protobuf/unittest_import_public.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto
/* eslint-disable */

import { BinaryReader, BinaryWriter } from "protoscript";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes PublicImportMessage to protobuf.
   */
  encode: function (msg) {
    return PublicImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes PublicImportMessage from protobuf.
   */
  decode: function (bytes) {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes PublicImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const PublicImportMessageJSON = {
  /**
   * Serializes PublicImportMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(PublicImportMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes PublicImportMessage from JSON.
   */
  decode: function (json) {
    return PublicImportMessageJSON._readMessage(
      PublicImportMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes PublicImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.e) {
      json["e"] = msg.e;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _e_ = json["e"];
    if (_e_) {
      msg.e = _e_;
    }
    return msg;
  },
};
",
      ],
      [
        "google/protobuf/unittest_import.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto
/* eslint-disable */

import { BinaryReader, BinaryWriter } from "protoscript";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: "IMPORT_FOO",
  IMPORT_BAR: "IMPORT_BAR",
  IMPORT_BAZ: "IMPORT_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 7: {
        return "IMPORT_FOO";
      }
      case 8: {
        return "IMPORT_BAR";
      }
      case 9: {
        return "IMPORT_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "IMPORT_FOO": {
        return 7;
      }
      case "IMPORT_BAR": {
        return 8;
      }
      case "IMPORT_BAZ": {
        return 9;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const ImportEnumForMap = {
  UNKNOWN: "UNKNOWN",
  FOO: "FOO",
  BAR: "BAR",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "FOO";
      }
      case 2: {
        return "BAR";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "FOO": {
        return 1;
      }
      case "BAR": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const ImportMessage = {
  /**
   * Serializes ImportMessage to protobuf.
   */
  encode: function (msg) {
    return ImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ImportMessage from protobuf.
   */
  decode: function (bytes) {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ImportEnumJSON = {
  IMPORT_FOO: "IMPORT_FOO",
  IMPORT_BAR: "IMPORT_BAR",
  IMPORT_BAZ: "IMPORT_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 7: {
        return "IMPORT_FOO";
      }
      case 8: {
        return "IMPORT_BAR";
      }
      case 9: {
        return "IMPORT_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "IMPORT_FOO": {
        return 7;
      }
      case "IMPORT_BAR": {
        return 8;
      }
      case "IMPORT_BAZ": {
        return 9;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const ImportEnumForMapJSON = {
  UNKNOWN: "UNKNOWN",
  FOO: "FOO",
  BAR: "BAR",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "FOO";
      }
      case 2: {
        return "BAR";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "FOO": {
        return 1;
      }
      case "BAR": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const ImportMessageJSON = {
  /**
   * Serializes ImportMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(ImportMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ImportMessage from JSON.
   */
  decode: function (json) {
    return ImportMessageJSON._readMessage(
      ImportMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.d) {
      json["d"] = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _d_ = json["d"];
    if (_d_) {
      msg.d = _d_;
    }
    return msg;
  },
};
",
      ],
      [
        "google/protobuf/unittest.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto
/* eslint-disable */

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";

import * as googleProtobufUnittest_import from "./unittest_import.pb.js";
import * as googleProtobufUnittest_import_public from "./unittest_import_public.pb.js";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(fooRequest, config) {
  const response = await PBrequest(
    "/protobuf_unittest.TestService/Foo",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(barRequest, config) {
  const response = await PBrequest(
    "/protobuf_unittest.TestService/Bar",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(fooRequest, config) {
  const response = await JSONrequest(
    "/protobuf_unittest.TestService/Foo",
    FooRequestJSON.encode(fooRequest),
    config
  );
  return FooResponseJSON.decode(response);
}

export async function BarJSON(barRequest, config) {
  const response = await JSONrequest(
    "/protobuf_unittest.TestService/Bar",
    BarRequestJSON.encode(barRequest),
    config
  );
  return BarResponseJSON.decode(response);
}

export function createTestService(service) {
  return {
    name: "protobuf_unittest.TestService",
    methods: {
      Foo: {
        name: "Foo",
        handler: service.Foo,
        input: { protobuf: FooRequest, json: FooRequestJSON },
        output: { protobuf: FooResponse, json: FooResponseJSON },
      },
      Bar: {
        name: "Bar",
        handler: service.Bar,
        input: { protobuf: BarRequest, json: BarRequestJSON },
        output: { protobuf: BarResponse, json: BarResponseJSON },
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestEnumWithDupValue = {
  FOO1: "FOO1",
  BAR1: "BAR1",
  BAZ: "BAZ",
  FOO2: "FOO2",
  BAR2: "BAR2",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 1: {
        return "FOO1";
      }
      case 2: {
        return "BAR1";
      }
      case 3: {
        return "BAZ";
      }
      case 1: {
        return "FOO2";
      }
      case 2: {
        return "BAR2";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOO1": {
        return 1;
      }
      case "BAR1": {
        return 2;
      }
      case "BAZ": {
        return 3;
      }
      case "FOO2": {
        return 1;
      }
      case "BAR2": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestSparseEnum = {
  SPARSE_A: "SPARSE_A",
  SPARSE_B: "SPARSE_B",
  SPARSE_C: "SPARSE_C",
  SPARSE_D: "SPARSE_D",
  SPARSE_E: "SPARSE_E",
  SPARSE_F: "SPARSE_F",
  SPARSE_G: "SPARSE_G",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 123: {
        return "SPARSE_A";
      }
      case 62374: {
        return "SPARSE_B";
      }
      case 12589234: {
        return "SPARSE_C";
      }
      case -15: {
        return "SPARSE_D";
      }
      case -53452: {
        return "SPARSE_E";
      }
      case 0: {
        return "SPARSE_F";
      }
      case 2: {
        return "SPARSE_G";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "SPARSE_A": {
        return 123;
      }
      case "SPARSE_B": {
        return 62374;
      }
      case "SPARSE_C": {
        return 12589234;
      }
      case "SPARSE_D": {
        return -15;
      }
      case "SPARSE_E": {
        return -53452;
      }
      case "SPARSE_F": {
        return 0;
      }
      case "SPARSE_G": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: "ENUM_LABEL_DEFAULT",
  ENUM_LABEL_1: "ENUM_LABEL_1",
  ENUM_LABEL_2: "ENUM_LABEL_2",
  ENUM_LABEL_3: "ENUM_LABEL_3",
  ENUM_LABEL_4: "ENUM_LABEL_4",
  ENUM_LABEL_5: "ENUM_LABEL_5",
  ENUM_LABEL_6: "ENUM_LABEL_6",
  ENUM_LABEL_7: "ENUM_LABEL_7",
  ENUM_LABEL_8: "ENUM_LABEL_8",
  ENUM_LABEL_9: "ENUM_LABEL_9",
  ENUM_LABEL_10: "ENUM_LABEL_10",
  ENUM_LABEL_11: "ENUM_LABEL_11",
  ENUM_LABEL_12: "ENUM_LABEL_12",
  ENUM_LABEL_13: "ENUM_LABEL_13",
  ENUM_LABEL_14: "ENUM_LABEL_14",
  ENUM_LABEL_15: "ENUM_LABEL_15",
  ENUM_LABEL_16: "ENUM_LABEL_16",
  ENUM_LABEL_17: "ENUM_LABEL_17",
  ENUM_LABEL_18: "ENUM_LABEL_18",
  ENUM_LABEL_19: "ENUM_LABEL_19",
  ENUM_LABEL_20: "ENUM_LABEL_20",
  ENUM_LABEL_21: "ENUM_LABEL_21",
  ENUM_LABEL_22: "ENUM_LABEL_22",
  ENUM_LABEL_23: "ENUM_LABEL_23",
  ENUM_LABEL_24: "ENUM_LABEL_24",
  ENUM_LABEL_25: "ENUM_LABEL_25",
  ENUM_LABEL_26: "ENUM_LABEL_26",
  ENUM_LABEL_27: "ENUM_LABEL_27",
  ENUM_LABEL_28: "ENUM_LABEL_28",
  ENUM_LABEL_29: "ENUM_LABEL_29",
  ENUM_LABEL_30: "ENUM_LABEL_30",
  ENUM_LABEL_31: "ENUM_LABEL_31",
  ENUM_LABEL_32: "ENUM_LABEL_32",
  ENUM_LABEL_33: "ENUM_LABEL_33",
  ENUM_LABEL_34: "ENUM_LABEL_34",
  ENUM_LABEL_35: "ENUM_LABEL_35",
  ENUM_LABEL_36: "ENUM_LABEL_36",
  ENUM_LABEL_37: "ENUM_LABEL_37",
  ENUM_LABEL_38: "ENUM_LABEL_38",
  ENUM_LABEL_39: "ENUM_LABEL_39",
  ENUM_LABEL_40: "ENUM_LABEL_40",
  ENUM_LABEL_41: "ENUM_LABEL_41",
  ENUM_LABEL_42: "ENUM_LABEL_42",
  ENUM_LABEL_43: "ENUM_LABEL_43",
  ENUM_LABEL_44: "ENUM_LABEL_44",
  ENUM_LABEL_45: "ENUM_LABEL_45",
  ENUM_LABEL_46: "ENUM_LABEL_46",
  ENUM_LABEL_47: "ENUM_LABEL_47",
  ENUM_LABEL_48: "ENUM_LABEL_48",
  ENUM_LABEL_49: "ENUM_LABEL_49",
  ENUM_LABEL_50: "ENUM_LABEL_50",
  ENUM_LABEL_51: "ENUM_LABEL_51",
  ENUM_LABEL_52: "ENUM_LABEL_52",
  ENUM_LABEL_53: "ENUM_LABEL_53",
  ENUM_LABEL_54: "ENUM_LABEL_54",
  ENUM_LABEL_55: "ENUM_LABEL_55",
  ENUM_LABEL_56: "ENUM_LABEL_56",
  ENUM_LABEL_57: "ENUM_LABEL_57",
  ENUM_LABEL_58: "ENUM_LABEL_58",
  ENUM_LABEL_59: "ENUM_LABEL_59",
  ENUM_LABEL_60: "ENUM_LABEL_60",
  ENUM_LABEL_61: "ENUM_LABEL_61",
  ENUM_LABEL_62: "ENUM_LABEL_62",
  ENUM_LABEL_63: "ENUM_LABEL_63",
  ENUM_LABEL_64: "ENUM_LABEL_64",
  ENUM_LABEL_65: "ENUM_LABEL_65",
  ENUM_LABEL_66: "ENUM_LABEL_66",
  ENUM_LABEL_67: "ENUM_LABEL_67",
  ENUM_LABEL_68: "ENUM_LABEL_68",
  ENUM_LABEL_69: "ENUM_LABEL_69",
  ENUM_LABEL_70: "ENUM_LABEL_70",
  ENUM_LABEL_71: "ENUM_LABEL_71",
  ENUM_LABEL_72: "ENUM_LABEL_72",
  ENUM_LABEL_73: "ENUM_LABEL_73",
  ENUM_LABEL_74: "ENUM_LABEL_74",
  ENUM_LABEL_75: "ENUM_LABEL_75",
  ENUM_LABEL_76: "ENUM_LABEL_76",
  ENUM_LABEL_77: "ENUM_LABEL_77",
  ENUM_LABEL_78: "ENUM_LABEL_78",
  ENUM_LABEL_79: "ENUM_LABEL_79",
  ENUM_LABEL_80: "ENUM_LABEL_80",
  ENUM_LABEL_81: "ENUM_LABEL_81",
  ENUM_LABEL_82: "ENUM_LABEL_82",
  ENUM_LABEL_83: "ENUM_LABEL_83",
  ENUM_LABEL_84: "ENUM_LABEL_84",
  ENUM_LABEL_85: "ENUM_LABEL_85",
  ENUM_LABEL_86: "ENUM_LABEL_86",
  ENUM_LABEL_87: "ENUM_LABEL_87",
  ENUM_LABEL_88: "ENUM_LABEL_88",
  ENUM_LABEL_89: "ENUM_LABEL_89",
  ENUM_LABEL_90: "ENUM_LABEL_90",
  ENUM_LABEL_91: "ENUM_LABEL_91",
  ENUM_LABEL_92: "ENUM_LABEL_92",
  ENUM_LABEL_93: "ENUM_LABEL_93",
  ENUM_LABEL_94: "ENUM_LABEL_94",
  ENUM_LABEL_95: "ENUM_LABEL_95",
  ENUM_LABEL_96: "ENUM_LABEL_96",
  ENUM_LABEL_97: "ENUM_LABEL_97",
  ENUM_LABEL_98: "ENUM_LABEL_98",
  ENUM_LABEL_99: "ENUM_LABEL_99",
  ENUM_LABEL_100: "ENUM_LABEL_100",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "ENUM_LABEL_DEFAULT";
      }
      case 1: {
        return "ENUM_LABEL_1";
      }
      case 2: {
        return "ENUM_LABEL_2";
      }
      case 3: {
        return "ENUM_LABEL_3";
      }
      case 4: {
        return "ENUM_LABEL_4";
      }
      case 5: {
        return "ENUM_LABEL_5";
      }
      case 6: {
        return "ENUM_LABEL_6";
      }
      case 7: {
        return "ENUM_LABEL_7";
      }
      case 8: {
        return "ENUM_LABEL_8";
      }
      case 9: {
        return "ENUM_LABEL_9";
      }
      case 10: {
        return "ENUM_LABEL_10";
      }
      case 11: {
        return "ENUM_LABEL_11";
      }
      case 12: {
        return "ENUM_LABEL_12";
      }
      case 13: {
        return "ENUM_LABEL_13";
      }
      case 14: {
        return "ENUM_LABEL_14";
      }
      case 15: {
        return "ENUM_LABEL_15";
      }
      case 16: {
        return "ENUM_LABEL_16";
      }
      case 17: {
        return "ENUM_LABEL_17";
      }
      case 18: {
        return "ENUM_LABEL_18";
      }
      case 19: {
        return "ENUM_LABEL_19";
      }
      case 20: {
        return "ENUM_LABEL_20";
      }
      case 21: {
        return "ENUM_LABEL_21";
      }
      case 22: {
        return "ENUM_LABEL_22";
      }
      case 23: {
        return "ENUM_LABEL_23";
      }
      case 24: {
        return "ENUM_LABEL_24";
      }
      case 25: {
        return "ENUM_LABEL_25";
      }
      case 26: {
        return "ENUM_LABEL_26";
      }
      case 27: {
        return "ENUM_LABEL_27";
      }
      case 28: {
        return "ENUM_LABEL_28";
      }
      case 29: {
        return "ENUM_LABEL_29";
      }
      case 30: {
        return "ENUM_LABEL_30";
      }
      case 31: {
        return "ENUM_LABEL_31";
      }
      case 32: {
        return "ENUM_LABEL_32";
      }
      case 33: {
        return "ENUM_LABEL_33";
      }
      case 34: {
        return "ENUM_LABEL_34";
      }
      case 35: {
        return "ENUM_LABEL_35";
      }
      case 36: {
        return "ENUM_LABEL_36";
      }
      case 37: {
        return "ENUM_LABEL_37";
      }
      case 38: {
        return "ENUM_LABEL_38";
      }
      case 39: {
        return "ENUM_LABEL_39";
      }
      case 40: {
        return "ENUM_LABEL_40";
      }
      case 41: {
        return "ENUM_LABEL_41";
      }
      case 42: {
        return "ENUM_LABEL_42";
      }
      case 43: {
        return "ENUM_LABEL_43";
      }
      case 44: {
        return "ENUM_LABEL_44";
      }
      case 45: {
        return "ENUM_LABEL_45";
      }
      case 46: {
        return "ENUM_LABEL_46";
      }
      case 47: {
        return "ENUM_LABEL_47";
      }
      case 48: {
        return "ENUM_LABEL_48";
      }
      case 49: {
        return "ENUM_LABEL_49";
      }
      case 50: {
        return "ENUM_LABEL_50";
      }
      case 51: {
        return "ENUM_LABEL_51";
      }
      case 52: {
        return "ENUM_LABEL_52";
      }
      case 53: {
        return "ENUM_LABEL_53";
      }
      case 54: {
        return "ENUM_LABEL_54";
      }
      case 55: {
        return "ENUM_LABEL_55";
      }
      case 56: {
        return "ENUM_LABEL_56";
      }
      case 57: {
        return "ENUM_LABEL_57";
      }
      case 58: {
        return "ENUM_LABEL_58";
      }
      case 59: {
        return "ENUM_LABEL_59";
      }
      case 60: {
        return "ENUM_LABEL_60";
      }
      case 61: {
        return "ENUM_LABEL_61";
      }
      case 62: {
        return "ENUM_LABEL_62";
      }
      case 63: {
        return "ENUM_LABEL_63";
      }
      case 64: {
        return "ENUM_LABEL_64";
      }
      case 65: {
        return "ENUM_LABEL_65";
      }
      case 66: {
        return "ENUM_LABEL_66";
      }
      case 67: {
        return "ENUM_LABEL_67";
      }
      case 68: {
        return "ENUM_LABEL_68";
      }
      case 69: {
        return "ENUM_LABEL_69";
      }
      case 70: {
        return "ENUM_LABEL_70";
      }
      case 71: {
        return "ENUM_LABEL_71";
      }
      case 72: {
        return "ENUM_LABEL_72";
      }
      case 73: {
        return "ENUM_LABEL_73";
      }
      case 74: {
        return "ENUM_LABEL_74";
      }
      case 75: {
        return "ENUM_LABEL_75";
      }
      case 76: {
        return "ENUM_LABEL_76";
      }
      case 77: {
        return "ENUM_LABEL_77";
      }
      case 78: {
        return "ENUM_LABEL_78";
      }
      case 79: {
        return "ENUM_LABEL_79";
      }
      case 80: {
        return "ENUM_LABEL_80";
      }
      case 81: {
        return "ENUM_LABEL_81";
      }
      case 82: {
        return "ENUM_LABEL_82";
      }
      case 83: {
        return "ENUM_LABEL_83";
      }
      case 84: {
        return "ENUM_LABEL_84";
      }
      case 85: {
        return "ENUM_LABEL_85";
      }
      case 86: {
        return "ENUM_LABEL_86";
      }
      case 87: {
        return "ENUM_LABEL_87";
      }
      case 88: {
        return "ENUM_LABEL_88";
      }
      case 89: {
        return "ENUM_LABEL_89";
      }
      case 90: {
        return "ENUM_LABEL_90";
      }
      case 91: {
        return "ENUM_LABEL_91";
      }
      case 92: {
        return "ENUM_LABEL_92";
      }
      case 93: {
        return "ENUM_LABEL_93";
      }
      case 94: {
        return "ENUM_LABEL_94";
      }
      case 95: {
        return "ENUM_LABEL_95";
      }
      case 96: {
        return "ENUM_LABEL_96";
      }
      case 97: {
        return "ENUM_LABEL_97";
      }
      case 98: {
        return "ENUM_LABEL_98";
      }
      case 99: {
        return "ENUM_LABEL_99";
      }
      case 100: {
        return "ENUM_LABEL_100";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "ENUM_LABEL_DEFAULT": {
        return 0;
      }
      case "ENUM_LABEL_1": {
        return 1;
      }
      case "ENUM_LABEL_2": {
        return 2;
      }
      case "ENUM_LABEL_3": {
        return 3;
      }
      case "ENUM_LABEL_4": {
        return 4;
      }
      case "ENUM_LABEL_5": {
        return 5;
      }
      case "ENUM_LABEL_6": {
        return 6;
      }
      case "ENUM_LABEL_7": {
        return 7;
      }
      case "ENUM_LABEL_8": {
        return 8;
      }
      case "ENUM_LABEL_9": {
        return 9;
      }
      case "ENUM_LABEL_10": {
        return 10;
      }
      case "ENUM_LABEL_11": {
        return 11;
      }
      case "ENUM_LABEL_12": {
        return 12;
      }
      case "ENUM_LABEL_13": {
        return 13;
      }
      case "ENUM_LABEL_14": {
        return 14;
      }
      case "ENUM_LABEL_15": {
        return 15;
      }
      case "ENUM_LABEL_16": {
        return 16;
      }
      case "ENUM_LABEL_17": {
        return 17;
      }
      case "ENUM_LABEL_18": {
        return 18;
      }
      case "ENUM_LABEL_19": {
        return 19;
      }
      case "ENUM_LABEL_20": {
        return 20;
      }
      case "ENUM_LABEL_21": {
        return 21;
      }
      case "ENUM_LABEL_22": {
        return 22;
      }
      case "ENUM_LABEL_23": {
        return 23;
      }
      case "ENUM_LABEL_24": {
        return 24;
      }
      case "ENUM_LABEL_25": {
        return 25;
      }
      case "ENUM_LABEL_26": {
        return 26;
      }
      case "ENUM_LABEL_27": {
        return 27;
      }
      case "ENUM_LABEL_28": {
        return 28;
      }
      case "ENUM_LABEL_29": {
        return 29;
      }
      case "ENUM_LABEL_30": {
        return 30;
      }
      case "ENUM_LABEL_31": {
        return 31;
      }
      case "ENUM_LABEL_32": {
        return 32;
      }
      case "ENUM_LABEL_33": {
        return 33;
      }
      case "ENUM_LABEL_34": {
        return 34;
      }
      case "ENUM_LABEL_35": {
        return 35;
      }
      case "ENUM_LABEL_36": {
        return 36;
      }
      case "ENUM_LABEL_37": {
        return 37;
      }
      case "ENUM_LABEL_38": {
        return 38;
      }
      case "ENUM_LABEL_39": {
        return 39;
      }
      case "ENUM_LABEL_40": {
        return 40;
      }
      case "ENUM_LABEL_41": {
        return 41;
      }
      case "ENUM_LABEL_42": {
        return 42;
      }
      case "ENUM_LABEL_43": {
        return 43;
      }
      case "ENUM_LABEL_44": {
        return 44;
      }
      case "ENUM_LABEL_45": {
        return 45;
      }
      case "ENUM_LABEL_46": {
        return 46;
      }
      case "ENUM_LABEL_47": {
        return 47;
      }
      case "ENUM_LABEL_48": {
        return 48;
      }
      case "ENUM_LABEL_49": {
        return 49;
      }
      case "ENUM_LABEL_50": {
        return 50;
      }
      case "ENUM_LABEL_51": {
        return 51;
      }
      case "ENUM_LABEL_52": {
        return 52;
      }
      case "ENUM_LABEL_53": {
        return 53;
      }
      case "ENUM_LABEL_54": {
        return 54;
      }
      case "ENUM_LABEL_55": {
        return 55;
      }
      case "ENUM_LABEL_56": {
        return 56;
      }
      case "ENUM_LABEL_57": {
        return 57;
      }
      case "ENUM_LABEL_58": {
        return 58;
      }
      case "ENUM_LABEL_59": {
        return 59;
      }
      case "ENUM_LABEL_60": {
        return 60;
      }
      case "ENUM_LABEL_61": {
        return 61;
      }
      case "ENUM_LABEL_62": {
        return 62;
      }
      case "ENUM_LABEL_63": {
        return 63;
      }
      case "ENUM_LABEL_64": {
        return 64;
      }
      case "ENUM_LABEL_65": {
        return 65;
      }
      case "ENUM_LABEL_66": {
        return 66;
      }
      case "ENUM_LABEL_67": {
        return 67;
      }
      case "ENUM_LABEL_68": {
        return 68;
      }
      case "ENUM_LABEL_69": {
        return 69;
      }
      case "ENUM_LABEL_70": {
        return 70;
      }
      case "ENUM_LABEL_71": {
        return 71;
      }
      case "ENUM_LABEL_72": {
        return 72;
      }
      case "ENUM_LABEL_73": {
        return 73;
      }
      case "ENUM_LABEL_74": {
        return 74;
      }
      case "ENUM_LABEL_75": {
        return 75;
      }
      case "ENUM_LABEL_76": {
        return 76;
      }
      case "ENUM_LABEL_77": {
        return 77;
      }
      case "ENUM_LABEL_78": {
        return 78;
      }
      case "ENUM_LABEL_79": {
        return 79;
      }
      case "ENUM_LABEL_80": {
        return 80;
      }
      case "ENUM_LABEL_81": {
        return 81;
      }
      case "ENUM_LABEL_82": {
        return 82;
      }
      case "ENUM_LABEL_83": {
        return 83;
      }
      case "ENUM_LABEL_84": {
        return 84;
      }
      case "ENUM_LABEL_85": {
        return 85;
      }
      case "ENUM_LABEL_86": {
        return 86;
      }
      case "ENUM_LABEL_87": {
        return 87;
      }
      case "ENUM_LABEL_88": {
        return 88;
      }
      case "ENUM_LABEL_89": {
        return 89;
      }
      case "ENUM_LABEL_90": {
        return 90;
      }
      case "ENUM_LABEL_91": {
        return 91;
      }
      case "ENUM_LABEL_92": {
        return 92;
      }
      case "ENUM_LABEL_93": {
        return 93;
      }
      case "ENUM_LABEL_94": {
        return 94;
      }
      case "ENUM_LABEL_95": {
        return 95;
      }
      case "ENUM_LABEL_96": {
        return 96;
      }
      case "ENUM_LABEL_97": {
        return 97;
      }
      case "ENUM_LABEL_98": {
        return 98;
      }
      case "ENUM_LABEL_99": {
        return 99;
      }
      case "ENUM_LABEL_100": {
        return 100;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestAllTypes = {
  /**
   * Serializes TestAllTypes to protobuf.
   */
  encode: function (msg) {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      defaultForeignEnum: ForeignEnum._fromInt(0),
      defaultImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      defaultStringPiece: "",
      defaultCord: "",
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64String(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
      );
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    if (
      msg.optionalImportEnum &&
      googleProtobufUnittest_import.ImportEnum._toInt(msg.optionalImportEnum)
    ) {
      writer.writeEnum(
        23,
        googleProtobufUnittest_import.ImportEnum._toInt(msg.optionalImportEnum)
      );
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        googleProtobufUnittest_import_public.PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        40,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writePackedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnum._toInt)
      );
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writePackedEnum(
        53,
        msg.repeatedImportEnum.map(
          googleProtobufUnittest_import.ImportEnum._toInt
        )
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString());
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString());
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString());
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString());
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64String(70, msg.defaultSfixed64.toString());
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes?.length) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.defaultNestedEnum)
    ) {
      writer.writeEnum(
        81,
        TestAllTypes.NestedEnum._toInt(msg.defaultNestedEnum)
      );
    }
    if (msg.defaultForeignEnum && ForeignEnum._toInt(msg.defaultForeignEnum)) {
      writer.writeEnum(82, ForeignEnum._toInt(msg.defaultForeignEnum));
    }
    if (
      msg.defaultImportEnum &&
      googleProtobufUnittest_import.ImportEnum._toInt(msg.defaultImportEnum)
    ) {
      writer.writeEnum(
        83,
        googleProtobufUnittest_import.ImportEnum._toInt(msg.defaultImportEnum)
      );
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 23: {
          msg.optionalImportEnum =
            googleProtobufUnittest_import.ImportEnum._fromInt(
              reader.readEnum()
            );
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            googleProtobufUnittest_import_public.PublicImportMessage
              ._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 32: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 33: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 34: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 35: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 36: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 37: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 38: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 39: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 40: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 41: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 42: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 43: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = googleProtobufUnittest_import.ImportMessage.initialize();
          reader.readMessage(
            m,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt)
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 52: {
          if (reader.isDelimited()) {
            msg.repeatedForeignEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.repeatedForeignEnum.push(
              ForeignEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 53: {
          if (reader.isDelimited()) {
            msg.repeatedImportEnum.push(
              ...reader
                .readPackedEnum()
                .map(googleProtobufUnittest_import.ImportEnum._fromInt)
            );
          } else {
            msg.repeatedImportEnum.push(
              googleProtobufUnittest_import.ImportEnum._fromInt(
                reader.readEnum()
              )
            );
          }
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum()
          );
          break;
        }
        case 82: {
          msg.defaultForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 83: {
          msg.defaultImportEnum =
            googleProtobufUnittest_import.ImportEnum._fromInt(
              reader.readEnum()
            );
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          msg.oneofNestedMessage = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes NestedTestAllTypes to protobuf.
   */
  encode: function (msg) {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes TestDeprecatedFields to protobuf.
   */
  encode: function (msg) {
    return TestDeprecatedFields._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDeprecatedFields from protobuf.
   */
  decode: function (bytes) {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecatedInt32: 0,
      deprecatedInt32InOneof: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes TestDeprecatedMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestDeprecatedMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes ForeignMessage to protobuf.
   */
  encode: function (msg) {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes TestReservedFields to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestReservedFields from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes TestAllExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestAllExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes OptionalGroup_extension to protobuf.
   */
  encode: function (msg) {
    return OptionalGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes OptionalGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes RepeatedGroup_extension to protobuf.
   */
  encode: function (msg) {
    return RepeatedGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes TestGroup to protobuf.
   */
  encode: function (msg) {
    return TestGroup._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestGroup from protobuf.
   */
  decode: function (bytes) {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalForeignEnum: ForeignEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestGroup.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestGroup.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes TestGroupExtension to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestGroupExtension from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes TestNestedExtension to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestNestedExtension from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (msg) {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (bytes) {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes TestChildExtension to protobuf.
   */
  encode: function (msg) {
    return TestChildExtension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestChildExtension from protobuf.
   */
  decode: function (bytes) {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: "",
      b: "",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes TestRequired to protobuf.
   */
  encode: function (msg) {
    return TestRequired._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequired from protobuf.
   */
  decode: function (bytes) {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes TestRequiredForeign to protobuf.
   */
  encode: function (msg) {
    return TestRequiredForeign._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredForeign from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes TestRequiredMessage to protobuf.
   */
  encode: function (msg) {
    return TestRequiredMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes TestForeignNested to protobuf.
   */
  encode: function (msg) {
    return TestForeignNested._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestForeignNested from protobuf.
   */
  decode: function (bytes) {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes TestEmptyMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes TestPickleNestedMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestPickleNestedMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },

  NestedMessage: {
    /**
     * Serializes TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (msg) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (bytes) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes TestMultipleExtensionRanges to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestMultipleExtensionRanges from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes TestReallyLargeTagNumber to protobuf.
   */
  encode: function (msg) {
    return TestReallyLargeTagNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes) {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes TestRecursiveMessage to protobuf.
   */
  encode: function (msg) {
    return TestRecursiveMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRecursiveMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes TestMutualRecursionA to protobuf.
   */
  encode: function (msg) {
    return TestMutualRecursionA._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMutualRecursionA from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (msg) {
      return TestMutualRecursionA.SubMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (msg) {
      return TestMutualRecursionA.SubGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes TestMutualRecursionB to protobuf.
   */
  encode: function (msg) {
    return TestMutualRecursionB._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMutualRecursionB from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes TestIsInitialized to protobuf.
   */
  encode: function (msg) {
    return TestIsInitialized._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestIsInitialized from protobuf.
   */
  decode: function (bytes) {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (_msg) {
      return new Uint8Array();
    },

    /**
     * Deserializes TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (_bytes) {
      return {};
    },

    /**
     * Initializes TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (_msg, writer) {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (_msg, _reader) {
      return _msg;
    },

    SubGroup: {
      /**
       * Serializes TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (msg) {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (bytes) {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes TestDupFieldNumber to protobuf.
   */
  encode: function (msg) {
    return TestDupFieldNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDupFieldNumber from protobuf.
   */
  decode: function (bytes) {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (msg) {
      return TestDupFieldNumber.Foo._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (msg) {
      return TestDupFieldNumber.Bar._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes TestEagerMessage to protobuf.
   */
  encode: function (msg) {
    return TestEagerMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestEagerMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes TestLazyMessage to protobuf.
   */
  encode: function (msg) {
    return TestLazyMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestLazyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes TestNestedMessageHasBits to protobuf.
   */
  encode: function (msg) {
    return TestNestedMessageHasBits._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes) {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writePackedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            if (reader.isDelimited()) {
              msg.nestedmessageRepeatedInt32.push(...reader.readPackedInt32());
            } else {
              msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            }
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes TestCamelCaseFieldNames to protobuf.
   */
  encode: function (msg) {
    return TestCamelCaseFieldNames._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes) {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: "",
      EnumField: ForeignEnum._fromInt(0),
      MessageField: ForeignMessage.initialize(),
      StringPieceField: "",
      CordField: "",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField && ForeignEnum._toInt(msg.EnumField)) {
      writer.writeEnum(3, ForeignEnum._toInt(msg.EnumField));
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writePackedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writePackedEnum(9, msg.RepeatedEnumField.map(ForeignEnum._toInt));
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          if (reader.isDelimited()) {
            msg.RepeatedPrimitiveField.push(...reader.readPackedInt32());
          } else {
            msg.RepeatedPrimitiveField.push(reader.readInt32());
          }
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          if (reader.isDelimited()) {
            msg.RepeatedEnumField.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.RepeatedEnumField.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes TestFieldOrderings to protobuf.
   */
  encode: function (msg) {
    return TestFieldOrderings._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestFieldOrderings from protobuf.
   */
  decode: function (bytes) {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString());
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestFieldOrderings.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString());
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes TestExtensionOrderings1 to protobuf.
   */
  encode: function (msg) {
    return TestExtensionOrderings1._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes TestExtensionOrderings2 to protobuf.
   */
  encode: function (msg) {
    return TestExtensionOrderings2._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (msg) {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (bytes) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        myString: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes TestExtremeDefaultValues to protobuf.
   */
  encode: function (msg) {
    return TestExtremeDefaultValues._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes) {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: "",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: "",
      stringWithZero: "",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: "",
      cordWithZero: "",
      replacementString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.escapedBytes?.length) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString());
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString());
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString());
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero?.length) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes SparseEnumMessage to protobuf.
   */
  encode: function (msg) {
    return SparseEnumMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes SparseEnumMessage from protobuf.
   */
  decode: function (bytes) {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparseEnum: TestSparseEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sparseEnum && TestSparseEnum._toInt(msg.sparseEnum)) {
      writer.writeEnum(1, TestSparseEnum._toInt(msg.sparseEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = TestSparseEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes OneString to protobuf.
   */
  encode: function (msg) {
    return OneString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes OneString from protobuf.
   */
  decode: function (bytes) {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes MoreString to protobuf.
   */
  encode: function (msg) {
    return MoreString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes MoreString from protobuf.
   */
  decode: function (bytes) {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes OneBytes to protobuf.
   */
  encode: function (msg) {
    return OneBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes OneBytes from protobuf.
   */
  decode: function (bytes) {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes MoreBytes to protobuf.
   */
  encode: function (msg) {
    return MoreBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes MoreBytes from protobuf.
   */
  decode: function (bytes) {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes Int32Message to protobuf.
   */
  encode: function (msg) {
    return Int32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Int32Message from protobuf.
   */
  decode: function (bytes) {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes Uint32Message to protobuf.
   */
  encode: function (msg) {
    return Uint32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Uint32Message from protobuf.
   */
  decode: function (bytes) {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes Int64Message to protobuf.
   */
  encode: function (msg) {
    return Int64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Int64Message from protobuf.
   */
  decode: function (bytes) {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes Uint64Message to protobuf.
   */
  encode: function (msg) {
    return Uint64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Uint64Message from protobuf.
   */
  decode: function (bytes) {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes BoolMessage to protobuf.
   */
  encode: function (msg) {
    return BoolMessage._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes BoolMessage from protobuf.
   */
  decode: function (bytes) {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes TestOneof to protobuf.
   */
  encode: function (msg) {
    return TestOneof._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof from protobuf.
   */
  decode: function (bytes) {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooMessage = TestAllTypes.initialize();
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneof.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneof.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (msg) {
    return TestOneofBackwardsCompatible._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes) {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: 0,
      fooString: "",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes TestOneof2 to protobuf.
   */
  encode: function (msg) {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooCord: undefined,
      fooStringPiece: undefined,
      fooBytes: undefined,
      fooEnum: undefined,
      fooMessage: undefined,
      fooLazyMessage: undefined,
      barInt: undefined,
      barString: undefined,
      barCord: undefined,
      barStringPiece: undefined,
      barBytes: undefined,
      barEnum: undefined,
      barStringWithEmptyDefault: undefined,
      barCordWithEmptyDefault: undefined,
      barStringPieceWithEmptyDefault: undefined,
      barBytesWithEmptyDefault: undefined,
      bazInt: 0,
      bazString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes?.length) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnum._toInt(msg.fooEnum));
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes?.length) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, TestOneof2.NestedEnum._toInt(msg.barEnum));
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.fooMessage = TestOneof2.NestedMessage.initialize();
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          msg.fooLazyMessage = TestOneof2.NestedMessage.initialize();
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  FooGroup: {
    /**
     * Serializes TestOneof2.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneof2.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes TestOneof2.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestOneof2.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString());
      }
      if (msg.corgeInt?.length) {
        writer.writePackedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            if (reader.isDelimited()) {
              msg.corgeInt.push(...reader.readPackedInt32());
            } else {
              msg.corgeInt.push(reader.readInt32());
            }
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes TestRequiredOneof to protobuf.
   */
  encode: function (msg) {
    return TestRequiredOneof._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredOneof from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooMessage = TestRequiredOneof.NestedMessage.initialize();
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestRequiredOneof.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes TestPackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString())
      );
    }
    if (msg.packedUint32?.length) {
      writer.writePackedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString())
      );
    }
    if (msg.packedSint32?.length) {
      writer.writePackedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString())
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writePackedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString())
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.packedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.packedFloat?.length) {
      writer.writePackedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writePackedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writePackedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writePackedEnum(103, msg.packedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.packedInt64.push(...reader.readPackedInt64String().map(BigInt));
          } else {
            msg.packedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.packedUint32.push(...reader.readPackedUint32());
          } else {
            msg.packedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.packedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.packedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.packedSint32.push(...reader.readPackedSint32());
          } else {
            msg.packedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.packedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.packedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.packedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.packedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.packedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.packedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.packedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.packedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.packedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.packedFloat.push(...reader.readPackedFloat());
          } else {
            msg.packedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.packedDouble.push(...reader.readPackedDouble());
          } else {
            msg.packedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.packedBool.push(...reader.readPackedBool());
          } else {
            msg.packedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.packedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.packedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes TestUnpackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.unpackedInt32?.length) {
      writer.writePackedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.unpackedInt64.map((x) => x.toString())
      );
    }
    if (msg.unpackedUint32?.length) {
      writer.writePackedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.unpackedUint64.map((x) => x.toString())
      );
    }
    if (msg.unpackedSint32?.length) {
      writer.writePackedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.unpackedSint64.map((x) => x.toString())
      );
    }
    if (msg.unpackedFixed32?.length) {
      writer.writePackedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.unpackedFixed64.map((x) => x.toString())
      );
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.unpackedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.unpackedFloat?.length) {
      writer.writePackedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writePackedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writePackedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writePackedEnum(103, msg.unpackedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.unpackedInt32.push(...reader.readPackedInt32());
          } else {
            msg.unpackedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.unpackedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.unpackedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.unpackedUint32.push(...reader.readPackedUint32());
          } else {
            msg.unpackedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.unpackedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.unpackedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.unpackedSint32.push(...reader.readPackedSint32());
          } else {
            msg.unpackedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.unpackedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.unpackedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.unpackedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.unpackedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.unpackedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.unpackedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.unpackedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.unpackedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.unpackedFloat.push(...reader.readPackedFloat());
          } else {
            msg.unpackedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.unpackedDouble.push(...reader.readPackedDouble());
          } else {
            msg.unpackedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.unpackedBool.push(...reader.readPackedBool());
          } else {
            msg.unpackedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.unpackedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.unpackedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes TestPackedExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestPackedExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes TestUnpackedExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestUnpackedExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes TestDynamicExtensions to protobuf.
   */
  encode: function (msg) {
    return TestDynamicExtensions._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDynamicExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnum._fromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType._fromInt(0),
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension && ForeignEnum._toInt(msg.enumExtension)) {
      writer.writeEnum(2001, ForeignEnum._toInt(msg.enumExtension));
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumType._toInt(msg.dynamicEnumExtension)
    ) {
      writer.writeEnum(
        2002,
        TestDynamicExtensions.DynamicEnumType._toInt(msg.dynamicEnumExtension)
      );
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writePackedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            TestDynamicExtensions.DynamicEnumType._fromInt(reader.readEnum());
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          if (reader.isDelimited()) {
            msg.packedExtension.push(...reader.readPackedSint32());
          } else {
            msg.packedExtension.push(reader.readSint32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: "DYNAMIC_FOO",
    DYNAMIC_BAR: "DYNAMIC_BAR",
    DYNAMIC_BAZ: "DYNAMIC_BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 2200: {
          return "DYNAMIC_FOO";
        }
        case 2201: {
          return "DYNAMIC_BAR";
        }
        case 2202: {
          return "DYNAMIC_BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "DYNAMIC_FOO": {
          return 2200;
        }
        case "DYNAMIC_BAR": {
          return 2201;
        }
        case "DYNAMIC_BAZ": {
          return 2202;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  DynamicMessageType: {
    /**
     * Serializes TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (msg) {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (bytes) {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (msg) {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes) {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        2046,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        2047,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        262143,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 13: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 2046: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 2047: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 262142: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 262143: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes TestParsingMerge to protobuf.
   */
  encode: function (msg) {
    return TestParsingMerge._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestParsingMerge from protobuf.
   */
  decode: function (bytes) {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(1, msg.field1, TestAllTypes._writeMessage);
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(2, msg.field2, TestAllTypes._writeMessage);
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(3, msg.field3, TestAllTypes._writeMessage);
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(1000, msg.ext1, TestAllTypes._writeMessage);
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(1001, msg.ext2, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (msg) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (msg) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes TestCommentInjectionMessage to protobuf.
   */
  encode: function (msg) {
    return TestCommentInjectionMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes) {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes FooRequest to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes FooRequest from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const FooResponse = {
  /**
   * Serializes FooResponse to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes FooResponse from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes FooClientMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes FooClientMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes FooServerMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes FooServerMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const BarRequest = {
  /**
   * Serializes BarRequest to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes BarRequest from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const BarResponse = {
  /**
   * Serializes BarResponse to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes BarResponse from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes TestJsonName to protobuf.
   */
  encode: function (msg) {
    return TestJsonName._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestJsonName from protobuf.
   */
  decode: function (bytes) {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes TestHugeFieldNumbers to protobuf.
   */
  encode: function (msg) {
    return TestHugeFieldNumbers._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes) {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnum._fromInt(0),
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofUint32: undefined,
      oneofTestAllTypes: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum && ForeignEnum._toInt(msg.optionalEnum)) {
      writer.writeEnum(536870004, ForeignEnum._toInt(msg.optionalEnum));
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      writer.writeRepeatedMessage(
        536870010,
        Object.entries(msg.stringStringMap).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestHugeFieldNumbers.StringStringMap._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 536870003: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 536870004: {
          msg.optionalEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          const map = {};
          reader.readMessage(
            map,
            TestHugeFieldNumbers.StringStringMap._readMessage
          );
          msg.stringStringMap[map.key.toString()] = map.value;
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          msg.oneofTestAllTypes = TestAllTypes.initialize();
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes TestExtensionInsideTable to protobuf.
   */
  encode: function (msg) {
    return TestExtensionInsideTable._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes TestExtensionRangeSerialize to protobuf.
   */
  encode: function (msg) {
    return TestExtensionRangeSerialize._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ForeignEnumJSON = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestEnumWithDupValueJSON = {
  FOO1: "FOO1",
  BAR1: "BAR1",
  BAZ: "BAZ",
  FOO2: "FOO2",
  BAR2: "BAR2",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 1: {
        return "FOO1";
      }
      case 2: {
        return "BAR1";
      }
      case 3: {
        return "BAZ";
      }
      case 1: {
        return "FOO2";
      }
      case 2: {
        return "BAR2";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOO1": {
        return 1;
      }
      case "BAR1": {
        return 2;
      }
      case "BAZ": {
        return 3;
      }
      case "FOO2": {
        return 1;
      }
      case "BAR2": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestSparseEnumJSON = {
  SPARSE_A: "SPARSE_A",
  SPARSE_B: "SPARSE_B",
  SPARSE_C: "SPARSE_C",
  SPARSE_D: "SPARSE_D",
  SPARSE_E: "SPARSE_E",
  SPARSE_F: "SPARSE_F",
  SPARSE_G: "SPARSE_G",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 123: {
        return "SPARSE_A";
      }
      case 62374: {
        return "SPARSE_B";
      }
      case 12589234: {
        return "SPARSE_C";
      }
      case -15: {
        return "SPARSE_D";
      }
      case -53452: {
        return "SPARSE_E";
      }
      case 0: {
        return "SPARSE_F";
      }
      case 2: {
        return "SPARSE_G";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "SPARSE_A": {
        return 123;
      }
      case "SPARSE_B": {
        return 62374;
      }
      case "SPARSE_C": {
        return 12589234;
      }
      case "SPARSE_D": {
        return -15;
      }
      case "SPARSE_E": {
        return -53452;
      }
      case "SPARSE_F": {
        return 0;
      }
      case "SPARSE_G": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const VeryLargeEnumJSON = {
  ENUM_LABEL_DEFAULT: "ENUM_LABEL_DEFAULT",
  ENUM_LABEL_1: "ENUM_LABEL_1",
  ENUM_LABEL_2: "ENUM_LABEL_2",
  ENUM_LABEL_3: "ENUM_LABEL_3",
  ENUM_LABEL_4: "ENUM_LABEL_4",
  ENUM_LABEL_5: "ENUM_LABEL_5",
  ENUM_LABEL_6: "ENUM_LABEL_6",
  ENUM_LABEL_7: "ENUM_LABEL_7",
  ENUM_LABEL_8: "ENUM_LABEL_8",
  ENUM_LABEL_9: "ENUM_LABEL_9",
  ENUM_LABEL_10: "ENUM_LABEL_10",
  ENUM_LABEL_11: "ENUM_LABEL_11",
  ENUM_LABEL_12: "ENUM_LABEL_12",
  ENUM_LABEL_13: "ENUM_LABEL_13",
  ENUM_LABEL_14: "ENUM_LABEL_14",
  ENUM_LABEL_15: "ENUM_LABEL_15",
  ENUM_LABEL_16: "ENUM_LABEL_16",
  ENUM_LABEL_17: "ENUM_LABEL_17",
  ENUM_LABEL_18: "ENUM_LABEL_18",
  ENUM_LABEL_19: "ENUM_LABEL_19",
  ENUM_LABEL_20: "ENUM_LABEL_20",
  ENUM_LABEL_21: "ENUM_LABEL_21",
  ENUM_LABEL_22: "ENUM_LABEL_22",
  ENUM_LABEL_23: "ENUM_LABEL_23",
  ENUM_LABEL_24: "ENUM_LABEL_24",
  ENUM_LABEL_25: "ENUM_LABEL_25",
  ENUM_LABEL_26: "ENUM_LABEL_26",
  ENUM_LABEL_27: "ENUM_LABEL_27",
  ENUM_LABEL_28: "ENUM_LABEL_28",
  ENUM_LABEL_29: "ENUM_LABEL_29",
  ENUM_LABEL_30: "ENUM_LABEL_30",
  ENUM_LABEL_31: "ENUM_LABEL_31",
  ENUM_LABEL_32: "ENUM_LABEL_32",
  ENUM_LABEL_33: "ENUM_LABEL_33",
  ENUM_LABEL_34: "ENUM_LABEL_34",
  ENUM_LABEL_35: "ENUM_LABEL_35",
  ENUM_LABEL_36: "ENUM_LABEL_36",
  ENUM_LABEL_37: "ENUM_LABEL_37",
  ENUM_LABEL_38: "ENUM_LABEL_38",
  ENUM_LABEL_39: "ENUM_LABEL_39",
  ENUM_LABEL_40: "ENUM_LABEL_40",
  ENUM_LABEL_41: "ENUM_LABEL_41",
  ENUM_LABEL_42: "ENUM_LABEL_42",
  ENUM_LABEL_43: "ENUM_LABEL_43",
  ENUM_LABEL_44: "ENUM_LABEL_44",
  ENUM_LABEL_45: "ENUM_LABEL_45",
  ENUM_LABEL_46: "ENUM_LABEL_46",
  ENUM_LABEL_47: "ENUM_LABEL_47",
  ENUM_LABEL_48: "ENUM_LABEL_48",
  ENUM_LABEL_49: "ENUM_LABEL_49",
  ENUM_LABEL_50: "ENUM_LABEL_50",
  ENUM_LABEL_51: "ENUM_LABEL_51",
  ENUM_LABEL_52: "ENUM_LABEL_52",
  ENUM_LABEL_53: "ENUM_LABEL_53",
  ENUM_LABEL_54: "ENUM_LABEL_54",
  ENUM_LABEL_55: "ENUM_LABEL_55",
  ENUM_LABEL_56: "ENUM_LABEL_56",
  ENUM_LABEL_57: "ENUM_LABEL_57",
  ENUM_LABEL_58: "ENUM_LABEL_58",
  ENUM_LABEL_59: "ENUM_LABEL_59",
  ENUM_LABEL_60: "ENUM_LABEL_60",
  ENUM_LABEL_61: "ENUM_LABEL_61",
  ENUM_LABEL_62: "ENUM_LABEL_62",
  ENUM_LABEL_63: "ENUM_LABEL_63",
  ENUM_LABEL_64: "ENUM_LABEL_64",
  ENUM_LABEL_65: "ENUM_LABEL_65",
  ENUM_LABEL_66: "ENUM_LABEL_66",
  ENUM_LABEL_67: "ENUM_LABEL_67",
  ENUM_LABEL_68: "ENUM_LABEL_68",
  ENUM_LABEL_69: "ENUM_LABEL_69",
  ENUM_LABEL_70: "ENUM_LABEL_70",
  ENUM_LABEL_71: "ENUM_LABEL_71",
  ENUM_LABEL_72: "ENUM_LABEL_72",
  ENUM_LABEL_73: "ENUM_LABEL_73",
  ENUM_LABEL_74: "ENUM_LABEL_74",
  ENUM_LABEL_75: "ENUM_LABEL_75",
  ENUM_LABEL_76: "ENUM_LABEL_76",
  ENUM_LABEL_77: "ENUM_LABEL_77",
  ENUM_LABEL_78: "ENUM_LABEL_78",
  ENUM_LABEL_79: "ENUM_LABEL_79",
  ENUM_LABEL_80: "ENUM_LABEL_80",
  ENUM_LABEL_81: "ENUM_LABEL_81",
  ENUM_LABEL_82: "ENUM_LABEL_82",
  ENUM_LABEL_83: "ENUM_LABEL_83",
  ENUM_LABEL_84: "ENUM_LABEL_84",
  ENUM_LABEL_85: "ENUM_LABEL_85",
  ENUM_LABEL_86: "ENUM_LABEL_86",
  ENUM_LABEL_87: "ENUM_LABEL_87",
  ENUM_LABEL_88: "ENUM_LABEL_88",
  ENUM_LABEL_89: "ENUM_LABEL_89",
  ENUM_LABEL_90: "ENUM_LABEL_90",
  ENUM_LABEL_91: "ENUM_LABEL_91",
  ENUM_LABEL_92: "ENUM_LABEL_92",
  ENUM_LABEL_93: "ENUM_LABEL_93",
  ENUM_LABEL_94: "ENUM_LABEL_94",
  ENUM_LABEL_95: "ENUM_LABEL_95",
  ENUM_LABEL_96: "ENUM_LABEL_96",
  ENUM_LABEL_97: "ENUM_LABEL_97",
  ENUM_LABEL_98: "ENUM_LABEL_98",
  ENUM_LABEL_99: "ENUM_LABEL_99",
  ENUM_LABEL_100: "ENUM_LABEL_100",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "ENUM_LABEL_DEFAULT";
      }
      case 1: {
        return "ENUM_LABEL_1";
      }
      case 2: {
        return "ENUM_LABEL_2";
      }
      case 3: {
        return "ENUM_LABEL_3";
      }
      case 4: {
        return "ENUM_LABEL_4";
      }
      case 5: {
        return "ENUM_LABEL_5";
      }
      case 6: {
        return "ENUM_LABEL_6";
      }
      case 7: {
        return "ENUM_LABEL_7";
      }
      case 8: {
        return "ENUM_LABEL_8";
      }
      case 9: {
        return "ENUM_LABEL_9";
      }
      case 10: {
        return "ENUM_LABEL_10";
      }
      case 11: {
        return "ENUM_LABEL_11";
      }
      case 12: {
        return "ENUM_LABEL_12";
      }
      case 13: {
        return "ENUM_LABEL_13";
      }
      case 14: {
        return "ENUM_LABEL_14";
      }
      case 15: {
        return "ENUM_LABEL_15";
      }
      case 16: {
        return "ENUM_LABEL_16";
      }
      case 17: {
        return "ENUM_LABEL_17";
      }
      case 18: {
        return "ENUM_LABEL_18";
      }
      case 19: {
        return "ENUM_LABEL_19";
      }
      case 20: {
        return "ENUM_LABEL_20";
      }
      case 21: {
        return "ENUM_LABEL_21";
      }
      case 22: {
        return "ENUM_LABEL_22";
      }
      case 23: {
        return "ENUM_LABEL_23";
      }
      case 24: {
        return "ENUM_LABEL_24";
      }
      case 25: {
        return "ENUM_LABEL_25";
      }
      case 26: {
        return "ENUM_LABEL_26";
      }
      case 27: {
        return "ENUM_LABEL_27";
      }
      case 28: {
        return "ENUM_LABEL_28";
      }
      case 29: {
        return "ENUM_LABEL_29";
      }
      case 30: {
        return "ENUM_LABEL_30";
      }
      case 31: {
        return "ENUM_LABEL_31";
      }
      case 32: {
        return "ENUM_LABEL_32";
      }
      case 33: {
        return "ENUM_LABEL_33";
      }
      case 34: {
        return "ENUM_LABEL_34";
      }
      case 35: {
        return "ENUM_LABEL_35";
      }
      case 36: {
        return "ENUM_LABEL_36";
      }
      case 37: {
        return "ENUM_LABEL_37";
      }
      case 38: {
        return "ENUM_LABEL_38";
      }
      case 39: {
        return "ENUM_LABEL_39";
      }
      case 40: {
        return "ENUM_LABEL_40";
      }
      case 41: {
        return "ENUM_LABEL_41";
      }
      case 42: {
        return "ENUM_LABEL_42";
      }
      case 43: {
        return "ENUM_LABEL_43";
      }
      case 44: {
        return "ENUM_LABEL_44";
      }
      case 45: {
        return "ENUM_LABEL_45";
      }
      case 46: {
        return "ENUM_LABEL_46";
      }
      case 47: {
        return "ENUM_LABEL_47";
      }
      case 48: {
        return "ENUM_LABEL_48";
      }
      case 49: {
        return "ENUM_LABEL_49";
      }
      case 50: {
        return "ENUM_LABEL_50";
      }
      case 51: {
        return "ENUM_LABEL_51";
      }
      case 52: {
        return "ENUM_LABEL_52";
      }
      case 53: {
        return "ENUM_LABEL_53";
      }
      case 54: {
        return "ENUM_LABEL_54";
      }
      case 55: {
        return "ENUM_LABEL_55";
      }
      case 56: {
        return "ENUM_LABEL_56";
      }
      case 57: {
        return "ENUM_LABEL_57";
      }
      case 58: {
        return "ENUM_LABEL_58";
      }
      case 59: {
        return "ENUM_LABEL_59";
      }
      case 60: {
        return "ENUM_LABEL_60";
      }
      case 61: {
        return "ENUM_LABEL_61";
      }
      case 62: {
        return "ENUM_LABEL_62";
      }
      case 63: {
        return "ENUM_LABEL_63";
      }
      case 64: {
        return "ENUM_LABEL_64";
      }
      case 65: {
        return "ENUM_LABEL_65";
      }
      case 66: {
        return "ENUM_LABEL_66";
      }
      case 67: {
        return "ENUM_LABEL_67";
      }
      case 68: {
        return "ENUM_LABEL_68";
      }
      case 69: {
        return "ENUM_LABEL_69";
      }
      case 70: {
        return "ENUM_LABEL_70";
      }
      case 71: {
        return "ENUM_LABEL_71";
      }
      case 72: {
        return "ENUM_LABEL_72";
      }
      case 73: {
        return "ENUM_LABEL_73";
      }
      case 74: {
        return "ENUM_LABEL_74";
      }
      case 75: {
        return "ENUM_LABEL_75";
      }
      case 76: {
        return "ENUM_LABEL_76";
      }
      case 77: {
        return "ENUM_LABEL_77";
      }
      case 78: {
        return "ENUM_LABEL_78";
      }
      case 79: {
        return "ENUM_LABEL_79";
      }
      case 80: {
        return "ENUM_LABEL_80";
      }
      case 81: {
        return "ENUM_LABEL_81";
      }
      case 82: {
        return "ENUM_LABEL_82";
      }
      case 83: {
        return "ENUM_LABEL_83";
      }
      case 84: {
        return "ENUM_LABEL_84";
      }
      case 85: {
        return "ENUM_LABEL_85";
      }
      case 86: {
        return "ENUM_LABEL_86";
      }
      case 87: {
        return "ENUM_LABEL_87";
      }
      case 88: {
        return "ENUM_LABEL_88";
      }
      case 89: {
        return "ENUM_LABEL_89";
      }
      case 90: {
        return "ENUM_LABEL_90";
      }
      case 91: {
        return "ENUM_LABEL_91";
      }
      case 92: {
        return "ENUM_LABEL_92";
      }
      case 93: {
        return "ENUM_LABEL_93";
      }
      case 94: {
        return "ENUM_LABEL_94";
      }
      case 95: {
        return "ENUM_LABEL_95";
      }
      case 96: {
        return "ENUM_LABEL_96";
      }
      case 97: {
        return "ENUM_LABEL_97";
      }
      case 98: {
        return "ENUM_LABEL_98";
      }
      case 99: {
        return "ENUM_LABEL_99";
      }
      case 100: {
        return "ENUM_LABEL_100";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "ENUM_LABEL_DEFAULT": {
        return 0;
      }
      case "ENUM_LABEL_1": {
        return 1;
      }
      case "ENUM_LABEL_2": {
        return 2;
      }
      case "ENUM_LABEL_3": {
        return 3;
      }
      case "ENUM_LABEL_4": {
        return 4;
      }
      case "ENUM_LABEL_5": {
        return 5;
      }
      case "ENUM_LABEL_6": {
        return 6;
      }
      case "ENUM_LABEL_7": {
        return 7;
      }
      case "ENUM_LABEL_8": {
        return 8;
      }
      case "ENUM_LABEL_9": {
        return 9;
      }
      case "ENUM_LABEL_10": {
        return 10;
      }
      case "ENUM_LABEL_11": {
        return 11;
      }
      case "ENUM_LABEL_12": {
        return 12;
      }
      case "ENUM_LABEL_13": {
        return 13;
      }
      case "ENUM_LABEL_14": {
        return 14;
      }
      case "ENUM_LABEL_15": {
        return 15;
      }
      case "ENUM_LABEL_16": {
        return 16;
      }
      case "ENUM_LABEL_17": {
        return 17;
      }
      case "ENUM_LABEL_18": {
        return 18;
      }
      case "ENUM_LABEL_19": {
        return 19;
      }
      case "ENUM_LABEL_20": {
        return 20;
      }
      case "ENUM_LABEL_21": {
        return 21;
      }
      case "ENUM_LABEL_22": {
        return 22;
      }
      case "ENUM_LABEL_23": {
        return 23;
      }
      case "ENUM_LABEL_24": {
        return 24;
      }
      case "ENUM_LABEL_25": {
        return 25;
      }
      case "ENUM_LABEL_26": {
        return 26;
      }
      case "ENUM_LABEL_27": {
        return 27;
      }
      case "ENUM_LABEL_28": {
        return 28;
      }
      case "ENUM_LABEL_29": {
        return 29;
      }
      case "ENUM_LABEL_30": {
        return 30;
      }
      case "ENUM_LABEL_31": {
        return 31;
      }
      case "ENUM_LABEL_32": {
        return 32;
      }
      case "ENUM_LABEL_33": {
        return 33;
      }
      case "ENUM_LABEL_34": {
        return 34;
      }
      case "ENUM_LABEL_35": {
        return 35;
      }
      case "ENUM_LABEL_36": {
        return 36;
      }
      case "ENUM_LABEL_37": {
        return 37;
      }
      case "ENUM_LABEL_38": {
        return 38;
      }
      case "ENUM_LABEL_39": {
        return 39;
      }
      case "ENUM_LABEL_40": {
        return 40;
      }
      case "ENUM_LABEL_41": {
        return 41;
      }
      case "ENUM_LABEL_42": {
        return 42;
      }
      case "ENUM_LABEL_43": {
        return 43;
      }
      case "ENUM_LABEL_44": {
        return 44;
      }
      case "ENUM_LABEL_45": {
        return 45;
      }
      case "ENUM_LABEL_46": {
        return 46;
      }
      case "ENUM_LABEL_47": {
        return 47;
      }
      case "ENUM_LABEL_48": {
        return 48;
      }
      case "ENUM_LABEL_49": {
        return 49;
      }
      case "ENUM_LABEL_50": {
        return 50;
      }
      case "ENUM_LABEL_51": {
        return 51;
      }
      case "ENUM_LABEL_52": {
        return 52;
      }
      case "ENUM_LABEL_53": {
        return 53;
      }
      case "ENUM_LABEL_54": {
        return 54;
      }
      case "ENUM_LABEL_55": {
        return 55;
      }
      case "ENUM_LABEL_56": {
        return 56;
      }
      case "ENUM_LABEL_57": {
        return 57;
      }
      case "ENUM_LABEL_58": {
        return 58;
      }
      case "ENUM_LABEL_59": {
        return 59;
      }
      case "ENUM_LABEL_60": {
        return 60;
      }
      case "ENUM_LABEL_61": {
        return 61;
      }
      case "ENUM_LABEL_62": {
        return 62;
      }
      case "ENUM_LABEL_63": {
        return 63;
      }
      case "ENUM_LABEL_64": {
        return 64;
      }
      case "ENUM_LABEL_65": {
        return 65;
      }
      case "ENUM_LABEL_66": {
        return 66;
      }
      case "ENUM_LABEL_67": {
        return 67;
      }
      case "ENUM_LABEL_68": {
        return 68;
      }
      case "ENUM_LABEL_69": {
        return 69;
      }
      case "ENUM_LABEL_70": {
        return 70;
      }
      case "ENUM_LABEL_71": {
        return 71;
      }
      case "ENUM_LABEL_72": {
        return 72;
      }
      case "ENUM_LABEL_73": {
        return 73;
      }
      case "ENUM_LABEL_74": {
        return 74;
      }
      case "ENUM_LABEL_75": {
        return 75;
      }
      case "ENUM_LABEL_76": {
        return 76;
      }
      case "ENUM_LABEL_77": {
        return 77;
      }
      case "ENUM_LABEL_78": {
        return 78;
      }
      case "ENUM_LABEL_79": {
        return 79;
      }
      case "ENUM_LABEL_80": {
        return 80;
      }
      case "ENUM_LABEL_81": {
        return 81;
      }
      case "ENUM_LABEL_82": {
        return 82;
      }
      case "ENUM_LABEL_83": {
        return 83;
      }
      case "ENUM_LABEL_84": {
        return 84;
      }
      case "ENUM_LABEL_85": {
        return 85;
      }
      case "ENUM_LABEL_86": {
        return 86;
      }
      case "ENUM_LABEL_87": {
        return 87;
      }
      case "ENUM_LABEL_88": {
        return 88;
      }
      case "ENUM_LABEL_89": {
        return 89;
      }
      case "ENUM_LABEL_90": {
        return 90;
      }
      case "ENUM_LABEL_91": {
        return 91;
      }
      case "ENUM_LABEL_92": {
        return 92;
      }
      case "ENUM_LABEL_93": {
        return 93;
      }
      case "ENUM_LABEL_94": {
        return 94;
      }
      case "ENUM_LABEL_95": {
        return 95;
      }
      case "ENUM_LABEL_96": {
        return 96;
      }
      case "ENUM_LABEL_97": {
        return 97;
      }
      case "ENUM_LABEL_98": {
        return 98;
      }
      case "ENUM_LABEL_99": {
        return 99;
      }
      case "ENUM_LABEL_100": {
        return 100;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestAllTypesJSON = {
  /**
   * Serializes TestAllTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestAllTypes from JSON.
   */
  decode: function (json) {
    return TestAllTypesJSON._readMessage(
      TestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessageJSON.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessageJSON.initialize(),
      optionalLazyMessage: TestAllTypesJSON.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      defaultForeignEnum: ForeignEnum._fromInt(0),
      defaultImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      defaultStringPiece: "",
      defaultCord: "",
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json["optionalInt64"] = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json["optionalUint32"] = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json["optionalUint64"] = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json["optionalSint32"] = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json["optionalSint64"] = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json["optionalFixed32"] = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json["optionalFixed64"] = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json["optionalSfixed32"] = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json["optionalSfixed64"] = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json["optionalFloat"] = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json["optionalDouble"] = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json["optionalBool"] = msg.optionalBool;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalNestedMessage);
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    if (msg.optionalForeignMessage) {
      const _optionalForeignMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalForeignMessage
      );
      if (Object.keys(_optionalForeignMessage_).length > 0) {
        json["optionalForeignMessage"] = _optionalForeignMessage_;
      }
    }
    if (msg.optionalImportMessage) {
      const _optionalImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalImportMessage
        );
      if (Object.keys(_optionalImportMessage_).length > 0) {
        json["optionalImportMessage"] = _optionalImportMessage_;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      json["optionalNestedEnum"] = msg.optionalNestedEnum;
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    if (
      msg.optionalImportEnum &&
      googleProtobufUnittest_import.ImportEnumJSON._toInt(
        msg.optionalImportEnum
      )
    ) {
      json["optionalImportEnum"] = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json["optionalStringPiece"] = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json["optionalCord"] = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const _optionalPublicImportMessage_ =
        googleProtobufUnittest_import_public.PublicImportMessageJSON._writeMessage(
          msg.optionalPublicImportMessage
        );
      if (Object.keys(_optionalPublicImportMessage_).length > 0) {
        json["optionalPublicImportMessage"] = _optionalPublicImportMessage_;
      }
    }
    if (msg.optionalLazyMessage) {
      const _optionalLazyMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalLazyMessage);
      if (Object.keys(_optionalLazyMessage_).length > 0) {
        json["optionalLazyMessage"] = _optionalLazyMessage_;
      }
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json["repeatedString"] = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json["repeatedBytes"] = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json["repeatedNestedMessage"] = msg.repeatedNestedMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json["repeatedForeignMessage"] = msg.repeatedForeignMessage.map(
        ForeignMessageJSON._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json["repeatedImportMessage"] = msg.repeatedImportMessage.map(
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json["repeatedForeignEnum"] = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json["repeatedImportEnum"] = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json["repeatedStringPiece"] = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json["repeatedCord"] = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json["repeatedLazyMessage"] = msg.repeatedLazyMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      json["defaultInt32"] = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json["defaultInt64"] = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json["defaultUint32"] = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json["defaultUint64"] = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json["defaultSint32"] = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json["defaultSint64"] = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json["defaultFixed32"] = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json["defaultFixed64"] = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json["defaultSfixed32"] = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json["defaultSfixed64"] = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json["defaultFloat"] = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json["defaultDouble"] = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json["defaultBool"] = msg.defaultBool;
    }
    if (msg.defaultString) {
      json["defaultString"] = msg.defaultString;
    }
    if (msg.defaultBytes?.length) {
      json["defaultBytes"] = encodeBase64Bytes(msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.defaultNestedEnum)
    ) {
      json["defaultNestedEnum"] = msg.defaultNestedEnum;
    }
    if (
      msg.defaultForeignEnum &&
      ForeignEnumJSON._toInt(msg.defaultForeignEnum)
    ) {
      json["defaultForeignEnum"] = msg.defaultForeignEnum;
    }
    if (
      msg.defaultImportEnum &&
      googleProtobufUnittest_import.ImportEnumJSON._toInt(msg.defaultImportEnum)
    ) {
      json["defaultImportEnum"] = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json["defaultStringPiece"] = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json["defaultCord"] = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const _oneofNestedMessage_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.oneofNestedMessage
      );
      json["oneofNestedMessage"] = _oneofNestedMessage_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _optionalInt64_ = json["optionalInt64"] ?? json["optional_int64"];
    if (_optionalInt64_) {
      msg.optionalInt64 = BigInt(_optionalInt64_);
    }
    const _optionalUint32_ = json["optionalUint32"] ?? json["optional_uint32"];
    if (_optionalUint32_) {
      msg.optionalUint32 = _optionalUint32_;
    }
    const _optionalUint64_ = json["optionalUint64"] ?? json["optional_uint64"];
    if (_optionalUint64_) {
      msg.optionalUint64 = BigInt(_optionalUint64_);
    }
    const _optionalSint32_ = json["optionalSint32"] ?? json["optional_sint32"];
    if (_optionalSint32_) {
      msg.optionalSint32 = _optionalSint32_;
    }
    const _optionalSint64_ = json["optionalSint64"] ?? json["optional_sint64"];
    if (_optionalSint64_) {
      msg.optionalSint64 = BigInt(_optionalSint64_);
    }
    const _optionalFixed32_ =
      json["optionalFixed32"] ?? json["optional_fixed32"];
    if (_optionalFixed32_) {
      msg.optionalFixed32 = _optionalFixed32_;
    }
    const _optionalFixed64_ =
      json["optionalFixed64"] ?? json["optional_fixed64"];
    if (_optionalFixed64_) {
      msg.optionalFixed64 = BigInt(_optionalFixed64_);
    }
    const _optionalSfixed32_ =
      json["optionalSfixed32"] ?? json["optional_sfixed32"];
    if (_optionalSfixed32_) {
      msg.optionalSfixed32 = _optionalSfixed32_;
    }
    const _optionalSfixed64_ =
      json["optionalSfixed64"] ?? json["optional_sfixed64"];
    if (_optionalSfixed64_) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64_);
    }
    const _optionalFloat_ = json["optionalFloat"] ?? json["optional_float"];
    if (_optionalFloat_) {
      msg.optionalFloat = _optionalFloat_;
    }
    const _optionalDouble_ = json["optionalDouble"] ?? json["optional_double"];
    if (_optionalDouble_) {
      msg.optionalDouble = _optionalDouble_;
    }
    const _optionalBool_ = json["optionalBool"] ?? json["optional_bool"];
    if (_optionalBool_) {
      msg.optionalBool = _optionalBool_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalNestedMessage_);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage_ =
      json["optionalForeignMessage"] ?? json["optional_foreign_message"];
    if (_optionalForeignMessage_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _optionalForeignMessage_);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage_ =
      json["optionalImportMessage"] ?? json["optional_import_message"];
    if (_optionalImportMessage_) {
      const m = googleProtobufUnittest_import.ImportMessage.initialize();
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        m,
        _optionalImportMessage_
      );
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum_ =
      json["optionalNestedEnum"] ?? json["optional_nested_enum"];
    if (_optionalNestedEnum_) {
      msg.optionalNestedEnum = _optionalNestedEnum_;
    }
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    const _optionalImportEnum_ =
      json["optionalImportEnum"] ?? json["optional_import_enum"];
    if (_optionalImportEnum_) {
      msg.optionalImportEnum = _optionalImportEnum_;
    }
    const _optionalStringPiece_ =
      json["optionalStringPiece"] ?? json["optional_string_piece"];
    if (_optionalStringPiece_) {
      msg.optionalStringPiece = _optionalStringPiece_;
    }
    const _optionalCord_ = json["optionalCord"] ?? json["optional_cord"];
    if (_optionalCord_) {
      msg.optionalCord = _optionalCord_;
    }
    const _optionalPublicImportMessage_ =
      json["optionalPublicImportMessage"] ??
      json["optional_public_import_message"];
    if (_optionalPublicImportMessage_) {
      const m =
        googleProtobufUnittest_import_public.PublicImportMessage.initialize();
      googleProtobufUnittest_import_public.PublicImportMessageJSON._readMessage(
        m,
        _optionalPublicImportMessage_
      );
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage_ =
      json["optionalLazyMessage"] ?? json["optional_lazy_message"];
    if (_optionalLazyMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalLazyMessage_);
      msg.optionalLazyMessage = m;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedString_ = json["repeatedString"] ?? json["repeated_string"];
    if (_repeatedString_) {
      msg.repeatedString = _repeatedString_;
    }
    const _repeatedBytes_ = json["repeatedBytes"] ?? json["repeated_bytes"];
    if (_repeatedBytes_) {
      msg.repeatedBytes = _repeatedBytes_.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage_ =
      json["repeatedNestedMessage"] ?? json["repeated_nested_message"];
    if (_repeatedNestedMessage_) {
      for (const item of _repeatedNestedMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage_ =
      json["repeatedForeignMessage"] ?? json["repeated_foreign_message"];
    if (_repeatedForeignMessage_) {
      for (const item of _repeatedForeignMessage_) {
        const m = ForeignMessage.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage_ =
      json["repeatedImportMessage"] ?? json["repeated_import_message"];
    if (_repeatedImportMessage_) {
      for (const item of _repeatedImportMessage_) {
        const m = googleProtobufUnittest_import.ImportMessage.initialize();
        googleProtobufUnittest_import.ImportMessageJSON._readMessage(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    const _repeatedForeignEnum_ =
      json["repeatedForeignEnum"] ?? json["repeated_foreign_enum"];
    if (_repeatedForeignEnum_) {
      msg.repeatedForeignEnum = _repeatedForeignEnum_;
    }
    const _repeatedImportEnum_ =
      json["repeatedImportEnum"] ?? json["repeated_import_enum"];
    if (_repeatedImportEnum_) {
      msg.repeatedImportEnum = _repeatedImportEnum_;
    }
    const _repeatedStringPiece_ =
      json["repeatedStringPiece"] ?? json["repeated_string_piece"];
    if (_repeatedStringPiece_) {
      msg.repeatedStringPiece = _repeatedStringPiece_;
    }
    const _repeatedCord_ = json["repeatedCord"] ?? json["repeated_cord"];
    if (_repeatedCord_) {
      msg.repeatedCord = _repeatedCord_;
    }
    const _repeatedLazyMessage_ =
      json["repeatedLazyMessage"] ?? json["repeated_lazy_message"];
    if (_repeatedLazyMessage_) {
      for (const item of _repeatedLazyMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _defaultInt32_ = json["defaultInt32"] ?? json["default_int32"];
    if (_defaultInt32_) {
      msg.defaultInt32 = _defaultInt32_;
    }
    const _defaultInt64_ = json["defaultInt64"] ?? json["default_int64"];
    if (_defaultInt64_) {
      msg.defaultInt64 = BigInt(_defaultInt64_);
    }
    const _defaultUint32_ = json["defaultUint32"] ?? json["default_uint32"];
    if (_defaultUint32_) {
      msg.defaultUint32 = _defaultUint32_;
    }
    const _defaultUint64_ = json["defaultUint64"] ?? json["default_uint64"];
    if (_defaultUint64_) {
      msg.defaultUint64 = BigInt(_defaultUint64_);
    }
    const _defaultSint32_ = json["defaultSint32"] ?? json["default_sint32"];
    if (_defaultSint32_) {
      msg.defaultSint32 = _defaultSint32_;
    }
    const _defaultSint64_ = json["defaultSint64"] ?? json["default_sint64"];
    if (_defaultSint64_) {
      msg.defaultSint64 = BigInt(_defaultSint64_);
    }
    const _defaultFixed32_ = json["defaultFixed32"] ?? json["default_fixed32"];
    if (_defaultFixed32_) {
      msg.defaultFixed32 = _defaultFixed32_;
    }
    const _defaultFixed64_ = json["defaultFixed64"] ?? json["default_fixed64"];
    if (_defaultFixed64_) {
      msg.defaultFixed64 = BigInt(_defaultFixed64_);
    }
    const _defaultSfixed32_ =
      json["defaultSfixed32"] ?? json["default_sfixed32"];
    if (_defaultSfixed32_) {
      msg.defaultSfixed32 = _defaultSfixed32_;
    }
    const _defaultSfixed64_ =
      json["defaultSfixed64"] ?? json["default_sfixed64"];
    if (_defaultSfixed64_) {
      msg.defaultSfixed64 = BigInt(_defaultSfixed64_);
    }
    const _defaultFloat_ = json["defaultFloat"] ?? json["default_float"];
    if (_defaultFloat_) {
      msg.defaultFloat = _defaultFloat_;
    }
    const _defaultDouble_ = json["defaultDouble"] ?? json["default_double"];
    if (_defaultDouble_) {
      msg.defaultDouble = _defaultDouble_;
    }
    const _defaultBool_ = json["defaultBool"] ?? json["default_bool"];
    if (_defaultBool_) {
      msg.defaultBool = _defaultBool_;
    }
    const _defaultString_ = json["defaultString"] ?? json["default_string"];
    if (_defaultString_) {
      msg.defaultString = _defaultString_;
    }
    const _defaultBytes_ = json["defaultBytes"] ?? json["default_bytes"];
    if (_defaultBytes_) {
      msg.defaultBytes = decodeBase64Bytes(_defaultBytes_);
    }
    const _defaultNestedEnum_ =
      json["defaultNestedEnum"] ?? json["default_nested_enum"];
    if (_defaultNestedEnum_) {
      msg.defaultNestedEnum = _defaultNestedEnum_;
    }
    const _defaultForeignEnum_ =
      json["defaultForeignEnum"] ?? json["default_foreign_enum"];
    if (_defaultForeignEnum_) {
      msg.defaultForeignEnum = _defaultForeignEnum_;
    }
    const _defaultImportEnum_ =
      json["defaultImportEnum"] ?? json["default_import_enum"];
    if (_defaultImportEnum_) {
      msg.defaultImportEnum = _defaultImportEnum_;
    }
    const _defaultStringPiece_ =
      json["defaultStringPiece"] ?? json["default_string_piece"];
    if (_defaultStringPiece_) {
      msg.defaultStringPiece = _defaultStringPiece_;
    }
    const _defaultCord_ = json["defaultCord"] ?? json["default_cord"];
    if (_defaultCord_) {
      msg.defaultCord = _defaultCord_;
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofNestedMessage_ =
      json["oneofNestedMessage"] ?? json["oneof_nested_message"];
    if (_oneofNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _oneofNestedMessage_);
      msg.oneofNestedMessage = m;
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestAllTypesJSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestAllTypesJSON.NestedMessage._readMessage(
        TestAllTypesJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestAllTypes.OptionalGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestAllTypesJSON.OptionalGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.OptionalGroup from JSON.
     */
    decode: function (json) {
      return TestAllTypesJSON.OptionalGroup._readMessage(
        TestAllTypesJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestAllTypes.RepeatedGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestAllTypesJSON.RepeatedGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.RepeatedGroup from JSON.
     */
    decode: function (json) {
      return TestAllTypesJSON.RepeatedGroup._readMessage(
        TestAllTypesJSON.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypesJSON = {
  /**
   * Serializes NestedTestAllTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(NestedTestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes NestedTestAllTypes from JSON.
   */
  decode: function (json) {
    return NestedTestAllTypesJSON._readMessage(
      NestedTestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypesJSON.initialize(),
      payload: TestAllTypesJSON.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.child) {
      const _child_ = NestedTestAllTypesJSON._writeMessage(msg.child);
      if (Object.keys(_child_).length > 0) {
        json["child"] = _child_;
      }
    }
    if (msg.payload) {
      const _payload_ = TestAllTypesJSON._writeMessage(msg.payload);
      if (Object.keys(_payload_).length > 0) {
        json["payload"] = _payload_;
      }
    }
    if (msg.repeatedChild?.length) {
      json["repeatedChild"] = msg.repeatedChild.map(
        NestedTestAllTypesJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _child_ = json["child"];
    if (_child_) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypesJSON._readMessage(m, _child_);
      msg.child = m;
    }
    const _payload_ = json["payload"];
    if (_payload_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _payload_);
      msg.payload = m;
    }
    const _repeatedChild_ = json["repeatedChild"] ?? json["repeated_child"];
    if (_repeatedChild_) {
      for (const item of _repeatedChild_) {
        const m = NestedTestAllTypes.initialize();
        NestedTestAllTypesJSON._readMessage(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFieldsJSON = {
  /**
   * Serializes TestDeprecatedFields to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestDeprecatedFieldsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDeprecatedFields from JSON.
   */
  decode: function (json) {
    return TestDeprecatedFieldsJSON._readMessage(
      TestDeprecatedFieldsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecatedInt32: 0,
      deprecatedInt32InOneof: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.deprecatedInt32) {
      json["deprecatedInt32"] = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json["deprecatedInt32InOneof"] = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _deprecatedInt32_ =
      json["deprecatedInt32"] ?? json["deprecated_int32"];
    if (_deprecatedInt32_) {
      msg.deprecatedInt32 = _deprecatedInt32_;
    }
    const _deprecatedInt32InOneof_ =
      json["deprecatedInt32InOneof"] ?? json["deprecated_int32_in_oneof"];
    if (_deprecatedInt32InOneof_) {
      msg.deprecatedInt32InOneof = _deprecatedInt32InOneof_;
    }
    return msg;
  },
};

export const TestDeprecatedMessageJSON = {
  /**
   * Serializes TestDeprecatedMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestDeprecatedMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const ForeignMessageJSON = {
  /**
   * Serializes ForeignMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(ForeignMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ForeignMessage from JSON.
   */
  decode: function (json) {
    return ForeignMessageJSON._readMessage(
      ForeignMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.c) {
      json["c"] = msg.c;
    }
    if (msg.d) {
      json["d"] = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    const _d_ = json["d"];
    if (_d_) {
      msg.d = _d_;
    }
    return msg;
  },
};

export const TestReservedFieldsJSON = {
  /**
   * Serializes TestReservedFields to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestReservedFields from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestAllExtensionsJSON = {
  /**
   * Serializes TestAllExtensions to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestAllExtensions from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const OptionalGroup_extensionJSON = {
  /**
   * Serializes OptionalGroup_extension to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(OptionalGroup_extensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes OptionalGroup_extension from JSON.
   */
  decode: function (json) {
    return OptionalGroup_extensionJSON._readMessage(
      OptionalGroup_extensionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const RepeatedGroup_extensionJSON = {
  /**
   * Serializes RepeatedGroup_extension to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(RepeatedGroup_extensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes RepeatedGroup_extension from JSON.
   */
  decode: function (json) {
    return RepeatedGroup_extensionJSON._readMessage(
      RepeatedGroup_extensionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const TestGroupJSON = {
  /**
   * Serializes TestGroup to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestGroupJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestGroup from JSON.
   */
  decode: function (json) {
    return TestGroupJSON._readMessage(
      TestGroupJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalForeignEnum: ForeignEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestGroup.OptionalGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestGroupJSON.OptionalGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestGroup.OptionalGroup from JSON.
     */
    decode: function (json) {
      return TestGroupJSON.OptionalGroup._readMessage(
        TestGroupJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestGroupExtensionJSON = {
  /**
   * Serializes TestGroupExtension to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestGroupExtension from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestNestedExtensionJSON = {
  /**
   * Serializes TestNestedExtension to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestNestedExtension from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestNestedExtensionJSON.OptionalGroup_extension._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decode: function (json) {
      return TestNestedExtensionJSON.OptionalGroup_extension._readMessage(
        TestNestedExtensionJSON.OptionalGroup_extension.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestChildExtensionJSON = {
  /**
   * Serializes TestChildExtension to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestChildExtensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestChildExtension from JSON.
   */
  decode: function (json) {
    return TestChildExtensionJSON._readMessage(
      TestChildExtensionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: "",
      b: "",
      optionalExtension: TestAllExtensionsJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.b) {
      json["b"] = msg.b;
    }
    if (msg.optionalExtension) {
      const _optionalExtension_ = TestAllExtensionsJSON._writeMessage(
        msg.optionalExtension
      );
      if (Object.keys(_optionalExtension_).length > 0) {
        json["optionalExtension"] = _optionalExtension_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _b_ = json["b"];
    if (_b_) {
      msg.b = _b_;
    }
    const _optionalExtension_ =
      json["optionalExtension"] ?? json["optional_extension"];
    if (_optionalExtension_) {
      const m = TestAllExtensions.initialize();
      TestAllExtensionsJSON._readMessage(m, _optionalExtension_);
      msg.optionalExtension = m;
    }
    return msg;
  },
};

export const TestRequiredJSON = {
  /**
   * Serializes TestRequired to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequired from JSON.
   */
  decode: function (json) {
    return TestRequiredJSON._readMessage(
      TestRequiredJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.dummy2) {
      json["dummy2"] = msg.dummy2;
    }
    if (msg.b) {
      json["b"] = msg.b;
    }
    if (msg.dummy4) {
      json["dummy4"] = msg.dummy4;
    }
    if (msg.dummy5) {
      json["dummy5"] = msg.dummy5;
    }
    if (msg.dummy6) {
      json["dummy6"] = msg.dummy6;
    }
    if (msg.dummy7) {
      json["dummy7"] = msg.dummy7;
    }
    if (msg.dummy8) {
      json["dummy8"] = msg.dummy8;
    }
    if (msg.dummy9) {
      json["dummy9"] = msg.dummy9;
    }
    if (msg.dummy10) {
      json["dummy10"] = msg.dummy10;
    }
    if (msg.dummy11) {
      json["dummy11"] = msg.dummy11;
    }
    if (msg.dummy12) {
      json["dummy12"] = msg.dummy12;
    }
    if (msg.dummy13) {
      json["dummy13"] = msg.dummy13;
    }
    if (msg.dummy14) {
      json["dummy14"] = msg.dummy14;
    }
    if (msg.dummy15) {
      json["dummy15"] = msg.dummy15;
    }
    if (msg.dummy16) {
      json["dummy16"] = msg.dummy16;
    }
    if (msg.dummy17) {
      json["dummy17"] = msg.dummy17;
    }
    if (msg.dummy18) {
      json["dummy18"] = msg.dummy18;
    }
    if (msg.dummy19) {
      json["dummy19"] = msg.dummy19;
    }
    if (msg.dummy20) {
      json["dummy20"] = msg.dummy20;
    }
    if (msg.dummy21) {
      json["dummy21"] = msg.dummy21;
    }
    if (msg.dummy22) {
      json["dummy22"] = msg.dummy22;
    }
    if (msg.dummy23) {
      json["dummy23"] = msg.dummy23;
    }
    if (msg.dummy24) {
      json["dummy24"] = msg.dummy24;
    }
    if (msg.dummy25) {
      json["dummy25"] = msg.dummy25;
    }
    if (msg.dummy26) {
      json["dummy26"] = msg.dummy26;
    }
    if (msg.dummy27) {
      json["dummy27"] = msg.dummy27;
    }
    if (msg.dummy28) {
      json["dummy28"] = msg.dummy28;
    }
    if (msg.dummy29) {
      json["dummy29"] = msg.dummy29;
    }
    if (msg.dummy30) {
      json["dummy30"] = msg.dummy30;
    }
    if (msg.dummy31) {
      json["dummy31"] = msg.dummy31;
    }
    if (msg.dummy32) {
      json["dummy32"] = msg.dummy32;
    }
    if (msg.c) {
      json["c"] = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _dummy2_ = json["dummy2"];
    if (_dummy2_) {
      msg.dummy2 = _dummy2_;
    }
    const _b_ = json["b"];
    if (_b_) {
      msg.b = _b_;
    }
    const _dummy4_ = json["dummy4"];
    if (_dummy4_) {
      msg.dummy4 = _dummy4_;
    }
    const _dummy5_ = json["dummy5"];
    if (_dummy5_) {
      msg.dummy5 = _dummy5_;
    }
    const _dummy6_ = json["dummy6"];
    if (_dummy6_) {
      msg.dummy6 = _dummy6_;
    }
    const _dummy7_ = json["dummy7"];
    if (_dummy7_) {
      msg.dummy7 = _dummy7_;
    }
    const _dummy8_ = json["dummy8"];
    if (_dummy8_) {
      msg.dummy8 = _dummy8_;
    }
    const _dummy9_ = json["dummy9"];
    if (_dummy9_) {
      msg.dummy9 = _dummy9_;
    }
    const _dummy10_ = json["dummy10"];
    if (_dummy10_) {
      msg.dummy10 = _dummy10_;
    }
    const _dummy11_ = json["dummy11"];
    if (_dummy11_) {
      msg.dummy11 = _dummy11_;
    }
    const _dummy12_ = json["dummy12"];
    if (_dummy12_) {
      msg.dummy12 = _dummy12_;
    }
    const _dummy13_ = json["dummy13"];
    if (_dummy13_) {
      msg.dummy13 = _dummy13_;
    }
    const _dummy14_ = json["dummy14"];
    if (_dummy14_) {
      msg.dummy14 = _dummy14_;
    }
    const _dummy15_ = json["dummy15"];
    if (_dummy15_) {
      msg.dummy15 = _dummy15_;
    }
    const _dummy16_ = json["dummy16"];
    if (_dummy16_) {
      msg.dummy16 = _dummy16_;
    }
    const _dummy17_ = json["dummy17"];
    if (_dummy17_) {
      msg.dummy17 = _dummy17_;
    }
    const _dummy18_ = json["dummy18"];
    if (_dummy18_) {
      msg.dummy18 = _dummy18_;
    }
    const _dummy19_ = json["dummy19"];
    if (_dummy19_) {
      msg.dummy19 = _dummy19_;
    }
    const _dummy20_ = json["dummy20"];
    if (_dummy20_) {
      msg.dummy20 = _dummy20_;
    }
    const _dummy21_ = json["dummy21"];
    if (_dummy21_) {
      msg.dummy21 = _dummy21_;
    }
    const _dummy22_ = json["dummy22"];
    if (_dummy22_) {
      msg.dummy22 = _dummy22_;
    }
    const _dummy23_ = json["dummy23"];
    if (_dummy23_) {
      msg.dummy23 = _dummy23_;
    }
    const _dummy24_ = json["dummy24"];
    if (_dummy24_) {
      msg.dummy24 = _dummy24_;
    }
    const _dummy25_ = json["dummy25"];
    if (_dummy25_) {
      msg.dummy25 = _dummy25_;
    }
    const _dummy26_ = json["dummy26"];
    if (_dummy26_) {
      msg.dummy26 = _dummy26_;
    }
    const _dummy27_ = json["dummy27"];
    if (_dummy27_) {
      msg.dummy27 = _dummy27_;
    }
    const _dummy28_ = json["dummy28"];
    if (_dummy28_) {
      msg.dummy28 = _dummy28_;
    }
    const _dummy29_ = json["dummy29"];
    if (_dummy29_) {
      msg.dummy29 = _dummy29_;
    }
    const _dummy30_ = json["dummy30"];
    if (_dummy30_) {
      msg.dummy30 = _dummy30_;
    }
    const _dummy31_ = json["dummy31"];
    if (_dummy31_) {
      msg.dummy31 = _dummy31_;
    }
    const _dummy32_ = json["dummy32"];
    if (_dummy32_) {
      msg.dummy32 = _dummy32_;
    }
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    return msg;
  },
};

export const TestRequiredForeignJSON = {
  /**
   * Serializes TestRequiredForeign to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredForeignJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredForeign from JSON.
   */
  decode: function (json) {
    return TestRequiredForeignJSON._readMessage(
      TestRequiredForeignJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequiredJSON.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const _optionalMessage_ = TestRequiredJSON._writeMessage(
        msg.optionalMessage
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.repeatedMessage?.length) {
      json["repeatedMessage"] = msg.repeatedMessage.map(
        TestRequiredJSON._writeMessage
      );
    }
    if (msg.dummy) {
      json["dummy"] = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      const m = TestRequired.initialize();
      TestRequiredJSON._readMessage(m, _optionalMessage_);
      msg.optionalMessage = m;
    }
    const _repeatedMessage_ =
      json["repeatedMessage"] ?? json["repeated_message"];
    if (_repeatedMessage_) {
      for (const item of _repeatedMessage_) {
        const m = TestRequired.initialize();
        TestRequiredJSON._readMessage(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _dummy_ = json["dummy"];
    if (_dummy_) {
      msg.dummy = _dummy_;
    }
    return msg;
  },
};

export const TestRequiredMessageJSON = {
  /**
   * Serializes TestRequiredMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredMessage from JSON.
   */
  decode: function (json) {
    return TestRequiredMessageJSON._readMessage(
      TestRequiredMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequiredJSON.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequiredJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const _optionalMessage_ = TestRequiredJSON._writeMessage(
        msg.optionalMessage
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.repeatedMessage?.length) {
      json["repeatedMessage"] = msg.repeatedMessage.map(
        TestRequiredJSON._writeMessage
      );
    }
    if (msg.requiredMessage) {
      const _requiredMessage_ = TestRequiredJSON._writeMessage(
        msg.requiredMessage
      );
      if (Object.keys(_requiredMessage_).length > 0) {
        json["requiredMessage"] = _requiredMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      const m = TestRequired.initialize();
      TestRequiredJSON._readMessage(m, _optionalMessage_);
      msg.optionalMessage = m;
    }
    const _repeatedMessage_ =
      json["repeatedMessage"] ?? json["repeated_message"];
    if (_repeatedMessage_) {
      for (const item of _repeatedMessage_) {
        const m = TestRequired.initialize();
        TestRequiredJSON._readMessage(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _requiredMessage_ =
      json["requiredMessage"] ?? json["required_message"];
    if (_requiredMessage_) {
      const m = TestRequired.initialize();
      TestRequiredJSON._readMessage(m, _requiredMessage_);
      msg.requiredMessage = m;
    }
    return msg;
  },
};

export const TestForeignNestedJSON = {
  /**
   * Serializes TestForeignNested to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestForeignNestedJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestForeignNested from JSON.
   */
  decode: function (json) {
    return TestForeignNestedJSON._readMessage(
      TestForeignNestedJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreignNested: TestAllTypesJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.foreignNested) {
      const _foreignNested_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.foreignNested
      );
      if (Object.keys(_foreignNested_).length > 0) {
        json["foreignNested"] = _foreignNested_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _foreignNested_ = json["foreignNested"] ?? json["foreign_nested"];
    if (_foreignNested_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _foreignNested_);
      msg.foreignNested = m;
    }
    return msg;
  },
};

export const TestEmptyMessageJSON = {
  /**
   * Serializes TestEmptyMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestEmptyMessageWithExtensionsJSON = {
  /**
   * Serializes TestEmptyMessageWithExtensions to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessageWithExtensions from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestPickleNestedMessageJSON = {
  /**
   * Serializes TestPickleNestedMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestPickleNestedMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestPickleNestedMessage.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestPickleNestedMessageJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestPickleNestedMessage.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestPickleNestedMessageJSON.NestedMessage._readMessage(
        TestPickleNestedMessageJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encode: function (msg) {
        return JSON.stringify(
          TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage._writeMessage(
            msg
          )
        );
      },

      /**
       * Deserializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decode: function (json) {
        return TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg) {
        const json = {};
        if (msg.cc) {
          json["cc"] = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, json) {
        const _cc_ = json["cc"];
        if (_cc_) {
          msg.cc = _cc_;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRangesJSON = {
  /**
   * Serializes TestMultipleExtensionRanges to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestMultipleExtensionRanges from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestReallyLargeTagNumberJSON = {
  /**
   * Serializes TestReallyLargeTagNumber to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestReallyLargeTagNumberJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestReallyLargeTagNumber from JSON.
   */
  decode: function (json) {
    return TestReallyLargeTagNumberJSON._readMessage(
      TestReallyLargeTagNumberJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.bb) {
      json["bb"] = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _bb_ = json["bb"];
    if (_bb_) {
      msg.bb = _bb_;
    }
    return msg;
  },
};

export const TestRecursiveMessageJSON = {
  /**
   * Serializes TestRecursiveMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRecursiveMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRecursiveMessage from JSON.
   */
  decode: function (json) {
    return TestRecursiveMessageJSON._readMessage(
      TestRecursiveMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestRecursiveMessageJSON.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      const _a_ = TestRecursiveMessageJSON._writeMessage(msg.a);
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    if (msg.i) {
      json["i"] = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      const m = TestRecursiveMessage.initialize();
      TestRecursiveMessageJSON._readMessage(m, _a_);
      msg.a = m;
    }
    const _i_ = json["i"];
    if (_i_) {
      msg.i = _i_;
    }
    return msg;
  },
};

export const TestMutualRecursionAJSON = {
  /**
   * Serializes TestMutualRecursionA to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMutualRecursionAJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMutualRecursionA from JSON.
   */
  decode: function (json) {
    return TestMutualRecursionAJSON._readMessage(
      TestMutualRecursionAJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionBJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.bb) {
      const _bb_ = TestMutualRecursionBJSON._writeMessage(msg.bb);
      if (Object.keys(_bb_).length > 0) {
        json["bb"] = _bb_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _bb_ = json["bb"];
    if (_bb_) {
      const m = TestMutualRecursionB.initialize();
      TestMutualRecursionBJSON._readMessage(m, _bb_);
      msg.bb = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestMutualRecursionA.SubMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestMutualRecursionAJSON.SubMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestMutualRecursionA.SubMessage from JSON.
     */
    decode: function (json) {
      return TestMutualRecursionAJSON.SubMessage._readMessage(
        TestMutualRecursionAJSON.SubMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionBJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.b) {
        const _b_ = TestMutualRecursionBJSON._writeMessage(msg.b);
        if (Object.keys(_b_).length > 0) {
          json["b"] = _b_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _b_ = json["b"];
      if (_b_) {
        const m = TestMutualRecursionB.initialize();
        TestMutualRecursionBJSON._readMessage(m, _b_);
        msg.b = m;
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes TestMutualRecursionA.SubGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestMutualRecursionAJSON.SubGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestMutualRecursionA.SubGroup from JSON.
     */
    decode: function (json) {
      return TestMutualRecursionAJSON.SubGroup._readMessage(
        TestMutualRecursionAJSON.SubGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        subMessage: TestMutualRecursionAJSON.SubMessage.initialize(),
        notInThisScc: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.subMessage) {
        const _subMessage_ = TestMutualRecursionAJSON.SubMessage._writeMessage(
          msg.subMessage
        );
        if (Object.keys(_subMessage_).length > 0) {
          json["subMessage"] = _subMessage_;
        }
      }
      if (msg.notInThisScc) {
        const _notInThisScc_ = TestAllTypesJSON._writeMessage(msg.notInThisScc);
        if (Object.keys(_notInThisScc_).length > 0) {
          json["notInThisScc"] = _notInThisScc_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _subMessage_ = json["subMessage"] ?? json["sub_message"];
      if (_subMessage_) {
        const m = TestMutualRecursionA.SubMessage.initialize();
        TestMutualRecursionAJSON.SubMessage._readMessage(m, _subMessage_);
        msg.subMessage = m;
      }
      const _notInThisScc_ = json["notInThisScc"] ?? json["not_in_this_scc"];
      if (_notInThisScc_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, _notInThisScc_);
        msg.notInThisScc = m;
      }
      return msg;
    },
  },
};

export const TestMutualRecursionBJSON = {
  /**
   * Serializes TestMutualRecursionB to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMutualRecursionBJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMutualRecursionB from JSON.
   */
  decode: function (json) {
    return TestMutualRecursionBJSON._readMessage(
      TestMutualRecursionBJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionAJSON.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      const _a_ = TestMutualRecursionAJSON._writeMessage(msg.a);
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      const m = TestMutualRecursionA.initialize();
      TestMutualRecursionAJSON._readMessage(m, _a_);
      msg.a = m;
    }
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    return msg;
  },
};

export const TestIsInitializedJSON = {
  /**
   * Serializes TestIsInitialized to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestIsInitializedJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestIsInitialized from JSON.
   */
  decode: function (json) {
    return TestIsInitializedJSON._readMessage(
      TestIsInitializedJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestIsInitializedJSON.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const _subMessage_ = TestIsInitializedJSON.SubMessage._writeMessage(
        msg.subMessage
      );
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      const m = TestIsInitialized.SubMessage.initialize();
      TestIsInitializedJSON.SubMessage._readMessage(m, _subMessage_);
      msg.subMessage = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestIsInitialized.SubMessage to JSON.
     */
    encode: function (_msg) {
      return "{}";
    },

    /**
     * Deserializes TestIsInitialized.SubMessage from JSON.
     */
    decode: function (_json) {
      return {};
    },

    /**
     * Initializes TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (_msg) {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (msg, _json) {
      return msg;
    },

    SubGroup: {
      /**
       * Serializes TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encode: function (msg) {
        return JSON.stringify(
          TestIsInitializedJSON.SubMessage.SubGroup._writeMessage(msg)
        );
      },

      /**
       * Deserializes TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decode: function (json) {
        return TestIsInitializedJSON.SubMessage.SubGroup._readMessage(
          TestIsInitializedJSON.SubMessage.SubGroup.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg) {
        const json = {};
        if (msg.i) {
          json["i"] = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, json) {
        const _i_ = json["i"];
        if (_i_) {
          msg.i = _i_;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumberJSON = {
  /**
   * Serializes TestDupFieldNumber to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestDupFieldNumberJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDupFieldNumber from JSON.
   */
  decode: function (json) {
    return TestDupFieldNumberJSON._readMessage(
      TestDupFieldNumberJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes TestDupFieldNumber.Foo to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestDupFieldNumberJSON.Foo._writeMessage(msg));
    },

    /**
     * Deserializes TestDupFieldNumber.Foo from JSON.
     */
    decode: function (json) {
      return TestDupFieldNumberJSON.Foo._readMessage(
        TestDupFieldNumberJSON.Foo.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes TestDupFieldNumber.Bar to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestDupFieldNumberJSON.Bar._writeMessage(msg));
    },

    /**
     * Deserializes TestDupFieldNumber.Bar from JSON.
     */
    decode: function (json) {
      return TestDupFieldNumberJSON.Bar._readMessage(
        TestDupFieldNumberJSON.Bar.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestEagerMessageJSON = {
  /**
   * Serializes TestEagerMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestEagerMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestEagerMessage from JSON.
   */
  decode: function (json) {
    return TestEagerMessageJSON._readMessage(
      TestEagerMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const _subMessage_ = TestAllTypesJSON._writeMessage(msg.subMessage);
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _subMessage_);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestLazyMessageJSON = {
  /**
   * Serializes TestLazyMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestLazyMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestLazyMessage from JSON.
   */
  decode: function (json) {
    return TestLazyMessageJSON._readMessage(
      TestLazyMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const _subMessage_ = TestAllTypesJSON._writeMessage(msg.subMessage);
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _subMessage_);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestNestedMessageHasBitsJSON = {
  /**
   * Serializes TestNestedMessageHasBits to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestNestedMessageHasBitsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestNestedMessageHasBits from JSON.
   */
  decode: function (json) {
    return TestNestedMessageHasBitsJSON._readMessage(
      TestNestedMessageHasBitsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBitsJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestNestedMessageHasBitsJSON.NestedMessage._writeMessage(
          msg.optionalNestedMessage
        );
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestNestedMessageHasBits.NestedMessage.initialize();
      TestNestedMessageHasBitsJSON.NestedMessage._readMessage(
        m,
        _optionalNestedMessage_
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestNestedMessageHasBitsJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestNestedMessageHasBitsJSON.NestedMessage._readMessage(
        TestNestedMessageHasBitsJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json["nestedmessageRepeatedInt32"] = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json["nestedmessageRepeatedForeignmessage"] =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessageJSON._writeMessage
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _nestedmessageRepeatedInt32_ =
        json["nestedmessageRepeatedInt32"] ??
        json["nestedmessage_repeated_int32"];
      if (_nestedmessageRepeatedInt32_) {
        msg.nestedmessageRepeatedInt32 = _nestedmessageRepeatedInt32_;
      }
      const _nestedmessageRepeatedForeignmessage_ =
        json["nestedmessageRepeatedForeignmessage"] ??
        json["nestedmessage_repeated_foreignmessage"];
      if (_nestedmessageRepeatedForeignmessage_) {
        for (const item of _nestedmessageRepeatedForeignmessage_) {
          const m = ForeignMessage.initialize();
          ForeignMessageJSON._readMessage(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNamesJSON = {
  /**
   * Serializes TestCamelCaseFieldNames to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestCamelCaseFieldNamesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestCamelCaseFieldNames from JSON.
   */
  decode: function (json) {
    return TestCamelCaseFieldNamesJSON._readMessage(
      TestCamelCaseFieldNamesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: "",
      EnumField: ForeignEnum._fromInt(0),
      MessageField: ForeignMessageJSON.initialize(),
      StringPieceField: "",
      CordField: "",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.PrimitiveField) {
      json["PrimitiveField"] = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json["StringField"] = msg.StringField;
    }
    if (msg.EnumField && ForeignEnumJSON._toInt(msg.EnumField)) {
      json["EnumField"] = msg.EnumField;
    }
    if (msg.MessageField) {
      const _MessageField_ = ForeignMessageJSON._writeMessage(msg.MessageField);
      if (Object.keys(_MessageField_).length > 0) {
        json["MessageField"] = _MessageField_;
      }
    }
    if (msg.StringPieceField) {
      json["StringPieceField"] = msg.StringPieceField;
    }
    if (msg.CordField) {
      json["CordField"] = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json["RepeatedPrimitiveField"] = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json["RepeatedStringField"] = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json["RepeatedEnumField"] = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json["RepeatedMessageField"] = msg.RepeatedMessageField.map(
        ForeignMessageJSON._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json["RepeatedStringPieceField"] = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json["RepeatedCordField"] = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _PrimitiveField_ = json["PrimitiveField"];
    if (_PrimitiveField_) {
      msg.PrimitiveField = _PrimitiveField_;
    }
    const _StringField_ = json["StringField"];
    if (_StringField_) {
      msg.StringField = _StringField_;
    }
    const _EnumField_ = json["EnumField"];
    if (_EnumField_) {
      msg.EnumField = _EnumField_;
    }
    const _MessageField_ = json["MessageField"];
    if (_MessageField_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _MessageField_);
      msg.MessageField = m;
    }
    const _StringPieceField_ = json["StringPieceField"];
    if (_StringPieceField_) {
      msg.StringPieceField = _StringPieceField_;
    }
    const _CordField_ = json["CordField"];
    if (_CordField_) {
      msg.CordField = _CordField_;
    }
    const _RepeatedPrimitiveField_ = json["RepeatedPrimitiveField"];
    if (_RepeatedPrimitiveField_) {
      msg.RepeatedPrimitiveField = _RepeatedPrimitiveField_;
    }
    const _RepeatedStringField_ = json["RepeatedStringField"];
    if (_RepeatedStringField_) {
      msg.RepeatedStringField = _RepeatedStringField_;
    }
    const _RepeatedEnumField_ = json["RepeatedEnumField"];
    if (_RepeatedEnumField_) {
      msg.RepeatedEnumField = _RepeatedEnumField_;
    }
    const _RepeatedMessageField_ = json["RepeatedMessageField"];
    if (_RepeatedMessageField_) {
      for (const item of _RepeatedMessageField_) {
        const m = ForeignMessage.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const _RepeatedStringPieceField_ = json["RepeatedStringPieceField"];
    if (_RepeatedStringPieceField_) {
      msg.RepeatedStringPieceField = _RepeatedStringPieceField_;
    }
    const _RepeatedCordField_ = json["RepeatedCordField"];
    if (_RepeatedCordField_) {
      msg.RepeatedCordField = _RepeatedCordField_;
    }
    return msg;
  },
};

export const TestFieldOrderingsJSON = {
  /**
   * Serializes TestFieldOrderings to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestFieldOrderingsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestFieldOrderings from JSON.
   */
  decode: function (json) {
    return TestFieldOrderingsJSON._readMessage(
      TestFieldOrderingsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderingsJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    if (msg.myInt) {
      json["myInt"] = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json["myFloat"] = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestFieldOrderingsJSON.NestedMessage._writeMessage(
          msg.optionalNestedMessage
        );
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    const _myInt_ = json["myInt"] ?? json["my_int"];
    if (_myInt_) {
      msg.myInt = BigInt(_myInt_);
    }
    const _myFloat_ = json["myFloat"] ?? json["my_float"];
    if (_myFloat_) {
      msg.myFloat = _myFloat_;
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestFieldOrderings.NestedMessage.initialize();
      TestFieldOrderingsJSON.NestedMessage._readMessage(
        m,
        _optionalNestedMessage_
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestFieldOrderings.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestFieldOrderingsJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestFieldOrderings.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestFieldOrderingsJSON.NestedMessage._readMessage(
        TestFieldOrderingsJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.oo) {
        json["oo"] = msg.oo.toString();
      }
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _oo_ = json["oo"];
      if (_oo_) {
        msg.oo = BigInt(_oo_);
      }
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1JSON = {
  /**
   * Serializes TestExtensionOrderings1 to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtensionOrderings1JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionOrderings1 from JSON.
   */
  decode: function (json) {
    return TestExtensionOrderings1JSON._readMessage(
      TestExtensionOrderings1JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    return msg;
  },
};

export const TestExtensionOrderings2JSON = {
  /**
   * Serializes TestExtensionOrderings2 to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtensionOrderings2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionOrderings2 from JSON.
   */
  decode: function (json) {
    return TestExtensionOrderings2JSON._readMessage(
      TestExtensionOrderings2JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestExtensionOrderings2JSON.TestExtensionOrderings3._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decode: function (json) {
      return TestExtensionOrderings2JSON.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2JSON.TestExtensionOrderings3.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        myString: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.myString) {
        json["myString"] = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _myString_ = json["myString"] ?? json["my_string"];
      if (_myString_) {
        msg.myString = _myString_;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValuesJSON = {
  /**
   * Serializes TestExtremeDefaultValues to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtremeDefaultValuesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtremeDefaultValues from JSON.
   */
  decode: function (json) {
    return TestExtremeDefaultValuesJSON._readMessage(
      TestExtremeDefaultValuesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: "",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: "",
      stringWithZero: "",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: "",
      cordWithZero: "",
      replacementString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.escapedBytes?.length) {
      json["escapedBytes"] = encodeBase64Bytes(msg.escapedBytes);
    }
    if (msg.largeUint32) {
      json["largeUint32"] = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json["largeUint64"] = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json["smallInt32"] = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json["smallInt64"] = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json["reallySmallInt32"] = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json["reallySmallInt64"] = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json["utf8String"] = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json["zeroFloat"] = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json["oneFloat"] = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json["smallFloat"] = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json["negativeOneFloat"] = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json["negativeFloat"] = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json["largeFloat"] = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json["smallNegativeFloat"] = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json["infDouble"] = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json["negInfDouble"] = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json["nanDouble"] = msg.nanDouble;
    }
    if (msg.infFloat) {
      json["infFloat"] = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json["negInfFloat"] = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json["nanFloat"] = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json["cppTrigraph"] = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json["stringWithZero"] = msg.stringWithZero;
    }
    if (msg.bytesWithZero?.length) {
      json["bytesWithZero"] = encodeBase64Bytes(msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      json["stringPieceWithZero"] = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json["cordWithZero"] = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json["replacementString"] = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _escapedBytes_ = json["escapedBytes"] ?? json["escaped_bytes"];
    if (_escapedBytes_) {
      msg.escapedBytes = decodeBase64Bytes(_escapedBytes_);
    }
    const _largeUint32_ = json["largeUint32"] ?? json["large_uint32"];
    if (_largeUint32_) {
      msg.largeUint32 = _largeUint32_;
    }
    const _largeUint64_ = json["largeUint64"] ?? json["large_uint64"];
    if (_largeUint64_) {
      msg.largeUint64 = BigInt(_largeUint64_);
    }
    const _smallInt32_ = json["smallInt32"] ?? json["small_int32"];
    if (_smallInt32_) {
      msg.smallInt32 = _smallInt32_;
    }
    const _smallInt64_ = json["smallInt64"] ?? json["small_int64"];
    if (_smallInt64_) {
      msg.smallInt64 = BigInt(_smallInt64_);
    }
    const _reallySmallInt32_ =
      json["reallySmallInt32"] ?? json["really_small_int32"];
    if (_reallySmallInt32_) {
      msg.reallySmallInt32 = _reallySmallInt32_;
    }
    const _reallySmallInt64_ =
      json["reallySmallInt64"] ?? json["really_small_int64"];
    if (_reallySmallInt64_) {
      msg.reallySmallInt64 = BigInt(_reallySmallInt64_);
    }
    const _utf8String_ = json["utf8String"] ?? json["utf8_string"];
    if (_utf8String_) {
      msg.utf8String = _utf8String_;
    }
    const _zeroFloat_ = json["zeroFloat"] ?? json["zero_float"];
    if (_zeroFloat_) {
      msg.zeroFloat = _zeroFloat_;
    }
    const _oneFloat_ = json["oneFloat"] ?? json["one_float"];
    if (_oneFloat_) {
      msg.oneFloat = _oneFloat_;
    }
    const _smallFloat_ = json["smallFloat"] ?? json["small_float"];
    if (_smallFloat_) {
      msg.smallFloat = _smallFloat_;
    }
    const _negativeOneFloat_ =
      json["negativeOneFloat"] ?? json["negative_one_float"];
    if (_negativeOneFloat_) {
      msg.negativeOneFloat = _negativeOneFloat_;
    }
    const _negativeFloat_ = json["negativeFloat"] ?? json["negative_float"];
    if (_negativeFloat_) {
      msg.negativeFloat = _negativeFloat_;
    }
    const _largeFloat_ = json["largeFloat"] ?? json["large_float"];
    if (_largeFloat_) {
      msg.largeFloat = _largeFloat_;
    }
    const _smallNegativeFloat_ =
      json["smallNegativeFloat"] ?? json["small_negative_float"];
    if (_smallNegativeFloat_) {
      msg.smallNegativeFloat = _smallNegativeFloat_;
    }
    const _infDouble_ = json["infDouble"] ?? json["inf_double"];
    if (_infDouble_) {
      msg.infDouble = _infDouble_;
    }
    const _negInfDouble_ = json["negInfDouble"] ?? json["neg_inf_double"];
    if (_negInfDouble_) {
      msg.negInfDouble = _negInfDouble_;
    }
    const _nanDouble_ = json["nanDouble"] ?? json["nan_double"];
    if (_nanDouble_) {
      msg.nanDouble = _nanDouble_;
    }
    const _infFloat_ = json["infFloat"] ?? json["inf_float"];
    if (_infFloat_) {
      msg.infFloat = _infFloat_;
    }
    const _negInfFloat_ = json["negInfFloat"] ?? json["neg_inf_float"];
    if (_negInfFloat_) {
      msg.negInfFloat = _negInfFloat_;
    }
    const _nanFloat_ = json["nanFloat"] ?? json["nan_float"];
    if (_nanFloat_) {
      msg.nanFloat = _nanFloat_;
    }
    const _cppTrigraph_ = json["cppTrigraph"] ?? json["cpp_trigraph"];
    if (_cppTrigraph_) {
      msg.cppTrigraph = _cppTrigraph_;
    }
    const _stringWithZero_ = json["stringWithZero"] ?? json["string_with_zero"];
    if (_stringWithZero_) {
      msg.stringWithZero = _stringWithZero_;
    }
    const _bytesWithZero_ = json["bytesWithZero"] ?? json["bytes_with_zero"];
    if (_bytesWithZero_) {
      msg.bytesWithZero = decodeBase64Bytes(_bytesWithZero_);
    }
    const _stringPieceWithZero_ =
      json["stringPieceWithZero"] ?? json["string_piece_with_zero"];
    if (_stringPieceWithZero_) {
      msg.stringPieceWithZero = _stringPieceWithZero_;
    }
    const _cordWithZero_ = json["cordWithZero"] ?? json["cord_with_zero"];
    if (_cordWithZero_) {
      msg.cordWithZero = _cordWithZero_;
    }
    const _replacementString_ =
      json["replacementString"] ?? json["replacement_string"];
    if (_replacementString_) {
      msg.replacementString = _replacementString_;
    }
    return msg;
  },
};

export const SparseEnumMessageJSON = {
  /**
   * Serializes SparseEnumMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(SparseEnumMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes SparseEnumMessage from JSON.
   */
  decode: function (json) {
    return SparseEnumMessageJSON._readMessage(
      SparseEnumMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparseEnum: TestSparseEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.sparseEnum && TestSparseEnumJSON._toInt(msg.sparseEnum)) {
      json["sparseEnum"] = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _sparseEnum_ = json["sparseEnum"] ?? json["sparse_enum"];
    if (_sparseEnum_) {
      msg.sparseEnum = _sparseEnum_;
    }
    return msg;
  },
};

export const OneStringJSON = {
  /**
   * Serializes OneString to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(OneStringJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneString from JSON.
   */
  decode: function (json) {
    return OneStringJSON._readMessage(
      OneStringJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const MoreStringJSON = {
  /**
   * Serializes MoreString to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(MoreStringJSON._writeMessage(msg));
  },

  /**
   * Deserializes MoreString from JSON.
   */
  decode: function (json) {
    return MoreStringJSON._readMessage(
      MoreStringJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const OneBytesJSON = {
  /**
   * Serializes OneBytes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(OneBytesJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneBytes from JSON.
   */
  decode: function (json) {
    return OneBytesJSON._readMessage(
      OneBytesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json["data"] = encodeBase64Bytes(msg.data);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = decodeBase64Bytes(_data_);
    }
    return msg;
  },
};

export const MoreBytesJSON = {
  /**
   * Serializes MoreBytes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(MoreBytesJSON._writeMessage(msg));
  },

  /**
   * Deserializes MoreBytes from JSON.
   */
  decode: function (json) {
    return MoreBytesJSON._readMessage(
      MoreBytesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json["data"] = msg.data.map(encodeBase64Bytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_.map(decodeBase64Bytes);
    }
    return msg;
  },
};

export const Int32MessageJSON = {
  /**
   * Serializes Int32Message to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(Int32MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Int32Message from JSON.
   */
  decode: function (json) {
    return Int32MessageJSON._readMessage(
      Int32MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const Uint32MessageJSON = {
  /**
   * Serializes Uint32Message to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(Uint32MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Uint32Message from JSON.
   */
  decode: function (json) {
    return Uint32MessageJSON._readMessage(
      Uint32MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const Int64MessageJSON = {
  /**
   * Serializes Int64Message to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(Int64MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Int64Message from JSON.
   */
  decode: function (json) {
    return Int64MessageJSON._readMessage(
      Int64MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = BigInt(_data_);
    }
    return msg;
  },
};

export const Uint64MessageJSON = {
  /**
   * Serializes Uint64Message to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(Uint64MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Uint64Message from JSON.
   */
  decode: function (json) {
    return Uint64MessageJSON._readMessage(
      Uint64MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = BigInt(_data_);
    }
    return msg;
  },
};

export const BoolMessageJSON = {
  /**
   * Serializes BoolMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(BoolMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes BoolMessage from JSON.
   */
  decode: function (json) {
    return BoolMessageJSON._readMessage(
      BoolMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const TestOneofJSON = {
  /**
   * Serializes TestOneof to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestOneofJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof from JSON.
   */
  decode: function (json) {
    return TestOneofJSON._readMessage(
      TestOneofJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestAllTypesJSON._writeMessage(msg.fooMessage);
      json["fooMessage"] = _fooMessage_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneof.FooGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestOneofJSON.FooGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof.FooGroup from JSON.
     */
    decode: function (json) {
      return TestOneofJSON.FooGroup._readMessage(
        TestOneofJSON.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatibleJSON = {
  /**
   * Serializes TestOneofBackwardsCompatible to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestOneofBackwardsCompatibleJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneofBackwardsCompatible from JSON.
   */
  decode: function (json) {
    return TestOneofBackwardsCompatibleJSON._readMessage(
      TestOneofBackwardsCompatibleJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: 0,
      fooString: "",
      fooMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooInt) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage) {
      const _fooMessage_ = TestAllTypesJSON._writeMessage(msg.fooMessage);
      if (Object.keys(_fooMessage_).length > 0) {
        json["fooMessage"] = _fooMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestOneofBackwardsCompatibleJSON.FooGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decode: function (json) {
      return TestOneofBackwardsCompatibleJSON.FooGroup._readMessage(
        TestOneofBackwardsCompatibleJSON.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },
};

export const TestOneof2JSON = {
  /**
   * Serializes TestOneof2 to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestOneof2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof2 from JSON.
   */
  decode: function (json) {
    return TestOneof2JSON._readMessage(
      TestOneof2JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooCord: undefined,
      fooStringPiece: undefined,
      fooBytes: undefined,
      fooEnum: undefined,
      fooMessage: undefined,
      fooLazyMessage: undefined,
      barInt: undefined,
      barString: undefined,
      barCord: undefined,
      barStringPiece: undefined,
      barBytes: undefined,
      barEnum: undefined,
      barStringWithEmptyDefault: undefined,
      barCordWithEmptyDefault: undefined,
      barStringPieceWithEmptyDefault: undefined,
      barBytesWithEmptyDefault: undefined,
      bazInt: 0,
      bazString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json["fooCord"] = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json["fooStringPiece"] = msg.fooStringPiece;
    }
    if (msg.fooBytes?.length) {
      json["fooBytes"] = encodeBase64Bytes(msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      json["fooEnum"] = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestOneof2JSON.NestedMessage._writeMessage(
        msg.fooMessage
      );
      json["fooMessage"] = _fooMessage_;
    }
    if (msg.fooLazyMessage != undefined) {
      const _fooLazyMessage_ = TestOneof2JSON.NestedMessage._writeMessage(
        msg.fooLazyMessage
      );
      json["fooLazyMessage"] = _fooLazyMessage_;
    }
    if (msg.barInt != undefined) {
      json["barInt"] = msg.barInt;
    }
    if (msg.barString != undefined) {
      json["barString"] = msg.barString;
    }
    if (msg.barCord != undefined) {
      json["barCord"] = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json["barStringPiece"] = msg.barStringPiece;
    }
    if (msg.barBytes?.length) {
      json["barBytes"] = encodeBase64Bytes(msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      json["barEnum"] = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json["barStringWithEmptyDefault"] = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json["barCordWithEmptyDefault"] = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json["barStringPieceWithEmptyDefault"] =
        msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      json["barBytesWithEmptyDefault"] = encodeBase64Bytes(
        msg.barBytesWithEmptyDefault
      );
    }
    if (msg.bazInt) {
      json["bazInt"] = msg.bazInt;
    }
    if (msg.bazString) {
      json["bazString"] = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooCord_ = json["fooCord"] ?? json["foo_cord"];
    if (_fooCord_) {
      msg.fooCord = _fooCord_;
    }
    const _fooStringPiece_ = json["fooStringPiece"] ?? json["foo_string_piece"];
    if (_fooStringPiece_) {
      msg.fooStringPiece = _fooStringPiece_;
    }
    const _fooBytes_ = json["fooBytes"] ?? json["foo_bytes"];
    if (_fooBytes_) {
      msg.fooBytes = decodeBase64Bytes(_fooBytes_);
    }
    const _fooEnum_ = json["fooEnum"] ?? json["foo_enum"];
    if (_fooEnum_) {
      msg.fooEnum = _fooEnum_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2JSON.NestedMessage._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    const _fooLazyMessage_ = json["fooLazyMessage"] ?? json["foo_lazy_message"];
    if (_fooLazyMessage_) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2JSON.NestedMessage._readMessage(m, _fooLazyMessage_);
      msg.fooLazyMessage = m;
    }
    const _barInt_ = json["barInt"] ?? json["bar_int"];
    if (_barInt_) {
      msg.barInt = _barInt_;
    }
    const _barString_ = json["barString"] ?? json["bar_string"];
    if (_barString_) {
      msg.barString = _barString_;
    }
    const _barCord_ = json["barCord"] ?? json["bar_cord"];
    if (_barCord_) {
      msg.barCord = _barCord_;
    }
    const _barStringPiece_ = json["barStringPiece"] ?? json["bar_string_piece"];
    if (_barStringPiece_) {
      msg.barStringPiece = _barStringPiece_;
    }
    const _barBytes_ = json["barBytes"] ?? json["bar_bytes"];
    if (_barBytes_) {
      msg.barBytes = decodeBase64Bytes(_barBytes_);
    }
    const _barEnum_ = json["barEnum"] ?? json["bar_enum"];
    if (_barEnum_) {
      msg.barEnum = _barEnum_;
    }
    const _barStringWithEmptyDefault_ =
      json["barStringWithEmptyDefault"] ??
      json["bar_string_with_empty_default"];
    if (_barStringWithEmptyDefault_) {
      msg.barStringWithEmptyDefault = _barStringWithEmptyDefault_;
    }
    const _barCordWithEmptyDefault_ =
      json["barCordWithEmptyDefault"] ?? json["bar_cord_with_empty_default"];
    if (_barCordWithEmptyDefault_) {
      msg.barCordWithEmptyDefault = _barCordWithEmptyDefault_;
    }
    const _barStringPieceWithEmptyDefault_ =
      json["barStringPieceWithEmptyDefault"] ??
      json["bar_string_piece_with_empty_default"];
    if (_barStringPieceWithEmptyDefault_) {
      msg.barStringPieceWithEmptyDefault = _barStringPieceWithEmptyDefault_;
    }
    const _barBytesWithEmptyDefault_ =
      json["barBytesWithEmptyDefault"] ?? json["bar_bytes_with_empty_default"];
    if (_barBytesWithEmptyDefault_) {
      msg.barBytesWithEmptyDefault = decodeBase64Bytes(
        _barBytesWithEmptyDefault_
      );
    }
    const _bazInt_ = json["bazInt"] ?? json["baz_int"];
    if (_bazInt_) {
      msg.bazInt = _bazInt_;
    }
    const _bazString_ = json["bazString"] ?? json["baz_string"];
    if (_bazString_) {
      msg.bazString = _bazString_;
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  FooGroup: {
    /**
     * Serializes TestOneof2.FooGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestOneof2JSON.FooGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof2.FooGroup from JSON.
     */
    decode: function (json) {
      return TestOneof2JSON.FooGroup._readMessage(
        TestOneof2JSON.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes TestOneof2.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestOneof2JSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof2.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestOneof2JSON.NestedMessage._readMessage(
        TestOneof2JSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.quxInt) {
        json["quxInt"] = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json["corgeInt"] = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _quxInt_ = json["quxInt"] ?? json["qux_int"];
      if (_quxInt_) {
        msg.quxInt = BigInt(_quxInt_);
      }
      const _corgeInt_ = json["corgeInt"] ?? json["corge_int"];
      if (_corgeInt_) {
        msg.corgeInt = _corgeInt_;
      }
      return msg;
    },
  },
};

export const TestRequiredOneofJSON = {
  /**
   * Serializes TestRequiredOneof to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredOneofJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredOneof from JSON.
   */
  decode: function (json) {
    return TestRequiredOneofJSON._readMessage(
      TestRequiredOneofJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestRequiredOneofJSON.NestedMessage._writeMessage(
        msg.fooMessage
      );
      json["fooMessage"] = _fooMessage_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestRequiredOneof.NestedMessage.initialize();
      TestRequiredOneofJSON.NestedMessage._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestRequiredOneof.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestRequiredOneofJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestRequiredOneof.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestRequiredOneofJSON.NestedMessage._readMessage(
        TestRequiredOneofJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.requiredDouble) {
        json["requiredDouble"] = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _requiredDouble_ =
        json["requiredDouble"] ?? json["required_double"];
      if (_requiredDouble_) {
        msg.requiredDouble = _requiredDouble_;
      }
      return msg;
    },
  },
};

export const TestPackedTypesJSON = {
  /**
   * Serializes TestPackedTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestPackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestPackedTypes from JSON.
   */
  decode: function (json) {
    return TestPackedTypesJSON._readMessage(
      TestPackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json["packedInt64"] = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json["packedUint32"] = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json["packedUint64"] = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json["packedSint32"] = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json["packedSint64"] = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json["packedFixed32"] = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json["packedFixed64"] = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json["packedSfixed32"] = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json["packedSfixed64"] = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json["packedFloat"] = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json["packedDouble"] = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json["packedBool"] = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json["packedEnum"] = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _packedInt64_ = json["packedInt64"] ?? json["packed_int64"];
    if (_packedInt64_) {
      msg.packedInt64 = _packedInt64_.map(BigInt);
    }
    const _packedUint32_ = json["packedUint32"] ?? json["packed_uint32"];
    if (_packedUint32_) {
      msg.packedUint32 = _packedUint32_;
    }
    const _packedUint64_ = json["packedUint64"] ?? json["packed_uint64"];
    if (_packedUint64_) {
      msg.packedUint64 = _packedUint64_.map(BigInt);
    }
    const _packedSint32_ = json["packedSint32"] ?? json["packed_sint32"];
    if (_packedSint32_) {
      msg.packedSint32 = _packedSint32_;
    }
    const _packedSint64_ = json["packedSint64"] ?? json["packed_sint64"];
    if (_packedSint64_) {
      msg.packedSint64 = _packedSint64_.map(BigInt);
    }
    const _packedFixed32_ = json["packedFixed32"] ?? json["packed_fixed32"];
    if (_packedFixed32_) {
      msg.packedFixed32 = _packedFixed32_;
    }
    const _packedFixed64_ = json["packedFixed64"] ?? json["packed_fixed64"];
    if (_packedFixed64_) {
      msg.packedFixed64 = _packedFixed64_.map(BigInt);
    }
    const _packedSfixed32_ = json["packedSfixed32"] ?? json["packed_sfixed32"];
    if (_packedSfixed32_) {
      msg.packedSfixed32 = _packedSfixed32_;
    }
    const _packedSfixed64_ = json["packedSfixed64"] ?? json["packed_sfixed64"];
    if (_packedSfixed64_) {
      msg.packedSfixed64 = _packedSfixed64_.map(BigInt);
    }
    const _packedFloat_ = json["packedFloat"] ?? json["packed_float"];
    if (_packedFloat_) {
      msg.packedFloat = _packedFloat_;
    }
    const _packedDouble_ = json["packedDouble"] ?? json["packed_double"];
    if (_packedDouble_) {
      msg.packedDouble = _packedDouble_;
    }
    const _packedBool_ = json["packedBool"] ?? json["packed_bool"];
    if (_packedBool_) {
      msg.packedBool = _packedBool_;
    }
    const _packedEnum_ = json["packedEnum"] ?? json["packed_enum"];
    if (_packedEnum_) {
      msg.packedEnum = _packedEnum_;
    }
    return msg;
  },
};

export const TestUnpackedTypesJSON = {
  /**
   * Serializes TestUnpackedTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestUnpackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestUnpackedTypes from JSON.
   */
  decode: function (json) {
    return TestUnpackedTypesJSON._readMessage(
      TestUnpackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.unpackedInt32?.length) {
      json["unpackedInt32"] = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json["unpackedInt64"] = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json["unpackedUint32"] = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json["unpackedUint64"] = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json["unpackedSint32"] = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json["unpackedSint64"] = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json["unpackedFixed32"] = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json["unpackedFixed64"] = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json["unpackedSfixed32"] = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json["unpackedSfixed64"] = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json["unpackedFloat"] = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json["unpackedDouble"] = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json["unpackedBool"] = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json["unpackedEnum"] = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _unpackedInt32_ = json["unpackedInt32"] ?? json["unpacked_int32"];
    if (_unpackedInt32_) {
      msg.unpackedInt32 = _unpackedInt32_;
    }
    const _unpackedInt64_ = json["unpackedInt64"] ?? json["unpacked_int64"];
    if (_unpackedInt64_) {
      msg.unpackedInt64 = _unpackedInt64_.map(BigInt);
    }
    const _unpackedUint32_ = json["unpackedUint32"] ?? json["unpacked_uint32"];
    if (_unpackedUint32_) {
      msg.unpackedUint32 = _unpackedUint32_;
    }
    const _unpackedUint64_ = json["unpackedUint64"] ?? json["unpacked_uint64"];
    if (_unpackedUint64_) {
      msg.unpackedUint64 = _unpackedUint64_.map(BigInt);
    }
    const _unpackedSint32_ = json["unpackedSint32"] ?? json["unpacked_sint32"];
    if (_unpackedSint32_) {
      msg.unpackedSint32 = _unpackedSint32_;
    }
    const _unpackedSint64_ = json["unpackedSint64"] ?? json["unpacked_sint64"];
    if (_unpackedSint64_) {
      msg.unpackedSint64 = _unpackedSint64_.map(BigInt);
    }
    const _unpackedFixed32_ =
      json["unpackedFixed32"] ?? json["unpacked_fixed32"];
    if (_unpackedFixed32_) {
      msg.unpackedFixed32 = _unpackedFixed32_;
    }
    const _unpackedFixed64_ =
      json["unpackedFixed64"] ?? json["unpacked_fixed64"];
    if (_unpackedFixed64_) {
      msg.unpackedFixed64 = _unpackedFixed64_.map(BigInt);
    }
    const _unpackedSfixed32_ =
      json["unpackedSfixed32"] ?? json["unpacked_sfixed32"];
    if (_unpackedSfixed32_) {
      msg.unpackedSfixed32 = _unpackedSfixed32_;
    }
    const _unpackedSfixed64_ =
      json["unpackedSfixed64"] ?? json["unpacked_sfixed64"];
    if (_unpackedSfixed64_) {
      msg.unpackedSfixed64 = _unpackedSfixed64_.map(BigInt);
    }
    const _unpackedFloat_ = json["unpackedFloat"] ?? json["unpacked_float"];
    if (_unpackedFloat_) {
      msg.unpackedFloat = _unpackedFloat_;
    }
    const _unpackedDouble_ = json["unpackedDouble"] ?? json["unpacked_double"];
    if (_unpackedDouble_) {
      msg.unpackedDouble = _unpackedDouble_;
    }
    const _unpackedBool_ = json["unpackedBool"] ?? json["unpacked_bool"];
    if (_unpackedBool_) {
      msg.unpackedBool = _unpackedBool_;
    }
    const _unpackedEnum_ = json["unpackedEnum"] ?? json["unpacked_enum"];
    if (_unpackedEnum_) {
      msg.unpackedEnum = _unpackedEnum_;
    }
    return msg;
  },
};

export const TestPackedExtensionsJSON = {
  /**
   * Serializes TestPackedExtensions to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestPackedExtensions from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestUnpackedExtensionsJSON = {
  /**
   * Serializes TestUnpackedExtensions to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestUnpackedExtensions from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestDynamicExtensionsJSON = {
  /**
   * Serializes TestDynamicExtensions to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestDynamicExtensionsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDynamicExtensions from JSON.
   */
  decode: function (json) {
    return TestDynamicExtensionsJSON._readMessage(
      TestDynamicExtensionsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnum._fromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType._fromInt(0),
      messageExtension: ForeignMessageJSON.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensionsJSON.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.scalarExtension) {
      json["scalarExtension"] = msg.scalarExtension;
    }
    if (msg.enumExtension && ForeignEnumJSON._toInt(msg.enumExtension)) {
      json["enumExtension"] = msg.enumExtension;
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensionsJSON.DynamicEnumType._toInt(msg.dynamicEnumExtension)
    ) {
      json["dynamicEnumExtension"] = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const _messageExtension_ = ForeignMessageJSON._writeMessage(
        msg.messageExtension
      );
      if (Object.keys(_messageExtension_).length > 0) {
        json["messageExtension"] = _messageExtension_;
      }
    }
    if (msg.dynamicMessageExtension) {
      const _dynamicMessageExtension_ =
        TestDynamicExtensionsJSON.DynamicMessageType._writeMessage(
          msg.dynamicMessageExtension
        );
      if (Object.keys(_dynamicMessageExtension_).length > 0) {
        json["dynamicMessageExtension"] = _dynamicMessageExtension_;
      }
    }
    if (msg.repeatedExtension?.length) {
      json["repeatedExtension"] = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json["packedExtension"] = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _scalarExtension_ =
      json["scalarExtension"] ?? json["scalar_extension"];
    if (_scalarExtension_) {
      msg.scalarExtension = _scalarExtension_;
    }
    const _enumExtension_ = json["enumExtension"] ?? json["enum_extension"];
    if (_enumExtension_) {
      msg.enumExtension = _enumExtension_;
    }
    const _dynamicEnumExtension_ =
      json["dynamicEnumExtension"] ?? json["dynamic_enum_extension"];
    if (_dynamicEnumExtension_) {
      msg.dynamicEnumExtension = _dynamicEnumExtension_;
    }
    const _messageExtension_ =
      json["messageExtension"] ?? json["message_extension"];
    if (_messageExtension_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _messageExtension_);
      msg.messageExtension = m;
    }
    const _dynamicMessageExtension_ =
      json["dynamicMessageExtension"] ?? json["dynamic_message_extension"];
    if (_dynamicMessageExtension_) {
      const m = TestDynamicExtensions.DynamicMessageType.initialize();
      TestDynamicExtensionsJSON.DynamicMessageType._readMessage(
        m,
        _dynamicMessageExtension_
      );
      msg.dynamicMessageExtension = m;
    }
    const _repeatedExtension_ =
      json["repeatedExtension"] ?? json["repeated_extension"];
    if (_repeatedExtension_) {
      msg.repeatedExtension = _repeatedExtension_;
    }
    const _packedExtension_ =
      json["packedExtension"] ?? json["packed_extension"];
    if (_packedExtension_) {
      msg.packedExtension = _packedExtension_;
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: "DYNAMIC_FOO",
    DYNAMIC_BAR: "DYNAMIC_BAR",
    DYNAMIC_BAZ: "DYNAMIC_BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 2200: {
          return "DYNAMIC_FOO";
        }
        case 2201: {
          return "DYNAMIC_BAR";
        }
        case 2202: {
          return "DYNAMIC_BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "DYNAMIC_FOO": {
          return 2200;
        }
        case "DYNAMIC_BAR": {
          return 2201;
        }
        case "DYNAMIC_BAZ": {
          return 2202;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  DynamicMessageType: {
    /**
     * Serializes TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestDynamicExtensionsJSON.DynamicMessageType._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decode: function (json) {
      return TestDynamicExtensionsJSON.DynamicMessageType._readMessage(
        TestDynamicExtensionsJSON.DynamicMessageType.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.dynamicField) {
        json["dynamicField"] = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _dynamicField_ = json["dynamicField"] ?? json["dynamic_field"];
      if (_dynamicField_) {
        msg.dynamicField = _dynamicField_;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizesJSON = {
  /**
   * Serializes TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizesJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decode: function (json) {
    return TestRepeatedScalarDifferentTagSizesJSON._readMessage(
      TestRepeatedScalarDifferentTagSizesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMergeJSON = {
  /**
   * Serializes TestParsingMerge to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestParsingMergeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestParsingMerge from JSON.
   */
  decode: function (json) {
    return TestParsingMergeJSON._readMessage(
      TestParsingMergeJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      requiredAllTypes: TestAllTypesJSON.initialize(),
      optionalAllTypes: TestAllTypesJSON.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.requiredAllTypes) {
      const _requiredAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.requiredAllTypes
      );
      if (Object.keys(_requiredAllTypes_).length > 0) {
        json["requiredAllTypes"] = _requiredAllTypes_;
      }
    }
    if (msg.optionalAllTypes) {
      const _optionalAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.optionalAllTypes
      );
      if (Object.keys(_optionalAllTypes_).length > 0) {
        json["optionalAllTypes"] = _optionalAllTypes_;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json["repeatedAllTypes"] = msg.repeatedAllTypes.map(
        TestAllTypesJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _requiredAllTypes_ =
      json["requiredAllTypes"] ?? json["required_all_types"];
    if (_requiredAllTypes_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _requiredAllTypes_);
      msg.requiredAllTypes = m;
    }
    const _optionalAllTypes_ =
      json["optionalAllTypes"] ?? json["optional_all_types"];
    if (_optionalAllTypes_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _optionalAllTypes_);
      msg.optionalAllTypes = m;
    }
    const _repeatedAllTypes_ =
      json["repeatedAllTypes"] ?? json["repeated_all_types"];
    if (_repeatedAllTypes_) {
      for (const item of _repeatedAllTypes_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestParsingMergeJSON.RepeatedFieldsGenerator._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decode: function (json) {
      return TestParsingMergeJSON.RepeatedFieldsGenerator._readMessage(
        TestParsingMergeJSON.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.field1?.length) {
        json["field1"] = msg.field1.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.field2?.length) {
        json["field2"] = msg.field2.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.field3?.length) {
        json["field3"] = msg.field3.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.ext1?.length) {
        json["ext1"] = msg.ext1.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.ext2?.length) {
        json["ext2"] = msg.ext2.map(TestAllTypesJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _field1_ = json["field1"];
      if (_field1_) {
        for (const item of _field1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field1.push(m);
        }
      }
      const _field2_ = json["field2"];
      if (_field2_) {
        for (const item of _field2_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field2.push(m);
        }
      }
      const _field3_ = json["field3"];
      if (_field3_) {
        for (const item of _field3_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field3.push(m);
        }
      }
      const _ext1_ = json["ext1"];
      if (_ext1_) {
        for (const item of _ext1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.ext1.push(m);
        }
      }
      const _ext2_ = json["ext2"];
      if (_ext2_) {
        for (const item of _ext2_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encode: function (msg) {
        return JSON.stringify(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group1._writeMessage(msg)
        );
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decode: function (json) {
        return TestParsingMergeJSON.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypesJSON.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg) {
        const json = {};
        if (msg.field1) {
          const _field1_ = TestAllTypesJSON._writeMessage(msg.field1);
          if (Object.keys(_field1_).length > 0) {
            json["field1"] = _field1_;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, json) {
        const _field1_ = json["field1"];
        if (_field1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, _field1_);
          msg.field1 = m;
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encode: function (msg) {
        return JSON.stringify(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group2._writeMessage(msg)
        );
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decode: function (json) {
        return TestParsingMergeJSON.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypesJSON.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg) {
        const json = {};
        if (msg.field1) {
          const _field1_ = TestAllTypesJSON._writeMessage(msg.field1);
          if (Object.keys(_field1_).length > 0) {
            json["field1"] = _field1_;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, json) {
        const _field1_ = json["field1"];
        if (_field1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, _field1_);
          msg.field1 = m;
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestParsingMerge.OptionalGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestParsingMergeJSON.OptionalGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestParsingMerge.OptionalGroup from JSON.
     */
    decode: function (json) {
      return TestParsingMergeJSON.OptionalGroup._readMessage(
        TestParsingMergeJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optionalGroupAllTypes: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.optionalGroupAllTypes) {
        const _optionalGroupAllTypes_ = TestAllTypesJSON._writeMessage(
          msg.optionalGroupAllTypes
        );
        if (Object.keys(_optionalGroupAllTypes_).length > 0) {
          json["optionalGroupAllTypes"] = _optionalGroupAllTypes_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _optionalGroupAllTypes_ =
        json["optionalGroupAllTypes"] ?? json["optional_group_all_types"];
      if (_optionalGroupAllTypes_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, _optionalGroupAllTypes_);
        msg.optionalGroupAllTypes = m;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestParsingMerge.RepeatedGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestParsingMergeJSON.RepeatedGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestParsingMerge.RepeatedGroup from JSON.
     */
    decode: function (json) {
      return TestParsingMergeJSON.RepeatedGroup._readMessage(
        TestParsingMergeJSON.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeatedGroupAllTypes: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.repeatedGroupAllTypes) {
        const _repeatedGroupAllTypes_ = TestAllTypesJSON._writeMessage(
          msg.repeatedGroupAllTypes
        );
        if (Object.keys(_repeatedGroupAllTypes_).length > 0) {
          json["repeatedGroupAllTypes"] = _repeatedGroupAllTypes_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _repeatedGroupAllTypes_ =
        json["repeatedGroupAllTypes"] ?? json["repeated_group_all_types"];
      if (_repeatedGroupAllTypes_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, _repeatedGroupAllTypes_);
        msg.repeatedGroupAllTypes = m;
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessageJSON = {
  /**
   * Serializes TestCommentInjectionMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestCommentInjectionMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestCommentInjectionMessage from JSON.
   */
  decode: function (json) {
    return TestCommentInjectionMessageJSON._readMessage(
      TestCommentInjectionMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const FooRequestJSON = {
  /**
   * Serializes FooRequest to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes FooRequest from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const FooResponseJSON = {
  /**
   * Serializes FooResponse to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes FooResponse from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const FooClientMessageJSON = {
  /**
   * Serializes FooClientMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes FooClientMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const FooServerMessageJSON = {
  /**
   * Serializes FooServerMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes FooServerMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const BarRequestJSON = {
  /**
   * Serializes BarRequest to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes BarRequest from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const BarResponseJSON = {
  /**
   * Serializes BarResponse to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes BarResponse from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestJsonNameJSON = {
  /**
   * Serializes TestJsonName to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestJsonNameJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestJsonName from JSON.
   */
  decode: function (json) {
    return TestJsonNameJSON._readMessage(
      TestJsonNameJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fieldName1) {
      json["fieldName1"] = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json["fieldName2"] = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json["FieldName3"] = msg.FieldName3;
    }
    if (msg.FieldName4) {
      json["FieldName4"] = msg.FieldName4;
    }
    if (msg.FIELDNAME5) {
      json["FIELDNAME5"] = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json["@type"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json["fieldname7"] = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fieldName1_ = json["fieldName1"] ?? json["field_name1"];
    if (_fieldName1_) {
      msg.fieldName1 = _fieldName1_;
    }
    const _fieldName2_ = json["fieldName2"];
    if (_fieldName2_) {
      msg.fieldName2 = _fieldName2_;
    }
    const _FieldName3_ = json["FieldName3"];
    if (_FieldName3_) {
      msg.FieldName3 = _FieldName3_;
    }
    const _FieldName4_ = json["FieldName4"] ?? json["_field_name4"];
    if (_FieldName4_) {
      msg.FieldName4 = _FieldName4_;
    }
    const _FIELDNAME5_ = json["FIELDNAME5"] ?? json["FIELD_NAME5"];
    if (_FIELDNAME5_) {
      msg.FIELDNAME5 = _FIELDNAME5_;
    }
    const _fieldName6_ =
      json["@type"] ?? json["fieldName6"] ?? json["field_name6"];
    if (_fieldName6_) {
      msg.fieldName6 = _fieldName6_;
    }
    const _fieldname7_ = json["fieldname7"];
    if (_fieldname7_) {
      msg.fieldname7 = _fieldname7_;
    }
    return msg;
  },
};

export const TestHugeFieldNumbersJSON = {
  /**
   * Serializes TestHugeFieldNumbers to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestHugeFieldNumbersJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestHugeFieldNumbers from JSON.
   */
  decode: function (json) {
    return TestHugeFieldNumbersJSON._readMessage(
      TestHugeFieldNumbersJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnum._fromInt(0),
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessageJSON.initialize(),
      stringStringMap: {},
      oneofUint32: undefined,
      oneofTestAllTypes: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json["fixed32"] = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.optionalEnum && ForeignEnumJSON._toInt(msg.optionalEnum)) {
      json["optionalEnum"] = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      const _optionalMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalMessage
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.stringStringMap) {
      const _stringStringMap_ = Object.fromEntries(
        Object.entries(msg.stringStringMap)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbersJSON.StringStringMap._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_stringStringMap_).length > 0) {
        json["stringStringMap"] = _stringStringMap_;
      }
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const _oneofTestAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.oneofTestAllTypes
      );
      json["oneofTestAllTypes"] = _oneofTestAllTypes_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _fixed32_ = json["fixed32"] ?? json["fixed_32"];
    if (_fixed32_) {
      msg.fixed32 = _fixed32_;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _optionalEnum_ = json["optionalEnum"] ?? json["optional_enum"];
    if (_optionalEnum_) {
      msg.optionalEnum = _optionalEnum_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _optionalMessage_);
      msg.optionalMessage = m;
    }
    const _stringStringMap_ =
      json["stringStringMap"] ?? json["string_string_map"];
    if (_stringStringMap_) {
      msg.stringStringMap = Object.fromEntries(
        Object.entries(_stringStringMap_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbersJSON.StringStringMap._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofTestAllTypes_ =
      json["oneofTestAllTypes"] ?? json["oneof_test_all_types"];
    if (_oneofTestAllTypes_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _oneofTestAllTypes_);
      msg.oneofTestAllTypes = m;
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestHugeFieldNumbersJSON.OptionalGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decode: function (json) {
      return TestHugeFieldNumbersJSON.OptionalGroup._readMessage(
        TestHugeFieldNumbersJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.groupA) {
        json["groupA"] = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _groupA_ = json["groupA"] ?? json["group_a"];
      if (_groupA_) {
        msg.groupA = _groupA_;
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTableJSON = {
  /**
   * Serializes TestExtensionInsideTable to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtensionInsideTableJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionInsideTable from JSON.
   */
  decode: function (json) {
    return TestExtensionInsideTableJSON._readMessage(
      TestExtensionInsideTableJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.field1) {
      json["field1"] = msg.field1;
    }
    if (msg.field2) {
      json["field2"] = msg.field2;
    }
    if (msg.field3) {
      json["field3"] = msg.field3;
    }
    if (msg.field4) {
      json["field4"] = msg.field4;
    }
    if (msg.field6) {
      json["field6"] = msg.field6;
    }
    if (msg.field7) {
      json["field7"] = msg.field7;
    }
    if (msg.field8) {
      json["field8"] = msg.field8;
    }
    if (msg.field9) {
      json["field9"] = msg.field9;
    }
    if (msg.field10) {
      json["field10"] = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _field1_ = json["field1"];
    if (_field1_) {
      msg.field1 = _field1_;
    }
    const _field2_ = json["field2"];
    if (_field2_) {
      msg.field2 = _field2_;
    }
    const _field3_ = json["field3"];
    if (_field3_) {
      msg.field3 = _field3_;
    }
    const _field4_ = json["field4"];
    if (_field4_) {
      msg.field4 = _field4_;
    }
    const _field6_ = json["field6"];
    if (_field6_) {
      msg.field6 = _field6_;
    }
    const _field7_ = json["field7"];
    if (_field7_) {
      msg.field7 = _field7_;
    }
    const _field8_ = json["field8"];
    if (_field8_) {
      msg.field8 = _field8_;
    }
    const _field9_ = json["field9"];
    if (_field9_) {
      msg.field9 = _field9_;
    }
    const _field10_ = json["field10"];
    if (_field10_) {
      msg.field10 = _field10_;
    }
    return msg;
  },
};

export const TestExtensionRangeSerializeJSON = {
  /**
   * Serializes TestExtensionRangeSerialize to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtensionRangeSerializeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionRangeSerialize from JSON.
   */
  decode: function (json) {
    return TestExtensionRangeSerializeJSON._readMessage(
      TestExtensionRangeSerializeJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooOne) {
      json["fooOne"] = msg.fooOne;
    }
    if (msg.fooTwo) {
      json["fooTwo"] = msg.fooTwo;
    }
    if (msg.fooThree) {
      json["fooThree"] = msg.fooThree;
    }
    if (msg.fooFour) {
      json["fooFour"] = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooOne_ = json["fooOne"] ?? json["foo_one"];
    if (_fooOne_) {
      msg.fooOne = _fooOne_;
    }
    const _fooTwo_ = json["fooTwo"] ?? json["foo_two"];
    if (_fooTwo_) {
      msg.fooTwo = _fooTwo_;
    }
    const _fooThree_ = json["fooThree"] ?? json["foo_three"];
    if (_fooThree_) {
      msg.fooThree = _fooThree_;
    }
    const _fooFour_ = json["fooFour"] ?? json["foo_four"];
    if (_fooFour_) {
      msg.fooFour = _fooFour_;
    }
    return msg;
  },
};
",
      ],
      [
        "google/protobuf/map_unittest.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto
/* eslint-disable */

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";

import * as googleProtobufUnittest from "./unittest.pb.js";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: "MAP_ENUM_FOO",
  MAP_ENUM_BAR: "MAP_ENUM_BAR",
  MAP_ENUM_BAZ: "MAP_ENUM_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "MAP_ENUM_FOO";
      }
      case 1: {
        return "MAP_ENUM_BAR";
      }
      case 2: {
        return "MAP_ENUM_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "MAP_ENUM_FOO": {
        return 0;
      }
      case "MAP_ENUM_BAR": {
        return 1;
      }
      case "MAP_ENUM_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestMap = {
  /**
   * Serializes TestMap to protobuf.
   */
  encode: function (msg) {
    return TestMap._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestMap from protobuf.
   */
  decode: function (bytes) {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32ForeignMessage._writeMessage
      );
    }
    if (msg.mapStringForeignMessage) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.mapStringForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapStringForeignMessage._writeMessage
      );
    }
    if (msg.mapInt32AllTypes) {
      writer.writeRepeatedMessage(
        19,
        Object.entries(msg.mapInt32AllTypes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32AllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {};
          reader.readMessage(map, TestMap.MapUint32Uint32._readMessage);
          msg.mapUint32Uint32[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {};
          reader.readMessage(map, TestMap.MapUint64Uint64._readMessage);
          msg.mapUint64Uint64[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {};
          reader.readMessage(map, TestMap.MapSint32Sint32._readMessage);
          msg.mapSint32Sint32[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {};
          reader.readMessage(map, TestMap.MapSint64Sint64._readMessage);
          msg.mapSint64Sint64[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {};
          reader.readMessage(map, TestMap.MapFixed32Fixed32._readMessage);
          msg.mapFixed32Fixed32[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {};
          reader.readMessage(map, TestMap.MapFixed64Fixed64._readMessage);
          msg.mapFixed64Fixed64[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {};
          reader.readMessage(map, TestMap.MapSfixed32Sfixed32._readMessage);
          msg.mapSfixed32Sfixed32[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {};
          reader.readMessage(map, TestMap.MapSfixed64Sfixed64._readMessage);
          msg.mapSfixed64Sfixed64[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Float._readMessage);
          msg.mapInt32Float[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Double._readMessage);
          msg.mapInt32Double[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {};
          reader.readMessage(map, TestMap.MapBoolBool._readMessage);
          msg.mapBoolBool[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {};
          reader.readMessage(map, TestMap.MapStringString._readMessage);
          msg.mapStringString[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32ForeignMessage._readMessage);
          msg.mapInt32ForeignMessage[map.key.toString()] = map.value;
          break;
        }
        case 18: {
          const map = {};
          reader.readMessage(map, TestMap.MapStringForeignMessage._readMessage);
          msg.mapStringForeignMessage[map.key.toString()] = map.value;
          break;
        }
        case 19: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32AllTypes._readMessage);
          msg.mapInt32AllTypes[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnum._toInt(msg.value)) {
        writer.writeEnum(2, MapEnum._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnum._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestAllTypes.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes TestMapSubmessage to protobuf.
   */
  encode: function (msg) {
    return TestMapSubmessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMapSubmessage from protobuf.
   */
  decode: function (bytes) {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes TestMessageMap to protobuf.
   */
  encode: function (msg) {
    return TestMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Message) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Message).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMessageMap.MapInt32Message._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestMessageMap.MapInt32Message._readMessage);
          msg.mapInt32Message[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestAllTypes.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes TestSameTypeMap to protobuf.
   */
  encode: function (msg) {
    return TestSameTypeMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestSameTypeMap from protobuf.
   */
  decode: function (bytes) {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map1) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.map1).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestSameTypeMap.Map1._writeMessage
      );
    }
    if (msg.map2) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.map2).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestSameTypeMap.Map2._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestSameTypeMap.Map1._readMessage);
          msg.map1[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {};
          reader.readMessage(map, TestSameTypeMap.Map2._readMessage);
          msg.map2[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes TestRequiredMessageMap to protobuf.
   */
  encode: function (msg) {
    return TestRequiredMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestRequiredMessageMap.MapField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestRequiredMessageMap.MapField._readMessage);
          msg.mapField[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestRequired._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestRequired.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestRequired._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestArenaMap = {
  /**
   * Serializes TestArenaMap to protobuf.
   */
  encode: function (msg) {
    return TestArenaMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestArenaMap from protobuf.
   */
  decode: function (bytes) {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32ForeignMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapUint32Uint32._readMessage);
          msg.mapUint32Uint32[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapUint64Uint64._readMessage);
          msg.mapUint64Uint64[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapSint32Sint32._readMessage);
          msg.mapSint32Sint32[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapSint64Sint64._readMessage);
          msg.mapSint64Sint64[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapFixed32Fixed32._readMessage);
          msg.mapFixed32Fixed32[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapFixed64Fixed64._readMessage);
          msg.mapFixed64Fixed64[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {};
          reader.readMessage(
            map,
            TestArenaMap.MapSfixed32Sfixed32._readMessage
          );
          msg.mapSfixed32Sfixed32[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {};
          reader.readMessage(
            map,
            TestArenaMap.MapSfixed64Sfixed64._readMessage
          );
          msg.mapSfixed64Sfixed64[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Float._readMessage);
          msg.mapInt32Float[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Double._readMessage);
          msg.mapInt32Double[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapBoolBool._readMessage);
          msg.mapBoolBool[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapStringString._readMessage);
          msg.mapStringString[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {};
          reader.readMessage(
            map,
            TestArenaMap.MapInt32ForeignMessage._readMessage
          );
          msg.mapInt32ForeignMessage[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnum._toInt(msg.value)) {
        writer.writeEnum(2, MapEnum._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnum._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (msg) {
    return MessageContainingMapCalledEntry._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes) {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.entry) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.entry).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MessageContainingMapCalledEntry.Entry._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(
            map,
            MessageContainingMapCalledEntry.Entry._readMessage
          );
          msg.entry[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes TestRecursiveMapMessage to protobuf.
   */
  encode: function (msg) {
    return TestRecursiveMapMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.a).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestRecursiveMapMessage.A._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestRecursiveMapMessage.A._readMessage);
          msg.a[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          TestRecursiveMapMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = TestRecursiveMapMessage.initialize();
            reader.readMessage(msg.value, TestRecursiveMapMessage._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const MapEnumJSON = {
  MAP_ENUM_FOO: "MAP_ENUM_FOO",
  MAP_ENUM_BAR: "MAP_ENUM_BAR",
  MAP_ENUM_BAZ: "MAP_ENUM_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "MAP_ENUM_FOO";
      }
      case 1: {
        return "MAP_ENUM_BAR";
      }
      case 2: {
        return "MAP_ENUM_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "MAP_ENUM_FOO": {
        return 0;
      }
      case "MAP_ENUM_BAR": {
        return 1;
      }
      case "MAP_ENUM_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestMapJSON = {
  /**
   * Serializes TestMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMap from JSON.
   */
  decode: function (json) {
    return TestMapJSON._readMessage(TestMapJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      const _mapInt32Int32_ = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Int32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Int32_).length > 0) {
        json["mapInt32Int32"] = _mapInt32Int32_;
      }
    }
    if (msg.mapInt64Int64) {
      const _mapInt64Int64_ = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt64Int64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt64Int64_).length > 0) {
        json["mapInt64Int64"] = _mapInt64Int64_;
      }
    }
    if (msg.mapUint32Uint32) {
      const _mapUint32Uint32_ = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapUint32Uint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint32Uint32_).length > 0) {
        json["mapUint32Uint32"] = _mapUint32Uint32_;
      }
    }
    if (msg.mapUint64Uint64) {
      const _mapUint64Uint64_ = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapUint64Uint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint64Uint64_).length > 0) {
        json["mapUint64Uint64"] = _mapUint64Uint64_;
      }
    }
    if (msg.mapSint32Sint32) {
      const _mapSint32Sint32_ = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSint32Sint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint32Sint32_).length > 0) {
        json["mapSint32Sint32"] = _mapSint32Sint32_;
      }
    }
    if (msg.mapSint64Sint64) {
      const _mapSint64Sint64_ = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSint64Sint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint64Sint64_).length > 0) {
        json["mapSint64Sint64"] = _mapSint64Sint64_;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const _mapFixed32Fixed32_ = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapFixed32Fixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed32Fixed32_).length > 0) {
        json["mapFixed32Fixed32"] = _mapFixed32Fixed32_;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const _mapFixed64Fixed64_ = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapFixed64Fixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed64Fixed64_).length > 0) {
        json["mapFixed64Fixed64"] = _mapFixed64Fixed64_;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const _mapSfixed32Sfixed32_ = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSfixed32Sfixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed32Sfixed32_).length > 0) {
        json["mapSfixed32Sfixed32"] = _mapSfixed32Sfixed32_;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const _mapSfixed64Sfixed64_ = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSfixed64Sfixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed64Sfixed64_).length > 0) {
        json["mapSfixed64Sfixed64"] = _mapSfixed64Sfixed64_;
      }
    }
    if (msg.mapInt32Float) {
      const _mapInt32Float_ = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Float._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Float_).length > 0) {
        json["mapInt32Float"] = _mapInt32Float_;
      }
    }
    if (msg.mapInt32Double) {
      const _mapInt32Double_ = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Double._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Double_).length > 0) {
        json["mapInt32Double"] = _mapInt32Double_;
      }
    }
    if (msg.mapBoolBool) {
      const _mapBoolBool_ = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapBoolBool._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapBoolBool_).length > 0) {
        json["mapBoolBool"] = _mapBoolBool_;
      }
    }
    if (msg.mapStringString) {
      const _mapStringString_ = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapStringString._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapStringString_).length > 0) {
        json["mapStringString"] = _mapStringString_;
      }
    }
    if (msg.mapInt32Bytes) {
      const _mapInt32Bytes_ = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Bytes._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Bytes_).length > 0) {
        json["mapInt32Bytes"] = _mapInt32Bytes_;
      }
    }
    if (msg.mapInt32Enum) {
      const _mapInt32Enum_ = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Enum._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Enum_).length > 0) {
        json["mapInt32Enum"] = _mapInt32Enum_;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const _mapInt32ForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32ForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32ForeignMessage_).length > 0) {
        json["mapInt32ForeignMessage"] = _mapInt32ForeignMessage_;
      }
    }
    if (msg.mapStringForeignMessage) {
      const _mapStringForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapStringForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapStringForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapStringForeignMessage_).length > 0) {
        json["mapStringForeignMessage"] = _mapStringForeignMessage_;
      }
    }
    if (msg.mapInt32AllTypes) {
      const _mapInt32AllTypes_ = Object.fromEntries(
        Object.entries(msg.mapInt32AllTypes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32AllTypes._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32AllTypes_).length > 0) {
        json["mapInt32AllTypes"] = _mapInt32AllTypes_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _mapInt32Int32_ = json["mapInt32Int32"] ?? json["map_int32_int32"];
    if (_mapInt32Int32_) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Int32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64_ = json["mapInt64Int64"] ?? json["map_int64_int64"];
    if (_mapInt64Int64_) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt64Int64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32_ =
      json["mapUint32Uint32"] ?? json["map_uint32_uint32"];
    if (_mapUint32Uint32_) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapUint32Uint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64_ =
      json["mapUint64Uint64"] ?? json["map_uint64_uint64"];
    if (_mapUint64Uint64_) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapUint64Uint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32_ =
      json["mapSint32Sint32"] ?? json["map_sint32_sint32"];
    if (_mapSint32Sint32_) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSint32Sint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64_ =
      json["mapSint64Sint64"] ?? json["map_sint64_sint64"];
    if (_mapSint64Sint64_) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSint64Sint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32_ =
      json["mapFixed32Fixed32"] ?? json["map_fixed32_fixed32"];
    if (_mapFixed32Fixed32_) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapFixed32Fixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64_ =
      json["mapFixed64Fixed64"] ?? json["map_fixed64_fixed64"];
    if (_mapFixed64Fixed64_) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapFixed64Fixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32_ =
      json["mapSfixed32Sfixed32"] ?? json["map_sfixed32_sfixed32"];
    if (_mapSfixed32Sfixed32_) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSfixed32Sfixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64_ =
      json["mapSfixed64Sfixed64"] ?? json["map_sfixed64_sfixed64"];
    if (_mapSfixed64Sfixed64_) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSfixed64Sfixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float_ = json["mapInt32Float"] ?? json["map_int32_float"];
    if (_mapInt32Float_) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Float._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double_ = json["mapInt32Double"] ?? json["map_int32_double"];
    if (_mapInt32Double_) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Double._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool_ = json["mapBoolBool"] ?? json["map_bool_bool"];
    if (_mapBoolBool_) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapBoolBool._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString_ =
      json["mapStringString"] ?? json["map_string_string"];
    if (_mapStringString_) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapStringString._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes_ = json["mapInt32Bytes"] ?? json["map_int32_bytes"];
    if (_mapInt32Bytes_) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Bytes._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum_ = json["mapInt32Enum"] ?? json["map_int32_enum"];
    if (_mapInt32Enum_) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Enum._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage_ =
      json["mapInt32ForeignMessage"] ?? json["map_int32_foreign_message"];
    if (_mapInt32ForeignMessage_) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32ForeignMessage._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringForeignMessage_ =
      json["mapStringForeignMessage"] ?? json["map_string_foreign_message"];
    if (_mapStringForeignMessage_) {
      msg.mapStringForeignMessage = Object.fromEntries(
        Object.entries(_mapStringForeignMessage_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapStringForeignMessage._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32AllTypes_ =
      json["mapInt32AllTypes"] ?? json["map_int32_all_types"];
    if (_mapInt32AllTypes_) {
      msg.mapInt32AllTypes = Object.fromEntries(
        Object.entries(_mapInt32AllTypes_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32AllTypes._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value?.length) {
        json["value"] = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = decodeBase64Bytes(_value_);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && MapEnumJSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.ForeignMessage.initialize();
        googleProtobufUnittest.ForeignMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.ForeignMessage.initialize();
        googleProtobufUnittest.ForeignMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestAllTypesJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.TestAllTypes.initialize();
        googleProtobufUnittest.TestAllTypesJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestMapSubmessageJSON = {
  /**
   * Serializes TestMapSubmessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMapSubmessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMapSubmessage from JSON.
   */
  decode: function (json) {
    return TestMapSubmessageJSON._readMessage(
      TestMapSubmessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      testMap: TestMapJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.testMap) {
      const _testMap_ = TestMapJSON._writeMessage(msg.testMap);
      if (Object.keys(_testMap_).length > 0) {
        json["testMap"] = _testMap_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _testMap_ = json["testMap"] ?? json["test_map"];
    if (_testMap_) {
      const m = TestMap.initialize();
      TestMapJSON._readMessage(m, _testMap_);
      msg.testMap = m;
    }
    return msg;
  },
};

export const TestMessageMapJSON = {
  /**
   * Serializes TestMessageMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMessageMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMessageMap from JSON.
   */
  decode: function (json) {
    return TestMessageMapJSON._readMessage(
      TestMessageMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.mapInt32Message) {
      const _mapInt32Message_ = Object.fromEntries(
        Object.entries(msg.mapInt32Message)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMapJSON.MapInt32Message._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Message_).length > 0) {
        json["mapInt32Message"] = _mapInt32Message_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _mapInt32Message_ =
      json["mapInt32Message"] ?? json["map_int32_message"];
    if (_mapInt32Message_) {
      msg.mapInt32Message = Object.fromEntries(
        Object.entries(_mapInt32Message_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMapJSON.MapInt32Message._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestAllTypesJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.TestAllTypes.initialize();
        googleProtobufUnittest.TestAllTypesJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestSameTypeMapJSON = {
  /**
   * Serializes TestSameTypeMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestSameTypeMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestSameTypeMap from JSON.
   */
  decode: function (json) {
    return TestSameTypeMapJSON._readMessage(
      TestSameTypeMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.map1) {
      const _map1_ = Object.fromEntries(
        Object.entries(msg.map1)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMapJSON.Map1._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_map1_).length > 0) {
        json["map1"] = _map1_;
      }
    }
    if (msg.map2) {
      const _map2_ = Object.fromEntries(
        Object.entries(msg.map2)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMapJSON.Map2._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_map2_).length > 0) {
        json["map2"] = _map2_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _map1_ = json["map1"];
    if (_map1_) {
      msg.map1 = Object.fromEntries(
        Object.entries(_map1_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMapJSON.Map1._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _map2_ = json["map2"];
    if (_map2_) {
      msg.map2 = Object.fromEntries(
        Object.entries(_map2_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMapJSON.Map2._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMapJSON = {
  /**
   * Serializes TestRequiredMessageMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredMessageMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredMessageMap from JSON.
   */
  decode: function (json) {
    return TestRequiredMessageMapJSON._readMessage(
      TestRequiredMessageMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.mapField) {
      const _mapField_ = Object.fromEntries(
        Object.entries(msg.mapField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMapJSON.MapField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapField_).length > 0) {
        json["mapField"] = _mapField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _mapField_ = json["mapField"] ?? json["map_field"];
    if (_mapField_) {
      msg.mapField = Object.fromEntries(
        Object.entries(_mapField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMapJSON.MapField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestRequiredJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.TestRequired.initialize();
        googleProtobufUnittest.TestRequiredJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestArenaMapJSON = {
  /**
   * Serializes TestArenaMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestArenaMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestArenaMap from JSON.
   */
  decode: function (json) {
    return TestArenaMapJSON._readMessage(
      TestArenaMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      const _mapInt32Int32_ = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Int32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Int32_).length > 0) {
        json["mapInt32Int32"] = _mapInt32Int32_;
      }
    }
    if (msg.mapInt64Int64) {
      const _mapInt64Int64_ = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt64Int64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt64Int64_).length > 0) {
        json["mapInt64Int64"] = _mapInt64Int64_;
      }
    }
    if (msg.mapUint32Uint32) {
      const _mapUint32Uint32_ = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapUint32Uint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint32Uint32_).length > 0) {
        json["mapUint32Uint32"] = _mapUint32Uint32_;
      }
    }
    if (msg.mapUint64Uint64) {
      const _mapUint64Uint64_ = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapUint64Uint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint64Uint64_).length > 0) {
        json["mapUint64Uint64"] = _mapUint64Uint64_;
      }
    }
    if (msg.mapSint32Sint32) {
      const _mapSint32Sint32_ = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSint32Sint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint32Sint32_).length > 0) {
        json["mapSint32Sint32"] = _mapSint32Sint32_;
      }
    }
    if (msg.mapSint64Sint64) {
      const _mapSint64Sint64_ = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSint64Sint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint64Sint64_).length > 0) {
        json["mapSint64Sint64"] = _mapSint64Sint64_;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const _mapFixed32Fixed32_ = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapFixed32Fixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed32Fixed32_).length > 0) {
        json["mapFixed32Fixed32"] = _mapFixed32Fixed32_;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const _mapFixed64Fixed64_ = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapFixed64Fixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed64Fixed64_).length > 0) {
        json["mapFixed64Fixed64"] = _mapFixed64Fixed64_;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const _mapSfixed32Sfixed32_ = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSfixed32Sfixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed32Sfixed32_).length > 0) {
        json["mapSfixed32Sfixed32"] = _mapSfixed32Sfixed32_;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const _mapSfixed64Sfixed64_ = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSfixed64Sfixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed64Sfixed64_).length > 0) {
        json["mapSfixed64Sfixed64"] = _mapSfixed64Sfixed64_;
      }
    }
    if (msg.mapInt32Float) {
      const _mapInt32Float_ = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Float._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Float_).length > 0) {
        json["mapInt32Float"] = _mapInt32Float_;
      }
    }
    if (msg.mapInt32Double) {
      const _mapInt32Double_ = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Double._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Double_).length > 0) {
        json["mapInt32Double"] = _mapInt32Double_;
      }
    }
    if (msg.mapBoolBool) {
      const _mapBoolBool_ = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapBoolBool._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapBoolBool_).length > 0) {
        json["mapBoolBool"] = _mapBoolBool_;
      }
    }
    if (msg.mapStringString) {
      const _mapStringString_ = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapStringString._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapStringString_).length > 0) {
        json["mapStringString"] = _mapStringString_;
      }
    }
    if (msg.mapInt32Bytes) {
      const _mapInt32Bytes_ = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Bytes._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Bytes_).length > 0) {
        json["mapInt32Bytes"] = _mapInt32Bytes_;
      }
    }
    if (msg.mapInt32Enum) {
      const _mapInt32Enum_ = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Enum._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Enum_).length > 0) {
        json["mapInt32Enum"] = _mapInt32Enum_;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const _mapInt32ForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32ForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32ForeignMessage_).length > 0) {
        json["mapInt32ForeignMessage"] = _mapInt32ForeignMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _mapInt32Int32_ = json["mapInt32Int32"] ?? json["map_int32_int32"];
    if (_mapInt32Int32_) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Int32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64_ = json["mapInt64Int64"] ?? json["map_int64_int64"];
    if (_mapInt64Int64_) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt64Int64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32_ =
      json["mapUint32Uint32"] ?? json["map_uint32_uint32"];
    if (_mapUint32Uint32_) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapUint32Uint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64_ =
      json["mapUint64Uint64"] ?? json["map_uint64_uint64"];
    if (_mapUint64Uint64_) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapUint64Uint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32_ =
      json["mapSint32Sint32"] ?? json["map_sint32_sint32"];
    if (_mapSint32Sint32_) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSint32Sint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64_ =
      json["mapSint64Sint64"] ?? json["map_sint64_sint64"];
    if (_mapSint64Sint64_) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSint64Sint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32_ =
      json["mapFixed32Fixed32"] ?? json["map_fixed32_fixed32"];
    if (_mapFixed32Fixed32_) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapFixed32Fixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64_ =
      json["mapFixed64Fixed64"] ?? json["map_fixed64_fixed64"];
    if (_mapFixed64Fixed64_) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapFixed64Fixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32_ =
      json["mapSfixed32Sfixed32"] ?? json["map_sfixed32_sfixed32"];
    if (_mapSfixed32Sfixed32_) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSfixed32Sfixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64_ =
      json["mapSfixed64Sfixed64"] ?? json["map_sfixed64_sfixed64"];
    if (_mapSfixed64Sfixed64_) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSfixed64Sfixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float_ = json["mapInt32Float"] ?? json["map_int32_float"];
    if (_mapInt32Float_) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Float._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double_ = json["mapInt32Double"] ?? json["map_int32_double"];
    if (_mapInt32Double_) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Double._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool_ = json["mapBoolBool"] ?? json["map_bool_bool"];
    if (_mapBoolBool_) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapBoolBool._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString_ =
      json["mapStringString"] ?? json["map_string_string"];
    if (_mapStringString_) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapStringString._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes_ = json["mapInt32Bytes"] ?? json["map_int32_bytes"];
    if (_mapInt32Bytes_) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Bytes._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum_ = json["mapInt32Enum"] ?? json["map_int32_enum"];
    if (_mapInt32Enum_) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Enum._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage_ =
      json["mapInt32ForeignMessage"] ?? json["map_int32_foreign_message"];
    if (_mapInt32ForeignMessage_) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32ForeignMessage._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value?.length) {
        json["value"] = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = decodeBase64Bytes(_value_);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && MapEnumJSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.ForeignMessage.initialize();
        googleProtobufUnittest.ForeignMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntryJSON = {
  /**
   * Serializes MessageContainingMapCalledEntry to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(
      MessageContainingMapCalledEntryJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes MessageContainingMapCalledEntry from JSON.
   */
  decode: function (json) {
    return MessageContainingMapCalledEntryJSON._readMessage(
      MessageContainingMapCalledEntryJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.entry) {
      const _entry_ = Object.fromEntries(
        Object.entries(msg.entry)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntryJSON.Entry._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_entry_).length > 0) {
        json["entry"] = _entry_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _entry_ = json["entry"];
    if (_entry_) {
      msg.entry = Object.fromEntries(
        Object.entries(_entry_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntryJSON.Entry._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessageJSON = {
  /**
   * Serializes TestRecursiveMapMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRecursiveMapMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRecursiveMapMessage from JSON.
   */
  decode: function (json) {
    return TestRecursiveMapMessageJSON._readMessage(
      TestRecursiveMapMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      const _a_ = Object.fromEntries(
        Object.entries(msg.a)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessageJSON.A._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = Object.fromEntries(
        Object.entries(_a_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessageJSON.A._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = TestRecursiveMapMessageJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = TestRecursiveMapMessage.initialize();
        TestRecursiveMapMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
      ],
      [
        "google/protobuf/unittest_well_known_types.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_well_known_types.proto
/* eslint-disable */

import { BinaryReader, BinaryWriter } from "protoscript";

import * as protoscript from "protoscript";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const TestWellKnownTypes = {
  /**
   * Serializes TestWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return TestWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return TestWellKnownTypes._readMessage(
      TestWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: protoscript.Any.initialize(),
      apiField: protoscript.Api.initialize(),
      durationField: protoscript.Duration.initialize(),
      emptyField: protoscript.Empty.initialize(),
      fieldMaskField: protoscript.FieldMask.initialize(),
      sourceContextField: protoscript.SourceContext.initialize(),
      structField: protoscript.Struct.initialize(),
      timestampField: protoscript.Timestamp.initialize(),
      typeField: protoscript.Type.initialize(),
      doubleField: protoscript.DoubleValue.initialize(),
      floatField: protoscript.FloatValue.initialize(),
      int64Field: protoscript.Int64Value.initialize(),
      uint64Field: protoscript.UInt64Value.initialize(),
      int32Field: protoscript.Int32Value.initialize(),
      uint32Field: protoscript.UInt32Value.initialize(),
      boolField: protoscript.BoolValue.initialize(),
      stringField: protoscript.StringValue.initialize(),
      bytesField: protoscript.BytesValue.initialize(),
      valueField: protoscript.Value.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField) {
      writer.writeMessage(1, msg.anyField, protoscript.Any._writeMessage);
    }
    if (msg.apiField) {
      writer.writeMessage(2, msg.apiField, protoscript.Api._writeMessage);
    }
    if (msg.durationField) {
      writer.writeMessage(
        3,
        msg.durationField,
        protoscript.Duration._writeMessage
      );
    }
    if (msg.emptyField) {
      writer.writeMessage(4, msg.emptyField, protoscript.Empty._writeMessage);
    }
    if (msg.fieldMaskField) {
      writer.writeMessage(
        5,
        msg.fieldMaskField,
        protoscript.FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        protoscript.SourceContext._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeMessage(7, msg.structField, protoscript.Struct._writeMessage);
    }
    if (msg.timestampField) {
      writer.writeMessage(
        8,
        msg.timestampField,
        protoscript.Timestamp._writeMessage
      );
    }
    if (msg.typeField) {
      writer.writeMessage(9, msg.typeField, protoscript.Type._writeMessage);
    }
    if (msg.doubleField) {
      writer.writeMessage(
        10,
        msg.doubleField,
        protoscript.DoubleValue._writeMessage
      );
    }
    if (msg.floatField) {
      writer.writeMessage(
        11,
        msg.floatField,
        protoscript.FloatValue._writeMessage
      );
    }
    if (msg.int64Field) {
      writer.writeMessage(
        12,
        msg.int64Field,
        protoscript.Int64Value._writeMessage
      );
    }
    if (msg.uint64Field) {
      writer.writeMessage(
        13,
        msg.uint64Field,
        protoscript.UInt64Value._writeMessage
      );
    }
    if (msg.int32Field) {
      writer.writeMessage(
        14,
        msg.int32Field,
        protoscript.Int32Value._writeMessage
      );
    }
    if (msg.uint32Field) {
      writer.writeMessage(
        15,
        msg.uint32Field,
        protoscript.UInt32Value._writeMessage
      );
    }
    if (msg.boolField) {
      writer.writeMessage(
        16,
        msg.boolField,
        protoscript.BoolValue._writeMessage
      );
    }
    if (msg.stringField) {
      writer.writeMessage(
        17,
        msg.stringField,
        protoscript.StringValue._writeMessage
      );
    }
    if (msg.bytesField) {
      writer.writeMessage(
        18,
        msg.bytesField,
        protoscript.BytesValue._writeMessage
      );
    }
    if (msg.valueField) {
      writer.writeMessage(19, msg.valueField, protoscript.Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.anyField, protoscript.Any._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.apiField, protoscript.Api._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(
            msg.durationField,
            protoscript.Duration._readMessage
          );
          break;
        }
        case 4: {
          reader.readMessage(msg.emptyField, protoscript.Empty._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(
            msg.fieldMaskField,
            protoscript.FieldMask._readMessage
          );
          break;
        }
        case 6: {
          reader.readMessage(
            msg.sourceContextField,
            protoscript.SourceContext._readMessage
          );
          break;
        }
        case 7: {
          reader.readMessage(msg.structField, protoscript.Struct._readMessage);
          break;
        }
        case 8: {
          reader.readMessage(
            msg.timestampField,
            protoscript.Timestamp._readMessage
          );
          break;
        }
        case 9: {
          reader.readMessage(msg.typeField, protoscript.Type._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(
            msg.doubleField,
            protoscript.DoubleValue._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.floatField,
            protoscript.FloatValue._readMessage
          );
          break;
        }
        case 12: {
          reader.readMessage(
            msg.int64Field,
            protoscript.Int64Value._readMessage
          );
          break;
        }
        case 13: {
          reader.readMessage(
            msg.uint64Field,
            protoscript.UInt64Value._readMessage
          );
          break;
        }
        case 14: {
          reader.readMessage(
            msg.int32Field,
            protoscript.Int32Value._readMessage
          );
          break;
        }
        case 15: {
          reader.readMessage(
            msg.uint32Field,
            protoscript.UInt32Value._readMessage
          );
          break;
        }
        case 16: {
          reader.readMessage(msg.boolField, protoscript.BoolValue._readMessage);
          break;
        }
        case 17: {
          reader.readMessage(
            msg.stringField,
            protoscript.StringValue._readMessage
          );
          break;
        }
        case 18: {
          reader.readMessage(
            msg.bytesField,
            protoscript.BytesValue._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(msg.valueField, protoscript.Value._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedWellKnownTypes = {
  /**
   * Serializes RepeatedWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return RepeatedWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes RepeatedWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return RepeatedWellKnownTypes._readMessage(
      RepeatedWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes RepeatedWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: [],
      apiField: [],
      durationField: [],
      emptyField: [],
      fieldMaskField: [],
      sourceContextField: [],
      structField: [],
      timestampField: [],
      typeField: [],
      doubleField: [],
      floatField: [],
      int64Field: [],
      uint64Field: [],
      int32Field: [],
      uint32Field: [],
      boolField: [],
      stringField: [],
      bytesField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.anyField,
        protoscript.Any._writeMessage
      );
    }
    if (msg.apiField?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.apiField,
        protoscript.Api._writeMessage
      );
    }
    if (msg.durationField?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.durationField,
        protoscript.Duration._writeMessage
      );
    }
    if (msg.emptyField?.length) {
      writer.writeRepeatedMessage(
        4,
        msg.emptyField,
        protoscript.Empty._writeMessage
      );
    }
    if (msg.fieldMaskField?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.fieldMaskField,
        protoscript.FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField?.length) {
      writer.writeRepeatedMessage(
        6,
        msg.sourceContextField,
        protoscript.SourceContext._writeMessage
      );
    }
    if (msg.structField?.length) {
      writer.writeRepeatedMessage(
        7,
        msg.structField,
        protoscript.Struct._writeMessage
      );
    }
    if (msg.timestampField?.length) {
      writer.writeRepeatedMessage(
        8,
        msg.timestampField,
        protoscript.Timestamp._writeMessage
      );
    }
    if (msg.typeField?.length) {
      writer.writeRepeatedMessage(
        9,
        msg.typeField,
        protoscript.Type._writeMessage
      );
    }
    if (msg.doubleField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.doubleField,
        protoscript.DoubleValue._writeMessage
      );
    }
    if (msg.floatField?.length) {
      writer.writeRepeatedMessage(
        11,
        msg.floatField,
        protoscript.FloatValue._writeMessage
      );
    }
    if (msg.int64Field?.length) {
      writer.writeRepeatedMessage(
        12,
        msg.int64Field,
        protoscript.Int64Value._writeMessage
      );
    }
    if (msg.uint64Field?.length) {
      writer.writeRepeatedMessage(
        13,
        msg.uint64Field,
        protoscript.UInt64Value._writeMessage
      );
    }
    if (msg.int32Field?.length) {
      writer.writeRepeatedMessage(
        14,
        msg.int32Field,
        protoscript.Int32Value._writeMessage
      );
    }
    if (msg.uint32Field?.length) {
      writer.writeRepeatedMessage(
        15,
        msg.uint32Field,
        protoscript.UInt32Value._writeMessage
      );
    }
    if (msg.boolField?.length) {
      writer.writeRepeatedMessage(
        16,
        msg.boolField,
        protoscript.BoolValue._writeMessage
      );
    }
    if (msg.stringField?.length) {
      writer.writeRepeatedMessage(
        17,
        msg.stringField,
        protoscript.StringValue._writeMessage
      );
    }
    if (msg.bytesField?.length) {
      writer.writeRepeatedMessage(
        18,
        msg.bytesField,
        protoscript.BytesValue._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoscript.Any.initialize();
          reader.readMessage(m, protoscript.Any._readMessage);
          msg.anyField.push(m);
          break;
        }
        case 2: {
          const m = protoscript.Api.initialize();
          reader.readMessage(m, protoscript.Api._readMessage);
          msg.apiField.push(m);
          break;
        }
        case 3: {
          const m = protoscript.Duration.initialize();
          reader.readMessage(m, protoscript.Duration._readMessage);
          msg.durationField.push(m);
          break;
        }
        case 4: {
          const m = protoscript.Empty.initialize();
          reader.readMessage(m, protoscript.Empty._readMessage);
          msg.emptyField.push(m);
          break;
        }
        case 5: {
          const m = protoscript.FieldMask.initialize();
          reader.readMessage(m, protoscript.FieldMask._readMessage);
          msg.fieldMaskField.push(m);
          break;
        }
        case 6: {
          const m = protoscript.SourceContext.initialize();
          reader.readMessage(m, protoscript.SourceContext._readMessage);
          msg.sourceContextField.push(m);
          break;
        }
        case 7: {
          const m = protoscript.Struct.initialize();
          reader.readMessage(m, protoscript.Struct._readMessage);
          msg.structField.push(m);
          break;
        }
        case 8: {
          const m = protoscript.Timestamp.initialize();
          reader.readMessage(m, protoscript.Timestamp._readMessage);
          msg.timestampField.push(m);
          break;
        }
        case 9: {
          const m = protoscript.Type.initialize();
          reader.readMessage(m, protoscript.Type._readMessage);
          msg.typeField.push(m);
          break;
        }
        case 10: {
          const m = protoscript.DoubleValue.initialize();
          reader.readMessage(m, protoscript.DoubleValue._readMessage);
          msg.doubleField.push(m);
          break;
        }
        case 11: {
          const m = protoscript.FloatValue.initialize();
          reader.readMessage(m, protoscript.FloatValue._readMessage);
          msg.floatField.push(m);
          break;
        }
        case 12: {
          const m = protoscript.Int64Value.initialize();
          reader.readMessage(m, protoscript.Int64Value._readMessage);
          msg.int64Field.push(m);
          break;
        }
        case 13: {
          const m = protoscript.UInt64Value.initialize();
          reader.readMessage(m, protoscript.UInt64Value._readMessage);
          msg.uint64Field.push(m);
          break;
        }
        case 14: {
          const m = protoscript.Int32Value.initialize();
          reader.readMessage(m, protoscript.Int32Value._readMessage);
          msg.int32Field.push(m);
          break;
        }
        case 15: {
          const m = protoscript.UInt32Value.initialize();
          reader.readMessage(m, protoscript.UInt32Value._readMessage);
          msg.uint32Field.push(m);
          break;
        }
        case 16: {
          const m = protoscript.BoolValue.initialize();
          reader.readMessage(m, protoscript.BoolValue._readMessage);
          msg.boolField.push(m);
          break;
        }
        case 17: {
          const m = protoscript.StringValue.initialize();
          reader.readMessage(m, protoscript.StringValue._readMessage);
          msg.stringField.push(m);
          break;
        }
        case 18: {
          const m = protoscript.BytesValue.initialize();
          reader.readMessage(m, protoscript.BytesValue._readMessage);
          msg.bytesField.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneofWellKnownTypes = {
  /**
   * Serializes OneofWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return OneofWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes OneofWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return OneofWellKnownTypes._readMessage(
      OneofWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OneofWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: undefined,
      apiField: undefined,
      durationField: undefined,
      emptyField: undefined,
      fieldMaskField: undefined,
      sourceContextField: undefined,
      structField: undefined,
      timestampField: undefined,
      typeField: undefined,
      doubleField: undefined,
      floatField: undefined,
      int64Field: undefined,
      uint64Field: undefined,
      int32Field: undefined,
      uint32Field: undefined,
      boolField: undefined,
      stringField: undefined,
      bytesField: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField != undefined) {
      writer.writeMessage(1, msg.anyField, protoscript.Any._writeMessage);
    }
    if (msg.apiField != undefined) {
      writer.writeMessage(2, msg.apiField, protoscript.Api._writeMessage);
    }
    if (msg.durationField != undefined) {
      writer.writeMessage(
        3,
        msg.durationField,
        protoscript.Duration._writeMessage
      );
    }
    if (msg.emptyField != undefined) {
      writer.writeMessage(4, msg.emptyField, protoscript.Empty._writeMessage);
    }
    if (msg.fieldMaskField != undefined) {
      writer.writeMessage(
        5,
        msg.fieldMaskField,
        protoscript.FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField != undefined) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        protoscript.SourceContext._writeMessage
      );
    }
    if (msg.structField != undefined) {
      writer.writeMessage(7, msg.structField, protoscript.Struct._writeMessage);
    }
    if (msg.timestampField != undefined) {
      writer.writeMessage(
        8,
        msg.timestampField,
        protoscript.Timestamp._writeMessage
      );
    }
    if (msg.typeField != undefined) {
      writer.writeMessage(9, msg.typeField, protoscript.Type._writeMessage);
    }
    if (msg.doubleField != undefined) {
      writer.writeMessage(
        10,
        msg.doubleField,
        protoscript.DoubleValue._writeMessage
      );
    }
    if (msg.floatField != undefined) {
      writer.writeMessage(
        11,
        msg.floatField,
        protoscript.FloatValue._writeMessage
      );
    }
    if (msg.int64Field != undefined) {
      writer.writeMessage(
        12,
        msg.int64Field,
        protoscript.Int64Value._writeMessage
      );
    }
    if (msg.uint64Field != undefined) {
      writer.writeMessage(
        13,
        msg.uint64Field,
        protoscript.UInt64Value._writeMessage
      );
    }
    if (msg.int32Field != undefined) {
      writer.writeMessage(
        14,
        msg.int32Field,
        protoscript.Int32Value._writeMessage
      );
    }
    if (msg.uint32Field != undefined) {
      writer.writeMessage(
        15,
        msg.uint32Field,
        protoscript.UInt32Value._writeMessage
      );
    }
    if (msg.boolField != undefined) {
      writer.writeMessage(
        16,
        msg.boolField,
        protoscript.BoolValue._writeMessage
      );
    }
    if (msg.stringField != undefined) {
      writer.writeMessage(
        17,
        msg.stringField,
        protoscript.StringValue._writeMessage
      );
    }
    if (msg.bytesField != undefined) {
      writer.writeMessage(
        18,
        msg.bytesField,
        protoscript.BytesValue._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.anyField = protoscript.Any.initialize();
          reader.readMessage(msg.anyField, protoscript.Any._readMessage);
          break;
        }
        case 2: {
          msg.apiField = protoscript.Api.initialize();
          reader.readMessage(msg.apiField, protoscript.Api._readMessage);
          break;
        }
        case 3: {
          msg.durationField = protoscript.Duration.initialize();
          reader.readMessage(
            msg.durationField,
            protoscript.Duration._readMessage
          );
          break;
        }
        case 4: {
          msg.emptyField = protoscript.Empty.initialize();
          reader.readMessage(msg.emptyField, protoscript.Empty._readMessage);
          break;
        }
        case 5: {
          msg.fieldMaskField = protoscript.FieldMask.initialize();
          reader.readMessage(
            msg.fieldMaskField,
            protoscript.FieldMask._readMessage
          );
          break;
        }
        case 6: {
          msg.sourceContextField = protoscript.SourceContext.initialize();
          reader.readMessage(
            msg.sourceContextField,
            protoscript.SourceContext._readMessage
          );
          break;
        }
        case 7: {
          msg.structField = protoscript.Struct.initialize();
          reader.readMessage(msg.structField, protoscript.Struct._readMessage);
          break;
        }
        case 8: {
          msg.timestampField = protoscript.Timestamp.initialize();
          reader.readMessage(
            msg.timestampField,
            protoscript.Timestamp._readMessage
          );
          break;
        }
        case 9: {
          msg.typeField = protoscript.Type.initialize();
          reader.readMessage(msg.typeField, protoscript.Type._readMessage);
          break;
        }
        case 10: {
          msg.doubleField = protoscript.DoubleValue.initialize();
          reader.readMessage(
            msg.doubleField,
            protoscript.DoubleValue._readMessage
          );
          break;
        }
        case 11: {
          msg.floatField = protoscript.FloatValue.initialize();
          reader.readMessage(
            msg.floatField,
            protoscript.FloatValue._readMessage
          );
          break;
        }
        case 12: {
          msg.int64Field = protoscript.Int64Value.initialize();
          reader.readMessage(
            msg.int64Field,
            protoscript.Int64Value._readMessage
          );
          break;
        }
        case 13: {
          msg.uint64Field = protoscript.UInt64Value.initialize();
          reader.readMessage(
            msg.uint64Field,
            protoscript.UInt64Value._readMessage
          );
          break;
        }
        case 14: {
          msg.int32Field = protoscript.Int32Value.initialize();
          reader.readMessage(
            msg.int32Field,
            protoscript.Int32Value._readMessage
          );
          break;
        }
        case 15: {
          msg.uint32Field = protoscript.UInt32Value.initialize();
          reader.readMessage(
            msg.uint32Field,
            protoscript.UInt32Value._readMessage
          );
          break;
        }
        case 16: {
          msg.boolField = protoscript.BoolValue.initialize();
          reader.readMessage(msg.boolField, protoscript.BoolValue._readMessage);
          break;
        }
        case 17: {
          msg.stringField = protoscript.StringValue.initialize();
          reader.readMessage(
            msg.stringField,
            protoscript.StringValue._readMessage
          );
          break;
        }
        case 18: {
          msg.bytesField = protoscript.BytesValue.initialize();
          reader.readMessage(
            msg.bytesField,
            protoscript.BytesValue._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MapWellKnownTypes = {
  /**
   * Serializes MapWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return MapWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes MapWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return MapWellKnownTypes._readMessage(
      MapWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MapWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: {},
      apiField: {},
      durationField: {},
      emptyField: {},
      fieldMaskField: {},
      sourceContextField: {},
      structField: {},
      timestampField: {},
      typeField: {},
      doubleField: {},
      floatField: {},
      int64Field: {},
      uint64Field: {},
      int32Field: {},
      uint32Field: {},
      boolField: {},
      stringField: {},
      bytesField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.anyField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.AnyField._writeMessage
      );
    }
    if (msg.apiField) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.apiField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.ApiField._writeMessage
      );
    }
    if (msg.durationField) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.durationField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.DurationField._writeMessage
      );
    }
    if (msg.emptyField) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.emptyField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.EmptyField._writeMessage
      );
    }
    if (msg.fieldMaskField) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.fieldMaskField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.FieldMaskField._writeMessage
      );
    }
    if (msg.sourceContextField) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.sourceContextField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.SourceContextField._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.structField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.StructField._writeMessage
      );
    }
    if (msg.timestampField) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.timestampField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.TimestampField._writeMessage
      );
    }
    if (msg.typeField) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.typeField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.TypeField._writeMessage
      );
    }
    if (msg.doubleField) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.doubleField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.DoubleField._writeMessage
      );
    }
    if (msg.floatField) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.floatField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.FloatField._writeMessage
      );
    }
    if (msg.int64Field) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.int64Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Int64Field._writeMessage
      );
    }
    if (msg.uint64Field) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.uint64Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Uint64Field._writeMessage
      );
    }
    if (msg.int32Field) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.int32Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Int32Field._writeMessage
      );
    }
    if (msg.uint32Field) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.uint32Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Uint32Field._writeMessage
      );
    }
    if (msg.boolField) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.boolField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.BoolField._writeMessage
      );
    }
    if (msg.stringField) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.stringField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.StringField._writeMessage
      );
    }
    if (msg.bytesField) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.bytesField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.BytesField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.AnyField._readMessage);
          msg.anyField[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.ApiField._readMessage);
          msg.apiField[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.DurationField._readMessage);
          msg.durationField[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.EmptyField._readMessage);
          msg.emptyField[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {};
          reader.readMessage(
            map,
            MapWellKnownTypes.FieldMaskField._readMessage
          );
          msg.fieldMaskField[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {};
          reader.readMessage(
            map,
            MapWellKnownTypes.SourceContextField._readMessage
          );
          msg.sourceContextField[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.StructField._readMessage);
          msg.structField[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {};
          reader.readMessage(
            map,
            MapWellKnownTypes.TimestampField._readMessage
          );
          msg.timestampField[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.TypeField._readMessage);
          msg.typeField[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.DoubleField._readMessage);
          msg.doubleField[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.FloatField._readMessage);
          msg.floatField[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.Int64Field._readMessage);
          msg.int64Field[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.Uint64Field._readMessage);
          msg.uint64Field[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.Int32Field._readMessage);
          msg.int32Field[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.Uint32Field._readMessage);
          msg.uint32Field[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.BoolField._readMessage);
          msg.boolField[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.StringField._readMessage);
          msg.stringField[map.key.toString()] = map.value;
          break;
        }
        case 18: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.BytesField._readMessage);
          msg.bytesField[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  AnyField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Any._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Any.initialize();
            reader.readMessage(msg.value, protoscript.Any._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ApiField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Api._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Api.initialize();
            reader.readMessage(msg.value, protoscript.Api._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  DurationField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Duration._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Duration.initialize();
            reader.readMessage(msg.value, protoscript.Duration._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  EmptyField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Empty._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Empty.initialize();
            reader.readMessage(msg.value, protoscript.Empty._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FieldMaskField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.FieldMask._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.FieldMask.initialize();
            reader.readMessage(msg.value, protoscript.FieldMask._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SourceContextField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.SourceContext._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.SourceContext.initialize();
            reader.readMessage(
              msg.value,
              protoscript.SourceContext._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StructField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Struct._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Struct.initialize();
            reader.readMessage(msg.value, protoscript.Struct._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  TimestampField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Timestamp._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Timestamp.initialize();
            reader.readMessage(msg.value, protoscript.Timestamp._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  TypeField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Type._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Type.initialize();
            reader.readMessage(msg.value, protoscript.Type._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  DoubleField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.DoubleValue._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.DoubleValue.initialize();
            reader.readMessage(msg.value, protoscript.DoubleValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FloatField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.FloatValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.FloatValue.initialize();
            reader.readMessage(msg.value, protoscript.FloatValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Int64Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Int64Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Int64Value.initialize();
            reader.readMessage(msg.value, protoscript.Int64Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Uint64Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.UInt64Value._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.UInt64Value.initialize();
            reader.readMessage(msg.value, protoscript.UInt64Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Int32Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Int32Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Int32Value.initialize();
            reader.readMessage(msg.value, protoscript.Int32Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Uint32Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.UInt32Value._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.UInt32Value.initialize();
            reader.readMessage(msg.value, protoscript.UInt32Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  BoolField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.BoolValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.BoolValue.initialize();
            reader.readMessage(msg.value, protoscript.BoolValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StringField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.StringValue._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.StringValue.initialize();
            reader.readMessage(msg.value, protoscript.StringValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  BytesField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.BytesValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.BytesValue.initialize();
            reader.readMessage(msg.value, protoscript.BytesValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const TestWellKnownTypesJSON = {
  /**
   * Serializes TestWellKnownTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestWellKnownTypes from JSON.
   */
  decode: function (json) {
    return TestWellKnownTypesJSON._readMessage(
      TestWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: protoscript.AnyJSON.initialize(),
      apiField: protoscript.ApiJSON.initialize(),
      durationField: protoscript.DurationJSON.initialize(),
      emptyField: protoscript.EmptyJSON.initialize(),
      fieldMaskField: protoscript.FieldMaskJSON.initialize(),
      sourceContextField: protoscript.SourceContextJSON.initialize(),
      structField: protoscript.StructJSON.initialize(),
      timestampField: protoscript.TimestampJSON.initialize(),
      typeField: protoscript.TypeJSON.initialize(),
      doubleField: protoscript.DoubleValueJSON.initialize(),
      floatField: protoscript.FloatValueJSON.initialize(),
      int64Field: protoscript.Int64ValueJSON.initialize(),
      uint64Field: protoscript.UInt64ValueJSON.initialize(),
      int32Field: protoscript.Int32ValueJSON.initialize(),
      uint32Field: protoscript.UInt32ValueJSON.initialize(),
      boolField: protoscript.BoolValueJSON.initialize(),
      stringField: protoscript.StringValueJSON.initialize(),
      bytesField: protoscript.BytesValueJSON.initialize(),
      valueField: protoscript.ValueJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.anyField) {
      const _anyField_ = protoscript.AnyJSON._writeMessage(msg.anyField);
      if (Object.keys(_anyField_).length > 0) {
        json["anyField"] = _anyField_;
      }
    }
    if (msg.apiField) {
      const _apiField_ = protoscript.ApiJSON._writeMessage(msg.apiField);
      if (Object.keys(_apiField_).length > 0) {
        json["apiField"] = _apiField_;
      }
    }
    if (msg.durationField) {
      const _durationField_ = protoscript.DurationJSON._writeMessage(
        msg.durationField
      );
      if (Object.keys(_durationField_).length > 0) {
        json["durationField"] = _durationField_;
      }
    }
    if (msg.emptyField) {
      const _emptyField_ = protoscript.EmptyJSON._writeMessage(msg.emptyField);
      if (Object.keys(_emptyField_).length > 0) {
        json["emptyField"] = _emptyField_;
      }
    }
    if (msg.fieldMaskField) {
      const _fieldMaskField_ = protoscript.FieldMaskJSON._writeMessage(
        msg.fieldMaskField
      );
      if (Object.keys(_fieldMaskField_).length > 0) {
        json["fieldMaskField"] = _fieldMaskField_;
      }
    }
    if (msg.sourceContextField) {
      const _sourceContextField_ = protoscript.SourceContextJSON._writeMessage(
        msg.sourceContextField
      );
      if (Object.keys(_sourceContextField_).length > 0) {
        json["sourceContextField"] = _sourceContextField_;
      }
    }
    if (msg.structField) {
      const _structField_ = protoscript.StructJSON._writeMessage(
        msg.structField
      );
      if (Object.keys(_structField_).length > 0) {
        json["structField"] = _structField_;
      }
    }
    if (msg.timestampField) {
      const _timestampField_ = protoscript.TimestampJSON._writeMessage(
        msg.timestampField
      );
      if (Object.keys(_timestampField_).length > 0) {
        json["timestampField"] = _timestampField_;
      }
    }
    if (msg.typeField) {
      const _typeField_ = protoscript.TypeJSON._writeMessage(msg.typeField);
      if (Object.keys(_typeField_).length > 0) {
        json["typeField"] = _typeField_;
      }
    }
    if (msg.doubleField) {
      const _doubleField_ = protoscript.DoubleValueJSON._writeMessage(
        msg.doubleField
      );
      if (Object.keys(_doubleField_).length > 0) {
        json["doubleField"] = _doubleField_;
      }
    }
    if (msg.floatField) {
      const _floatField_ = protoscript.FloatValueJSON._writeMessage(
        msg.floatField
      );
      if (Object.keys(_floatField_).length > 0) {
        json["floatField"] = _floatField_;
      }
    }
    if (msg.int64Field) {
      const _int64Field_ = protoscript.Int64ValueJSON._writeMessage(
        msg.int64Field
      );
      if (Object.keys(_int64Field_).length > 0) {
        json["int64Field"] = _int64Field_;
      }
    }
    if (msg.uint64Field) {
      const _uint64Field_ = protoscript.UInt64ValueJSON._writeMessage(
        msg.uint64Field
      );
      if (Object.keys(_uint64Field_).length > 0) {
        json["uint64Field"] = _uint64Field_;
      }
    }
    if (msg.int32Field) {
      const _int32Field_ = protoscript.Int32ValueJSON._writeMessage(
        msg.int32Field
      );
      if (Object.keys(_int32Field_).length > 0) {
        json["int32Field"] = _int32Field_;
      }
    }
    if (msg.uint32Field) {
      const _uint32Field_ = protoscript.UInt32ValueJSON._writeMessage(
        msg.uint32Field
      );
      if (Object.keys(_uint32Field_).length > 0) {
        json["uint32Field"] = _uint32Field_;
      }
    }
    if (msg.boolField) {
      const _boolField_ = protoscript.BoolValueJSON._writeMessage(
        msg.boolField
      );
      if (Object.keys(_boolField_).length > 0) {
        json["boolField"] = _boolField_;
      }
    }
    if (msg.stringField) {
      const _stringField_ = protoscript.StringValueJSON._writeMessage(
        msg.stringField
      );
      if (Object.keys(_stringField_).length > 0) {
        json["stringField"] = _stringField_;
      }
    }
    if (msg.bytesField) {
      const _bytesField_ = protoscript.BytesValueJSON._writeMessage(
        msg.bytesField
      );
      if (Object.keys(_bytesField_).length > 0) {
        json["bytesField"] = _bytesField_;
      }
    }
    if (msg.valueField) {
      const _valueField_ = protoscript.ValueJSON._writeMessage(msg.valueField);
      if (Object.keys(_valueField_).length > 0) {
        json["valueField"] = _valueField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      const m = protoscript.Any.initialize();
      protoscript.AnyJSON._readMessage(m, _anyField_);
      msg.anyField = m;
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      const m = protoscript.Api.initialize();
      protoscript.ApiJSON._readMessage(m, _apiField_);
      msg.apiField = m;
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      const m = protoscript.Duration.initialize();
      protoscript.DurationJSON._readMessage(m, _durationField_);
      msg.durationField = m;
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      const m = protoscript.Empty.initialize();
      protoscript.EmptyJSON._readMessage(m, _emptyField_);
      msg.emptyField = m;
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      const m = protoscript.FieldMask.initialize();
      protoscript.FieldMaskJSON._readMessage(m, _fieldMaskField_);
      msg.fieldMaskField = m;
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      const m = protoscript.SourceContext.initialize();
      protoscript.SourceContextJSON._readMessage(m, _sourceContextField_);
      msg.sourceContextField = m;
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      const m = protoscript.Struct.initialize();
      protoscript.StructJSON._readMessage(m, _structField_);
      msg.structField = m;
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      const m = protoscript.Timestamp.initialize();
      protoscript.TimestampJSON._readMessage(m, _timestampField_);
      msg.timestampField = m;
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      const m = protoscript.Type.initialize();
      protoscript.TypeJSON._readMessage(m, _typeField_);
      msg.typeField = m;
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      const m = protoscript.DoubleValue.initialize();
      protoscript.DoubleValueJSON._readMessage(m, _doubleField_);
      msg.doubleField = m;
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      const m = protoscript.FloatValue.initialize();
      protoscript.FloatValueJSON._readMessage(m, _floatField_);
      msg.floatField = m;
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      const m = protoscript.Int64Value.initialize();
      protoscript.Int64ValueJSON._readMessage(m, _int64Field_);
      msg.int64Field = m;
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      const m = protoscript.UInt64Value.initialize();
      protoscript.UInt64ValueJSON._readMessage(m, _uint64Field_);
      msg.uint64Field = m;
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      const m = protoscript.Int32Value.initialize();
      protoscript.Int32ValueJSON._readMessage(m, _int32Field_);
      msg.int32Field = m;
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      const m = protoscript.UInt32Value.initialize();
      protoscript.UInt32ValueJSON._readMessage(m, _uint32Field_);
      msg.uint32Field = m;
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      const m = protoscript.BoolValue.initialize();
      protoscript.BoolValueJSON._readMessage(m, _boolField_);
      msg.boolField = m;
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      const m = protoscript.StringValue.initialize();
      protoscript.StringValueJSON._readMessage(m, _stringField_);
      msg.stringField = m;
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      const m = protoscript.BytesValue.initialize();
      protoscript.BytesValueJSON._readMessage(m, _bytesField_);
      msg.bytesField = m;
    }
    const _valueField_ = json["valueField"] ?? json["value_field"];
    if (_valueField_) {
      const m = protoscript.Value.initialize();
      protoscript.ValueJSON._readMessage(m, _valueField_);
      msg.valueField = m;
    }
    return msg;
  },
};

export const RepeatedWellKnownTypesJSON = {
  /**
   * Serializes RepeatedWellKnownTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(RepeatedWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes RepeatedWellKnownTypes from JSON.
   */
  decode: function (json) {
    return RepeatedWellKnownTypesJSON._readMessage(
      RepeatedWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes RepeatedWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: [],
      apiField: [],
      durationField: [],
      emptyField: [],
      fieldMaskField: [],
      sourceContextField: [],
      structField: [],
      timestampField: [],
      typeField: [],
      doubleField: [],
      floatField: [],
      int64Field: [],
      uint64Field: [],
      int32Field: [],
      uint32Field: [],
      boolField: [],
      stringField: [],
      bytesField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.anyField?.length) {
      json["anyField"] = msg.anyField.map(protoscript.AnyJSON._writeMessage);
    }
    if (msg.apiField?.length) {
      json["apiField"] = msg.apiField.map(protoscript.ApiJSON._writeMessage);
    }
    if (msg.durationField?.length) {
      json["durationField"] = msg.durationField.map(
        protoscript.DurationJSON._writeMessage
      );
    }
    if (msg.emptyField?.length) {
      json["emptyField"] = msg.emptyField.map(
        protoscript.EmptyJSON._writeMessage
      );
    }
    if (msg.fieldMaskField?.length) {
      json["fieldMaskField"] = msg.fieldMaskField.map(
        protoscript.FieldMaskJSON._writeMessage
      );
    }
    if (msg.sourceContextField?.length) {
      json["sourceContextField"] = msg.sourceContextField.map(
        protoscript.SourceContextJSON._writeMessage
      );
    }
    if (msg.structField?.length) {
      json["structField"] = msg.structField.map(
        protoscript.StructJSON._writeMessage
      );
    }
    if (msg.timestampField?.length) {
      json["timestampField"] = msg.timestampField.map(
        protoscript.TimestampJSON._writeMessage
      );
    }
    if (msg.typeField?.length) {
      json["typeField"] = msg.typeField.map(protoscript.TypeJSON._writeMessage);
    }
    if (msg.doubleField?.length) {
      json["doubleField"] = msg.doubleField.map(
        protoscript.DoubleValueJSON._writeMessage
      );
    }
    if (msg.floatField?.length) {
      json["floatField"] = msg.floatField.map(
        protoscript.FloatValueJSON._writeMessage
      );
    }
    if (msg.int64Field?.length) {
      json["int64Field"] = msg.int64Field.map(
        protoscript.Int64ValueJSON._writeMessage
      );
    }
    if (msg.uint64Field?.length) {
      json["uint64Field"] = msg.uint64Field.map(
        protoscript.UInt64ValueJSON._writeMessage
      );
    }
    if (msg.int32Field?.length) {
      json["int32Field"] = msg.int32Field.map(
        protoscript.Int32ValueJSON._writeMessage
      );
    }
    if (msg.uint32Field?.length) {
      json["uint32Field"] = msg.uint32Field.map(
        protoscript.UInt32ValueJSON._writeMessage
      );
    }
    if (msg.boolField?.length) {
      json["boolField"] = msg.boolField.map(
        protoscript.BoolValueJSON._writeMessage
      );
    }
    if (msg.stringField?.length) {
      json["stringField"] = msg.stringField.map(
        protoscript.StringValueJSON._writeMessage
      );
    }
    if (msg.bytesField?.length) {
      json["bytesField"] = msg.bytesField.map(
        protoscript.BytesValueJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      for (const item of _anyField_) {
        const m = protoscript.Any.initialize();
        protoscript.AnyJSON._readMessage(m, item);
        msg.anyField.push(m);
      }
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      for (const item of _apiField_) {
        const m = protoscript.Api.initialize();
        protoscript.ApiJSON._readMessage(m, item);
        msg.apiField.push(m);
      }
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      for (const item of _durationField_) {
        const m = protoscript.Duration.initialize();
        protoscript.DurationJSON._readMessage(m, item);
        msg.durationField.push(m);
      }
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      for (const item of _emptyField_) {
        const m = protoscript.Empty.initialize();
        protoscript.EmptyJSON._readMessage(m, item);
        msg.emptyField.push(m);
      }
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      for (const item of _fieldMaskField_) {
        const m = protoscript.FieldMask.initialize();
        protoscript.FieldMaskJSON._readMessage(m, item);
        msg.fieldMaskField.push(m);
      }
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      for (const item of _sourceContextField_) {
        const m = protoscript.SourceContext.initialize();
        protoscript.SourceContextJSON._readMessage(m, item);
        msg.sourceContextField.push(m);
      }
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      for (const item of _structField_) {
        const m = protoscript.Struct.initialize();
        protoscript.StructJSON._readMessage(m, item);
        msg.structField.push(m);
      }
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      for (const item of _timestampField_) {
        const m = protoscript.Timestamp.initialize();
        protoscript.TimestampJSON._readMessage(m, item);
        msg.timestampField.push(m);
      }
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      for (const item of _typeField_) {
        const m = protoscript.Type.initialize();
        protoscript.TypeJSON._readMessage(m, item);
        msg.typeField.push(m);
      }
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      for (const item of _doubleField_) {
        const m = protoscript.DoubleValue.initialize();
        protoscript.DoubleValueJSON._readMessage(m, item);
        msg.doubleField.push(m);
      }
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      for (const item of _floatField_) {
        const m = protoscript.FloatValue.initialize();
        protoscript.FloatValueJSON._readMessage(m, item);
        msg.floatField.push(m);
      }
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      for (const item of _int64Field_) {
        const m = protoscript.Int64Value.initialize();
        protoscript.Int64ValueJSON._readMessage(m, item);
        msg.int64Field.push(m);
      }
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      for (const item of _uint64Field_) {
        const m = protoscript.UInt64Value.initialize();
        protoscript.UInt64ValueJSON._readMessage(m, item);
        msg.uint64Field.push(m);
      }
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      for (const item of _int32Field_) {
        const m = protoscript.Int32Value.initialize();
        protoscript.Int32ValueJSON._readMessage(m, item);
        msg.int32Field.push(m);
      }
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      for (const item of _uint32Field_) {
        const m = protoscript.UInt32Value.initialize();
        protoscript.UInt32ValueJSON._readMessage(m, item);
        msg.uint32Field.push(m);
      }
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      for (const item of _boolField_) {
        const m = protoscript.BoolValue.initialize();
        protoscript.BoolValueJSON._readMessage(m, item);
        msg.boolField.push(m);
      }
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      for (const item of _stringField_) {
        const m = protoscript.StringValue.initialize();
        protoscript.StringValueJSON._readMessage(m, item);
        msg.stringField.push(m);
      }
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      for (const item of _bytesField_) {
        const m = protoscript.BytesValue.initialize();
        protoscript.BytesValueJSON._readMessage(m, item);
        msg.bytesField.push(m);
      }
    }
    return msg;
  },
};

export const OneofWellKnownTypesJSON = {
  /**
   * Serializes OneofWellKnownTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(OneofWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneofWellKnownTypes from JSON.
   */
  decode: function (json) {
    return OneofWellKnownTypesJSON._readMessage(
      OneofWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OneofWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: undefined,
      apiField: undefined,
      durationField: undefined,
      emptyField: undefined,
      fieldMaskField: undefined,
      sourceContextField: undefined,
      structField: undefined,
      timestampField: undefined,
      typeField: undefined,
      doubleField: undefined,
      floatField: undefined,
      int64Field: undefined,
      uint64Field: undefined,
      int32Field: undefined,
      uint32Field: undefined,
      boolField: undefined,
      stringField: undefined,
      bytesField: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.anyField != undefined) {
      const _anyField_ = protoscript.AnyJSON._writeMessage(msg.anyField);
      json["anyField"] = _anyField_;
    }
    if (msg.apiField != undefined) {
      const _apiField_ = protoscript.ApiJSON._writeMessage(msg.apiField);
      json["apiField"] = _apiField_;
    }
    if (msg.durationField != undefined) {
      const _durationField_ = protoscript.DurationJSON._writeMessage(
        msg.durationField
      );
      json["durationField"] = _durationField_;
    }
    if (msg.emptyField != undefined) {
      const _emptyField_ = protoscript.EmptyJSON._writeMessage(msg.emptyField);
      json["emptyField"] = _emptyField_;
    }
    if (msg.fieldMaskField != undefined) {
      const _fieldMaskField_ = protoscript.FieldMaskJSON._writeMessage(
        msg.fieldMaskField
      );
      json["fieldMaskField"] = _fieldMaskField_;
    }
    if (msg.sourceContextField != undefined) {
      const _sourceContextField_ = protoscript.SourceContextJSON._writeMessage(
        msg.sourceContextField
      );
      json["sourceContextField"] = _sourceContextField_;
    }
    if (msg.structField != undefined) {
      const _structField_ = protoscript.StructJSON._writeMessage(
        msg.structField
      );
      json["structField"] = _structField_;
    }
    if (msg.timestampField != undefined) {
      const _timestampField_ = protoscript.TimestampJSON._writeMessage(
        msg.timestampField
      );
      json["timestampField"] = _timestampField_;
    }
    if (msg.typeField != undefined) {
      const _typeField_ = protoscript.TypeJSON._writeMessage(msg.typeField);
      json["typeField"] = _typeField_;
    }
    if (msg.doubleField != undefined) {
      const _doubleField_ = protoscript.DoubleValueJSON._writeMessage(
        msg.doubleField
      );
      json["doubleField"] = _doubleField_;
    }
    if (msg.floatField != undefined) {
      const _floatField_ = protoscript.FloatValueJSON._writeMessage(
        msg.floatField
      );
      json["floatField"] = _floatField_;
    }
    if (msg.int64Field != undefined) {
      const _int64Field_ = protoscript.Int64ValueJSON._writeMessage(
        msg.int64Field
      );
      json["int64Field"] = _int64Field_;
    }
    if (msg.uint64Field != undefined) {
      const _uint64Field_ = protoscript.UInt64ValueJSON._writeMessage(
        msg.uint64Field
      );
      json["uint64Field"] = _uint64Field_;
    }
    if (msg.int32Field != undefined) {
      const _int32Field_ = protoscript.Int32ValueJSON._writeMessage(
        msg.int32Field
      );
      json["int32Field"] = _int32Field_;
    }
    if (msg.uint32Field != undefined) {
      const _uint32Field_ = protoscript.UInt32ValueJSON._writeMessage(
        msg.uint32Field
      );
      json["uint32Field"] = _uint32Field_;
    }
    if (msg.boolField != undefined) {
      const _boolField_ = protoscript.BoolValueJSON._writeMessage(
        msg.boolField
      );
      json["boolField"] = _boolField_;
    }
    if (msg.stringField != undefined) {
      const _stringField_ = protoscript.StringValueJSON._writeMessage(
        msg.stringField
      );
      json["stringField"] = _stringField_;
    }
    if (msg.bytesField != undefined) {
      const _bytesField_ = protoscript.BytesValueJSON._writeMessage(
        msg.bytesField
      );
      json["bytesField"] = _bytesField_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      const m = protoscript.Any.initialize();
      protoscript.AnyJSON._readMessage(m, _anyField_);
      msg.anyField = m;
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      const m = protoscript.Api.initialize();
      protoscript.ApiJSON._readMessage(m, _apiField_);
      msg.apiField = m;
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      const m = protoscript.Duration.initialize();
      protoscript.DurationJSON._readMessage(m, _durationField_);
      msg.durationField = m;
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      const m = protoscript.Empty.initialize();
      protoscript.EmptyJSON._readMessage(m, _emptyField_);
      msg.emptyField = m;
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      const m = protoscript.FieldMask.initialize();
      protoscript.FieldMaskJSON._readMessage(m, _fieldMaskField_);
      msg.fieldMaskField = m;
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      const m = protoscript.SourceContext.initialize();
      protoscript.SourceContextJSON._readMessage(m, _sourceContextField_);
      msg.sourceContextField = m;
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      const m = protoscript.Struct.initialize();
      protoscript.StructJSON._readMessage(m, _structField_);
      msg.structField = m;
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      const m = protoscript.Timestamp.initialize();
      protoscript.TimestampJSON._readMessage(m, _timestampField_);
      msg.timestampField = m;
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      const m = protoscript.Type.initialize();
      protoscript.TypeJSON._readMessage(m, _typeField_);
      msg.typeField = m;
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      const m = protoscript.DoubleValue.initialize();
      protoscript.DoubleValueJSON._readMessage(m, _doubleField_);
      msg.doubleField = m;
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      const m = protoscript.FloatValue.initialize();
      protoscript.FloatValueJSON._readMessage(m, _floatField_);
      msg.floatField = m;
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      const m = protoscript.Int64Value.initialize();
      protoscript.Int64ValueJSON._readMessage(m, _int64Field_);
      msg.int64Field = m;
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      const m = protoscript.UInt64Value.initialize();
      protoscript.UInt64ValueJSON._readMessage(m, _uint64Field_);
      msg.uint64Field = m;
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      const m = protoscript.Int32Value.initialize();
      protoscript.Int32ValueJSON._readMessage(m, _int32Field_);
      msg.int32Field = m;
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      const m = protoscript.UInt32Value.initialize();
      protoscript.UInt32ValueJSON._readMessage(m, _uint32Field_);
      msg.uint32Field = m;
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      const m = protoscript.BoolValue.initialize();
      protoscript.BoolValueJSON._readMessage(m, _boolField_);
      msg.boolField = m;
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      const m = protoscript.StringValue.initialize();
      protoscript.StringValueJSON._readMessage(m, _stringField_);
      msg.stringField = m;
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      const m = protoscript.BytesValue.initialize();
      protoscript.BytesValueJSON._readMessage(m, _bytesField_);
      msg.bytesField = m;
    }
    return msg;
  },
};

export const MapWellKnownTypesJSON = {
  /**
   * Serializes MapWellKnownTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(MapWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes MapWellKnownTypes from JSON.
   */
  decode: function (json) {
    return MapWellKnownTypesJSON._readMessage(
      MapWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MapWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: {},
      apiField: {},
      durationField: {},
      emptyField: {},
      fieldMaskField: {},
      sourceContextField: {},
      structField: {},
      timestampField: {},
      typeField: {},
      doubleField: {},
      floatField: {},
      int64Field: {},
      uint64Field: {},
      int32Field: {},
      uint32Field: {},
      boolField: {},
      stringField: {},
      bytesField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.anyField) {
      const _anyField_ = Object.fromEntries(
        Object.entries(msg.anyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.AnyField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_anyField_).length > 0) {
        json["anyField"] = _anyField_;
      }
    }
    if (msg.apiField) {
      const _apiField_ = Object.fromEntries(
        Object.entries(msg.apiField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.ApiField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_apiField_).length > 0) {
        json["apiField"] = _apiField_;
      }
    }
    if (msg.durationField) {
      const _durationField_ = Object.fromEntries(
        Object.entries(msg.durationField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.DurationField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_durationField_).length > 0) {
        json["durationField"] = _durationField_;
      }
    }
    if (msg.emptyField) {
      const _emptyField_ = Object.fromEntries(
        Object.entries(msg.emptyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.EmptyField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_emptyField_).length > 0) {
        json["emptyField"] = _emptyField_;
      }
    }
    if (msg.fieldMaskField) {
      const _fieldMaskField_ = Object.fromEntries(
        Object.entries(msg.fieldMaskField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.FieldMaskField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_fieldMaskField_).length > 0) {
        json["fieldMaskField"] = _fieldMaskField_;
      }
    }
    if (msg.sourceContextField) {
      const _sourceContextField_ = Object.fromEntries(
        Object.entries(msg.sourceContextField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.SourceContextField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_sourceContextField_).length > 0) {
        json["sourceContextField"] = _sourceContextField_;
      }
    }
    if (msg.structField) {
      const _structField_ = Object.fromEntries(
        Object.entries(msg.structField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.StructField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_structField_).length > 0) {
        json["structField"] = _structField_;
      }
    }
    if (msg.timestampField) {
      const _timestampField_ = Object.fromEntries(
        Object.entries(msg.timestampField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.TimestampField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_timestampField_).length > 0) {
        json["timestampField"] = _timestampField_;
      }
    }
    if (msg.typeField) {
      const _typeField_ = Object.fromEntries(
        Object.entries(msg.typeField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.TypeField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_typeField_).length > 0) {
        json["typeField"] = _typeField_;
      }
    }
    if (msg.doubleField) {
      const _doubleField_ = Object.fromEntries(
        Object.entries(msg.doubleField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.DoubleField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_doubleField_).length > 0) {
        json["doubleField"] = _doubleField_;
      }
    }
    if (msg.floatField) {
      const _floatField_ = Object.fromEntries(
        Object.entries(msg.floatField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.FloatField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_floatField_).length > 0) {
        json["floatField"] = _floatField_;
      }
    }
    if (msg.int64Field) {
      const _int64Field_ = Object.fromEntries(
        Object.entries(msg.int64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Int64Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_int64Field_).length > 0) {
        json["int64Field"] = _int64Field_;
      }
    }
    if (msg.uint64Field) {
      const _uint64Field_ = Object.fromEntries(
        Object.entries(msg.uint64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Uint64Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_uint64Field_).length > 0) {
        json["uint64Field"] = _uint64Field_;
      }
    }
    if (msg.int32Field) {
      const _int32Field_ = Object.fromEntries(
        Object.entries(msg.int32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Int32Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_int32Field_).length > 0) {
        json["int32Field"] = _int32Field_;
      }
    }
    if (msg.uint32Field) {
      const _uint32Field_ = Object.fromEntries(
        Object.entries(msg.uint32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Uint32Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_uint32Field_).length > 0) {
        json["uint32Field"] = _uint32Field_;
      }
    }
    if (msg.boolField) {
      const _boolField_ = Object.fromEntries(
        Object.entries(msg.boolField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.BoolField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_boolField_).length > 0) {
        json["boolField"] = _boolField_;
      }
    }
    if (msg.stringField) {
      const _stringField_ = Object.fromEntries(
        Object.entries(msg.stringField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.StringField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_stringField_).length > 0) {
        json["stringField"] = _stringField_;
      }
    }
    if (msg.bytesField) {
      const _bytesField_ = Object.fromEntries(
        Object.entries(msg.bytesField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.BytesField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_bytesField_).length > 0) {
        json["bytesField"] = _bytesField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      msg.anyField = Object.fromEntries(
        Object.entries(_anyField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.AnyField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      msg.apiField = Object.fromEntries(
        Object.entries(_apiField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.ApiField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      msg.durationField = Object.fromEntries(
        Object.entries(_durationField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.DurationField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      msg.emptyField = Object.fromEntries(
        Object.entries(_emptyField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.EmptyField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      msg.fieldMaskField = Object.fromEntries(
        Object.entries(_fieldMaskField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.FieldMaskField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      msg.sourceContextField = Object.fromEntries(
        Object.entries(_sourceContextField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.SourceContextField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      msg.structField = Object.fromEntries(
        Object.entries(_structField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.StructField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      msg.timestampField = Object.fromEntries(
        Object.entries(_timestampField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.TimestampField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      msg.typeField = Object.fromEntries(
        Object.entries(_typeField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.TypeField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      msg.doubleField = Object.fromEntries(
        Object.entries(_doubleField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.DoubleField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      msg.floatField = Object.fromEntries(
        Object.entries(_floatField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.FloatField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      msg.int64Field = Object.fromEntries(
        Object.entries(_int64Field_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Int64Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      msg.uint64Field = Object.fromEntries(
        Object.entries(_uint64Field_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Uint64Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      msg.int32Field = Object.fromEntries(
        Object.entries(_int32Field_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Int32Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      msg.uint32Field = Object.fromEntries(
        Object.entries(_uint32Field_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Uint32Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      msg.boolField = Object.fromEntries(
        Object.entries(_boolField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.BoolField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      msg.stringField = Object.fromEntries(
        Object.entries(_stringField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.StringField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      msg.bytesField = Object.fromEntries(
        Object.entries(_bytesField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.BytesField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  AnyField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.AnyJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Any.initialize();
        protoscript.AnyJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  ApiField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.ApiJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Api.initialize();
        protoscript.ApiJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  DurationField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.DurationJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Duration.initialize();
        protoscript.DurationJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  EmptyField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.EmptyJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Empty.initialize();
        protoscript.EmptyJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  FieldMaskField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.FieldMaskJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.FieldMask.initialize();
        protoscript.FieldMaskJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  SourceContextField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.SourceContextJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.SourceContext.initialize();
        protoscript.SourceContextJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  StructField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.StructJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Struct.initialize();
        protoscript.StructJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  TimestampField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.TimestampJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Timestamp.initialize();
        protoscript.TimestampJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  TypeField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.TypeJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Type.initialize();
        protoscript.TypeJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  DoubleField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.DoubleValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.DoubleValue.initialize();
        protoscript.DoubleValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  FloatField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.FloatValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.FloatValue.initialize();
        protoscript.FloatValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Int64Field: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.Int64ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Int64Value.initialize();
        protoscript.Int64ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint64Field: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.UInt64ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.UInt64Value.initialize();
        protoscript.UInt64ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Int32Field: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.Int32ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Int32Value.initialize();
        protoscript.Int32ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint32Field: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.UInt32ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.UInt32Value.initialize();
        protoscript.UInt32ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  BoolField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.BoolValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.BoolValue.initialize();
        protoscript.BoolValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  StringField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.StringValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.StringValue.initialize();
        protoscript.StringValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  BytesField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.BytesValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.BytesValue.initialize();
        protoscript.BytesValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
      ],
      [
        "google/protobuf/unittest_proto3.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto
/* eslint-disable */

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";

import * as googleProtobufUnittest_import from "./unittest_import.pb.js";
import * as googleProtobufUnittest_import_public from "./unittest_import_public.pb.js";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: "FOREIGN_ZERO",
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "FOREIGN_ZERO";
      }
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOREIGN_ZERO": {
        return 0;
      }
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestAllTypes = {
  /**
   * Serializes TestAllTypes to protobuf.
   */
  encode: function (msg) {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64String(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
      );
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        googleProtobufUnittest_import_public.PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        40,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writePackedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnum._toInt)
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            googleProtobufUnittest_import_public.PublicImportMessage
              ._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 32: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 33: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 34: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 35: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 36: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 37: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 38: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 39: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 40: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 41: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 42: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 43: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = googleProtobufUnittest_import.ImportMessage.initialize();
          reader.readMessage(
            m,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt)
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 52: {
          if (reader.isDelimited()) {
            msg.repeatedForeignEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.repeatedForeignEnum.push(
              ForeignEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          msg.oneofNestedMessage = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    ZERO: "ZERO",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 0: {
          return "ZERO";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "ZERO": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes TestPackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString())
      );
    }
    if (msg.packedUint32?.length) {
      writer.writePackedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString())
      );
    }
    if (msg.packedSint32?.length) {
      writer.writePackedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString())
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writePackedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString())
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.packedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.packedFloat?.length) {
      writer.writePackedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writePackedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writePackedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writePackedEnum(103, msg.packedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.packedInt64.push(...reader.readPackedInt64String().map(BigInt));
          } else {
            msg.packedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.packedUint32.push(...reader.readPackedUint32());
          } else {
            msg.packedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.packedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.packedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.packedSint32.push(...reader.readPackedSint32());
          } else {
            msg.packedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.packedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.packedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.packedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.packedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.packedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.packedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.packedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.packedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.packedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.packedFloat.push(...reader.readPackedFloat());
          } else {
            msg.packedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.packedDouble.push(...reader.readPackedDouble());
          } else {
            msg.packedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.packedBool.push(...reader.readPackedBool());
          } else {
            msg.packedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.packedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.packedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes TestUnpackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        2,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        4,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        6,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        8,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        10,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        14,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt)
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 2: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 3: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 4: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 5: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 6: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 7: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 8: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 9: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 10: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 11: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 12: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 13: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 14: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt)
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes NestedTestAllTypes to protobuf.
   */
  encode: function (msg) {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes ForeignMessage to protobuf.
   */
  encode: function (msg) {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes TestEmptyMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes TestMessageWithDummy to protobuf.
   */
  encode: function (msg) {
    return TestMessageWithDummy._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMessageWithDummy from protobuf.
   */
  decode: function (bytes) {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function () {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes TestOneof2 to protobuf.
   */
  encode: function (msg) {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooEnum: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnum._toInt(msg.fooEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    UNKNOWN: "UNKNOWN",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 0: {
          return "UNKNOWN";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "UNKNOWN": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ForeignEnumJSON = {
  FOREIGN_ZERO: "FOREIGN_ZERO",
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "FOREIGN_ZERO";
      }
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOREIGN_ZERO": {
        return 0;
      }
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestAllTypesJSON = {
  /**
   * Serializes TestAllTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestAllTypes from JSON.
   */
  decode: function (json) {
    return TestAllTypesJSON._readMessage(
      TestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessageJSON.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessageJSON.initialize(),
      optionalLazyMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalLazyImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json["optionalInt64"] = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json["optionalUint32"] = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json["optionalUint64"] = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json["optionalSint32"] = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json["optionalSint64"] = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json["optionalFixed32"] = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json["optionalFixed64"] = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json["optionalSfixed32"] = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json["optionalSfixed64"] = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json["optionalFloat"] = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json["optionalDouble"] = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json["optionalBool"] = msg.optionalBool;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalNestedMessage);
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    if (msg.optionalForeignMessage) {
      const _optionalForeignMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalForeignMessage
      );
      if (Object.keys(_optionalForeignMessage_).length > 0) {
        json["optionalForeignMessage"] = _optionalForeignMessage_;
      }
    }
    if (msg.optionalImportMessage) {
      const _optionalImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalImportMessage
        );
      if (Object.keys(_optionalImportMessage_).length > 0) {
        json["optionalImportMessage"] = _optionalImportMessage_;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      json["optionalNestedEnum"] = msg.optionalNestedEnum;
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json["optionalStringPiece"] = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json["optionalCord"] = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const _optionalPublicImportMessage_ =
        googleProtobufUnittest_import_public.PublicImportMessageJSON._writeMessage(
          msg.optionalPublicImportMessage
        );
      if (Object.keys(_optionalPublicImportMessage_).length > 0) {
        json["optionalPublicImportMessage"] = _optionalPublicImportMessage_;
      }
    }
    if (msg.optionalLazyMessage) {
      const _optionalLazyMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalLazyMessage);
      if (Object.keys(_optionalLazyMessage_).length > 0) {
        json["optionalLazyMessage"] = _optionalLazyMessage_;
      }
    }
    if (msg.optionalLazyImportMessage) {
      const _optionalLazyImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalLazyImportMessage
        );
      if (Object.keys(_optionalLazyImportMessage_).length > 0) {
        json["optionalLazyImportMessage"] = _optionalLazyImportMessage_;
      }
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json["repeatedString"] = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json["repeatedBytes"] = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json["repeatedNestedMessage"] = msg.repeatedNestedMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json["repeatedForeignMessage"] = msg.repeatedForeignMessage.map(
        ForeignMessageJSON._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json["repeatedImportMessage"] = msg.repeatedImportMessage.map(
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json["repeatedForeignEnum"] = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json["repeatedStringPiece"] = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json["repeatedCord"] = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json["repeatedLazyMessage"] = msg.repeatedLazyMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const _oneofNestedMessage_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.oneofNestedMessage
      );
      json["oneofNestedMessage"] = _oneofNestedMessage_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _optionalInt64_ = json["optionalInt64"] ?? json["optional_int64"];
    if (_optionalInt64_) {
      msg.optionalInt64 = BigInt(_optionalInt64_);
    }
    const _optionalUint32_ = json["optionalUint32"] ?? json["optional_uint32"];
    if (_optionalUint32_) {
      msg.optionalUint32 = _optionalUint32_;
    }
    const _optionalUint64_ = json["optionalUint64"] ?? json["optional_uint64"];
    if (_optionalUint64_) {
      msg.optionalUint64 = BigInt(_optionalUint64_);
    }
    const _optionalSint32_ = json["optionalSint32"] ?? json["optional_sint32"];
    if (_optionalSint32_) {
      msg.optionalSint32 = _optionalSint32_;
    }
    const _optionalSint64_ = json["optionalSint64"] ?? json["optional_sint64"];
    if (_optionalSint64_) {
      msg.optionalSint64 = BigInt(_optionalSint64_);
    }
    const _optionalFixed32_ =
      json["optionalFixed32"] ?? json["optional_fixed32"];
    if (_optionalFixed32_) {
      msg.optionalFixed32 = _optionalFixed32_;
    }
    const _optionalFixed64_ =
      json["optionalFixed64"] ?? json["optional_fixed64"];
    if (_optionalFixed64_) {
      msg.optionalFixed64 = BigInt(_optionalFixed64_);
    }
    const _optionalSfixed32_ =
      json["optionalSfixed32"] ?? json["optional_sfixed32"];
    if (_optionalSfixed32_) {
      msg.optionalSfixed32 = _optionalSfixed32_;
    }
    const _optionalSfixed64_ =
      json["optionalSfixed64"] ?? json["optional_sfixed64"];
    if (_optionalSfixed64_) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64_);
    }
    const _optionalFloat_ = json["optionalFloat"] ?? json["optional_float"];
    if (_optionalFloat_) {
      msg.optionalFloat = _optionalFloat_;
    }
    const _optionalDouble_ = json["optionalDouble"] ?? json["optional_double"];
    if (_optionalDouble_) {
      msg.optionalDouble = _optionalDouble_;
    }
    const _optionalBool_ = json["optionalBool"] ?? json["optional_bool"];
    if (_optionalBool_) {
      msg.optionalBool = _optionalBool_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalNestedMessage_);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage_ =
      json["optionalForeignMessage"] ?? json["optional_foreign_message"];
    if (_optionalForeignMessage_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _optionalForeignMessage_);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage_ =
      json["optionalImportMessage"] ?? json["optional_import_message"];
    if (_optionalImportMessage_) {
      const m = googleProtobufUnittest_import.ImportMessage.initialize();
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        m,
        _optionalImportMessage_
      );
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum_ =
      json["optionalNestedEnum"] ?? json["optional_nested_enum"];
    if (_optionalNestedEnum_) {
      msg.optionalNestedEnum = _optionalNestedEnum_;
    }
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    const _optionalStringPiece_ =
      json["optionalStringPiece"] ?? json["optional_string_piece"];
    if (_optionalStringPiece_) {
      msg.optionalStringPiece = _optionalStringPiece_;
    }
    const _optionalCord_ = json["optionalCord"] ?? json["optional_cord"];
    if (_optionalCord_) {
      msg.optionalCord = _optionalCord_;
    }
    const _optionalPublicImportMessage_ =
      json["optionalPublicImportMessage"] ??
      json["optional_public_import_message"];
    if (_optionalPublicImportMessage_) {
      const m =
        googleProtobufUnittest_import_public.PublicImportMessage.initialize();
      googleProtobufUnittest_import_public.PublicImportMessageJSON._readMessage(
        m,
        _optionalPublicImportMessage_
      );
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage_ =
      json["optionalLazyMessage"] ?? json["optional_lazy_message"];
    if (_optionalLazyMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalLazyMessage_);
      msg.optionalLazyMessage = m;
    }
    const _optionalLazyImportMessage_ =
      json["optionalLazyImportMessage"] ?? json["optional_lazy_import_message"];
    if (_optionalLazyImportMessage_) {
      const m = googleProtobufUnittest_import.ImportMessage.initialize();
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        m,
        _optionalLazyImportMessage_
      );
      msg.optionalLazyImportMessage = m;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedString_ = json["repeatedString"] ?? json["repeated_string"];
    if (_repeatedString_) {
      msg.repeatedString = _repeatedString_;
    }
    const _repeatedBytes_ = json["repeatedBytes"] ?? json["repeated_bytes"];
    if (_repeatedBytes_) {
      msg.repeatedBytes = _repeatedBytes_.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage_ =
      json["repeatedNestedMessage"] ?? json["repeated_nested_message"];
    if (_repeatedNestedMessage_) {
      for (const item of _repeatedNestedMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage_ =
      json["repeatedForeignMessage"] ?? json["repeated_foreign_message"];
    if (_repeatedForeignMessage_) {
      for (const item of _repeatedForeignMessage_) {
        const m = ForeignMessage.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage_ =
      json["repeatedImportMessage"] ?? json["repeated_import_message"];
    if (_repeatedImportMessage_) {
      for (const item of _repeatedImportMessage_) {
        const m = googleProtobufUnittest_import.ImportMessage.initialize();
        googleProtobufUnittest_import.ImportMessageJSON._readMessage(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    const _repeatedForeignEnum_ =
      json["repeatedForeignEnum"] ?? json["repeated_foreign_enum"];
    if (_repeatedForeignEnum_) {
      msg.repeatedForeignEnum = _repeatedForeignEnum_;
    }
    const _repeatedStringPiece_ =
      json["repeatedStringPiece"] ?? json["repeated_string_piece"];
    if (_repeatedStringPiece_) {
      msg.repeatedStringPiece = _repeatedStringPiece_;
    }
    const _repeatedCord_ = json["repeatedCord"] ?? json["repeated_cord"];
    if (_repeatedCord_) {
      msg.repeatedCord = _repeatedCord_;
    }
    const _repeatedLazyMessage_ =
      json["repeatedLazyMessage"] ?? json["repeated_lazy_message"];
    if (_repeatedLazyMessage_) {
      for (const item of _repeatedLazyMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofNestedMessage_ =
      json["oneofNestedMessage"] ?? json["oneof_nested_message"];
    if (_oneofNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _oneofNestedMessage_);
      msg.oneofNestedMessage = m;
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  NestedEnum: {
    ZERO: "ZERO",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 0: {
          return "ZERO";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "ZERO": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestAllTypesJSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestAllTypesJSON.NestedMessage._readMessage(
        TestAllTypesJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },
};

export const TestPackedTypesJSON = {
  /**
   * Serializes TestPackedTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestPackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestPackedTypes from JSON.
   */
  decode: function (json) {
    return TestPackedTypesJSON._readMessage(
      TestPackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json["packedInt64"] = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json["packedUint32"] = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json["packedUint64"] = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json["packedSint32"] = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json["packedSint64"] = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json["packedFixed32"] = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json["packedFixed64"] = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json["packedSfixed32"] = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json["packedSfixed64"] = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json["packedFloat"] = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json["packedDouble"] = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json["packedBool"] = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json["packedEnum"] = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _packedInt64_ = json["packedInt64"] ?? json["packed_int64"];
    if (_packedInt64_) {
      msg.packedInt64 = _packedInt64_.map(BigInt);
    }
    const _packedUint32_ = json["packedUint32"] ?? json["packed_uint32"];
    if (_packedUint32_) {
      msg.packedUint32 = _packedUint32_;
    }
    const _packedUint64_ = json["packedUint64"] ?? json["packed_uint64"];
    if (_packedUint64_) {
      msg.packedUint64 = _packedUint64_.map(BigInt);
    }
    const _packedSint32_ = json["packedSint32"] ?? json["packed_sint32"];
    if (_packedSint32_) {
      msg.packedSint32 = _packedSint32_;
    }
    const _packedSint64_ = json["packedSint64"] ?? json["packed_sint64"];
    if (_packedSint64_) {
      msg.packedSint64 = _packedSint64_.map(BigInt);
    }
    const _packedFixed32_ = json["packedFixed32"] ?? json["packed_fixed32"];
    if (_packedFixed32_) {
      msg.packedFixed32 = _packedFixed32_;
    }
    const _packedFixed64_ = json["packedFixed64"] ?? json["packed_fixed64"];
    if (_packedFixed64_) {
      msg.packedFixed64 = _packedFixed64_.map(BigInt);
    }
    const _packedSfixed32_ = json["packedSfixed32"] ?? json["packed_sfixed32"];
    if (_packedSfixed32_) {
      msg.packedSfixed32 = _packedSfixed32_;
    }
    const _packedSfixed64_ = json["packedSfixed64"] ?? json["packed_sfixed64"];
    if (_packedSfixed64_) {
      msg.packedSfixed64 = _packedSfixed64_.map(BigInt);
    }
    const _packedFloat_ = json["packedFloat"] ?? json["packed_float"];
    if (_packedFloat_) {
      msg.packedFloat = _packedFloat_;
    }
    const _packedDouble_ = json["packedDouble"] ?? json["packed_double"];
    if (_packedDouble_) {
      msg.packedDouble = _packedDouble_;
    }
    const _packedBool_ = json["packedBool"] ?? json["packed_bool"];
    if (_packedBool_) {
      msg.packedBool = _packedBool_;
    }
    const _packedEnum_ = json["packedEnum"] ?? json["packed_enum"];
    if (_packedEnum_) {
      msg.packedEnum = _packedEnum_;
    }
    return msg;
  },
};

export const TestUnpackedTypesJSON = {
  /**
   * Serializes TestUnpackedTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestUnpackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestUnpackedTypes from JSON.
   */
  decode: function (json) {
    return TestUnpackedTypesJSON._readMessage(
      TestUnpackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    return msg;
  },
};

export const NestedTestAllTypesJSON = {
  /**
   * Serializes NestedTestAllTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(NestedTestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes NestedTestAllTypes from JSON.
   */
  decode: function (json) {
    return NestedTestAllTypesJSON._readMessage(
      NestedTestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypesJSON.initialize(),
      payload: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.child) {
      const _child_ = NestedTestAllTypesJSON._writeMessage(msg.child);
      if (Object.keys(_child_).length > 0) {
        json["child"] = _child_;
      }
    }
    if (msg.payload) {
      const _payload_ = TestAllTypesJSON._writeMessage(msg.payload);
      if (Object.keys(_payload_).length > 0) {
        json["payload"] = _payload_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _child_ = json["child"];
    if (_child_) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypesJSON._readMessage(m, _child_);
      msg.child = m;
    }
    const _payload_ = json["payload"];
    if (_payload_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _payload_);
      msg.payload = m;
    }
    return msg;
  },
};

export const ForeignMessageJSON = {
  /**
   * Serializes ForeignMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(ForeignMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ForeignMessage from JSON.
   */
  decode: function (json) {
    return ForeignMessageJSON._readMessage(
      ForeignMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.c) {
      json["c"] = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    return msg;
  },
};

export const TestEmptyMessageJSON = {
  /**
   * Serializes TestEmptyMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestMessageWithDummyJSON = {
  /**
   * Serializes TestMessageWithDummy to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMessageWithDummyJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMessageWithDummy from JSON.
   */
  decode: function (json) {
    return TestMessageWithDummyJSON._readMessage(
      TestMessageWithDummyJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function () {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.dummy) {
      json["dummy"] = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _dummy_ = json["dummy"];
    if (_dummy_) {
      msg.dummy = _dummy_;
    }
    return msg;
  },
};

export const TestOneof2JSON = {
  /**
   * Serializes TestOneof2 to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestOneof2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof2 from JSON.
   */
  decode: function (json) {
    return TestOneof2JSON._readMessage(
      TestOneof2JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooEnum: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooEnum != undefined) {
      json["fooEnum"] = msg.fooEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooEnum_ = json["fooEnum"] ?? json["foo_enum"];
    if (_fooEnum_) {
      msg.fooEnum = _fooEnum_;
    }
    return msg;
  },

  NestedEnum: {
    UNKNOWN: "UNKNOWN",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 0: {
          return "UNKNOWN";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "UNKNOWN": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },
};
",
      ],
    ],
  ],
  "arrayIndexOffset_": -1,
  "convertedPrimitiveFields_": {},
  "messageId_": undefined,
  "pivot_": 1.7976931348623157e+308,
  "wrappers_": {
    "15": [
      {
        "array": [
          "twirpscript/services.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: twirpscript/services.proto
/* eslint-disable */

import { BinaryReader, BinaryWriter } from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";

//========================================//
//      Haberdasher Protobuf Client       //
//========================================//

/**
 * MakeHat produces a hat of mysterious, randomly-selected color!
 */
export async function MakeHat(makeHat, config) {
  const response = await PBrequest(
    "/Haberdasher/MakeHat",
    Req.MakeHat.encode(makeHat),
    config
  );
  return Hat.decode(response);
}

//========================================//
//        Haberdasher JSON Client         //
//========================================//

/**
 * MakeHat produces a hat of mysterious, randomly-selected color!
 */
export async function MakeHatJSON(makeHat, config) {
  const response = await JSONrequest(
    "/Haberdasher/MakeHat",
    ReqJSON.MakeHat.encode(makeHat),
    config
  );
  return HatJSON.decode(response);
}

export function createHaberdasher(service) {
  return {
    name: "Haberdasher",
    methods: {
      MakeHat: {
        name: "MakeHat",
        handler: service.MakeHat,
        input: { protobuf: Req.MakeHat, json: ReqJSON.MakeHat },
        output: { protobuf: Hat, json: HatJSON },
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Req = {
  /**
   * Serializes Req to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes Req from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },

  MakeHat: {
    /**
     * Serializes Req.MakeHat to protobuf.
     */
    encode: function (msg) {
      return Req.MakeHat._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.MakeHat from protobuf.
     */
    decode: function (bytes) {
      return Req.MakeHat._readMessage(
        Req.MakeHat.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.MakeHat with all fields set to their default value.
     */
    initialize: function () {
      return {
        inches: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.inches) {
        writer.writeInt32(1, msg.inches);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.inches = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Hat = {
  /**
   * Serializes Hat to protobuf.
   */
  encode: function (msg) {
    return Hat._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Hat from protobuf.
   */
  decode: function (bytes) {
    return Hat._readMessage(Hat.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Hat with all fields set to their default value.
   */
  initialize: function () {
    return {
      inches: 0,
      color: "",
      name: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.inches) {
      writer.writeInt32(1, msg.inches);
    }
    if (msg.color) {
      writer.writeString(2, msg.color);
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.inches = reader.readInt32();
          break;
        }
        case 2: {
          msg.color = reader.readString();
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ReqJSON = {
  /**
   * Serializes Req to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes Req from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },

  MakeHat: {
    /**
     * Serializes Req.MakeHat to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(ReqJSON.MakeHat._writeMessage(msg));
    },

    /**
     * Deserializes Req.MakeHat from JSON.
     */
    decode: function (json) {
      return ReqJSON.MakeHat._readMessage(
        ReqJSON.MakeHat.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.MakeHat with all fields set to their default value.
     */
    initialize: function () {
      return {
        inches: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.inches) {
        json["inches"] = msg.inches;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _inches_ = json["inches"];
      if (_inches_) {
        msg.inches = _inches_;
      }
      return msg;
    },
  },
};

export const HatJSON = {
  /**
   * Serializes Hat to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(HatJSON._writeMessage(msg));
  },

  /**
   * Deserializes Hat from JSON.
   */
  decode: function (json) {
    return HatJSON._readMessage(HatJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Hat with all fields set to their default value.
   */
  initialize: function () {
    return {
      inches: 0,
      color: "",
      name: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.inches) {
      json["inches"] = msg.inches;
    }
    if (msg.color) {
      json["color"] = msg.color;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _inches_ = json["inches"];
    if (_inches_) {
      msg.inches = _inches_;
    }
    const _color_ = json["color"];
    if (_color_) {
      msg.color = _color_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "twirpscript/empty.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: twirpscript/empty.proto
/* eslint-disable */

import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";

import * as protoscript from "protoscript";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(empty, config) {
  const response = await PBrequest(
    "/Foo/Bar",
    protoscript.Empty.encode(empty),
    config
  );
  return protoscript.Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(empty, config) {
  const response = await JSONrequest(
    "/Foo/Bar",
    protoscript.EmptyJSON.encode(empty),
    config
  );
  return protoscript.EmptyJSON.decode(response);
}

export function createFoo(service) {
  return {
    name: "Foo",
    methods: {
      Bar: {
        name: "Bar",
        handler: service.Bar,
        input: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
        output: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
      },
    },
  };
}
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "google/protobuf/unittest_import_public.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto
/* eslint-disable */

import { BinaryReader, BinaryWriter } from "protoscript";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes PublicImportMessage to protobuf.
   */
  encode: function (msg) {
    return PublicImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes PublicImportMessage from protobuf.
   */
  decode: function (bytes) {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes PublicImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const PublicImportMessageJSON = {
  /**
   * Serializes PublicImportMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(PublicImportMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes PublicImportMessage from JSON.
   */
  decode: function (json) {
    return PublicImportMessageJSON._readMessage(
      PublicImportMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes PublicImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.e) {
      json["e"] = msg.e;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _e_ = json["e"];
    if (_e_) {
      msg.e = _e_;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "google/protobuf/unittest_import.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto
/* eslint-disable */

import { BinaryReader, BinaryWriter } from "protoscript";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: "IMPORT_FOO",
  IMPORT_BAR: "IMPORT_BAR",
  IMPORT_BAZ: "IMPORT_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 7: {
        return "IMPORT_FOO";
      }
      case 8: {
        return "IMPORT_BAR";
      }
      case 9: {
        return "IMPORT_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "IMPORT_FOO": {
        return 7;
      }
      case "IMPORT_BAR": {
        return 8;
      }
      case "IMPORT_BAZ": {
        return 9;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const ImportEnumForMap = {
  UNKNOWN: "UNKNOWN",
  FOO: "FOO",
  BAR: "BAR",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "FOO";
      }
      case 2: {
        return "BAR";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "FOO": {
        return 1;
      }
      case "BAR": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const ImportMessage = {
  /**
   * Serializes ImportMessage to protobuf.
   */
  encode: function (msg) {
    return ImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ImportMessage from protobuf.
   */
  decode: function (bytes) {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ImportEnumJSON = {
  IMPORT_FOO: "IMPORT_FOO",
  IMPORT_BAR: "IMPORT_BAR",
  IMPORT_BAZ: "IMPORT_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 7: {
        return "IMPORT_FOO";
      }
      case 8: {
        return "IMPORT_BAR";
      }
      case 9: {
        return "IMPORT_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "IMPORT_FOO": {
        return 7;
      }
      case "IMPORT_BAR": {
        return 8;
      }
      case "IMPORT_BAZ": {
        return 9;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const ImportEnumForMapJSON = {
  UNKNOWN: "UNKNOWN",
  FOO: "FOO",
  BAR: "BAR",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "FOO";
      }
      case 2: {
        return "BAR";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "FOO": {
        return 1;
      }
      case "BAR": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const ImportMessageJSON = {
  /**
   * Serializes ImportMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(ImportMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ImportMessage from JSON.
   */
  decode: function (json) {
    return ImportMessageJSON._readMessage(
      ImportMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.d) {
      json["d"] = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _d_ = json["d"];
    if (_d_) {
      msg.d = _d_;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "google/protobuf/unittest.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto
/* eslint-disable */

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";

import * as googleProtobufUnittest_import from "./unittest_import.pb.js";
import * as googleProtobufUnittest_import_public from "./unittest_import_public.pb.js";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(fooRequest, config) {
  const response = await PBrequest(
    "/protobuf_unittest.TestService/Foo",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(barRequest, config) {
  const response = await PBrequest(
    "/protobuf_unittest.TestService/Bar",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(fooRequest, config) {
  const response = await JSONrequest(
    "/protobuf_unittest.TestService/Foo",
    FooRequestJSON.encode(fooRequest),
    config
  );
  return FooResponseJSON.decode(response);
}

export async function BarJSON(barRequest, config) {
  const response = await JSONrequest(
    "/protobuf_unittest.TestService/Bar",
    BarRequestJSON.encode(barRequest),
    config
  );
  return BarResponseJSON.decode(response);
}

export function createTestService(service) {
  return {
    name: "protobuf_unittest.TestService",
    methods: {
      Foo: {
        name: "Foo",
        handler: service.Foo,
        input: { protobuf: FooRequest, json: FooRequestJSON },
        output: { protobuf: FooResponse, json: FooResponseJSON },
      },
      Bar: {
        name: "Bar",
        handler: service.Bar,
        input: { protobuf: BarRequest, json: BarRequestJSON },
        output: { protobuf: BarResponse, json: BarResponseJSON },
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestEnumWithDupValue = {
  FOO1: "FOO1",
  BAR1: "BAR1",
  BAZ: "BAZ",
  FOO2: "FOO2",
  BAR2: "BAR2",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 1: {
        return "FOO1";
      }
      case 2: {
        return "BAR1";
      }
      case 3: {
        return "BAZ";
      }
      case 1: {
        return "FOO2";
      }
      case 2: {
        return "BAR2";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOO1": {
        return 1;
      }
      case "BAR1": {
        return 2;
      }
      case "BAZ": {
        return 3;
      }
      case "FOO2": {
        return 1;
      }
      case "BAR2": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestSparseEnum = {
  SPARSE_A: "SPARSE_A",
  SPARSE_B: "SPARSE_B",
  SPARSE_C: "SPARSE_C",
  SPARSE_D: "SPARSE_D",
  SPARSE_E: "SPARSE_E",
  SPARSE_F: "SPARSE_F",
  SPARSE_G: "SPARSE_G",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 123: {
        return "SPARSE_A";
      }
      case 62374: {
        return "SPARSE_B";
      }
      case 12589234: {
        return "SPARSE_C";
      }
      case -15: {
        return "SPARSE_D";
      }
      case -53452: {
        return "SPARSE_E";
      }
      case 0: {
        return "SPARSE_F";
      }
      case 2: {
        return "SPARSE_G";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "SPARSE_A": {
        return 123;
      }
      case "SPARSE_B": {
        return 62374;
      }
      case "SPARSE_C": {
        return 12589234;
      }
      case "SPARSE_D": {
        return -15;
      }
      case "SPARSE_E": {
        return -53452;
      }
      case "SPARSE_F": {
        return 0;
      }
      case "SPARSE_G": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: "ENUM_LABEL_DEFAULT",
  ENUM_LABEL_1: "ENUM_LABEL_1",
  ENUM_LABEL_2: "ENUM_LABEL_2",
  ENUM_LABEL_3: "ENUM_LABEL_3",
  ENUM_LABEL_4: "ENUM_LABEL_4",
  ENUM_LABEL_5: "ENUM_LABEL_5",
  ENUM_LABEL_6: "ENUM_LABEL_6",
  ENUM_LABEL_7: "ENUM_LABEL_7",
  ENUM_LABEL_8: "ENUM_LABEL_8",
  ENUM_LABEL_9: "ENUM_LABEL_9",
  ENUM_LABEL_10: "ENUM_LABEL_10",
  ENUM_LABEL_11: "ENUM_LABEL_11",
  ENUM_LABEL_12: "ENUM_LABEL_12",
  ENUM_LABEL_13: "ENUM_LABEL_13",
  ENUM_LABEL_14: "ENUM_LABEL_14",
  ENUM_LABEL_15: "ENUM_LABEL_15",
  ENUM_LABEL_16: "ENUM_LABEL_16",
  ENUM_LABEL_17: "ENUM_LABEL_17",
  ENUM_LABEL_18: "ENUM_LABEL_18",
  ENUM_LABEL_19: "ENUM_LABEL_19",
  ENUM_LABEL_20: "ENUM_LABEL_20",
  ENUM_LABEL_21: "ENUM_LABEL_21",
  ENUM_LABEL_22: "ENUM_LABEL_22",
  ENUM_LABEL_23: "ENUM_LABEL_23",
  ENUM_LABEL_24: "ENUM_LABEL_24",
  ENUM_LABEL_25: "ENUM_LABEL_25",
  ENUM_LABEL_26: "ENUM_LABEL_26",
  ENUM_LABEL_27: "ENUM_LABEL_27",
  ENUM_LABEL_28: "ENUM_LABEL_28",
  ENUM_LABEL_29: "ENUM_LABEL_29",
  ENUM_LABEL_30: "ENUM_LABEL_30",
  ENUM_LABEL_31: "ENUM_LABEL_31",
  ENUM_LABEL_32: "ENUM_LABEL_32",
  ENUM_LABEL_33: "ENUM_LABEL_33",
  ENUM_LABEL_34: "ENUM_LABEL_34",
  ENUM_LABEL_35: "ENUM_LABEL_35",
  ENUM_LABEL_36: "ENUM_LABEL_36",
  ENUM_LABEL_37: "ENUM_LABEL_37",
  ENUM_LABEL_38: "ENUM_LABEL_38",
  ENUM_LABEL_39: "ENUM_LABEL_39",
  ENUM_LABEL_40: "ENUM_LABEL_40",
  ENUM_LABEL_41: "ENUM_LABEL_41",
  ENUM_LABEL_42: "ENUM_LABEL_42",
  ENUM_LABEL_43: "ENUM_LABEL_43",
  ENUM_LABEL_44: "ENUM_LABEL_44",
  ENUM_LABEL_45: "ENUM_LABEL_45",
  ENUM_LABEL_46: "ENUM_LABEL_46",
  ENUM_LABEL_47: "ENUM_LABEL_47",
  ENUM_LABEL_48: "ENUM_LABEL_48",
  ENUM_LABEL_49: "ENUM_LABEL_49",
  ENUM_LABEL_50: "ENUM_LABEL_50",
  ENUM_LABEL_51: "ENUM_LABEL_51",
  ENUM_LABEL_52: "ENUM_LABEL_52",
  ENUM_LABEL_53: "ENUM_LABEL_53",
  ENUM_LABEL_54: "ENUM_LABEL_54",
  ENUM_LABEL_55: "ENUM_LABEL_55",
  ENUM_LABEL_56: "ENUM_LABEL_56",
  ENUM_LABEL_57: "ENUM_LABEL_57",
  ENUM_LABEL_58: "ENUM_LABEL_58",
  ENUM_LABEL_59: "ENUM_LABEL_59",
  ENUM_LABEL_60: "ENUM_LABEL_60",
  ENUM_LABEL_61: "ENUM_LABEL_61",
  ENUM_LABEL_62: "ENUM_LABEL_62",
  ENUM_LABEL_63: "ENUM_LABEL_63",
  ENUM_LABEL_64: "ENUM_LABEL_64",
  ENUM_LABEL_65: "ENUM_LABEL_65",
  ENUM_LABEL_66: "ENUM_LABEL_66",
  ENUM_LABEL_67: "ENUM_LABEL_67",
  ENUM_LABEL_68: "ENUM_LABEL_68",
  ENUM_LABEL_69: "ENUM_LABEL_69",
  ENUM_LABEL_70: "ENUM_LABEL_70",
  ENUM_LABEL_71: "ENUM_LABEL_71",
  ENUM_LABEL_72: "ENUM_LABEL_72",
  ENUM_LABEL_73: "ENUM_LABEL_73",
  ENUM_LABEL_74: "ENUM_LABEL_74",
  ENUM_LABEL_75: "ENUM_LABEL_75",
  ENUM_LABEL_76: "ENUM_LABEL_76",
  ENUM_LABEL_77: "ENUM_LABEL_77",
  ENUM_LABEL_78: "ENUM_LABEL_78",
  ENUM_LABEL_79: "ENUM_LABEL_79",
  ENUM_LABEL_80: "ENUM_LABEL_80",
  ENUM_LABEL_81: "ENUM_LABEL_81",
  ENUM_LABEL_82: "ENUM_LABEL_82",
  ENUM_LABEL_83: "ENUM_LABEL_83",
  ENUM_LABEL_84: "ENUM_LABEL_84",
  ENUM_LABEL_85: "ENUM_LABEL_85",
  ENUM_LABEL_86: "ENUM_LABEL_86",
  ENUM_LABEL_87: "ENUM_LABEL_87",
  ENUM_LABEL_88: "ENUM_LABEL_88",
  ENUM_LABEL_89: "ENUM_LABEL_89",
  ENUM_LABEL_90: "ENUM_LABEL_90",
  ENUM_LABEL_91: "ENUM_LABEL_91",
  ENUM_LABEL_92: "ENUM_LABEL_92",
  ENUM_LABEL_93: "ENUM_LABEL_93",
  ENUM_LABEL_94: "ENUM_LABEL_94",
  ENUM_LABEL_95: "ENUM_LABEL_95",
  ENUM_LABEL_96: "ENUM_LABEL_96",
  ENUM_LABEL_97: "ENUM_LABEL_97",
  ENUM_LABEL_98: "ENUM_LABEL_98",
  ENUM_LABEL_99: "ENUM_LABEL_99",
  ENUM_LABEL_100: "ENUM_LABEL_100",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "ENUM_LABEL_DEFAULT";
      }
      case 1: {
        return "ENUM_LABEL_1";
      }
      case 2: {
        return "ENUM_LABEL_2";
      }
      case 3: {
        return "ENUM_LABEL_3";
      }
      case 4: {
        return "ENUM_LABEL_4";
      }
      case 5: {
        return "ENUM_LABEL_5";
      }
      case 6: {
        return "ENUM_LABEL_6";
      }
      case 7: {
        return "ENUM_LABEL_7";
      }
      case 8: {
        return "ENUM_LABEL_8";
      }
      case 9: {
        return "ENUM_LABEL_9";
      }
      case 10: {
        return "ENUM_LABEL_10";
      }
      case 11: {
        return "ENUM_LABEL_11";
      }
      case 12: {
        return "ENUM_LABEL_12";
      }
      case 13: {
        return "ENUM_LABEL_13";
      }
      case 14: {
        return "ENUM_LABEL_14";
      }
      case 15: {
        return "ENUM_LABEL_15";
      }
      case 16: {
        return "ENUM_LABEL_16";
      }
      case 17: {
        return "ENUM_LABEL_17";
      }
      case 18: {
        return "ENUM_LABEL_18";
      }
      case 19: {
        return "ENUM_LABEL_19";
      }
      case 20: {
        return "ENUM_LABEL_20";
      }
      case 21: {
        return "ENUM_LABEL_21";
      }
      case 22: {
        return "ENUM_LABEL_22";
      }
      case 23: {
        return "ENUM_LABEL_23";
      }
      case 24: {
        return "ENUM_LABEL_24";
      }
      case 25: {
        return "ENUM_LABEL_25";
      }
      case 26: {
        return "ENUM_LABEL_26";
      }
      case 27: {
        return "ENUM_LABEL_27";
      }
      case 28: {
        return "ENUM_LABEL_28";
      }
      case 29: {
        return "ENUM_LABEL_29";
      }
      case 30: {
        return "ENUM_LABEL_30";
      }
      case 31: {
        return "ENUM_LABEL_31";
      }
      case 32: {
        return "ENUM_LABEL_32";
      }
      case 33: {
        return "ENUM_LABEL_33";
      }
      case 34: {
        return "ENUM_LABEL_34";
      }
      case 35: {
        return "ENUM_LABEL_35";
      }
      case 36: {
        return "ENUM_LABEL_36";
      }
      case 37: {
        return "ENUM_LABEL_37";
      }
      case 38: {
        return "ENUM_LABEL_38";
      }
      case 39: {
        return "ENUM_LABEL_39";
      }
      case 40: {
        return "ENUM_LABEL_40";
      }
      case 41: {
        return "ENUM_LABEL_41";
      }
      case 42: {
        return "ENUM_LABEL_42";
      }
      case 43: {
        return "ENUM_LABEL_43";
      }
      case 44: {
        return "ENUM_LABEL_44";
      }
      case 45: {
        return "ENUM_LABEL_45";
      }
      case 46: {
        return "ENUM_LABEL_46";
      }
      case 47: {
        return "ENUM_LABEL_47";
      }
      case 48: {
        return "ENUM_LABEL_48";
      }
      case 49: {
        return "ENUM_LABEL_49";
      }
      case 50: {
        return "ENUM_LABEL_50";
      }
      case 51: {
        return "ENUM_LABEL_51";
      }
      case 52: {
        return "ENUM_LABEL_52";
      }
      case 53: {
        return "ENUM_LABEL_53";
      }
      case 54: {
        return "ENUM_LABEL_54";
      }
      case 55: {
        return "ENUM_LABEL_55";
      }
      case 56: {
        return "ENUM_LABEL_56";
      }
      case 57: {
        return "ENUM_LABEL_57";
      }
      case 58: {
        return "ENUM_LABEL_58";
      }
      case 59: {
        return "ENUM_LABEL_59";
      }
      case 60: {
        return "ENUM_LABEL_60";
      }
      case 61: {
        return "ENUM_LABEL_61";
      }
      case 62: {
        return "ENUM_LABEL_62";
      }
      case 63: {
        return "ENUM_LABEL_63";
      }
      case 64: {
        return "ENUM_LABEL_64";
      }
      case 65: {
        return "ENUM_LABEL_65";
      }
      case 66: {
        return "ENUM_LABEL_66";
      }
      case 67: {
        return "ENUM_LABEL_67";
      }
      case 68: {
        return "ENUM_LABEL_68";
      }
      case 69: {
        return "ENUM_LABEL_69";
      }
      case 70: {
        return "ENUM_LABEL_70";
      }
      case 71: {
        return "ENUM_LABEL_71";
      }
      case 72: {
        return "ENUM_LABEL_72";
      }
      case 73: {
        return "ENUM_LABEL_73";
      }
      case 74: {
        return "ENUM_LABEL_74";
      }
      case 75: {
        return "ENUM_LABEL_75";
      }
      case 76: {
        return "ENUM_LABEL_76";
      }
      case 77: {
        return "ENUM_LABEL_77";
      }
      case 78: {
        return "ENUM_LABEL_78";
      }
      case 79: {
        return "ENUM_LABEL_79";
      }
      case 80: {
        return "ENUM_LABEL_80";
      }
      case 81: {
        return "ENUM_LABEL_81";
      }
      case 82: {
        return "ENUM_LABEL_82";
      }
      case 83: {
        return "ENUM_LABEL_83";
      }
      case 84: {
        return "ENUM_LABEL_84";
      }
      case 85: {
        return "ENUM_LABEL_85";
      }
      case 86: {
        return "ENUM_LABEL_86";
      }
      case 87: {
        return "ENUM_LABEL_87";
      }
      case 88: {
        return "ENUM_LABEL_88";
      }
      case 89: {
        return "ENUM_LABEL_89";
      }
      case 90: {
        return "ENUM_LABEL_90";
      }
      case 91: {
        return "ENUM_LABEL_91";
      }
      case 92: {
        return "ENUM_LABEL_92";
      }
      case 93: {
        return "ENUM_LABEL_93";
      }
      case 94: {
        return "ENUM_LABEL_94";
      }
      case 95: {
        return "ENUM_LABEL_95";
      }
      case 96: {
        return "ENUM_LABEL_96";
      }
      case 97: {
        return "ENUM_LABEL_97";
      }
      case 98: {
        return "ENUM_LABEL_98";
      }
      case 99: {
        return "ENUM_LABEL_99";
      }
      case 100: {
        return "ENUM_LABEL_100";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "ENUM_LABEL_DEFAULT": {
        return 0;
      }
      case "ENUM_LABEL_1": {
        return 1;
      }
      case "ENUM_LABEL_2": {
        return 2;
      }
      case "ENUM_LABEL_3": {
        return 3;
      }
      case "ENUM_LABEL_4": {
        return 4;
      }
      case "ENUM_LABEL_5": {
        return 5;
      }
      case "ENUM_LABEL_6": {
        return 6;
      }
      case "ENUM_LABEL_7": {
        return 7;
      }
      case "ENUM_LABEL_8": {
        return 8;
      }
      case "ENUM_LABEL_9": {
        return 9;
      }
      case "ENUM_LABEL_10": {
        return 10;
      }
      case "ENUM_LABEL_11": {
        return 11;
      }
      case "ENUM_LABEL_12": {
        return 12;
      }
      case "ENUM_LABEL_13": {
        return 13;
      }
      case "ENUM_LABEL_14": {
        return 14;
      }
      case "ENUM_LABEL_15": {
        return 15;
      }
      case "ENUM_LABEL_16": {
        return 16;
      }
      case "ENUM_LABEL_17": {
        return 17;
      }
      case "ENUM_LABEL_18": {
        return 18;
      }
      case "ENUM_LABEL_19": {
        return 19;
      }
      case "ENUM_LABEL_20": {
        return 20;
      }
      case "ENUM_LABEL_21": {
        return 21;
      }
      case "ENUM_LABEL_22": {
        return 22;
      }
      case "ENUM_LABEL_23": {
        return 23;
      }
      case "ENUM_LABEL_24": {
        return 24;
      }
      case "ENUM_LABEL_25": {
        return 25;
      }
      case "ENUM_LABEL_26": {
        return 26;
      }
      case "ENUM_LABEL_27": {
        return 27;
      }
      case "ENUM_LABEL_28": {
        return 28;
      }
      case "ENUM_LABEL_29": {
        return 29;
      }
      case "ENUM_LABEL_30": {
        return 30;
      }
      case "ENUM_LABEL_31": {
        return 31;
      }
      case "ENUM_LABEL_32": {
        return 32;
      }
      case "ENUM_LABEL_33": {
        return 33;
      }
      case "ENUM_LABEL_34": {
        return 34;
      }
      case "ENUM_LABEL_35": {
        return 35;
      }
      case "ENUM_LABEL_36": {
        return 36;
      }
      case "ENUM_LABEL_37": {
        return 37;
      }
      case "ENUM_LABEL_38": {
        return 38;
      }
      case "ENUM_LABEL_39": {
        return 39;
      }
      case "ENUM_LABEL_40": {
        return 40;
      }
      case "ENUM_LABEL_41": {
        return 41;
      }
      case "ENUM_LABEL_42": {
        return 42;
      }
      case "ENUM_LABEL_43": {
        return 43;
      }
      case "ENUM_LABEL_44": {
        return 44;
      }
      case "ENUM_LABEL_45": {
        return 45;
      }
      case "ENUM_LABEL_46": {
        return 46;
      }
      case "ENUM_LABEL_47": {
        return 47;
      }
      case "ENUM_LABEL_48": {
        return 48;
      }
      case "ENUM_LABEL_49": {
        return 49;
      }
      case "ENUM_LABEL_50": {
        return 50;
      }
      case "ENUM_LABEL_51": {
        return 51;
      }
      case "ENUM_LABEL_52": {
        return 52;
      }
      case "ENUM_LABEL_53": {
        return 53;
      }
      case "ENUM_LABEL_54": {
        return 54;
      }
      case "ENUM_LABEL_55": {
        return 55;
      }
      case "ENUM_LABEL_56": {
        return 56;
      }
      case "ENUM_LABEL_57": {
        return 57;
      }
      case "ENUM_LABEL_58": {
        return 58;
      }
      case "ENUM_LABEL_59": {
        return 59;
      }
      case "ENUM_LABEL_60": {
        return 60;
      }
      case "ENUM_LABEL_61": {
        return 61;
      }
      case "ENUM_LABEL_62": {
        return 62;
      }
      case "ENUM_LABEL_63": {
        return 63;
      }
      case "ENUM_LABEL_64": {
        return 64;
      }
      case "ENUM_LABEL_65": {
        return 65;
      }
      case "ENUM_LABEL_66": {
        return 66;
      }
      case "ENUM_LABEL_67": {
        return 67;
      }
      case "ENUM_LABEL_68": {
        return 68;
      }
      case "ENUM_LABEL_69": {
        return 69;
      }
      case "ENUM_LABEL_70": {
        return 70;
      }
      case "ENUM_LABEL_71": {
        return 71;
      }
      case "ENUM_LABEL_72": {
        return 72;
      }
      case "ENUM_LABEL_73": {
        return 73;
      }
      case "ENUM_LABEL_74": {
        return 74;
      }
      case "ENUM_LABEL_75": {
        return 75;
      }
      case "ENUM_LABEL_76": {
        return 76;
      }
      case "ENUM_LABEL_77": {
        return 77;
      }
      case "ENUM_LABEL_78": {
        return 78;
      }
      case "ENUM_LABEL_79": {
        return 79;
      }
      case "ENUM_LABEL_80": {
        return 80;
      }
      case "ENUM_LABEL_81": {
        return 81;
      }
      case "ENUM_LABEL_82": {
        return 82;
      }
      case "ENUM_LABEL_83": {
        return 83;
      }
      case "ENUM_LABEL_84": {
        return 84;
      }
      case "ENUM_LABEL_85": {
        return 85;
      }
      case "ENUM_LABEL_86": {
        return 86;
      }
      case "ENUM_LABEL_87": {
        return 87;
      }
      case "ENUM_LABEL_88": {
        return 88;
      }
      case "ENUM_LABEL_89": {
        return 89;
      }
      case "ENUM_LABEL_90": {
        return 90;
      }
      case "ENUM_LABEL_91": {
        return 91;
      }
      case "ENUM_LABEL_92": {
        return 92;
      }
      case "ENUM_LABEL_93": {
        return 93;
      }
      case "ENUM_LABEL_94": {
        return 94;
      }
      case "ENUM_LABEL_95": {
        return 95;
      }
      case "ENUM_LABEL_96": {
        return 96;
      }
      case "ENUM_LABEL_97": {
        return 97;
      }
      case "ENUM_LABEL_98": {
        return 98;
      }
      case "ENUM_LABEL_99": {
        return 99;
      }
      case "ENUM_LABEL_100": {
        return 100;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestAllTypes = {
  /**
   * Serializes TestAllTypes to protobuf.
   */
  encode: function (msg) {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      defaultForeignEnum: ForeignEnum._fromInt(0),
      defaultImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      defaultStringPiece: "",
      defaultCord: "",
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64String(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
      );
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    if (
      msg.optionalImportEnum &&
      googleProtobufUnittest_import.ImportEnum._toInt(msg.optionalImportEnum)
    ) {
      writer.writeEnum(
        23,
        googleProtobufUnittest_import.ImportEnum._toInt(msg.optionalImportEnum)
      );
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        googleProtobufUnittest_import_public.PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        40,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writePackedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnum._toInt)
      );
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writePackedEnum(
        53,
        msg.repeatedImportEnum.map(
          googleProtobufUnittest_import.ImportEnum._toInt
        )
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString());
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString());
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString());
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString());
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64String(70, msg.defaultSfixed64.toString());
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes?.length) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.defaultNestedEnum)
    ) {
      writer.writeEnum(
        81,
        TestAllTypes.NestedEnum._toInt(msg.defaultNestedEnum)
      );
    }
    if (msg.defaultForeignEnum && ForeignEnum._toInt(msg.defaultForeignEnum)) {
      writer.writeEnum(82, ForeignEnum._toInt(msg.defaultForeignEnum));
    }
    if (
      msg.defaultImportEnum &&
      googleProtobufUnittest_import.ImportEnum._toInt(msg.defaultImportEnum)
    ) {
      writer.writeEnum(
        83,
        googleProtobufUnittest_import.ImportEnum._toInt(msg.defaultImportEnum)
      );
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 23: {
          msg.optionalImportEnum =
            googleProtobufUnittest_import.ImportEnum._fromInt(
              reader.readEnum()
            );
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            googleProtobufUnittest_import_public.PublicImportMessage
              ._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 32: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 33: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 34: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 35: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 36: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 37: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 38: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 39: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 40: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 41: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 42: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 43: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = googleProtobufUnittest_import.ImportMessage.initialize();
          reader.readMessage(
            m,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt)
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 52: {
          if (reader.isDelimited()) {
            msg.repeatedForeignEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.repeatedForeignEnum.push(
              ForeignEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 53: {
          if (reader.isDelimited()) {
            msg.repeatedImportEnum.push(
              ...reader
                .readPackedEnum()
                .map(googleProtobufUnittest_import.ImportEnum._fromInt)
            );
          } else {
            msg.repeatedImportEnum.push(
              googleProtobufUnittest_import.ImportEnum._fromInt(
                reader.readEnum()
              )
            );
          }
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum()
          );
          break;
        }
        case 82: {
          msg.defaultForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 83: {
          msg.defaultImportEnum =
            googleProtobufUnittest_import.ImportEnum._fromInt(
              reader.readEnum()
            );
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          msg.oneofNestedMessage = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes NestedTestAllTypes to protobuf.
   */
  encode: function (msg) {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes TestDeprecatedFields to protobuf.
   */
  encode: function (msg) {
    return TestDeprecatedFields._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDeprecatedFields from protobuf.
   */
  decode: function (bytes) {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecatedInt32: 0,
      deprecatedInt32InOneof: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes TestDeprecatedMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestDeprecatedMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes ForeignMessage to protobuf.
   */
  encode: function (msg) {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes TestReservedFields to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestReservedFields from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes TestAllExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestAllExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes OptionalGroup_extension to protobuf.
   */
  encode: function (msg) {
    return OptionalGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes OptionalGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes RepeatedGroup_extension to protobuf.
   */
  encode: function (msg) {
    return RepeatedGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes TestGroup to protobuf.
   */
  encode: function (msg) {
    return TestGroup._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestGroup from protobuf.
   */
  decode: function (bytes) {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalForeignEnum: ForeignEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestGroup.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestGroup.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes TestGroupExtension to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestGroupExtension from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes TestNestedExtension to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestNestedExtension from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (msg) {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (bytes) {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes TestChildExtension to protobuf.
   */
  encode: function (msg) {
    return TestChildExtension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestChildExtension from protobuf.
   */
  decode: function (bytes) {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: "",
      b: "",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes TestRequired to protobuf.
   */
  encode: function (msg) {
    return TestRequired._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequired from protobuf.
   */
  decode: function (bytes) {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes TestRequiredForeign to protobuf.
   */
  encode: function (msg) {
    return TestRequiredForeign._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredForeign from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes TestRequiredMessage to protobuf.
   */
  encode: function (msg) {
    return TestRequiredMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes TestForeignNested to protobuf.
   */
  encode: function (msg) {
    return TestForeignNested._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestForeignNested from protobuf.
   */
  decode: function (bytes) {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes TestEmptyMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes TestPickleNestedMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestPickleNestedMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },

  NestedMessage: {
    /**
     * Serializes TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (msg) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (bytes) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes TestMultipleExtensionRanges to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestMultipleExtensionRanges from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes TestReallyLargeTagNumber to protobuf.
   */
  encode: function (msg) {
    return TestReallyLargeTagNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes) {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes TestRecursiveMessage to protobuf.
   */
  encode: function (msg) {
    return TestRecursiveMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRecursiveMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes TestMutualRecursionA to protobuf.
   */
  encode: function (msg) {
    return TestMutualRecursionA._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMutualRecursionA from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (msg) {
      return TestMutualRecursionA.SubMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (msg) {
      return TestMutualRecursionA.SubGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes TestMutualRecursionB to protobuf.
   */
  encode: function (msg) {
    return TestMutualRecursionB._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMutualRecursionB from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes TestIsInitialized to protobuf.
   */
  encode: function (msg) {
    return TestIsInitialized._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestIsInitialized from protobuf.
   */
  decode: function (bytes) {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (_msg) {
      return new Uint8Array();
    },

    /**
     * Deserializes TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (_bytes) {
      return {};
    },

    /**
     * Initializes TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (_msg, writer) {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (_msg, _reader) {
      return _msg;
    },

    SubGroup: {
      /**
       * Serializes TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (msg) {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (bytes) {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes TestDupFieldNumber to protobuf.
   */
  encode: function (msg) {
    return TestDupFieldNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDupFieldNumber from protobuf.
   */
  decode: function (bytes) {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (msg) {
      return TestDupFieldNumber.Foo._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (msg) {
      return TestDupFieldNumber.Bar._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes TestEagerMessage to protobuf.
   */
  encode: function (msg) {
    return TestEagerMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestEagerMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes TestLazyMessage to protobuf.
   */
  encode: function (msg) {
    return TestLazyMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestLazyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes TestNestedMessageHasBits to protobuf.
   */
  encode: function (msg) {
    return TestNestedMessageHasBits._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes) {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writePackedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            if (reader.isDelimited()) {
              msg.nestedmessageRepeatedInt32.push(...reader.readPackedInt32());
            } else {
              msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            }
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes TestCamelCaseFieldNames to protobuf.
   */
  encode: function (msg) {
    return TestCamelCaseFieldNames._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes) {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: "",
      EnumField: ForeignEnum._fromInt(0),
      MessageField: ForeignMessage.initialize(),
      StringPieceField: "",
      CordField: "",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField && ForeignEnum._toInt(msg.EnumField)) {
      writer.writeEnum(3, ForeignEnum._toInt(msg.EnumField));
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writePackedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writePackedEnum(9, msg.RepeatedEnumField.map(ForeignEnum._toInt));
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          if (reader.isDelimited()) {
            msg.RepeatedPrimitiveField.push(...reader.readPackedInt32());
          } else {
            msg.RepeatedPrimitiveField.push(reader.readInt32());
          }
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          if (reader.isDelimited()) {
            msg.RepeatedEnumField.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.RepeatedEnumField.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes TestFieldOrderings to protobuf.
   */
  encode: function (msg) {
    return TestFieldOrderings._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestFieldOrderings from protobuf.
   */
  decode: function (bytes) {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString());
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestFieldOrderings.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString());
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes TestExtensionOrderings1 to protobuf.
   */
  encode: function (msg) {
    return TestExtensionOrderings1._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes TestExtensionOrderings2 to protobuf.
   */
  encode: function (msg) {
    return TestExtensionOrderings2._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (msg) {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (bytes) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        myString: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes TestExtremeDefaultValues to protobuf.
   */
  encode: function (msg) {
    return TestExtremeDefaultValues._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes) {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: "",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: "",
      stringWithZero: "",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: "",
      cordWithZero: "",
      replacementString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.escapedBytes?.length) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString());
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString());
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString());
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero?.length) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes SparseEnumMessage to protobuf.
   */
  encode: function (msg) {
    return SparseEnumMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes SparseEnumMessage from protobuf.
   */
  decode: function (bytes) {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparseEnum: TestSparseEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sparseEnum && TestSparseEnum._toInt(msg.sparseEnum)) {
      writer.writeEnum(1, TestSparseEnum._toInt(msg.sparseEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = TestSparseEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes OneString to protobuf.
   */
  encode: function (msg) {
    return OneString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes OneString from protobuf.
   */
  decode: function (bytes) {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes MoreString to protobuf.
   */
  encode: function (msg) {
    return MoreString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes MoreString from protobuf.
   */
  decode: function (bytes) {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes OneBytes to protobuf.
   */
  encode: function (msg) {
    return OneBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes OneBytes from protobuf.
   */
  decode: function (bytes) {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes MoreBytes to protobuf.
   */
  encode: function (msg) {
    return MoreBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes MoreBytes from protobuf.
   */
  decode: function (bytes) {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes Int32Message to protobuf.
   */
  encode: function (msg) {
    return Int32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Int32Message from protobuf.
   */
  decode: function (bytes) {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes Uint32Message to protobuf.
   */
  encode: function (msg) {
    return Uint32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Uint32Message from protobuf.
   */
  decode: function (bytes) {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes Int64Message to protobuf.
   */
  encode: function (msg) {
    return Int64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Int64Message from protobuf.
   */
  decode: function (bytes) {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes Uint64Message to protobuf.
   */
  encode: function (msg) {
    return Uint64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Uint64Message from protobuf.
   */
  decode: function (bytes) {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes BoolMessage to protobuf.
   */
  encode: function (msg) {
    return BoolMessage._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes BoolMessage from protobuf.
   */
  decode: function (bytes) {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes TestOneof to protobuf.
   */
  encode: function (msg) {
    return TestOneof._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof from protobuf.
   */
  decode: function (bytes) {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooMessage = TestAllTypes.initialize();
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneof.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneof.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (msg) {
    return TestOneofBackwardsCompatible._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes) {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: 0,
      fooString: "",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes TestOneof2 to protobuf.
   */
  encode: function (msg) {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooCord: undefined,
      fooStringPiece: undefined,
      fooBytes: undefined,
      fooEnum: undefined,
      fooMessage: undefined,
      fooLazyMessage: undefined,
      barInt: undefined,
      barString: undefined,
      barCord: undefined,
      barStringPiece: undefined,
      barBytes: undefined,
      barEnum: undefined,
      barStringWithEmptyDefault: undefined,
      barCordWithEmptyDefault: undefined,
      barStringPieceWithEmptyDefault: undefined,
      barBytesWithEmptyDefault: undefined,
      bazInt: 0,
      bazString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes?.length) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnum._toInt(msg.fooEnum));
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes?.length) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, TestOneof2.NestedEnum._toInt(msg.barEnum));
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.fooMessage = TestOneof2.NestedMessage.initialize();
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          msg.fooLazyMessage = TestOneof2.NestedMessage.initialize();
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  FooGroup: {
    /**
     * Serializes TestOneof2.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneof2.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes TestOneof2.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestOneof2.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString());
      }
      if (msg.corgeInt?.length) {
        writer.writePackedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            if (reader.isDelimited()) {
              msg.corgeInt.push(...reader.readPackedInt32());
            } else {
              msg.corgeInt.push(reader.readInt32());
            }
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes TestRequiredOneof to protobuf.
   */
  encode: function (msg) {
    return TestRequiredOneof._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredOneof from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooMessage = TestRequiredOneof.NestedMessage.initialize();
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestRequiredOneof.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes TestPackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString())
      );
    }
    if (msg.packedUint32?.length) {
      writer.writePackedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString())
      );
    }
    if (msg.packedSint32?.length) {
      writer.writePackedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString())
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writePackedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString())
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.packedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.packedFloat?.length) {
      writer.writePackedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writePackedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writePackedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writePackedEnum(103, msg.packedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.packedInt64.push(...reader.readPackedInt64String().map(BigInt));
          } else {
            msg.packedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.packedUint32.push(...reader.readPackedUint32());
          } else {
            msg.packedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.packedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.packedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.packedSint32.push(...reader.readPackedSint32());
          } else {
            msg.packedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.packedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.packedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.packedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.packedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.packedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.packedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.packedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.packedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.packedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.packedFloat.push(...reader.readPackedFloat());
          } else {
            msg.packedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.packedDouble.push(...reader.readPackedDouble());
          } else {
            msg.packedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.packedBool.push(...reader.readPackedBool());
          } else {
            msg.packedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.packedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.packedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes TestUnpackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.unpackedInt32?.length) {
      writer.writePackedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.unpackedInt64.map((x) => x.toString())
      );
    }
    if (msg.unpackedUint32?.length) {
      writer.writePackedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.unpackedUint64.map((x) => x.toString())
      );
    }
    if (msg.unpackedSint32?.length) {
      writer.writePackedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.unpackedSint64.map((x) => x.toString())
      );
    }
    if (msg.unpackedFixed32?.length) {
      writer.writePackedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.unpackedFixed64.map((x) => x.toString())
      );
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.unpackedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.unpackedFloat?.length) {
      writer.writePackedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writePackedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writePackedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writePackedEnum(103, msg.unpackedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.unpackedInt32.push(...reader.readPackedInt32());
          } else {
            msg.unpackedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.unpackedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.unpackedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.unpackedUint32.push(...reader.readPackedUint32());
          } else {
            msg.unpackedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.unpackedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.unpackedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.unpackedSint32.push(...reader.readPackedSint32());
          } else {
            msg.unpackedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.unpackedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.unpackedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.unpackedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.unpackedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.unpackedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.unpackedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.unpackedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.unpackedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.unpackedFloat.push(...reader.readPackedFloat());
          } else {
            msg.unpackedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.unpackedDouble.push(...reader.readPackedDouble());
          } else {
            msg.unpackedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.unpackedBool.push(...reader.readPackedBool());
          } else {
            msg.unpackedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.unpackedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.unpackedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes TestPackedExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestPackedExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes TestUnpackedExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestUnpackedExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes TestDynamicExtensions to protobuf.
   */
  encode: function (msg) {
    return TestDynamicExtensions._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDynamicExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnum._fromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType._fromInt(0),
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension && ForeignEnum._toInt(msg.enumExtension)) {
      writer.writeEnum(2001, ForeignEnum._toInt(msg.enumExtension));
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumType._toInt(msg.dynamicEnumExtension)
    ) {
      writer.writeEnum(
        2002,
        TestDynamicExtensions.DynamicEnumType._toInt(msg.dynamicEnumExtension)
      );
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writePackedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            TestDynamicExtensions.DynamicEnumType._fromInt(reader.readEnum());
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          if (reader.isDelimited()) {
            msg.packedExtension.push(...reader.readPackedSint32());
          } else {
            msg.packedExtension.push(reader.readSint32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: "DYNAMIC_FOO",
    DYNAMIC_BAR: "DYNAMIC_BAR",
    DYNAMIC_BAZ: "DYNAMIC_BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 2200: {
          return "DYNAMIC_FOO";
        }
        case 2201: {
          return "DYNAMIC_BAR";
        }
        case 2202: {
          return "DYNAMIC_BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "DYNAMIC_FOO": {
          return 2200;
        }
        case "DYNAMIC_BAR": {
          return 2201;
        }
        case "DYNAMIC_BAZ": {
          return 2202;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  DynamicMessageType: {
    /**
     * Serializes TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (msg) {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (bytes) {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (msg) {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes) {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        2046,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        2047,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        262143,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 13: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 2046: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 2047: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 262142: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 262143: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes TestParsingMerge to protobuf.
   */
  encode: function (msg) {
    return TestParsingMerge._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestParsingMerge from protobuf.
   */
  decode: function (bytes) {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(1, msg.field1, TestAllTypes._writeMessage);
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(2, msg.field2, TestAllTypes._writeMessage);
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(3, msg.field3, TestAllTypes._writeMessage);
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(1000, msg.ext1, TestAllTypes._writeMessage);
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(1001, msg.ext2, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (msg) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (msg) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes TestCommentInjectionMessage to protobuf.
   */
  encode: function (msg) {
    return TestCommentInjectionMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes) {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes FooRequest to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes FooRequest from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const FooResponse = {
  /**
   * Serializes FooResponse to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes FooResponse from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes FooClientMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes FooClientMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes FooServerMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes FooServerMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const BarRequest = {
  /**
   * Serializes BarRequest to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes BarRequest from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const BarResponse = {
  /**
   * Serializes BarResponse to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes BarResponse from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes TestJsonName to protobuf.
   */
  encode: function (msg) {
    return TestJsonName._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestJsonName from protobuf.
   */
  decode: function (bytes) {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes TestHugeFieldNumbers to protobuf.
   */
  encode: function (msg) {
    return TestHugeFieldNumbers._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes) {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnum._fromInt(0),
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofUint32: undefined,
      oneofTestAllTypes: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum && ForeignEnum._toInt(msg.optionalEnum)) {
      writer.writeEnum(536870004, ForeignEnum._toInt(msg.optionalEnum));
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      writer.writeRepeatedMessage(
        536870010,
        Object.entries(msg.stringStringMap).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestHugeFieldNumbers.StringStringMap._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 536870003: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 536870004: {
          msg.optionalEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          const map = {};
          reader.readMessage(
            map,
            TestHugeFieldNumbers.StringStringMap._readMessage
          );
          msg.stringStringMap[map.key.toString()] = map.value;
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          msg.oneofTestAllTypes = TestAllTypes.initialize();
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes TestExtensionInsideTable to protobuf.
   */
  encode: function (msg) {
    return TestExtensionInsideTable._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes TestExtensionRangeSerialize to protobuf.
   */
  encode: function (msg) {
    return TestExtensionRangeSerialize._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ForeignEnumJSON = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestEnumWithDupValueJSON = {
  FOO1: "FOO1",
  BAR1: "BAR1",
  BAZ: "BAZ",
  FOO2: "FOO2",
  BAR2: "BAR2",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 1: {
        return "FOO1";
      }
      case 2: {
        return "BAR1";
      }
      case 3: {
        return "BAZ";
      }
      case 1: {
        return "FOO2";
      }
      case 2: {
        return "BAR2";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOO1": {
        return 1;
      }
      case "BAR1": {
        return 2;
      }
      case "BAZ": {
        return 3;
      }
      case "FOO2": {
        return 1;
      }
      case "BAR2": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestSparseEnumJSON = {
  SPARSE_A: "SPARSE_A",
  SPARSE_B: "SPARSE_B",
  SPARSE_C: "SPARSE_C",
  SPARSE_D: "SPARSE_D",
  SPARSE_E: "SPARSE_E",
  SPARSE_F: "SPARSE_F",
  SPARSE_G: "SPARSE_G",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 123: {
        return "SPARSE_A";
      }
      case 62374: {
        return "SPARSE_B";
      }
      case 12589234: {
        return "SPARSE_C";
      }
      case -15: {
        return "SPARSE_D";
      }
      case -53452: {
        return "SPARSE_E";
      }
      case 0: {
        return "SPARSE_F";
      }
      case 2: {
        return "SPARSE_G";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "SPARSE_A": {
        return 123;
      }
      case "SPARSE_B": {
        return 62374;
      }
      case "SPARSE_C": {
        return 12589234;
      }
      case "SPARSE_D": {
        return -15;
      }
      case "SPARSE_E": {
        return -53452;
      }
      case "SPARSE_F": {
        return 0;
      }
      case "SPARSE_G": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const VeryLargeEnumJSON = {
  ENUM_LABEL_DEFAULT: "ENUM_LABEL_DEFAULT",
  ENUM_LABEL_1: "ENUM_LABEL_1",
  ENUM_LABEL_2: "ENUM_LABEL_2",
  ENUM_LABEL_3: "ENUM_LABEL_3",
  ENUM_LABEL_4: "ENUM_LABEL_4",
  ENUM_LABEL_5: "ENUM_LABEL_5",
  ENUM_LABEL_6: "ENUM_LABEL_6",
  ENUM_LABEL_7: "ENUM_LABEL_7",
  ENUM_LABEL_8: "ENUM_LABEL_8",
  ENUM_LABEL_9: "ENUM_LABEL_9",
  ENUM_LABEL_10: "ENUM_LABEL_10",
  ENUM_LABEL_11: "ENUM_LABEL_11",
  ENUM_LABEL_12: "ENUM_LABEL_12",
  ENUM_LABEL_13: "ENUM_LABEL_13",
  ENUM_LABEL_14: "ENUM_LABEL_14",
  ENUM_LABEL_15: "ENUM_LABEL_15",
  ENUM_LABEL_16: "ENUM_LABEL_16",
  ENUM_LABEL_17: "ENUM_LABEL_17",
  ENUM_LABEL_18: "ENUM_LABEL_18",
  ENUM_LABEL_19: "ENUM_LABEL_19",
  ENUM_LABEL_20: "ENUM_LABEL_20",
  ENUM_LABEL_21: "ENUM_LABEL_21",
  ENUM_LABEL_22: "ENUM_LABEL_22",
  ENUM_LABEL_23: "ENUM_LABEL_23",
  ENUM_LABEL_24: "ENUM_LABEL_24",
  ENUM_LABEL_25: "ENUM_LABEL_25",
  ENUM_LABEL_26: "ENUM_LABEL_26",
  ENUM_LABEL_27: "ENUM_LABEL_27",
  ENUM_LABEL_28: "ENUM_LABEL_28",
  ENUM_LABEL_29: "ENUM_LABEL_29",
  ENUM_LABEL_30: "ENUM_LABEL_30",
  ENUM_LABEL_31: "ENUM_LABEL_31",
  ENUM_LABEL_32: "ENUM_LABEL_32",
  ENUM_LABEL_33: "ENUM_LABEL_33",
  ENUM_LABEL_34: "ENUM_LABEL_34",
  ENUM_LABEL_35: "ENUM_LABEL_35",
  ENUM_LABEL_36: "ENUM_LABEL_36",
  ENUM_LABEL_37: "ENUM_LABEL_37",
  ENUM_LABEL_38: "ENUM_LABEL_38",
  ENUM_LABEL_39: "ENUM_LABEL_39",
  ENUM_LABEL_40: "ENUM_LABEL_40",
  ENUM_LABEL_41: "ENUM_LABEL_41",
  ENUM_LABEL_42: "ENUM_LABEL_42",
  ENUM_LABEL_43: "ENUM_LABEL_43",
  ENUM_LABEL_44: "ENUM_LABEL_44",
  ENUM_LABEL_45: "ENUM_LABEL_45",
  ENUM_LABEL_46: "ENUM_LABEL_46",
  ENUM_LABEL_47: "ENUM_LABEL_47",
  ENUM_LABEL_48: "ENUM_LABEL_48",
  ENUM_LABEL_49: "ENUM_LABEL_49",
  ENUM_LABEL_50: "ENUM_LABEL_50",
  ENUM_LABEL_51: "ENUM_LABEL_51",
  ENUM_LABEL_52: "ENUM_LABEL_52",
  ENUM_LABEL_53: "ENUM_LABEL_53",
  ENUM_LABEL_54: "ENUM_LABEL_54",
  ENUM_LABEL_55: "ENUM_LABEL_55",
  ENUM_LABEL_56: "ENUM_LABEL_56",
  ENUM_LABEL_57: "ENUM_LABEL_57",
  ENUM_LABEL_58: "ENUM_LABEL_58",
  ENUM_LABEL_59: "ENUM_LABEL_59",
  ENUM_LABEL_60: "ENUM_LABEL_60",
  ENUM_LABEL_61: "ENUM_LABEL_61",
  ENUM_LABEL_62: "ENUM_LABEL_62",
  ENUM_LABEL_63: "ENUM_LABEL_63",
  ENUM_LABEL_64: "ENUM_LABEL_64",
  ENUM_LABEL_65: "ENUM_LABEL_65",
  ENUM_LABEL_66: "ENUM_LABEL_66",
  ENUM_LABEL_67: "ENUM_LABEL_67",
  ENUM_LABEL_68: "ENUM_LABEL_68",
  ENUM_LABEL_69: "ENUM_LABEL_69",
  ENUM_LABEL_70: "ENUM_LABEL_70",
  ENUM_LABEL_71: "ENUM_LABEL_71",
  ENUM_LABEL_72: "ENUM_LABEL_72",
  ENUM_LABEL_73: "ENUM_LABEL_73",
  ENUM_LABEL_74: "ENUM_LABEL_74",
  ENUM_LABEL_75: "ENUM_LABEL_75",
  ENUM_LABEL_76: "ENUM_LABEL_76",
  ENUM_LABEL_77: "ENUM_LABEL_77",
  ENUM_LABEL_78: "ENUM_LABEL_78",
  ENUM_LABEL_79: "ENUM_LABEL_79",
  ENUM_LABEL_80: "ENUM_LABEL_80",
  ENUM_LABEL_81: "ENUM_LABEL_81",
  ENUM_LABEL_82: "ENUM_LABEL_82",
  ENUM_LABEL_83: "ENUM_LABEL_83",
  ENUM_LABEL_84: "ENUM_LABEL_84",
  ENUM_LABEL_85: "ENUM_LABEL_85",
  ENUM_LABEL_86: "ENUM_LABEL_86",
  ENUM_LABEL_87: "ENUM_LABEL_87",
  ENUM_LABEL_88: "ENUM_LABEL_88",
  ENUM_LABEL_89: "ENUM_LABEL_89",
  ENUM_LABEL_90: "ENUM_LABEL_90",
  ENUM_LABEL_91: "ENUM_LABEL_91",
  ENUM_LABEL_92: "ENUM_LABEL_92",
  ENUM_LABEL_93: "ENUM_LABEL_93",
  ENUM_LABEL_94: "ENUM_LABEL_94",
  ENUM_LABEL_95: "ENUM_LABEL_95",
  ENUM_LABEL_96: "ENUM_LABEL_96",
  ENUM_LABEL_97: "ENUM_LABEL_97",
  ENUM_LABEL_98: "ENUM_LABEL_98",
  ENUM_LABEL_99: "ENUM_LABEL_99",
  ENUM_LABEL_100: "ENUM_LABEL_100",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "ENUM_LABEL_DEFAULT";
      }
      case 1: {
        return "ENUM_LABEL_1";
      }
      case 2: {
        return "ENUM_LABEL_2";
      }
      case 3: {
        return "ENUM_LABEL_3";
      }
      case 4: {
        return "ENUM_LABEL_4";
      }
      case 5: {
        return "ENUM_LABEL_5";
      }
      case 6: {
        return "ENUM_LABEL_6";
      }
      case 7: {
        return "ENUM_LABEL_7";
      }
      case 8: {
        return "ENUM_LABEL_8";
      }
      case 9: {
        return "ENUM_LABEL_9";
      }
      case 10: {
        return "ENUM_LABEL_10";
      }
      case 11: {
        return "ENUM_LABEL_11";
      }
      case 12: {
        return "ENUM_LABEL_12";
      }
      case 13: {
        return "ENUM_LABEL_13";
      }
      case 14: {
        return "ENUM_LABEL_14";
      }
      case 15: {
        return "ENUM_LABEL_15";
      }
      case 16: {
        return "ENUM_LABEL_16";
      }
      case 17: {
        return "ENUM_LABEL_17";
      }
      case 18: {
        return "ENUM_LABEL_18";
      }
      case 19: {
        return "ENUM_LABEL_19";
      }
      case 20: {
        return "ENUM_LABEL_20";
      }
      case 21: {
        return "ENUM_LABEL_21";
      }
      case 22: {
        return "ENUM_LABEL_22";
      }
      case 23: {
        return "ENUM_LABEL_23";
      }
      case 24: {
        return "ENUM_LABEL_24";
      }
      case 25: {
        return "ENUM_LABEL_25";
      }
      case 26: {
        return "ENUM_LABEL_26";
      }
      case 27: {
        return "ENUM_LABEL_27";
      }
      case 28: {
        return "ENUM_LABEL_28";
      }
      case 29: {
        return "ENUM_LABEL_29";
      }
      case 30: {
        return "ENUM_LABEL_30";
      }
      case 31: {
        return "ENUM_LABEL_31";
      }
      case 32: {
        return "ENUM_LABEL_32";
      }
      case 33: {
        return "ENUM_LABEL_33";
      }
      case 34: {
        return "ENUM_LABEL_34";
      }
      case 35: {
        return "ENUM_LABEL_35";
      }
      case 36: {
        return "ENUM_LABEL_36";
      }
      case 37: {
        return "ENUM_LABEL_37";
      }
      case 38: {
        return "ENUM_LABEL_38";
      }
      case 39: {
        return "ENUM_LABEL_39";
      }
      case 40: {
        return "ENUM_LABEL_40";
      }
      case 41: {
        return "ENUM_LABEL_41";
      }
      case 42: {
        return "ENUM_LABEL_42";
      }
      case 43: {
        return "ENUM_LABEL_43";
      }
      case 44: {
        return "ENUM_LABEL_44";
      }
      case 45: {
        return "ENUM_LABEL_45";
      }
      case 46: {
        return "ENUM_LABEL_46";
      }
      case 47: {
        return "ENUM_LABEL_47";
      }
      case 48: {
        return "ENUM_LABEL_48";
      }
      case 49: {
        return "ENUM_LABEL_49";
      }
      case 50: {
        return "ENUM_LABEL_50";
      }
      case 51: {
        return "ENUM_LABEL_51";
      }
      case 52: {
        return "ENUM_LABEL_52";
      }
      case 53: {
        return "ENUM_LABEL_53";
      }
      case 54: {
        return "ENUM_LABEL_54";
      }
      case 55: {
        return "ENUM_LABEL_55";
      }
      case 56: {
        return "ENUM_LABEL_56";
      }
      case 57: {
        return "ENUM_LABEL_57";
      }
      case 58: {
        return "ENUM_LABEL_58";
      }
      case 59: {
        return "ENUM_LABEL_59";
      }
      case 60: {
        return "ENUM_LABEL_60";
      }
      case 61: {
        return "ENUM_LABEL_61";
      }
      case 62: {
        return "ENUM_LABEL_62";
      }
      case 63: {
        return "ENUM_LABEL_63";
      }
      case 64: {
        return "ENUM_LABEL_64";
      }
      case 65: {
        return "ENUM_LABEL_65";
      }
      case 66: {
        return "ENUM_LABEL_66";
      }
      case 67: {
        return "ENUM_LABEL_67";
      }
      case 68: {
        return "ENUM_LABEL_68";
      }
      case 69: {
        return "ENUM_LABEL_69";
      }
      case 70: {
        return "ENUM_LABEL_70";
      }
      case 71: {
        return "ENUM_LABEL_71";
      }
      case 72: {
        return "ENUM_LABEL_72";
      }
      case 73: {
        return "ENUM_LABEL_73";
      }
      case 74: {
        return "ENUM_LABEL_74";
      }
      case 75: {
        return "ENUM_LABEL_75";
      }
      case 76: {
        return "ENUM_LABEL_76";
      }
      case 77: {
        return "ENUM_LABEL_77";
      }
      case 78: {
        return "ENUM_LABEL_78";
      }
      case 79: {
        return "ENUM_LABEL_79";
      }
      case 80: {
        return "ENUM_LABEL_80";
      }
      case 81: {
        return "ENUM_LABEL_81";
      }
      case 82: {
        return "ENUM_LABEL_82";
      }
      case 83: {
        return "ENUM_LABEL_83";
      }
      case 84: {
        return "ENUM_LABEL_84";
      }
      case 85: {
        return "ENUM_LABEL_85";
      }
      case 86: {
        return "ENUM_LABEL_86";
      }
      case 87: {
        return "ENUM_LABEL_87";
      }
      case 88: {
        return "ENUM_LABEL_88";
      }
      case 89: {
        return "ENUM_LABEL_89";
      }
      case 90: {
        return "ENUM_LABEL_90";
      }
      case 91: {
        return "ENUM_LABEL_91";
      }
      case 92: {
        return "ENUM_LABEL_92";
      }
      case 93: {
        return "ENUM_LABEL_93";
      }
      case 94: {
        return "ENUM_LABEL_94";
      }
      case 95: {
        return "ENUM_LABEL_95";
      }
      case 96: {
        return "ENUM_LABEL_96";
      }
      case 97: {
        return "ENUM_LABEL_97";
      }
      case 98: {
        return "ENUM_LABEL_98";
      }
      case 99: {
        return "ENUM_LABEL_99";
      }
      case 100: {
        return "ENUM_LABEL_100";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "ENUM_LABEL_DEFAULT": {
        return 0;
      }
      case "ENUM_LABEL_1": {
        return 1;
      }
      case "ENUM_LABEL_2": {
        return 2;
      }
      case "ENUM_LABEL_3": {
        return 3;
      }
      case "ENUM_LABEL_4": {
        return 4;
      }
      case "ENUM_LABEL_5": {
        return 5;
      }
      case "ENUM_LABEL_6": {
        return 6;
      }
      case "ENUM_LABEL_7": {
        return 7;
      }
      case "ENUM_LABEL_8": {
        return 8;
      }
      case "ENUM_LABEL_9": {
        return 9;
      }
      case "ENUM_LABEL_10": {
        return 10;
      }
      case "ENUM_LABEL_11": {
        return 11;
      }
      case "ENUM_LABEL_12": {
        return 12;
      }
      case "ENUM_LABEL_13": {
        return 13;
      }
      case "ENUM_LABEL_14": {
        return 14;
      }
      case "ENUM_LABEL_15": {
        return 15;
      }
      case "ENUM_LABEL_16": {
        return 16;
      }
      case "ENUM_LABEL_17": {
        return 17;
      }
      case "ENUM_LABEL_18": {
        return 18;
      }
      case "ENUM_LABEL_19": {
        return 19;
      }
      case "ENUM_LABEL_20": {
        return 20;
      }
      case "ENUM_LABEL_21": {
        return 21;
      }
      case "ENUM_LABEL_22": {
        return 22;
      }
      case "ENUM_LABEL_23": {
        return 23;
      }
      case "ENUM_LABEL_24": {
        return 24;
      }
      case "ENUM_LABEL_25": {
        return 25;
      }
      case "ENUM_LABEL_26": {
        return 26;
      }
      case "ENUM_LABEL_27": {
        return 27;
      }
      case "ENUM_LABEL_28": {
        return 28;
      }
      case "ENUM_LABEL_29": {
        return 29;
      }
      case "ENUM_LABEL_30": {
        return 30;
      }
      case "ENUM_LABEL_31": {
        return 31;
      }
      case "ENUM_LABEL_32": {
        return 32;
      }
      case "ENUM_LABEL_33": {
        return 33;
      }
      case "ENUM_LABEL_34": {
        return 34;
      }
      case "ENUM_LABEL_35": {
        return 35;
      }
      case "ENUM_LABEL_36": {
        return 36;
      }
      case "ENUM_LABEL_37": {
        return 37;
      }
      case "ENUM_LABEL_38": {
        return 38;
      }
      case "ENUM_LABEL_39": {
        return 39;
      }
      case "ENUM_LABEL_40": {
        return 40;
      }
      case "ENUM_LABEL_41": {
        return 41;
      }
      case "ENUM_LABEL_42": {
        return 42;
      }
      case "ENUM_LABEL_43": {
        return 43;
      }
      case "ENUM_LABEL_44": {
        return 44;
      }
      case "ENUM_LABEL_45": {
        return 45;
      }
      case "ENUM_LABEL_46": {
        return 46;
      }
      case "ENUM_LABEL_47": {
        return 47;
      }
      case "ENUM_LABEL_48": {
        return 48;
      }
      case "ENUM_LABEL_49": {
        return 49;
      }
      case "ENUM_LABEL_50": {
        return 50;
      }
      case "ENUM_LABEL_51": {
        return 51;
      }
      case "ENUM_LABEL_52": {
        return 52;
      }
      case "ENUM_LABEL_53": {
        return 53;
      }
      case "ENUM_LABEL_54": {
        return 54;
      }
      case "ENUM_LABEL_55": {
        return 55;
      }
      case "ENUM_LABEL_56": {
        return 56;
      }
      case "ENUM_LABEL_57": {
        return 57;
      }
      case "ENUM_LABEL_58": {
        return 58;
      }
      case "ENUM_LABEL_59": {
        return 59;
      }
      case "ENUM_LABEL_60": {
        return 60;
      }
      case "ENUM_LABEL_61": {
        return 61;
      }
      case "ENUM_LABEL_62": {
        return 62;
      }
      case "ENUM_LABEL_63": {
        return 63;
      }
      case "ENUM_LABEL_64": {
        return 64;
      }
      case "ENUM_LABEL_65": {
        return 65;
      }
      case "ENUM_LABEL_66": {
        return 66;
      }
      case "ENUM_LABEL_67": {
        return 67;
      }
      case "ENUM_LABEL_68": {
        return 68;
      }
      case "ENUM_LABEL_69": {
        return 69;
      }
      case "ENUM_LABEL_70": {
        return 70;
      }
      case "ENUM_LABEL_71": {
        return 71;
      }
      case "ENUM_LABEL_72": {
        return 72;
      }
      case "ENUM_LABEL_73": {
        return 73;
      }
      case "ENUM_LABEL_74": {
        return 74;
      }
      case "ENUM_LABEL_75": {
        return 75;
      }
      case "ENUM_LABEL_76": {
        return 76;
      }
      case "ENUM_LABEL_77": {
        return 77;
      }
      case "ENUM_LABEL_78": {
        return 78;
      }
      case "ENUM_LABEL_79": {
        return 79;
      }
      case "ENUM_LABEL_80": {
        return 80;
      }
      case "ENUM_LABEL_81": {
        return 81;
      }
      case "ENUM_LABEL_82": {
        return 82;
      }
      case "ENUM_LABEL_83": {
        return 83;
      }
      case "ENUM_LABEL_84": {
        return 84;
      }
      case "ENUM_LABEL_85": {
        return 85;
      }
      case "ENUM_LABEL_86": {
        return 86;
      }
      case "ENUM_LABEL_87": {
        return 87;
      }
      case "ENUM_LABEL_88": {
        return 88;
      }
      case "ENUM_LABEL_89": {
        return 89;
      }
      case "ENUM_LABEL_90": {
        return 90;
      }
      case "ENUM_LABEL_91": {
        return 91;
      }
      case "ENUM_LABEL_92": {
        return 92;
      }
      case "ENUM_LABEL_93": {
        return 93;
      }
      case "ENUM_LABEL_94": {
        return 94;
      }
      case "ENUM_LABEL_95": {
        return 95;
      }
      case "ENUM_LABEL_96": {
        return 96;
      }
      case "ENUM_LABEL_97": {
        return 97;
      }
      case "ENUM_LABEL_98": {
        return 98;
      }
      case "ENUM_LABEL_99": {
        return 99;
      }
      case "ENUM_LABEL_100": {
        return 100;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestAllTypesJSON = {
  /**
   * Serializes TestAllTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestAllTypes from JSON.
   */
  decode: function (json) {
    return TestAllTypesJSON._readMessage(
      TestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessageJSON.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessageJSON.initialize(),
      optionalLazyMessage: TestAllTypesJSON.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      defaultForeignEnum: ForeignEnum._fromInt(0),
      defaultImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      defaultStringPiece: "",
      defaultCord: "",
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json["optionalInt64"] = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json["optionalUint32"] = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json["optionalUint64"] = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json["optionalSint32"] = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json["optionalSint64"] = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json["optionalFixed32"] = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json["optionalFixed64"] = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json["optionalSfixed32"] = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json["optionalSfixed64"] = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json["optionalFloat"] = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json["optionalDouble"] = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json["optionalBool"] = msg.optionalBool;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalNestedMessage);
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    if (msg.optionalForeignMessage) {
      const _optionalForeignMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalForeignMessage
      );
      if (Object.keys(_optionalForeignMessage_).length > 0) {
        json["optionalForeignMessage"] = _optionalForeignMessage_;
      }
    }
    if (msg.optionalImportMessage) {
      const _optionalImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalImportMessage
        );
      if (Object.keys(_optionalImportMessage_).length > 0) {
        json["optionalImportMessage"] = _optionalImportMessage_;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      json["optionalNestedEnum"] = msg.optionalNestedEnum;
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    if (
      msg.optionalImportEnum &&
      googleProtobufUnittest_import.ImportEnumJSON._toInt(
        msg.optionalImportEnum
      )
    ) {
      json["optionalImportEnum"] = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json["optionalStringPiece"] = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json["optionalCord"] = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const _optionalPublicImportMessage_ =
        googleProtobufUnittest_import_public.PublicImportMessageJSON._writeMessage(
          msg.optionalPublicImportMessage
        );
      if (Object.keys(_optionalPublicImportMessage_).length > 0) {
        json["optionalPublicImportMessage"] = _optionalPublicImportMessage_;
      }
    }
    if (msg.optionalLazyMessage) {
      const _optionalLazyMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalLazyMessage);
      if (Object.keys(_optionalLazyMessage_).length > 0) {
        json["optionalLazyMessage"] = _optionalLazyMessage_;
      }
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json["repeatedString"] = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json["repeatedBytes"] = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json["repeatedNestedMessage"] = msg.repeatedNestedMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json["repeatedForeignMessage"] = msg.repeatedForeignMessage.map(
        ForeignMessageJSON._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json["repeatedImportMessage"] = msg.repeatedImportMessage.map(
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json["repeatedForeignEnum"] = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json["repeatedImportEnum"] = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json["repeatedStringPiece"] = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json["repeatedCord"] = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json["repeatedLazyMessage"] = msg.repeatedLazyMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      json["defaultInt32"] = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json["defaultInt64"] = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json["defaultUint32"] = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json["defaultUint64"] = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json["defaultSint32"] = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json["defaultSint64"] = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json["defaultFixed32"] = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json["defaultFixed64"] = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json["defaultSfixed32"] = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json["defaultSfixed64"] = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json["defaultFloat"] = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json["defaultDouble"] = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json["defaultBool"] = msg.defaultBool;
    }
    if (msg.defaultString) {
      json["defaultString"] = msg.defaultString;
    }
    if (msg.defaultBytes?.length) {
      json["defaultBytes"] = encodeBase64Bytes(msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.defaultNestedEnum)
    ) {
      json["defaultNestedEnum"] = msg.defaultNestedEnum;
    }
    if (
      msg.defaultForeignEnum &&
      ForeignEnumJSON._toInt(msg.defaultForeignEnum)
    ) {
      json["defaultForeignEnum"] = msg.defaultForeignEnum;
    }
    if (
      msg.defaultImportEnum &&
      googleProtobufUnittest_import.ImportEnumJSON._toInt(msg.defaultImportEnum)
    ) {
      json["defaultImportEnum"] = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json["defaultStringPiece"] = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json["defaultCord"] = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const _oneofNestedMessage_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.oneofNestedMessage
      );
      json["oneofNestedMessage"] = _oneofNestedMessage_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _optionalInt64_ = json["optionalInt64"] ?? json["optional_int64"];
    if (_optionalInt64_) {
      msg.optionalInt64 = BigInt(_optionalInt64_);
    }
    const _optionalUint32_ = json["optionalUint32"] ?? json["optional_uint32"];
    if (_optionalUint32_) {
      msg.optionalUint32 = _optionalUint32_;
    }
    const _optionalUint64_ = json["optionalUint64"] ?? json["optional_uint64"];
    if (_optionalUint64_) {
      msg.optionalUint64 = BigInt(_optionalUint64_);
    }
    const _optionalSint32_ = json["optionalSint32"] ?? json["optional_sint32"];
    if (_optionalSint32_) {
      msg.optionalSint32 = _optionalSint32_;
    }
    const _optionalSint64_ = json["optionalSint64"] ?? json["optional_sint64"];
    if (_optionalSint64_) {
      msg.optionalSint64 = BigInt(_optionalSint64_);
    }
    const _optionalFixed32_ =
      json["optionalFixed32"] ?? json["optional_fixed32"];
    if (_optionalFixed32_) {
      msg.optionalFixed32 = _optionalFixed32_;
    }
    const _optionalFixed64_ =
      json["optionalFixed64"] ?? json["optional_fixed64"];
    if (_optionalFixed64_) {
      msg.optionalFixed64 = BigInt(_optionalFixed64_);
    }
    const _optionalSfixed32_ =
      json["optionalSfixed32"] ?? json["optional_sfixed32"];
    if (_optionalSfixed32_) {
      msg.optionalSfixed32 = _optionalSfixed32_;
    }
    const _optionalSfixed64_ =
      json["optionalSfixed64"] ?? json["optional_sfixed64"];
    if (_optionalSfixed64_) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64_);
    }
    const _optionalFloat_ = json["optionalFloat"] ?? json["optional_float"];
    if (_optionalFloat_) {
      msg.optionalFloat = _optionalFloat_;
    }
    const _optionalDouble_ = json["optionalDouble"] ?? json["optional_double"];
    if (_optionalDouble_) {
      msg.optionalDouble = _optionalDouble_;
    }
    const _optionalBool_ = json["optionalBool"] ?? json["optional_bool"];
    if (_optionalBool_) {
      msg.optionalBool = _optionalBool_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalNestedMessage_);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage_ =
      json["optionalForeignMessage"] ?? json["optional_foreign_message"];
    if (_optionalForeignMessage_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _optionalForeignMessage_);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage_ =
      json["optionalImportMessage"] ?? json["optional_import_message"];
    if (_optionalImportMessage_) {
      const m = googleProtobufUnittest_import.ImportMessage.initialize();
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        m,
        _optionalImportMessage_
      );
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum_ =
      json["optionalNestedEnum"] ?? json["optional_nested_enum"];
    if (_optionalNestedEnum_) {
      msg.optionalNestedEnum = _optionalNestedEnum_;
    }
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    const _optionalImportEnum_ =
      json["optionalImportEnum"] ?? json["optional_import_enum"];
    if (_optionalImportEnum_) {
      msg.optionalImportEnum = _optionalImportEnum_;
    }
    const _optionalStringPiece_ =
      json["optionalStringPiece"] ?? json["optional_string_piece"];
    if (_optionalStringPiece_) {
      msg.optionalStringPiece = _optionalStringPiece_;
    }
    const _optionalCord_ = json["optionalCord"] ?? json["optional_cord"];
    if (_optionalCord_) {
      msg.optionalCord = _optionalCord_;
    }
    const _optionalPublicImportMessage_ =
      json["optionalPublicImportMessage"] ??
      json["optional_public_import_message"];
    if (_optionalPublicImportMessage_) {
      const m =
        googleProtobufUnittest_import_public.PublicImportMessage.initialize();
      googleProtobufUnittest_import_public.PublicImportMessageJSON._readMessage(
        m,
        _optionalPublicImportMessage_
      );
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage_ =
      json["optionalLazyMessage"] ?? json["optional_lazy_message"];
    if (_optionalLazyMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalLazyMessage_);
      msg.optionalLazyMessage = m;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedString_ = json["repeatedString"] ?? json["repeated_string"];
    if (_repeatedString_) {
      msg.repeatedString = _repeatedString_;
    }
    const _repeatedBytes_ = json["repeatedBytes"] ?? json["repeated_bytes"];
    if (_repeatedBytes_) {
      msg.repeatedBytes = _repeatedBytes_.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage_ =
      json["repeatedNestedMessage"] ?? json["repeated_nested_message"];
    if (_repeatedNestedMessage_) {
      for (const item of _repeatedNestedMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage_ =
      json["repeatedForeignMessage"] ?? json["repeated_foreign_message"];
    if (_repeatedForeignMessage_) {
      for (const item of _repeatedForeignMessage_) {
        const m = ForeignMessage.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage_ =
      json["repeatedImportMessage"] ?? json["repeated_import_message"];
    if (_repeatedImportMessage_) {
      for (const item of _repeatedImportMessage_) {
        const m = googleProtobufUnittest_import.ImportMessage.initialize();
        googleProtobufUnittest_import.ImportMessageJSON._readMessage(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    const _repeatedForeignEnum_ =
      json["repeatedForeignEnum"] ?? json["repeated_foreign_enum"];
    if (_repeatedForeignEnum_) {
      msg.repeatedForeignEnum = _repeatedForeignEnum_;
    }
    const _repeatedImportEnum_ =
      json["repeatedImportEnum"] ?? json["repeated_import_enum"];
    if (_repeatedImportEnum_) {
      msg.repeatedImportEnum = _repeatedImportEnum_;
    }
    const _repeatedStringPiece_ =
      json["repeatedStringPiece"] ?? json["repeated_string_piece"];
    if (_repeatedStringPiece_) {
      msg.repeatedStringPiece = _repeatedStringPiece_;
    }
    const _repeatedCord_ = json["repeatedCord"] ?? json["repeated_cord"];
    if (_repeatedCord_) {
      msg.repeatedCord = _repeatedCord_;
    }
    const _repeatedLazyMessage_ =
      json["repeatedLazyMessage"] ?? json["repeated_lazy_message"];
    if (_repeatedLazyMessage_) {
      for (const item of _repeatedLazyMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _defaultInt32_ = json["defaultInt32"] ?? json["default_int32"];
    if (_defaultInt32_) {
      msg.defaultInt32 = _defaultInt32_;
    }
    const _defaultInt64_ = json["defaultInt64"] ?? json["default_int64"];
    if (_defaultInt64_) {
      msg.defaultInt64 = BigInt(_defaultInt64_);
    }
    const _defaultUint32_ = json["defaultUint32"] ?? json["default_uint32"];
    if (_defaultUint32_) {
      msg.defaultUint32 = _defaultUint32_;
    }
    const _defaultUint64_ = json["defaultUint64"] ?? json["default_uint64"];
    if (_defaultUint64_) {
      msg.defaultUint64 = BigInt(_defaultUint64_);
    }
    const _defaultSint32_ = json["defaultSint32"] ?? json["default_sint32"];
    if (_defaultSint32_) {
      msg.defaultSint32 = _defaultSint32_;
    }
    const _defaultSint64_ = json["defaultSint64"] ?? json["default_sint64"];
    if (_defaultSint64_) {
      msg.defaultSint64 = BigInt(_defaultSint64_);
    }
    const _defaultFixed32_ = json["defaultFixed32"] ?? json["default_fixed32"];
    if (_defaultFixed32_) {
      msg.defaultFixed32 = _defaultFixed32_;
    }
    const _defaultFixed64_ = json["defaultFixed64"] ?? json["default_fixed64"];
    if (_defaultFixed64_) {
      msg.defaultFixed64 = BigInt(_defaultFixed64_);
    }
    const _defaultSfixed32_ =
      json["defaultSfixed32"] ?? json["default_sfixed32"];
    if (_defaultSfixed32_) {
      msg.defaultSfixed32 = _defaultSfixed32_;
    }
    const _defaultSfixed64_ =
      json["defaultSfixed64"] ?? json["default_sfixed64"];
    if (_defaultSfixed64_) {
      msg.defaultSfixed64 = BigInt(_defaultSfixed64_);
    }
    const _defaultFloat_ = json["defaultFloat"] ?? json["default_float"];
    if (_defaultFloat_) {
      msg.defaultFloat = _defaultFloat_;
    }
    const _defaultDouble_ = json["defaultDouble"] ?? json["default_double"];
    if (_defaultDouble_) {
      msg.defaultDouble = _defaultDouble_;
    }
    const _defaultBool_ = json["defaultBool"] ?? json["default_bool"];
    if (_defaultBool_) {
      msg.defaultBool = _defaultBool_;
    }
    const _defaultString_ = json["defaultString"] ?? json["default_string"];
    if (_defaultString_) {
      msg.defaultString = _defaultString_;
    }
    const _defaultBytes_ = json["defaultBytes"] ?? json["default_bytes"];
    if (_defaultBytes_) {
      msg.defaultBytes = decodeBase64Bytes(_defaultBytes_);
    }
    const _defaultNestedEnum_ =
      json["defaultNestedEnum"] ?? json["default_nested_enum"];
    if (_defaultNestedEnum_) {
      msg.defaultNestedEnum = _defaultNestedEnum_;
    }
    const _defaultForeignEnum_ =
      json["defaultForeignEnum"] ?? json["default_foreign_enum"];
    if (_defaultForeignEnum_) {
      msg.defaultForeignEnum = _defaultForeignEnum_;
    }
    const _defaultImportEnum_ =
      json["defaultImportEnum"] ?? json["default_import_enum"];
    if (_defaultImportEnum_) {
      msg.defaultImportEnum = _defaultImportEnum_;
    }
    const _defaultStringPiece_ =
      json["defaultStringPiece"] ?? json["default_string_piece"];
    if (_defaultStringPiece_) {
      msg.defaultStringPiece = _defaultStringPiece_;
    }
    const _defaultCord_ = json["defaultCord"] ?? json["default_cord"];
    if (_defaultCord_) {
      msg.defaultCord = _defaultCord_;
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofNestedMessage_ =
      json["oneofNestedMessage"] ?? json["oneof_nested_message"];
    if (_oneofNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _oneofNestedMessage_);
      msg.oneofNestedMessage = m;
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestAllTypesJSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestAllTypesJSON.NestedMessage._readMessage(
        TestAllTypesJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestAllTypes.OptionalGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestAllTypesJSON.OptionalGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.OptionalGroup from JSON.
     */
    decode: function (json) {
      return TestAllTypesJSON.OptionalGroup._readMessage(
        TestAllTypesJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestAllTypes.RepeatedGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestAllTypesJSON.RepeatedGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.RepeatedGroup from JSON.
     */
    decode: function (json) {
      return TestAllTypesJSON.RepeatedGroup._readMessage(
        TestAllTypesJSON.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypesJSON = {
  /**
   * Serializes NestedTestAllTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(NestedTestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes NestedTestAllTypes from JSON.
   */
  decode: function (json) {
    return NestedTestAllTypesJSON._readMessage(
      NestedTestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypesJSON.initialize(),
      payload: TestAllTypesJSON.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.child) {
      const _child_ = NestedTestAllTypesJSON._writeMessage(msg.child);
      if (Object.keys(_child_).length > 0) {
        json["child"] = _child_;
      }
    }
    if (msg.payload) {
      const _payload_ = TestAllTypesJSON._writeMessage(msg.payload);
      if (Object.keys(_payload_).length > 0) {
        json["payload"] = _payload_;
      }
    }
    if (msg.repeatedChild?.length) {
      json["repeatedChild"] = msg.repeatedChild.map(
        NestedTestAllTypesJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _child_ = json["child"];
    if (_child_) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypesJSON._readMessage(m, _child_);
      msg.child = m;
    }
    const _payload_ = json["payload"];
    if (_payload_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _payload_);
      msg.payload = m;
    }
    const _repeatedChild_ = json["repeatedChild"] ?? json["repeated_child"];
    if (_repeatedChild_) {
      for (const item of _repeatedChild_) {
        const m = NestedTestAllTypes.initialize();
        NestedTestAllTypesJSON._readMessage(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFieldsJSON = {
  /**
   * Serializes TestDeprecatedFields to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestDeprecatedFieldsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDeprecatedFields from JSON.
   */
  decode: function (json) {
    return TestDeprecatedFieldsJSON._readMessage(
      TestDeprecatedFieldsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecatedInt32: 0,
      deprecatedInt32InOneof: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.deprecatedInt32) {
      json["deprecatedInt32"] = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json["deprecatedInt32InOneof"] = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _deprecatedInt32_ =
      json["deprecatedInt32"] ?? json["deprecated_int32"];
    if (_deprecatedInt32_) {
      msg.deprecatedInt32 = _deprecatedInt32_;
    }
    const _deprecatedInt32InOneof_ =
      json["deprecatedInt32InOneof"] ?? json["deprecated_int32_in_oneof"];
    if (_deprecatedInt32InOneof_) {
      msg.deprecatedInt32InOneof = _deprecatedInt32InOneof_;
    }
    return msg;
  },
};

export const TestDeprecatedMessageJSON = {
  /**
   * Serializes TestDeprecatedMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestDeprecatedMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const ForeignMessageJSON = {
  /**
   * Serializes ForeignMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(ForeignMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ForeignMessage from JSON.
   */
  decode: function (json) {
    return ForeignMessageJSON._readMessage(
      ForeignMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.c) {
      json["c"] = msg.c;
    }
    if (msg.d) {
      json["d"] = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    const _d_ = json["d"];
    if (_d_) {
      msg.d = _d_;
    }
    return msg;
  },
};

export const TestReservedFieldsJSON = {
  /**
   * Serializes TestReservedFields to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestReservedFields from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestAllExtensionsJSON = {
  /**
   * Serializes TestAllExtensions to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestAllExtensions from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const OptionalGroup_extensionJSON = {
  /**
   * Serializes OptionalGroup_extension to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(OptionalGroup_extensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes OptionalGroup_extension from JSON.
   */
  decode: function (json) {
    return OptionalGroup_extensionJSON._readMessage(
      OptionalGroup_extensionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const RepeatedGroup_extensionJSON = {
  /**
   * Serializes RepeatedGroup_extension to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(RepeatedGroup_extensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes RepeatedGroup_extension from JSON.
   */
  decode: function (json) {
    return RepeatedGroup_extensionJSON._readMessage(
      RepeatedGroup_extensionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const TestGroupJSON = {
  /**
   * Serializes TestGroup to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestGroupJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestGroup from JSON.
   */
  decode: function (json) {
    return TestGroupJSON._readMessage(
      TestGroupJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalForeignEnum: ForeignEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestGroup.OptionalGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestGroupJSON.OptionalGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestGroup.OptionalGroup from JSON.
     */
    decode: function (json) {
      return TestGroupJSON.OptionalGroup._readMessage(
        TestGroupJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestGroupExtensionJSON = {
  /**
   * Serializes TestGroupExtension to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestGroupExtension from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestNestedExtensionJSON = {
  /**
   * Serializes TestNestedExtension to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestNestedExtension from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestNestedExtensionJSON.OptionalGroup_extension._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decode: function (json) {
      return TestNestedExtensionJSON.OptionalGroup_extension._readMessage(
        TestNestedExtensionJSON.OptionalGroup_extension.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestChildExtensionJSON = {
  /**
   * Serializes TestChildExtension to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestChildExtensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestChildExtension from JSON.
   */
  decode: function (json) {
    return TestChildExtensionJSON._readMessage(
      TestChildExtensionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: "",
      b: "",
      optionalExtension: TestAllExtensionsJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.b) {
      json["b"] = msg.b;
    }
    if (msg.optionalExtension) {
      const _optionalExtension_ = TestAllExtensionsJSON._writeMessage(
        msg.optionalExtension
      );
      if (Object.keys(_optionalExtension_).length > 0) {
        json["optionalExtension"] = _optionalExtension_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _b_ = json["b"];
    if (_b_) {
      msg.b = _b_;
    }
    const _optionalExtension_ =
      json["optionalExtension"] ?? json["optional_extension"];
    if (_optionalExtension_) {
      const m = TestAllExtensions.initialize();
      TestAllExtensionsJSON._readMessage(m, _optionalExtension_);
      msg.optionalExtension = m;
    }
    return msg;
  },
};

export const TestRequiredJSON = {
  /**
   * Serializes TestRequired to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequired from JSON.
   */
  decode: function (json) {
    return TestRequiredJSON._readMessage(
      TestRequiredJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.dummy2) {
      json["dummy2"] = msg.dummy2;
    }
    if (msg.b) {
      json["b"] = msg.b;
    }
    if (msg.dummy4) {
      json["dummy4"] = msg.dummy4;
    }
    if (msg.dummy5) {
      json["dummy5"] = msg.dummy5;
    }
    if (msg.dummy6) {
      json["dummy6"] = msg.dummy6;
    }
    if (msg.dummy7) {
      json["dummy7"] = msg.dummy7;
    }
    if (msg.dummy8) {
      json["dummy8"] = msg.dummy8;
    }
    if (msg.dummy9) {
      json["dummy9"] = msg.dummy9;
    }
    if (msg.dummy10) {
      json["dummy10"] = msg.dummy10;
    }
    if (msg.dummy11) {
      json["dummy11"] = msg.dummy11;
    }
    if (msg.dummy12) {
      json["dummy12"] = msg.dummy12;
    }
    if (msg.dummy13) {
      json["dummy13"] = msg.dummy13;
    }
    if (msg.dummy14) {
      json["dummy14"] = msg.dummy14;
    }
    if (msg.dummy15) {
      json["dummy15"] = msg.dummy15;
    }
    if (msg.dummy16) {
      json["dummy16"] = msg.dummy16;
    }
    if (msg.dummy17) {
      json["dummy17"] = msg.dummy17;
    }
    if (msg.dummy18) {
      json["dummy18"] = msg.dummy18;
    }
    if (msg.dummy19) {
      json["dummy19"] = msg.dummy19;
    }
    if (msg.dummy20) {
      json["dummy20"] = msg.dummy20;
    }
    if (msg.dummy21) {
      json["dummy21"] = msg.dummy21;
    }
    if (msg.dummy22) {
      json["dummy22"] = msg.dummy22;
    }
    if (msg.dummy23) {
      json["dummy23"] = msg.dummy23;
    }
    if (msg.dummy24) {
      json["dummy24"] = msg.dummy24;
    }
    if (msg.dummy25) {
      json["dummy25"] = msg.dummy25;
    }
    if (msg.dummy26) {
      json["dummy26"] = msg.dummy26;
    }
    if (msg.dummy27) {
      json["dummy27"] = msg.dummy27;
    }
    if (msg.dummy28) {
      json["dummy28"] = msg.dummy28;
    }
    if (msg.dummy29) {
      json["dummy29"] = msg.dummy29;
    }
    if (msg.dummy30) {
      json["dummy30"] = msg.dummy30;
    }
    if (msg.dummy31) {
      json["dummy31"] = msg.dummy31;
    }
    if (msg.dummy32) {
      json["dummy32"] = msg.dummy32;
    }
    if (msg.c) {
      json["c"] = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _dummy2_ = json["dummy2"];
    if (_dummy2_) {
      msg.dummy2 = _dummy2_;
    }
    const _b_ = json["b"];
    if (_b_) {
      msg.b = _b_;
    }
    const _dummy4_ = json["dummy4"];
    if (_dummy4_) {
      msg.dummy4 = _dummy4_;
    }
    const _dummy5_ = json["dummy5"];
    if (_dummy5_) {
      msg.dummy5 = _dummy5_;
    }
    const _dummy6_ = json["dummy6"];
    if (_dummy6_) {
      msg.dummy6 = _dummy6_;
    }
    const _dummy7_ = json["dummy7"];
    if (_dummy7_) {
      msg.dummy7 = _dummy7_;
    }
    const _dummy8_ = json["dummy8"];
    if (_dummy8_) {
      msg.dummy8 = _dummy8_;
    }
    const _dummy9_ = json["dummy9"];
    if (_dummy9_) {
      msg.dummy9 = _dummy9_;
    }
    const _dummy10_ = json["dummy10"];
    if (_dummy10_) {
      msg.dummy10 = _dummy10_;
    }
    const _dummy11_ = json["dummy11"];
    if (_dummy11_) {
      msg.dummy11 = _dummy11_;
    }
    const _dummy12_ = json["dummy12"];
    if (_dummy12_) {
      msg.dummy12 = _dummy12_;
    }
    const _dummy13_ = json["dummy13"];
    if (_dummy13_) {
      msg.dummy13 = _dummy13_;
    }
    const _dummy14_ = json["dummy14"];
    if (_dummy14_) {
      msg.dummy14 = _dummy14_;
    }
    const _dummy15_ = json["dummy15"];
    if (_dummy15_) {
      msg.dummy15 = _dummy15_;
    }
    const _dummy16_ = json["dummy16"];
    if (_dummy16_) {
      msg.dummy16 = _dummy16_;
    }
    const _dummy17_ = json["dummy17"];
    if (_dummy17_) {
      msg.dummy17 = _dummy17_;
    }
    const _dummy18_ = json["dummy18"];
    if (_dummy18_) {
      msg.dummy18 = _dummy18_;
    }
    const _dummy19_ = json["dummy19"];
    if (_dummy19_) {
      msg.dummy19 = _dummy19_;
    }
    const _dummy20_ = json["dummy20"];
    if (_dummy20_) {
      msg.dummy20 = _dummy20_;
    }
    const _dummy21_ = json["dummy21"];
    if (_dummy21_) {
      msg.dummy21 = _dummy21_;
    }
    const _dummy22_ = json["dummy22"];
    if (_dummy22_) {
      msg.dummy22 = _dummy22_;
    }
    const _dummy23_ = json["dummy23"];
    if (_dummy23_) {
      msg.dummy23 = _dummy23_;
    }
    const _dummy24_ = json["dummy24"];
    if (_dummy24_) {
      msg.dummy24 = _dummy24_;
    }
    const _dummy25_ = json["dummy25"];
    if (_dummy25_) {
      msg.dummy25 = _dummy25_;
    }
    const _dummy26_ = json["dummy26"];
    if (_dummy26_) {
      msg.dummy26 = _dummy26_;
    }
    const _dummy27_ = json["dummy27"];
    if (_dummy27_) {
      msg.dummy27 = _dummy27_;
    }
    const _dummy28_ = json["dummy28"];
    if (_dummy28_) {
      msg.dummy28 = _dummy28_;
    }
    const _dummy29_ = json["dummy29"];
    if (_dummy29_) {
      msg.dummy29 = _dummy29_;
    }
    const _dummy30_ = json["dummy30"];
    if (_dummy30_) {
      msg.dummy30 = _dummy30_;
    }
    const _dummy31_ = json["dummy31"];
    if (_dummy31_) {
      msg.dummy31 = _dummy31_;
    }
    const _dummy32_ = json["dummy32"];
    if (_dummy32_) {
      msg.dummy32 = _dummy32_;
    }
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    return msg;
  },
};

export const TestRequiredForeignJSON = {
  /**
   * Serializes TestRequiredForeign to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredForeignJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredForeign from JSON.
   */
  decode: function (json) {
    return TestRequiredForeignJSON._readMessage(
      TestRequiredForeignJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequiredJSON.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const _optionalMessage_ = TestRequiredJSON._writeMessage(
        msg.optionalMessage
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.repeatedMessage?.length) {
      json["repeatedMessage"] = msg.repeatedMessage.map(
        TestRequiredJSON._writeMessage
      );
    }
    if (msg.dummy) {
      json["dummy"] = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      const m = TestRequired.initialize();
      TestRequiredJSON._readMessage(m, _optionalMessage_);
      msg.optionalMessage = m;
    }
    const _repeatedMessage_ =
      json["repeatedMessage"] ?? json["repeated_message"];
    if (_repeatedMessage_) {
      for (const item of _repeatedMessage_) {
        const m = TestRequired.initialize();
        TestRequiredJSON._readMessage(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _dummy_ = json["dummy"];
    if (_dummy_) {
      msg.dummy = _dummy_;
    }
    return msg;
  },
};

export const TestRequiredMessageJSON = {
  /**
   * Serializes TestRequiredMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredMessage from JSON.
   */
  decode: function (json) {
    return TestRequiredMessageJSON._readMessage(
      TestRequiredMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequiredJSON.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequiredJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const _optionalMessage_ = TestRequiredJSON._writeMessage(
        msg.optionalMessage
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.repeatedMessage?.length) {
      json["repeatedMessage"] = msg.repeatedMessage.map(
        TestRequiredJSON._writeMessage
      );
    }
    if (msg.requiredMessage) {
      const _requiredMessage_ = TestRequiredJSON._writeMessage(
        msg.requiredMessage
      );
      if (Object.keys(_requiredMessage_).length > 0) {
        json["requiredMessage"] = _requiredMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      const m = TestRequired.initialize();
      TestRequiredJSON._readMessage(m, _optionalMessage_);
      msg.optionalMessage = m;
    }
    const _repeatedMessage_ =
      json["repeatedMessage"] ?? json["repeated_message"];
    if (_repeatedMessage_) {
      for (const item of _repeatedMessage_) {
        const m = TestRequired.initialize();
        TestRequiredJSON._readMessage(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _requiredMessage_ =
      json["requiredMessage"] ?? json["required_message"];
    if (_requiredMessage_) {
      const m = TestRequired.initialize();
      TestRequiredJSON._readMessage(m, _requiredMessage_);
      msg.requiredMessage = m;
    }
    return msg;
  },
};

export const TestForeignNestedJSON = {
  /**
   * Serializes TestForeignNested to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestForeignNestedJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestForeignNested from JSON.
   */
  decode: function (json) {
    return TestForeignNestedJSON._readMessage(
      TestForeignNestedJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreignNested: TestAllTypesJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.foreignNested) {
      const _foreignNested_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.foreignNested
      );
      if (Object.keys(_foreignNested_).length > 0) {
        json["foreignNested"] = _foreignNested_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _foreignNested_ = json["foreignNested"] ?? json["foreign_nested"];
    if (_foreignNested_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _foreignNested_);
      msg.foreignNested = m;
    }
    return msg;
  },
};

export const TestEmptyMessageJSON = {
  /**
   * Serializes TestEmptyMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestEmptyMessageWithExtensionsJSON = {
  /**
   * Serializes TestEmptyMessageWithExtensions to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessageWithExtensions from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestPickleNestedMessageJSON = {
  /**
   * Serializes TestPickleNestedMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestPickleNestedMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestPickleNestedMessage.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestPickleNestedMessageJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestPickleNestedMessage.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestPickleNestedMessageJSON.NestedMessage._readMessage(
        TestPickleNestedMessageJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encode: function (msg) {
        return JSON.stringify(
          TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage._writeMessage(
            msg
          )
        );
      },

      /**
       * Deserializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decode: function (json) {
        return TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg) {
        const json = {};
        if (msg.cc) {
          json["cc"] = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, json) {
        const _cc_ = json["cc"];
        if (_cc_) {
          msg.cc = _cc_;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRangesJSON = {
  /**
   * Serializes TestMultipleExtensionRanges to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestMultipleExtensionRanges from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestReallyLargeTagNumberJSON = {
  /**
   * Serializes TestReallyLargeTagNumber to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestReallyLargeTagNumberJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestReallyLargeTagNumber from JSON.
   */
  decode: function (json) {
    return TestReallyLargeTagNumberJSON._readMessage(
      TestReallyLargeTagNumberJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.bb) {
      json["bb"] = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _bb_ = json["bb"];
    if (_bb_) {
      msg.bb = _bb_;
    }
    return msg;
  },
};

export const TestRecursiveMessageJSON = {
  /**
   * Serializes TestRecursiveMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRecursiveMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRecursiveMessage from JSON.
   */
  decode: function (json) {
    return TestRecursiveMessageJSON._readMessage(
      TestRecursiveMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestRecursiveMessageJSON.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      const _a_ = TestRecursiveMessageJSON._writeMessage(msg.a);
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    if (msg.i) {
      json["i"] = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      const m = TestRecursiveMessage.initialize();
      TestRecursiveMessageJSON._readMessage(m, _a_);
      msg.a = m;
    }
    const _i_ = json["i"];
    if (_i_) {
      msg.i = _i_;
    }
    return msg;
  },
};

export const TestMutualRecursionAJSON = {
  /**
   * Serializes TestMutualRecursionA to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMutualRecursionAJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMutualRecursionA from JSON.
   */
  decode: function (json) {
    return TestMutualRecursionAJSON._readMessage(
      TestMutualRecursionAJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionBJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.bb) {
      const _bb_ = TestMutualRecursionBJSON._writeMessage(msg.bb);
      if (Object.keys(_bb_).length > 0) {
        json["bb"] = _bb_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _bb_ = json["bb"];
    if (_bb_) {
      const m = TestMutualRecursionB.initialize();
      TestMutualRecursionBJSON._readMessage(m, _bb_);
      msg.bb = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestMutualRecursionA.SubMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestMutualRecursionAJSON.SubMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestMutualRecursionA.SubMessage from JSON.
     */
    decode: function (json) {
      return TestMutualRecursionAJSON.SubMessage._readMessage(
        TestMutualRecursionAJSON.SubMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionBJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.b) {
        const _b_ = TestMutualRecursionBJSON._writeMessage(msg.b);
        if (Object.keys(_b_).length > 0) {
          json["b"] = _b_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _b_ = json["b"];
      if (_b_) {
        const m = TestMutualRecursionB.initialize();
        TestMutualRecursionBJSON._readMessage(m, _b_);
        msg.b = m;
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes TestMutualRecursionA.SubGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestMutualRecursionAJSON.SubGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestMutualRecursionA.SubGroup from JSON.
     */
    decode: function (json) {
      return TestMutualRecursionAJSON.SubGroup._readMessage(
        TestMutualRecursionAJSON.SubGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        subMessage: TestMutualRecursionAJSON.SubMessage.initialize(),
        notInThisScc: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.subMessage) {
        const _subMessage_ = TestMutualRecursionAJSON.SubMessage._writeMessage(
          msg.subMessage
        );
        if (Object.keys(_subMessage_).length > 0) {
          json["subMessage"] = _subMessage_;
        }
      }
      if (msg.notInThisScc) {
        const _notInThisScc_ = TestAllTypesJSON._writeMessage(msg.notInThisScc);
        if (Object.keys(_notInThisScc_).length > 0) {
          json["notInThisScc"] = _notInThisScc_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _subMessage_ = json["subMessage"] ?? json["sub_message"];
      if (_subMessage_) {
        const m = TestMutualRecursionA.SubMessage.initialize();
        TestMutualRecursionAJSON.SubMessage._readMessage(m, _subMessage_);
        msg.subMessage = m;
      }
      const _notInThisScc_ = json["notInThisScc"] ?? json["not_in_this_scc"];
      if (_notInThisScc_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, _notInThisScc_);
        msg.notInThisScc = m;
      }
      return msg;
    },
  },
};

export const TestMutualRecursionBJSON = {
  /**
   * Serializes TestMutualRecursionB to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMutualRecursionBJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMutualRecursionB from JSON.
   */
  decode: function (json) {
    return TestMutualRecursionBJSON._readMessage(
      TestMutualRecursionBJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionAJSON.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      const _a_ = TestMutualRecursionAJSON._writeMessage(msg.a);
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      const m = TestMutualRecursionA.initialize();
      TestMutualRecursionAJSON._readMessage(m, _a_);
      msg.a = m;
    }
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    return msg;
  },
};

export const TestIsInitializedJSON = {
  /**
   * Serializes TestIsInitialized to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestIsInitializedJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestIsInitialized from JSON.
   */
  decode: function (json) {
    return TestIsInitializedJSON._readMessage(
      TestIsInitializedJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestIsInitializedJSON.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const _subMessage_ = TestIsInitializedJSON.SubMessage._writeMessage(
        msg.subMessage
      );
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      const m = TestIsInitialized.SubMessage.initialize();
      TestIsInitializedJSON.SubMessage._readMessage(m, _subMessage_);
      msg.subMessage = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestIsInitialized.SubMessage to JSON.
     */
    encode: function (_msg) {
      return "{}";
    },

    /**
     * Deserializes TestIsInitialized.SubMessage from JSON.
     */
    decode: function (_json) {
      return {};
    },

    /**
     * Initializes TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (_msg) {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (msg, _json) {
      return msg;
    },

    SubGroup: {
      /**
       * Serializes TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encode: function (msg) {
        return JSON.stringify(
          TestIsInitializedJSON.SubMessage.SubGroup._writeMessage(msg)
        );
      },

      /**
       * Deserializes TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decode: function (json) {
        return TestIsInitializedJSON.SubMessage.SubGroup._readMessage(
          TestIsInitializedJSON.SubMessage.SubGroup.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg) {
        const json = {};
        if (msg.i) {
          json["i"] = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, json) {
        const _i_ = json["i"];
        if (_i_) {
          msg.i = _i_;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumberJSON = {
  /**
   * Serializes TestDupFieldNumber to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestDupFieldNumberJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDupFieldNumber from JSON.
   */
  decode: function (json) {
    return TestDupFieldNumberJSON._readMessage(
      TestDupFieldNumberJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes TestDupFieldNumber.Foo to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestDupFieldNumberJSON.Foo._writeMessage(msg));
    },

    /**
     * Deserializes TestDupFieldNumber.Foo from JSON.
     */
    decode: function (json) {
      return TestDupFieldNumberJSON.Foo._readMessage(
        TestDupFieldNumberJSON.Foo.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes TestDupFieldNumber.Bar to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestDupFieldNumberJSON.Bar._writeMessage(msg));
    },

    /**
     * Deserializes TestDupFieldNumber.Bar from JSON.
     */
    decode: function (json) {
      return TestDupFieldNumberJSON.Bar._readMessage(
        TestDupFieldNumberJSON.Bar.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestEagerMessageJSON = {
  /**
   * Serializes TestEagerMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestEagerMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestEagerMessage from JSON.
   */
  decode: function (json) {
    return TestEagerMessageJSON._readMessage(
      TestEagerMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const _subMessage_ = TestAllTypesJSON._writeMessage(msg.subMessage);
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _subMessage_);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestLazyMessageJSON = {
  /**
   * Serializes TestLazyMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestLazyMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestLazyMessage from JSON.
   */
  decode: function (json) {
    return TestLazyMessageJSON._readMessage(
      TestLazyMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const _subMessage_ = TestAllTypesJSON._writeMessage(msg.subMessage);
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _subMessage_);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestNestedMessageHasBitsJSON = {
  /**
   * Serializes TestNestedMessageHasBits to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestNestedMessageHasBitsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestNestedMessageHasBits from JSON.
   */
  decode: function (json) {
    return TestNestedMessageHasBitsJSON._readMessage(
      TestNestedMessageHasBitsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBitsJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestNestedMessageHasBitsJSON.NestedMessage._writeMessage(
          msg.optionalNestedMessage
        );
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestNestedMessageHasBits.NestedMessage.initialize();
      TestNestedMessageHasBitsJSON.NestedMessage._readMessage(
        m,
        _optionalNestedMessage_
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestNestedMessageHasBitsJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestNestedMessageHasBitsJSON.NestedMessage._readMessage(
        TestNestedMessageHasBitsJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json["nestedmessageRepeatedInt32"] = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json["nestedmessageRepeatedForeignmessage"] =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessageJSON._writeMessage
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _nestedmessageRepeatedInt32_ =
        json["nestedmessageRepeatedInt32"] ??
        json["nestedmessage_repeated_int32"];
      if (_nestedmessageRepeatedInt32_) {
        msg.nestedmessageRepeatedInt32 = _nestedmessageRepeatedInt32_;
      }
      const _nestedmessageRepeatedForeignmessage_ =
        json["nestedmessageRepeatedForeignmessage"] ??
        json["nestedmessage_repeated_foreignmessage"];
      if (_nestedmessageRepeatedForeignmessage_) {
        for (const item of _nestedmessageRepeatedForeignmessage_) {
          const m = ForeignMessage.initialize();
          ForeignMessageJSON._readMessage(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNamesJSON = {
  /**
   * Serializes TestCamelCaseFieldNames to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestCamelCaseFieldNamesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestCamelCaseFieldNames from JSON.
   */
  decode: function (json) {
    return TestCamelCaseFieldNamesJSON._readMessage(
      TestCamelCaseFieldNamesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: "",
      EnumField: ForeignEnum._fromInt(0),
      MessageField: ForeignMessageJSON.initialize(),
      StringPieceField: "",
      CordField: "",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.PrimitiveField) {
      json["PrimitiveField"] = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json["StringField"] = msg.StringField;
    }
    if (msg.EnumField && ForeignEnumJSON._toInt(msg.EnumField)) {
      json["EnumField"] = msg.EnumField;
    }
    if (msg.MessageField) {
      const _MessageField_ = ForeignMessageJSON._writeMessage(msg.MessageField);
      if (Object.keys(_MessageField_).length > 0) {
        json["MessageField"] = _MessageField_;
      }
    }
    if (msg.StringPieceField) {
      json["StringPieceField"] = msg.StringPieceField;
    }
    if (msg.CordField) {
      json["CordField"] = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json["RepeatedPrimitiveField"] = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json["RepeatedStringField"] = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json["RepeatedEnumField"] = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json["RepeatedMessageField"] = msg.RepeatedMessageField.map(
        ForeignMessageJSON._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json["RepeatedStringPieceField"] = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json["RepeatedCordField"] = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _PrimitiveField_ = json["PrimitiveField"];
    if (_PrimitiveField_) {
      msg.PrimitiveField = _PrimitiveField_;
    }
    const _StringField_ = json["StringField"];
    if (_StringField_) {
      msg.StringField = _StringField_;
    }
    const _EnumField_ = json["EnumField"];
    if (_EnumField_) {
      msg.EnumField = _EnumField_;
    }
    const _MessageField_ = json["MessageField"];
    if (_MessageField_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _MessageField_);
      msg.MessageField = m;
    }
    const _StringPieceField_ = json["StringPieceField"];
    if (_StringPieceField_) {
      msg.StringPieceField = _StringPieceField_;
    }
    const _CordField_ = json["CordField"];
    if (_CordField_) {
      msg.CordField = _CordField_;
    }
    const _RepeatedPrimitiveField_ = json["RepeatedPrimitiveField"];
    if (_RepeatedPrimitiveField_) {
      msg.RepeatedPrimitiveField = _RepeatedPrimitiveField_;
    }
    const _RepeatedStringField_ = json["RepeatedStringField"];
    if (_RepeatedStringField_) {
      msg.RepeatedStringField = _RepeatedStringField_;
    }
    const _RepeatedEnumField_ = json["RepeatedEnumField"];
    if (_RepeatedEnumField_) {
      msg.RepeatedEnumField = _RepeatedEnumField_;
    }
    const _RepeatedMessageField_ = json["RepeatedMessageField"];
    if (_RepeatedMessageField_) {
      for (const item of _RepeatedMessageField_) {
        const m = ForeignMessage.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const _RepeatedStringPieceField_ = json["RepeatedStringPieceField"];
    if (_RepeatedStringPieceField_) {
      msg.RepeatedStringPieceField = _RepeatedStringPieceField_;
    }
    const _RepeatedCordField_ = json["RepeatedCordField"];
    if (_RepeatedCordField_) {
      msg.RepeatedCordField = _RepeatedCordField_;
    }
    return msg;
  },
};

export const TestFieldOrderingsJSON = {
  /**
   * Serializes TestFieldOrderings to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestFieldOrderingsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestFieldOrderings from JSON.
   */
  decode: function (json) {
    return TestFieldOrderingsJSON._readMessage(
      TestFieldOrderingsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderingsJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    if (msg.myInt) {
      json["myInt"] = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json["myFloat"] = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestFieldOrderingsJSON.NestedMessage._writeMessage(
          msg.optionalNestedMessage
        );
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    const _myInt_ = json["myInt"] ?? json["my_int"];
    if (_myInt_) {
      msg.myInt = BigInt(_myInt_);
    }
    const _myFloat_ = json["myFloat"] ?? json["my_float"];
    if (_myFloat_) {
      msg.myFloat = _myFloat_;
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestFieldOrderings.NestedMessage.initialize();
      TestFieldOrderingsJSON.NestedMessage._readMessage(
        m,
        _optionalNestedMessage_
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestFieldOrderings.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestFieldOrderingsJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestFieldOrderings.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestFieldOrderingsJSON.NestedMessage._readMessage(
        TestFieldOrderingsJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.oo) {
        json["oo"] = msg.oo.toString();
      }
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _oo_ = json["oo"];
      if (_oo_) {
        msg.oo = BigInt(_oo_);
      }
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1JSON = {
  /**
   * Serializes TestExtensionOrderings1 to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtensionOrderings1JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionOrderings1 from JSON.
   */
  decode: function (json) {
    return TestExtensionOrderings1JSON._readMessage(
      TestExtensionOrderings1JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    return msg;
  },
};

export const TestExtensionOrderings2JSON = {
  /**
   * Serializes TestExtensionOrderings2 to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtensionOrderings2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionOrderings2 from JSON.
   */
  decode: function (json) {
    return TestExtensionOrderings2JSON._readMessage(
      TestExtensionOrderings2JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestExtensionOrderings2JSON.TestExtensionOrderings3._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decode: function (json) {
      return TestExtensionOrderings2JSON.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2JSON.TestExtensionOrderings3.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        myString: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.myString) {
        json["myString"] = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _myString_ = json["myString"] ?? json["my_string"];
      if (_myString_) {
        msg.myString = _myString_;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValuesJSON = {
  /**
   * Serializes TestExtremeDefaultValues to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtremeDefaultValuesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtremeDefaultValues from JSON.
   */
  decode: function (json) {
    return TestExtremeDefaultValuesJSON._readMessage(
      TestExtremeDefaultValuesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: "",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: "",
      stringWithZero: "",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: "",
      cordWithZero: "",
      replacementString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.escapedBytes?.length) {
      json["escapedBytes"] = encodeBase64Bytes(msg.escapedBytes);
    }
    if (msg.largeUint32) {
      json["largeUint32"] = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json["largeUint64"] = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json["smallInt32"] = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json["smallInt64"] = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json["reallySmallInt32"] = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json["reallySmallInt64"] = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json["utf8String"] = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json["zeroFloat"] = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json["oneFloat"] = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json["smallFloat"] = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json["negativeOneFloat"] = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json["negativeFloat"] = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json["largeFloat"] = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json["smallNegativeFloat"] = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json["infDouble"] = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json["negInfDouble"] = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json["nanDouble"] = msg.nanDouble;
    }
    if (msg.infFloat) {
      json["infFloat"] = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json["negInfFloat"] = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json["nanFloat"] = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json["cppTrigraph"] = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json["stringWithZero"] = msg.stringWithZero;
    }
    if (msg.bytesWithZero?.length) {
      json["bytesWithZero"] = encodeBase64Bytes(msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      json["stringPieceWithZero"] = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json["cordWithZero"] = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json["replacementString"] = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _escapedBytes_ = json["escapedBytes"] ?? json["escaped_bytes"];
    if (_escapedBytes_) {
      msg.escapedBytes = decodeBase64Bytes(_escapedBytes_);
    }
    const _largeUint32_ = json["largeUint32"] ?? json["large_uint32"];
    if (_largeUint32_) {
      msg.largeUint32 = _largeUint32_;
    }
    const _largeUint64_ = json["largeUint64"] ?? json["large_uint64"];
    if (_largeUint64_) {
      msg.largeUint64 = BigInt(_largeUint64_);
    }
    const _smallInt32_ = json["smallInt32"] ?? json["small_int32"];
    if (_smallInt32_) {
      msg.smallInt32 = _smallInt32_;
    }
    const _smallInt64_ = json["smallInt64"] ?? json["small_int64"];
    if (_smallInt64_) {
      msg.smallInt64 = BigInt(_smallInt64_);
    }
    const _reallySmallInt32_ =
      json["reallySmallInt32"] ?? json["really_small_int32"];
    if (_reallySmallInt32_) {
      msg.reallySmallInt32 = _reallySmallInt32_;
    }
    const _reallySmallInt64_ =
      json["reallySmallInt64"] ?? json["really_small_int64"];
    if (_reallySmallInt64_) {
      msg.reallySmallInt64 = BigInt(_reallySmallInt64_);
    }
    const _utf8String_ = json["utf8String"] ?? json["utf8_string"];
    if (_utf8String_) {
      msg.utf8String = _utf8String_;
    }
    const _zeroFloat_ = json["zeroFloat"] ?? json["zero_float"];
    if (_zeroFloat_) {
      msg.zeroFloat = _zeroFloat_;
    }
    const _oneFloat_ = json["oneFloat"] ?? json["one_float"];
    if (_oneFloat_) {
      msg.oneFloat = _oneFloat_;
    }
    const _smallFloat_ = json["smallFloat"] ?? json["small_float"];
    if (_smallFloat_) {
      msg.smallFloat = _smallFloat_;
    }
    const _negativeOneFloat_ =
      json["negativeOneFloat"] ?? json["negative_one_float"];
    if (_negativeOneFloat_) {
      msg.negativeOneFloat = _negativeOneFloat_;
    }
    const _negativeFloat_ = json["negativeFloat"] ?? json["negative_float"];
    if (_negativeFloat_) {
      msg.negativeFloat = _negativeFloat_;
    }
    const _largeFloat_ = json["largeFloat"] ?? json["large_float"];
    if (_largeFloat_) {
      msg.largeFloat = _largeFloat_;
    }
    const _smallNegativeFloat_ =
      json["smallNegativeFloat"] ?? json["small_negative_float"];
    if (_smallNegativeFloat_) {
      msg.smallNegativeFloat = _smallNegativeFloat_;
    }
    const _infDouble_ = json["infDouble"] ?? json["inf_double"];
    if (_infDouble_) {
      msg.infDouble = _infDouble_;
    }
    const _negInfDouble_ = json["negInfDouble"] ?? json["neg_inf_double"];
    if (_negInfDouble_) {
      msg.negInfDouble = _negInfDouble_;
    }
    const _nanDouble_ = json["nanDouble"] ?? json["nan_double"];
    if (_nanDouble_) {
      msg.nanDouble = _nanDouble_;
    }
    const _infFloat_ = json["infFloat"] ?? json["inf_float"];
    if (_infFloat_) {
      msg.infFloat = _infFloat_;
    }
    const _negInfFloat_ = json["negInfFloat"] ?? json["neg_inf_float"];
    if (_negInfFloat_) {
      msg.negInfFloat = _negInfFloat_;
    }
    const _nanFloat_ = json["nanFloat"] ?? json["nan_float"];
    if (_nanFloat_) {
      msg.nanFloat = _nanFloat_;
    }
    const _cppTrigraph_ = json["cppTrigraph"] ?? json["cpp_trigraph"];
    if (_cppTrigraph_) {
      msg.cppTrigraph = _cppTrigraph_;
    }
    const _stringWithZero_ = json["stringWithZero"] ?? json["string_with_zero"];
    if (_stringWithZero_) {
      msg.stringWithZero = _stringWithZero_;
    }
    const _bytesWithZero_ = json["bytesWithZero"] ?? json["bytes_with_zero"];
    if (_bytesWithZero_) {
      msg.bytesWithZero = decodeBase64Bytes(_bytesWithZero_);
    }
    const _stringPieceWithZero_ =
      json["stringPieceWithZero"] ?? json["string_piece_with_zero"];
    if (_stringPieceWithZero_) {
      msg.stringPieceWithZero = _stringPieceWithZero_;
    }
    const _cordWithZero_ = json["cordWithZero"] ?? json["cord_with_zero"];
    if (_cordWithZero_) {
      msg.cordWithZero = _cordWithZero_;
    }
    const _replacementString_ =
      json["replacementString"] ?? json["replacement_string"];
    if (_replacementString_) {
      msg.replacementString = _replacementString_;
    }
    return msg;
  },
};

export const SparseEnumMessageJSON = {
  /**
   * Serializes SparseEnumMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(SparseEnumMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes SparseEnumMessage from JSON.
   */
  decode: function (json) {
    return SparseEnumMessageJSON._readMessage(
      SparseEnumMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparseEnum: TestSparseEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.sparseEnum && TestSparseEnumJSON._toInt(msg.sparseEnum)) {
      json["sparseEnum"] = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _sparseEnum_ = json["sparseEnum"] ?? json["sparse_enum"];
    if (_sparseEnum_) {
      msg.sparseEnum = _sparseEnum_;
    }
    return msg;
  },
};

export const OneStringJSON = {
  /**
   * Serializes OneString to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(OneStringJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneString from JSON.
   */
  decode: function (json) {
    return OneStringJSON._readMessage(
      OneStringJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const MoreStringJSON = {
  /**
   * Serializes MoreString to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(MoreStringJSON._writeMessage(msg));
  },

  /**
   * Deserializes MoreString from JSON.
   */
  decode: function (json) {
    return MoreStringJSON._readMessage(
      MoreStringJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const OneBytesJSON = {
  /**
   * Serializes OneBytes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(OneBytesJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneBytes from JSON.
   */
  decode: function (json) {
    return OneBytesJSON._readMessage(
      OneBytesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json["data"] = encodeBase64Bytes(msg.data);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = decodeBase64Bytes(_data_);
    }
    return msg;
  },
};

export const MoreBytesJSON = {
  /**
   * Serializes MoreBytes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(MoreBytesJSON._writeMessage(msg));
  },

  /**
   * Deserializes MoreBytes from JSON.
   */
  decode: function (json) {
    return MoreBytesJSON._readMessage(
      MoreBytesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json["data"] = msg.data.map(encodeBase64Bytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_.map(decodeBase64Bytes);
    }
    return msg;
  },
};

export const Int32MessageJSON = {
  /**
   * Serializes Int32Message to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(Int32MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Int32Message from JSON.
   */
  decode: function (json) {
    return Int32MessageJSON._readMessage(
      Int32MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const Uint32MessageJSON = {
  /**
   * Serializes Uint32Message to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(Uint32MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Uint32Message from JSON.
   */
  decode: function (json) {
    return Uint32MessageJSON._readMessage(
      Uint32MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const Int64MessageJSON = {
  /**
   * Serializes Int64Message to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(Int64MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Int64Message from JSON.
   */
  decode: function (json) {
    return Int64MessageJSON._readMessage(
      Int64MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = BigInt(_data_);
    }
    return msg;
  },
};

export const Uint64MessageJSON = {
  /**
   * Serializes Uint64Message to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(Uint64MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Uint64Message from JSON.
   */
  decode: function (json) {
    return Uint64MessageJSON._readMessage(
      Uint64MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = BigInt(_data_);
    }
    return msg;
  },
};

export const BoolMessageJSON = {
  /**
   * Serializes BoolMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(BoolMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes BoolMessage from JSON.
   */
  decode: function (json) {
    return BoolMessageJSON._readMessage(
      BoolMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const TestOneofJSON = {
  /**
   * Serializes TestOneof to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestOneofJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof from JSON.
   */
  decode: function (json) {
    return TestOneofJSON._readMessage(
      TestOneofJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestAllTypesJSON._writeMessage(msg.fooMessage);
      json["fooMessage"] = _fooMessage_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneof.FooGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestOneofJSON.FooGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof.FooGroup from JSON.
     */
    decode: function (json) {
      return TestOneofJSON.FooGroup._readMessage(
        TestOneofJSON.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatibleJSON = {
  /**
   * Serializes TestOneofBackwardsCompatible to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestOneofBackwardsCompatibleJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneofBackwardsCompatible from JSON.
   */
  decode: function (json) {
    return TestOneofBackwardsCompatibleJSON._readMessage(
      TestOneofBackwardsCompatibleJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: 0,
      fooString: "",
      fooMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooInt) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage) {
      const _fooMessage_ = TestAllTypesJSON._writeMessage(msg.fooMessage);
      if (Object.keys(_fooMessage_).length > 0) {
        json["fooMessage"] = _fooMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestOneofBackwardsCompatibleJSON.FooGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decode: function (json) {
      return TestOneofBackwardsCompatibleJSON.FooGroup._readMessage(
        TestOneofBackwardsCompatibleJSON.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },
};

export const TestOneof2JSON = {
  /**
   * Serializes TestOneof2 to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestOneof2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof2 from JSON.
   */
  decode: function (json) {
    return TestOneof2JSON._readMessage(
      TestOneof2JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooCord: undefined,
      fooStringPiece: undefined,
      fooBytes: undefined,
      fooEnum: undefined,
      fooMessage: undefined,
      fooLazyMessage: undefined,
      barInt: undefined,
      barString: undefined,
      barCord: undefined,
      barStringPiece: undefined,
      barBytes: undefined,
      barEnum: undefined,
      barStringWithEmptyDefault: undefined,
      barCordWithEmptyDefault: undefined,
      barStringPieceWithEmptyDefault: undefined,
      barBytesWithEmptyDefault: undefined,
      bazInt: 0,
      bazString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json["fooCord"] = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json["fooStringPiece"] = msg.fooStringPiece;
    }
    if (msg.fooBytes?.length) {
      json["fooBytes"] = encodeBase64Bytes(msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      json["fooEnum"] = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestOneof2JSON.NestedMessage._writeMessage(
        msg.fooMessage
      );
      json["fooMessage"] = _fooMessage_;
    }
    if (msg.fooLazyMessage != undefined) {
      const _fooLazyMessage_ = TestOneof2JSON.NestedMessage._writeMessage(
        msg.fooLazyMessage
      );
      json["fooLazyMessage"] = _fooLazyMessage_;
    }
    if (msg.barInt != undefined) {
      json["barInt"] = msg.barInt;
    }
    if (msg.barString != undefined) {
      json["barString"] = msg.barString;
    }
    if (msg.barCord != undefined) {
      json["barCord"] = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json["barStringPiece"] = msg.barStringPiece;
    }
    if (msg.barBytes?.length) {
      json["barBytes"] = encodeBase64Bytes(msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      json["barEnum"] = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json["barStringWithEmptyDefault"] = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json["barCordWithEmptyDefault"] = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json["barStringPieceWithEmptyDefault"] =
        msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      json["barBytesWithEmptyDefault"] = encodeBase64Bytes(
        msg.barBytesWithEmptyDefault
      );
    }
    if (msg.bazInt) {
      json["bazInt"] = msg.bazInt;
    }
    if (msg.bazString) {
      json["bazString"] = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooCord_ = json["fooCord"] ?? json["foo_cord"];
    if (_fooCord_) {
      msg.fooCord = _fooCord_;
    }
    const _fooStringPiece_ = json["fooStringPiece"] ?? json["foo_string_piece"];
    if (_fooStringPiece_) {
      msg.fooStringPiece = _fooStringPiece_;
    }
    const _fooBytes_ = json["fooBytes"] ?? json["foo_bytes"];
    if (_fooBytes_) {
      msg.fooBytes = decodeBase64Bytes(_fooBytes_);
    }
    const _fooEnum_ = json["fooEnum"] ?? json["foo_enum"];
    if (_fooEnum_) {
      msg.fooEnum = _fooEnum_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2JSON.NestedMessage._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    const _fooLazyMessage_ = json["fooLazyMessage"] ?? json["foo_lazy_message"];
    if (_fooLazyMessage_) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2JSON.NestedMessage._readMessage(m, _fooLazyMessage_);
      msg.fooLazyMessage = m;
    }
    const _barInt_ = json["barInt"] ?? json["bar_int"];
    if (_barInt_) {
      msg.barInt = _barInt_;
    }
    const _barString_ = json["barString"] ?? json["bar_string"];
    if (_barString_) {
      msg.barString = _barString_;
    }
    const _barCord_ = json["barCord"] ?? json["bar_cord"];
    if (_barCord_) {
      msg.barCord = _barCord_;
    }
    const _barStringPiece_ = json["barStringPiece"] ?? json["bar_string_piece"];
    if (_barStringPiece_) {
      msg.barStringPiece = _barStringPiece_;
    }
    const _barBytes_ = json["barBytes"] ?? json["bar_bytes"];
    if (_barBytes_) {
      msg.barBytes = decodeBase64Bytes(_barBytes_);
    }
    const _barEnum_ = json["barEnum"] ?? json["bar_enum"];
    if (_barEnum_) {
      msg.barEnum = _barEnum_;
    }
    const _barStringWithEmptyDefault_ =
      json["barStringWithEmptyDefault"] ??
      json["bar_string_with_empty_default"];
    if (_barStringWithEmptyDefault_) {
      msg.barStringWithEmptyDefault = _barStringWithEmptyDefault_;
    }
    const _barCordWithEmptyDefault_ =
      json["barCordWithEmptyDefault"] ?? json["bar_cord_with_empty_default"];
    if (_barCordWithEmptyDefault_) {
      msg.barCordWithEmptyDefault = _barCordWithEmptyDefault_;
    }
    const _barStringPieceWithEmptyDefault_ =
      json["barStringPieceWithEmptyDefault"] ??
      json["bar_string_piece_with_empty_default"];
    if (_barStringPieceWithEmptyDefault_) {
      msg.barStringPieceWithEmptyDefault = _barStringPieceWithEmptyDefault_;
    }
    const _barBytesWithEmptyDefault_ =
      json["barBytesWithEmptyDefault"] ?? json["bar_bytes_with_empty_default"];
    if (_barBytesWithEmptyDefault_) {
      msg.barBytesWithEmptyDefault = decodeBase64Bytes(
        _barBytesWithEmptyDefault_
      );
    }
    const _bazInt_ = json["bazInt"] ?? json["baz_int"];
    if (_bazInt_) {
      msg.bazInt = _bazInt_;
    }
    const _bazString_ = json["bazString"] ?? json["baz_string"];
    if (_bazString_) {
      msg.bazString = _bazString_;
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  FooGroup: {
    /**
     * Serializes TestOneof2.FooGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestOneof2JSON.FooGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof2.FooGroup from JSON.
     */
    decode: function (json) {
      return TestOneof2JSON.FooGroup._readMessage(
        TestOneof2JSON.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes TestOneof2.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestOneof2JSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof2.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestOneof2JSON.NestedMessage._readMessage(
        TestOneof2JSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.quxInt) {
        json["quxInt"] = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json["corgeInt"] = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _quxInt_ = json["quxInt"] ?? json["qux_int"];
      if (_quxInt_) {
        msg.quxInt = BigInt(_quxInt_);
      }
      const _corgeInt_ = json["corgeInt"] ?? json["corge_int"];
      if (_corgeInt_) {
        msg.corgeInt = _corgeInt_;
      }
      return msg;
    },
  },
};

export const TestRequiredOneofJSON = {
  /**
   * Serializes TestRequiredOneof to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredOneofJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredOneof from JSON.
   */
  decode: function (json) {
    return TestRequiredOneofJSON._readMessage(
      TestRequiredOneofJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestRequiredOneofJSON.NestedMessage._writeMessage(
        msg.fooMessage
      );
      json["fooMessage"] = _fooMessage_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestRequiredOneof.NestedMessage.initialize();
      TestRequiredOneofJSON.NestedMessage._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestRequiredOneof.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestRequiredOneofJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestRequiredOneof.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestRequiredOneofJSON.NestedMessage._readMessage(
        TestRequiredOneofJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.requiredDouble) {
        json["requiredDouble"] = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _requiredDouble_ =
        json["requiredDouble"] ?? json["required_double"];
      if (_requiredDouble_) {
        msg.requiredDouble = _requiredDouble_;
      }
      return msg;
    },
  },
};

export const TestPackedTypesJSON = {
  /**
   * Serializes TestPackedTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestPackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestPackedTypes from JSON.
   */
  decode: function (json) {
    return TestPackedTypesJSON._readMessage(
      TestPackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json["packedInt64"] = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json["packedUint32"] = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json["packedUint64"] = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json["packedSint32"] = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json["packedSint64"] = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json["packedFixed32"] = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json["packedFixed64"] = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json["packedSfixed32"] = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json["packedSfixed64"] = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json["packedFloat"] = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json["packedDouble"] = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json["packedBool"] = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json["packedEnum"] = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _packedInt64_ = json["packedInt64"] ?? json["packed_int64"];
    if (_packedInt64_) {
      msg.packedInt64 = _packedInt64_.map(BigInt);
    }
    const _packedUint32_ = json["packedUint32"] ?? json["packed_uint32"];
    if (_packedUint32_) {
      msg.packedUint32 = _packedUint32_;
    }
    const _packedUint64_ = json["packedUint64"] ?? json["packed_uint64"];
    if (_packedUint64_) {
      msg.packedUint64 = _packedUint64_.map(BigInt);
    }
    const _packedSint32_ = json["packedSint32"] ?? json["packed_sint32"];
    if (_packedSint32_) {
      msg.packedSint32 = _packedSint32_;
    }
    const _packedSint64_ = json["packedSint64"] ?? json["packed_sint64"];
    if (_packedSint64_) {
      msg.packedSint64 = _packedSint64_.map(BigInt);
    }
    const _packedFixed32_ = json["packedFixed32"] ?? json["packed_fixed32"];
    if (_packedFixed32_) {
      msg.packedFixed32 = _packedFixed32_;
    }
    const _packedFixed64_ = json["packedFixed64"] ?? json["packed_fixed64"];
    if (_packedFixed64_) {
      msg.packedFixed64 = _packedFixed64_.map(BigInt);
    }
    const _packedSfixed32_ = json["packedSfixed32"] ?? json["packed_sfixed32"];
    if (_packedSfixed32_) {
      msg.packedSfixed32 = _packedSfixed32_;
    }
    const _packedSfixed64_ = json["packedSfixed64"] ?? json["packed_sfixed64"];
    if (_packedSfixed64_) {
      msg.packedSfixed64 = _packedSfixed64_.map(BigInt);
    }
    const _packedFloat_ = json["packedFloat"] ?? json["packed_float"];
    if (_packedFloat_) {
      msg.packedFloat = _packedFloat_;
    }
    const _packedDouble_ = json["packedDouble"] ?? json["packed_double"];
    if (_packedDouble_) {
      msg.packedDouble = _packedDouble_;
    }
    const _packedBool_ = json["packedBool"] ?? json["packed_bool"];
    if (_packedBool_) {
      msg.packedBool = _packedBool_;
    }
    const _packedEnum_ = json["packedEnum"] ?? json["packed_enum"];
    if (_packedEnum_) {
      msg.packedEnum = _packedEnum_;
    }
    return msg;
  },
};

export const TestUnpackedTypesJSON = {
  /**
   * Serializes TestUnpackedTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestUnpackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestUnpackedTypes from JSON.
   */
  decode: function (json) {
    return TestUnpackedTypesJSON._readMessage(
      TestUnpackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.unpackedInt32?.length) {
      json["unpackedInt32"] = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json["unpackedInt64"] = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json["unpackedUint32"] = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json["unpackedUint64"] = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json["unpackedSint32"] = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json["unpackedSint64"] = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json["unpackedFixed32"] = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json["unpackedFixed64"] = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json["unpackedSfixed32"] = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json["unpackedSfixed64"] = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json["unpackedFloat"] = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json["unpackedDouble"] = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json["unpackedBool"] = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json["unpackedEnum"] = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _unpackedInt32_ = json["unpackedInt32"] ?? json["unpacked_int32"];
    if (_unpackedInt32_) {
      msg.unpackedInt32 = _unpackedInt32_;
    }
    const _unpackedInt64_ = json["unpackedInt64"] ?? json["unpacked_int64"];
    if (_unpackedInt64_) {
      msg.unpackedInt64 = _unpackedInt64_.map(BigInt);
    }
    const _unpackedUint32_ = json["unpackedUint32"] ?? json["unpacked_uint32"];
    if (_unpackedUint32_) {
      msg.unpackedUint32 = _unpackedUint32_;
    }
    const _unpackedUint64_ = json["unpackedUint64"] ?? json["unpacked_uint64"];
    if (_unpackedUint64_) {
      msg.unpackedUint64 = _unpackedUint64_.map(BigInt);
    }
    const _unpackedSint32_ = json["unpackedSint32"] ?? json["unpacked_sint32"];
    if (_unpackedSint32_) {
      msg.unpackedSint32 = _unpackedSint32_;
    }
    const _unpackedSint64_ = json["unpackedSint64"] ?? json["unpacked_sint64"];
    if (_unpackedSint64_) {
      msg.unpackedSint64 = _unpackedSint64_.map(BigInt);
    }
    const _unpackedFixed32_ =
      json["unpackedFixed32"] ?? json["unpacked_fixed32"];
    if (_unpackedFixed32_) {
      msg.unpackedFixed32 = _unpackedFixed32_;
    }
    const _unpackedFixed64_ =
      json["unpackedFixed64"] ?? json["unpacked_fixed64"];
    if (_unpackedFixed64_) {
      msg.unpackedFixed64 = _unpackedFixed64_.map(BigInt);
    }
    const _unpackedSfixed32_ =
      json["unpackedSfixed32"] ?? json["unpacked_sfixed32"];
    if (_unpackedSfixed32_) {
      msg.unpackedSfixed32 = _unpackedSfixed32_;
    }
    const _unpackedSfixed64_ =
      json["unpackedSfixed64"] ?? json["unpacked_sfixed64"];
    if (_unpackedSfixed64_) {
      msg.unpackedSfixed64 = _unpackedSfixed64_.map(BigInt);
    }
    const _unpackedFloat_ = json["unpackedFloat"] ?? json["unpacked_float"];
    if (_unpackedFloat_) {
      msg.unpackedFloat = _unpackedFloat_;
    }
    const _unpackedDouble_ = json["unpackedDouble"] ?? json["unpacked_double"];
    if (_unpackedDouble_) {
      msg.unpackedDouble = _unpackedDouble_;
    }
    const _unpackedBool_ = json["unpackedBool"] ?? json["unpacked_bool"];
    if (_unpackedBool_) {
      msg.unpackedBool = _unpackedBool_;
    }
    const _unpackedEnum_ = json["unpackedEnum"] ?? json["unpacked_enum"];
    if (_unpackedEnum_) {
      msg.unpackedEnum = _unpackedEnum_;
    }
    return msg;
  },
};

export const TestPackedExtensionsJSON = {
  /**
   * Serializes TestPackedExtensions to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestPackedExtensions from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestUnpackedExtensionsJSON = {
  /**
   * Serializes TestUnpackedExtensions to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestUnpackedExtensions from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestDynamicExtensionsJSON = {
  /**
   * Serializes TestDynamicExtensions to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestDynamicExtensionsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDynamicExtensions from JSON.
   */
  decode: function (json) {
    return TestDynamicExtensionsJSON._readMessage(
      TestDynamicExtensionsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnum._fromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType._fromInt(0),
      messageExtension: ForeignMessageJSON.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensionsJSON.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.scalarExtension) {
      json["scalarExtension"] = msg.scalarExtension;
    }
    if (msg.enumExtension && ForeignEnumJSON._toInt(msg.enumExtension)) {
      json["enumExtension"] = msg.enumExtension;
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensionsJSON.DynamicEnumType._toInt(msg.dynamicEnumExtension)
    ) {
      json["dynamicEnumExtension"] = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const _messageExtension_ = ForeignMessageJSON._writeMessage(
        msg.messageExtension
      );
      if (Object.keys(_messageExtension_).length > 0) {
        json["messageExtension"] = _messageExtension_;
      }
    }
    if (msg.dynamicMessageExtension) {
      const _dynamicMessageExtension_ =
        TestDynamicExtensionsJSON.DynamicMessageType._writeMessage(
          msg.dynamicMessageExtension
        );
      if (Object.keys(_dynamicMessageExtension_).length > 0) {
        json["dynamicMessageExtension"] = _dynamicMessageExtension_;
      }
    }
    if (msg.repeatedExtension?.length) {
      json["repeatedExtension"] = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json["packedExtension"] = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _scalarExtension_ =
      json["scalarExtension"] ?? json["scalar_extension"];
    if (_scalarExtension_) {
      msg.scalarExtension = _scalarExtension_;
    }
    const _enumExtension_ = json["enumExtension"] ?? json["enum_extension"];
    if (_enumExtension_) {
      msg.enumExtension = _enumExtension_;
    }
    const _dynamicEnumExtension_ =
      json["dynamicEnumExtension"] ?? json["dynamic_enum_extension"];
    if (_dynamicEnumExtension_) {
      msg.dynamicEnumExtension = _dynamicEnumExtension_;
    }
    const _messageExtension_ =
      json["messageExtension"] ?? json["message_extension"];
    if (_messageExtension_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _messageExtension_);
      msg.messageExtension = m;
    }
    const _dynamicMessageExtension_ =
      json["dynamicMessageExtension"] ?? json["dynamic_message_extension"];
    if (_dynamicMessageExtension_) {
      const m = TestDynamicExtensions.DynamicMessageType.initialize();
      TestDynamicExtensionsJSON.DynamicMessageType._readMessage(
        m,
        _dynamicMessageExtension_
      );
      msg.dynamicMessageExtension = m;
    }
    const _repeatedExtension_ =
      json["repeatedExtension"] ?? json["repeated_extension"];
    if (_repeatedExtension_) {
      msg.repeatedExtension = _repeatedExtension_;
    }
    const _packedExtension_ =
      json["packedExtension"] ?? json["packed_extension"];
    if (_packedExtension_) {
      msg.packedExtension = _packedExtension_;
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: "DYNAMIC_FOO",
    DYNAMIC_BAR: "DYNAMIC_BAR",
    DYNAMIC_BAZ: "DYNAMIC_BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 2200: {
          return "DYNAMIC_FOO";
        }
        case 2201: {
          return "DYNAMIC_BAR";
        }
        case 2202: {
          return "DYNAMIC_BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "DYNAMIC_FOO": {
          return 2200;
        }
        case "DYNAMIC_BAR": {
          return 2201;
        }
        case "DYNAMIC_BAZ": {
          return 2202;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  DynamicMessageType: {
    /**
     * Serializes TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestDynamicExtensionsJSON.DynamicMessageType._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decode: function (json) {
      return TestDynamicExtensionsJSON.DynamicMessageType._readMessage(
        TestDynamicExtensionsJSON.DynamicMessageType.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.dynamicField) {
        json["dynamicField"] = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _dynamicField_ = json["dynamicField"] ?? json["dynamic_field"];
      if (_dynamicField_) {
        msg.dynamicField = _dynamicField_;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizesJSON = {
  /**
   * Serializes TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizesJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decode: function (json) {
    return TestRepeatedScalarDifferentTagSizesJSON._readMessage(
      TestRepeatedScalarDifferentTagSizesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMergeJSON = {
  /**
   * Serializes TestParsingMerge to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestParsingMergeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestParsingMerge from JSON.
   */
  decode: function (json) {
    return TestParsingMergeJSON._readMessage(
      TestParsingMergeJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      requiredAllTypes: TestAllTypesJSON.initialize(),
      optionalAllTypes: TestAllTypesJSON.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.requiredAllTypes) {
      const _requiredAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.requiredAllTypes
      );
      if (Object.keys(_requiredAllTypes_).length > 0) {
        json["requiredAllTypes"] = _requiredAllTypes_;
      }
    }
    if (msg.optionalAllTypes) {
      const _optionalAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.optionalAllTypes
      );
      if (Object.keys(_optionalAllTypes_).length > 0) {
        json["optionalAllTypes"] = _optionalAllTypes_;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json["repeatedAllTypes"] = msg.repeatedAllTypes.map(
        TestAllTypesJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _requiredAllTypes_ =
      json["requiredAllTypes"] ?? json["required_all_types"];
    if (_requiredAllTypes_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _requiredAllTypes_);
      msg.requiredAllTypes = m;
    }
    const _optionalAllTypes_ =
      json["optionalAllTypes"] ?? json["optional_all_types"];
    if (_optionalAllTypes_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _optionalAllTypes_);
      msg.optionalAllTypes = m;
    }
    const _repeatedAllTypes_ =
      json["repeatedAllTypes"] ?? json["repeated_all_types"];
    if (_repeatedAllTypes_) {
      for (const item of _repeatedAllTypes_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestParsingMergeJSON.RepeatedFieldsGenerator._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decode: function (json) {
      return TestParsingMergeJSON.RepeatedFieldsGenerator._readMessage(
        TestParsingMergeJSON.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.field1?.length) {
        json["field1"] = msg.field1.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.field2?.length) {
        json["field2"] = msg.field2.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.field3?.length) {
        json["field3"] = msg.field3.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.ext1?.length) {
        json["ext1"] = msg.ext1.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.ext2?.length) {
        json["ext2"] = msg.ext2.map(TestAllTypesJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _field1_ = json["field1"];
      if (_field1_) {
        for (const item of _field1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field1.push(m);
        }
      }
      const _field2_ = json["field2"];
      if (_field2_) {
        for (const item of _field2_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field2.push(m);
        }
      }
      const _field3_ = json["field3"];
      if (_field3_) {
        for (const item of _field3_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field3.push(m);
        }
      }
      const _ext1_ = json["ext1"];
      if (_ext1_) {
        for (const item of _ext1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.ext1.push(m);
        }
      }
      const _ext2_ = json["ext2"];
      if (_ext2_) {
        for (const item of _ext2_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encode: function (msg) {
        return JSON.stringify(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group1._writeMessage(msg)
        );
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decode: function (json) {
        return TestParsingMergeJSON.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypesJSON.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg) {
        const json = {};
        if (msg.field1) {
          const _field1_ = TestAllTypesJSON._writeMessage(msg.field1);
          if (Object.keys(_field1_).length > 0) {
            json["field1"] = _field1_;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, json) {
        const _field1_ = json["field1"];
        if (_field1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, _field1_);
          msg.field1 = m;
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encode: function (msg) {
        return JSON.stringify(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group2._writeMessage(msg)
        );
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decode: function (json) {
        return TestParsingMergeJSON.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypesJSON.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg) {
        const json = {};
        if (msg.field1) {
          const _field1_ = TestAllTypesJSON._writeMessage(msg.field1);
          if (Object.keys(_field1_).length > 0) {
            json["field1"] = _field1_;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, json) {
        const _field1_ = json["field1"];
        if (_field1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, _field1_);
          msg.field1 = m;
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestParsingMerge.OptionalGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestParsingMergeJSON.OptionalGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestParsingMerge.OptionalGroup from JSON.
     */
    decode: function (json) {
      return TestParsingMergeJSON.OptionalGroup._readMessage(
        TestParsingMergeJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optionalGroupAllTypes: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.optionalGroupAllTypes) {
        const _optionalGroupAllTypes_ = TestAllTypesJSON._writeMessage(
          msg.optionalGroupAllTypes
        );
        if (Object.keys(_optionalGroupAllTypes_).length > 0) {
          json["optionalGroupAllTypes"] = _optionalGroupAllTypes_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _optionalGroupAllTypes_ =
        json["optionalGroupAllTypes"] ?? json["optional_group_all_types"];
      if (_optionalGroupAllTypes_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, _optionalGroupAllTypes_);
        msg.optionalGroupAllTypes = m;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestParsingMerge.RepeatedGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestParsingMergeJSON.RepeatedGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestParsingMerge.RepeatedGroup from JSON.
     */
    decode: function (json) {
      return TestParsingMergeJSON.RepeatedGroup._readMessage(
        TestParsingMergeJSON.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeatedGroupAllTypes: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.repeatedGroupAllTypes) {
        const _repeatedGroupAllTypes_ = TestAllTypesJSON._writeMessage(
          msg.repeatedGroupAllTypes
        );
        if (Object.keys(_repeatedGroupAllTypes_).length > 0) {
          json["repeatedGroupAllTypes"] = _repeatedGroupAllTypes_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _repeatedGroupAllTypes_ =
        json["repeatedGroupAllTypes"] ?? json["repeated_group_all_types"];
      if (_repeatedGroupAllTypes_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, _repeatedGroupAllTypes_);
        msg.repeatedGroupAllTypes = m;
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessageJSON = {
  /**
   * Serializes TestCommentInjectionMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestCommentInjectionMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestCommentInjectionMessage from JSON.
   */
  decode: function (json) {
    return TestCommentInjectionMessageJSON._readMessage(
      TestCommentInjectionMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const FooRequestJSON = {
  /**
   * Serializes FooRequest to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes FooRequest from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const FooResponseJSON = {
  /**
   * Serializes FooResponse to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes FooResponse from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const FooClientMessageJSON = {
  /**
   * Serializes FooClientMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes FooClientMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const FooServerMessageJSON = {
  /**
   * Serializes FooServerMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes FooServerMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const BarRequestJSON = {
  /**
   * Serializes BarRequest to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes BarRequest from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const BarResponseJSON = {
  /**
   * Serializes BarResponse to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes BarResponse from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestJsonNameJSON = {
  /**
   * Serializes TestJsonName to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestJsonNameJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestJsonName from JSON.
   */
  decode: function (json) {
    return TestJsonNameJSON._readMessage(
      TestJsonNameJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fieldName1) {
      json["fieldName1"] = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json["fieldName2"] = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json["FieldName3"] = msg.FieldName3;
    }
    if (msg.FieldName4) {
      json["FieldName4"] = msg.FieldName4;
    }
    if (msg.FIELDNAME5) {
      json["FIELDNAME5"] = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json["@type"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json["fieldname7"] = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fieldName1_ = json["fieldName1"] ?? json["field_name1"];
    if (_fieldName1_) {
      msg.fieldName1 = _fieldName1_;
    }
    const _fieldName2_ = json["fieldName2"];
    if (_fieldName2_) {
      msg.fieldName2 = _fieldName2_;
    }
    const _FieldName3_ = json["FieldName3"];
    if (_FieldName3_) {
      msg.FieldName3 = _FieldName3_;
    }
    const _FieldName4_ = json["FieldName4"] ?? json["_field_name4"];
    if (_FieldName4_) {
      msg.FieldName4 = _FieldName4_;
    }
    const _FIELDNAME5_ = json["FIELDNAME5"] ?? json["FIELD_NAME5"];
    if (_FIELDNAME5_) {
      msg.FIELDNAME5 = _FIELDNAME5_;
    }
    const _fieldName6_ =
      json["@type"] ?? json["fieldName6"] ?? json["field_name6"];
    if (_fieldName6_) {
      msg.fieldName6 = _fieldName6_;
    }
    const _fieldname7_ = json["fieldname7"];
    if (_fieldname7_) {
      msg.fieldname7 = _fieldname7_;
    }
    return msg;
  },
};

export const TestHugeFieldNumbersJSON = {
  /**
   * Serializes TestHugeFieldNumbers to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestHugeFieldNumbersJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestHugeFieldNumbers from JSON.
   */
  decode: function (json) {
    return TestHugeFieldNumbersJSON._readMessage(
      TestHugeFieldNumbersJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnum._fromInt(0),
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessageJSON.initialize(),
      stringStringMap: {},
      oneofUint32: undefined,
      oneofTestAllTypes: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json["fixed32"] = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.optionalEnum && ForeignEnumJSON._toInt(msg.optionalEnum)) {
      json["optionalEnum"] = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      const _optionalMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalMessage
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.stringStringMap) {
      const _stringStringMap_ = Object.fromEntries(
        Object.entries(msg.stringStringMap)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbersJSON.StringStringMap._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_stringStringMap_).length > 0) {
        json["stringStringMap"] = _stringStringMap_;
      }
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const _oneofTestAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.oneofTestAllTypes
      );
      json["oneofTestAllTypes"] = _oneofTestAllTypes_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _fixed32_ = json["fixed32"] ?? json["fixed_32"];
    if (_fixed32_) {
      msg.fixed32 = _fixed32_;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _optionalEnum_ = json["optionalEnum"] ?? json["optional_enum"];
    if (_optionalEnum_) {
      msg.optionalEnum = _optionalEnum_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _optionalMessage_);
      msg.optionalMessage = m;
    }
    const _stringStringMap_ =
      json["stringStringMap"] ?? json["string_string_map"];
    if (_stringStringMap_) {
      msg.stringStringMap = Object.fromEntries(
        Object.entries(_stringStringMap_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbersJSON.StringStringMap._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofTestAllTypes_ =
      json["oneofTestAllTypes"] ?? json["oneof_test_all_types"];
    if (_oneofTestAllTypes_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _oneofTestAllTypes_);
      msg.oneofTestAllTypes = m;
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestHugeFieldNumbersJSON.OptionalGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decode: function (json) {
      return TestHugeFieldNumbersJSON.OptionalGroup._readMessage(
        TestHugeFieldNumbersJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.groupA) {
        json["groupA"] = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _groupA_ = json["groupA"] ?? json["group_a"];
      if (_groupA_) {
        msg.groupA = _groupA_;
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTableJSON = {
  /**
   * Serializes TestExtensionInsideTable to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtensionInsideTableJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionInsideTable from JSON.
   */
  decode: function (json) {
    return TestExtensionInsideTableJSON._readMessage(
      TestExtensionInsideTableJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.field1) {
      json["field1"] = msg.field1;
    }
    if (msg.field2) {
      json["field2"] = msg.field2;
    }
    if (msg.field3) {
      json["field3"] = msg.field3;
    }
    if (msg.field4) {
      json["field4"] = msg.field4;
    }
    if (msg.field6) {
      json["field6"] = msg.field6;
    }
    if (msg.field7) {
      json["field7"] = msg.field7;
    }
    if (msg.field8) {
      json["field8"] = msg.field8;
    }
    if (msg.field9) {
      json["field9"] = msg.field9;
    }
    if (msg.field10) {
      json["field10"] = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _field1_ = json["field1"];
    if (_field1_) {
      msg.field1 = _field1_;
    }
    const _field2_ = json["field2"];
    if (_field2_) {
      msg.field2 = _field2_;
    }
    const _field3_ = json["field3"];
    if (_field3_) {
      msg.field3 = _field3_;
    }
    const _field4_ = json["field4"];
    if (_field4_) {
      msg.field4 = _field4_;
    }
    const _field6_ = json["field6"];
    if (_field6_) {
      msg.field6 = _field6_;
    }
    const _field7_ = json["field7"];
    if (_field7_) {
      msg.field7 = _field7_;
    }
    const _field8_ = json["field8"];
    if (_field8_) {
      msg.field8 = _field8_;
    }
    const _field9_ = json["field9"];
    if (_field9_) {
      msg.field9 = _field9_;
    }
    const _field10_ = json["field10"];
    if (_field10_) {
      msg.field10 = _field10_;
    }
    return msg;
  },
};

export const TestExtensionRangeSerializeJSON = {
  /**
   * Serializes TestExtensionRangeSerialize to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtensionRangeSerializeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionRangeSerialize from JSON.
   */
  decode: function (json) {
    return TestExtensionRangeSerializeJSON._readMessage(
      TestExtensionRangeSerializeJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooOne) {
      json["fooOne"] = msg.fooOne;
    }
    if (msg.fooTwo) {
      json["fooTwo"] = msg.fooTwo;
    }
    if (msg.fooThree) {
      json["fooThree"] = msg.fooThree;
    }
    if (msg.fooFour) {
      json["fooFour"] = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooOne_ = json["fooOne"] ?? json["foo_one"];
    if (_fooOne_) {
      msg.fooOne = _fooOne_;
    }
    const _fooTwo_ = json["fooTwo"] ?? json["foo_two"];
    if (_fooTwo_) {
      msg.fooTwo = _fooTwo_;
    }
    const _fooThree_ = json["fooThree"] ?? json["foo_three"];
    if (_fooThree_) {
      msg.fooThree = _fooThree_;
    }
    const _fooFour_ = json["fooFour"] ?? json["foo_four"];
    if (_fooFour_) {
      msg.fooFour = _fooFour_;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "google/protobuf/map_unittest.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto
/* eslint-disable */

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";

import * as googleProtobufUnittest from "./unittest.pb.js";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: "MAP_ENUM_FOO",
  MAP_ENUM_BAR: "MAP_ENUM_BAR",
  MAP_ENUM_BAZ: "MAP_ENUM_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "MAP_ENUM_FOO";
      }
      case 1: {
        return "MAP_ENUM_BAR";
      }
      case 2: {
        return "MAP_ENUM_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "MAP_ENUM_FOO": {
        return 0;
      }
      case "MAP_ENUM_BAR": {
        return 1;
      }
      case "MAP_ENUM_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestMap = {
  /**
   * Serializes TestMap to protobuf.
   */
  encode: function (msg) {
    return TestMap._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestMap from protobuf.
   */
  decode: function (bytes) {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32ForeignMessage._writeMessage
      );
    }
    if (msg.mapStringForeignMessage) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.mapStringForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapStringForeignMessage._writeMessage
      );
    }
    if (msg.mapInt32AllTypes) {
      writer.writeRepeatedMessage(
        19,
        Object.entries(msg.mapInt32AllTypes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32AllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {};
          reader.readMessage(map, TestMap.MapUint32Uint32._readMessage);
          msg.mapUint32Uint32[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {};
          reader.readMessage(map, TestMap.MapUint64Uint64._readMessage);
          msg.mapUint64Uint64[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {};
          reader.readMessage(map, TestMap.MapSint32Sint32._readMessage);
          msg.mapSint32Sint32[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {};
          reader.readMessage(map, TestMap.MapSint64Sint64._readMessage);
          msg.mapSint64Sint64[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {};
          reader.readMessage(map, TestMap.MapFixed32Fixed32._readMessage);
          msg.mapFixed32Fixed32[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {};
          reader.readMessage(map, TestMap.MapFixed64Fixed64._readMessage);
          msg.mapFixed64Fixed64[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {};
          reader.readMessage(map, TestMap.MapSfixed32Sfixed32._readMessage);
          msg.mapSfixed32Sfixed32[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {};
          reader.readMessage(map, TestMap.MapSfixed64Sfixed64._readMessage);
          msg.mapSfixed64Sfixed64[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Float._readMessage);
          msg.mapInt32Float[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Double._readMessage);
          msg.mapInt32Double[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {};
          reader.readMessage(map, TestMap.MapBoolBool._readMessage);
          msg.mapBoolBool[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {};
          reader.readMessage(map, TestMap.MapStringString._readMessage);
          msg.mapStringString[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32ForeignMessage._readMessage);
          msg.mapInt32ForeignMessage[map.key.toString()] = map.value;
          break;
        }
        case 18: {
          const map = {};
          reader.readMessage(map, TestMap.MapStringForeignMessage._readMessage);
          msg.mapStringForeignMessage[map.key.toString()] = map.value;
          break;
        }
        case 19: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32AllTypes._readMessage);
          msg.mapInt32AllTypes[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnum._toInt(msg.value)) {
        writer.writeEnum(2, MapEnum._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnum._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestAllTypes.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes TestMapSubmessage to protobuf.
   */
  encode: function (msg) {
    return TestMapSubmessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMapSubmessage from protobuf.
   */
  decode: function (bytes) {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes TestMessageMap to protobuf.
   */
  encode: function (msg) {
    return TestMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Message) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Message).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMessageMap.MapInt32Message._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestMessageMap.MapInt32Message._readMessage);
          msg.mapInt32Message[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestAllTypes.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes TestSameTypeMap to protobuf.
   */
  encode: function (msg) {
    return TestSameTypeMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestSameTypeMap from protobuf.
   */
  decode: function (bytes) {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map1) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.map1).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestSameTypeMap.Map1._writeMessage
      );
    }
    if (msg.map2) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.map2).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestSameTypeMap.Map2._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestSameTypeMap.Map1._readMessage);
          msg.map1[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {};
          reader.readMessage(map, TestSameTypeMap.Map2._readMessage);
          msg.map2[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes TestRequiredMessageMap to protobuf.
   */
  encode: function (msg) {
    return TestRequiredMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestRequiredMessageMap.MapField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestRequiredMessageMap.MapField._readMessage);
          msg.mapField[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestRequired._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestRequired.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestRequired._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestArenaMap = {
  /**
   * Serializes TestArenaMap to protobuf.
   */
  encode: function (msg) {
    return TestArenaMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestArenaMap from protobuf.
   */
  decode: function (bytes) {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32ForeignMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapUint32Uint32._readMessage);
          msg.mapUint32Uint32[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapUint64Uint64._readMessage);
          msg.mapUint64Uint64[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapSint32Sint32._readMessage);
          msg.mapSint32Sint32[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapSint64Sint64._readMessage);
          msg.mapSint64Sint64[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapFixed32Fixed32._readMessage);
          msg.mapFixed32Fixed32[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapFixed64Fixed64._readMessage);
          msg.mapFixed64Fixed64[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {};
          reader.readMessage(
            map,
            TestArenaMap.MapSfixed32Sfixed32._readMessage
          );
          msg.mapSfixed32Sfixed32[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {};
          reader.readMessage(
            map,
            TestArenaMap.MapSfixed64Sfixed64._readMessage
          );
          msg.mapSfixed64Sfixed64[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Float._readMessage);
          msg.mapInt32Float[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Double._readMessage);
          msg.mapInt32Double[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapBoolBool._readMessage);
          msg.mapBoolBool[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapStringString._readMessage);
          msg.mapStringString[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {};
          reader.readMessage(
            map,
            TestArenaMap.MapInt32ForeignMessage._readMessage
          );
          msg.mapInt32ForeignMessage[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnum._toInt(msg.value)) {
        writer.writeEnum(2, MapEnum._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnum._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (msg) {
    return MessageContainingMapCalledEntry._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes) {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.entry) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.entry).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MessageContainingMapCalledEntry.Entry._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(
            map,
            MessageContainingMapCalledEntry.Entry._readMessage
          );
          msg.entry[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes TestRecursiveMapMessage to protobuf.
   */
  encode: function (msg) {
    return TestRecursiveMapMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.a).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestRecursiveMapMessage.A._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestRecursiveMapMessage.A._readMessage);
          msg.a[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          TestRecursiveMapMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = TestRecursiveMapMessage.initialize();
            reader.readMessage(msg.value, TestRecursiveMapMessage._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const MapEnumJSON = {
  MAP_ENUM_FOO: "MAP_ENUM_FOO",
  MAP_ENUM_BAR: "MAP_ENUM_BAR",
  MAP_ENUM_BAZ: "MAP_ENUM_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "MAP_ENUM_FOO";
      }
      case 1: {
        return "MAP_ENUM_BAR";
      }
      case 2: {
        return "MAP_ENUM_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "MAP_ENUM_FOO": {
        return 0;
      }
      case "MAP_ENUM_BAR": {
        return 1;
      }
      case "MAP_ENUM_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestMapJSON = {
  /**
   * Serializes TestMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMap from JSON.
   */
  decode: function (json) {
    return TestMapJSON._readMessage(TestMapJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      const _mapInt32Int32_ = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Int32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Int32_).length > 0) {
        json["mapInt32Int32"] = _mapInt32Int32_;
      }
    }
    if (msg.mapInt64Int64) {
      const _mapInt64Int64_ = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt64Int64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt64Int64_).length > 0) {
        json["mapInt64Int64"] = _mapInt64Int64_;
      }
    }
    if (msg.mapUint32Uint32) {
      const _mapUint32Uint32_ = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapUint32Uint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint32Uint32_).length > 0) {
        json["mapUint32Uint32"] = _mapUint32Uint32_;
      }
    }
    if (msg.mapUint64Uint64) {
      const _mapUint64Uint64_ = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapUint64Uint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint64Uint64_).length > 0) {
        json["mapUint64Uint64"] = _mapUint64Uint64_;
      }
    }
    if (msg.mapSint32Sint32) {
      const _mapSint32Sint32_ = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSint32Sint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint32Sint32_).length > 0) {
        json["mapSint32Sint32"] = _mapSint32Sint32_;
      }
    }
    if (msg.mapSint64Sint64) {
      const _mapSint64Sint64_ = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSint64Sint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint64Sint64_).length > 0) {
        json["mapSint64Sint64"] = _mapSint64Sint64_;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const _mapFixed32Fixed32_ = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapFixed32Fixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed32Fixed32_).length > 0) {
        json["mapFixed32Fixed32"] = _mapFixed32Fixed32_;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const _mapFixed64Fixed64_ = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapFixed64Fixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed64Fixed64_).length > 0) {
        json["mapFixed64Fixed64"] = _mapFixed64Fixed64_;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const _mapSfixed32Sfixed32_ = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSfixed32Sfixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed32Sfixed32_).length > 0) {
        json["mapSfixed32Sfixed32"] = _mapSfixed32Sfixed32_;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const _mapSfixed64Sfixed64_ = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSfixed64Sfixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed64Sfixed64_).length > 0) {
        json["mapSfixed64Sfixed64"] = _mapSfixed64Sfixed64_;
      }
    }
    if (msg.mapInt32Float) {
      const _mapInt32Float_ = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Float._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Float_).length > 0) {
        json["mapInt32Float"] = _mapInt32Float_;
      }
    }
    if (msg.mapInt32Double) {
      const _mapInt32Double_ = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Double._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Double_).length > 0) {
        json["mapInt32Double"] = _mapInt32Double_;
      }
    }
    if (msg.mapBoolBool) {
      const _mapBoolBool_ = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapBoolBool._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapBoolBool_).length > 0) {
        json["mapBoolBool"] = _mapBoolBool_;
      }
    }
    if (msg.mapStringString) {
      const _mapStringString_ = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapStringString._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapStringString_).length > 0) {
        json["mapStringString"] = _mapStringString_;
      }
    }
    if (msg.mapInt32Bytes) {
      const _mapInt32Bytes_ = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Bytes._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Bytes_).length > 0) {
        json["mapInt32Bytes"] = _mapInt32Bytes_;
      }
    }
    if (msg.mapInt32Enum) {
      const _mapInt32Enum_ = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Enum._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Enum_).length > 0) {
        json["mapInt32Enum"] = _mapInt32Enum_;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const _mapInt32ForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32ForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32ForeignMessage_).length > 0) {
        json["mapInt32ForeignMessage"] = _mapInt32ForeignMessage_;
      }
    }
    if (msg.mapStringForeignMessage) {
      const _mapStringForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapStringForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapStringForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapStringForeignMessage_).length > 0) {
        json["mapStringForeignMessage"] = _mapStringForeignMessage_;
      }
    }
    if (msg.mapInt32AllTypes) {
      const _mapInt32AllTypes_ = Object.fromEntries(
        Object.entries(msg.mapInt32AllTypes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32AllTypes._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32AllTypes_).length > 0) {
        json["mapInt32AllTypes"] = _mapInt32AllTypes_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _mapInt32Int32_ = json["mapInt32Int32"] ?? json["map_int32_int32"];
    if (_mapInt32Int32_) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Int32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64_ = json["mapInt64Int64"] ?? json["map_int64_int64"];
    if (_mapInt64Int64_) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt64Int64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32_ =
      json["mapUint32Uint32"] ?? json["map_uint32_uint32"];
    if (_mapUint32Uint32_) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapUint32Uint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64_ =
      json["mapUint64Uint64"] ?? json["map_uint64_uint64"];
    if (_mapUint64Uint64_) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapUint64Uint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32_ =
      json["mapSint32Sint32"] ?? json["map_sint32_sint32"];
    if (_mapSint32Sint32_) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSint32Sint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64_ =
      json["mapSint64Sint64"] ?? json["map_sint64_sint64"];
    if (_mapSint64Sint64_) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSint64Sint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32_ =
      json["mapFixed32Fixed32"] ?? json["map_fixed32_fixed32"];
    if (_mapFixed32Fixed32_) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapFixed32Fixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64_ =
      json["mapFixed64Fixed64"] ?? json["map_fixed64_fixed64"];
    if (_mapFixed64Fixed64_) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapFixed64Fixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32_ =
      json["mapSfixed32Sfixed32"] ?? json["map_sfixed32_sfixed32"];
    if (_mapSfixed32Sfixed32_) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSfixed32Sfixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64_ =
      json["mapSfixed64Sfixed64"] ?? json["map_sfixed64_sfixed64"];
    if (_mapSfixed64Sfixed64_) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSfixed64Sfixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float_ = json["mapInt32Float"] ?? json["map_int32_float"];
    if (_mapInt32Float_) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Float._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double_ = json["mapInt32Double"] ?? json["map_int32_double"];
    if (_mapInt32Double_) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Double._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool_ = json["mapBoolBool"] ?? json["map_bool_bool"];
    if (_mapBoolBool_) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapBoolBool._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString_ =
      json["mapStringString"] ?? json["map_string_string"];
    if (_mapStringString_) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapStringString._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes_ = json["mapInt32Bytes"] ?? json["map_int32_bytes"];
    if (_mapInt32Bytes_) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Bytes._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum_ = json["mapInt32Enum"] ?? json["map_int32_enum"];
    if (_mapInt32Enum_) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Enum._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage_ =
      json["mapInt32ForeignMessage"] ?? json["map_int32_foreign_message"];
    if (_mapInt32ForeignMessage_) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32ForeignMessage._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringForeignMessage_ =
      json["mapStringForeignMessage"] ?? json["map_string_foreign_message"];
    if (_mapStringForeignMessage_) {
      msg.mapStringForeignMessage = Object.fromEntries(
        Object.entries(_mapStringForeignMessage_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapStringForeignMessage._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32AllTypes_ =
      json["mapInt32AllTypes"] ?? json["map_int32_all_types"];
    if (_mapInt32AllTypes_) {
      msg.mapInt32AllTypes = Object.fromEntries(
        Object.entries(_mapInt32AllTypes_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32AllTypes._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value?.length) {
        json["value"] = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = decodeBase64Bytes(_value_);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && MapEnumJSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.ForeignMessage.initialize();
        googleProtobufUnittest.ForeignMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.ForeignMessage.initialize();
        googleProtobufUnittest.ForeignMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestAllTypesJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.TestAllTypes.initialize();
        googleProtobufUnittest.TestAllTypesJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestMapSubmessageJSON = {
  /**
   * Serializes TestMapSubmessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMapSubmessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMapSubmessage from JSON.
   */
  decode: function (json) {
    return TestMapSubmessageJSON._readMessage(
      TestMapSubmessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      testMap: TestMapJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.testMap) {
      const _testMap_ = TestMapJSON._writeMessage(msg.testMap);
      if (Object.keys(_testMap_).length > 0) {
        json["testMap"] = _testMap_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _testMap_ = json["testMap"] ?? json["test_map"];
    if (_testMap_) {
      const m = TestMap.initialize();
      TestMapJSON._readMessage(m, _testMap_);
      msg.testMap = m;
    }
    return msg;
  },
};

export const TestMessageMapJSON = {
  /**
   * Serializes TestMessageMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMessageMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMessageMap from JSON.
   */
  decode: function (json) {
    return TestMessageMapJSON._readMessage(
      TestMessageMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.mapInt32Message) {
      const _mapInt32Message_ = Object.fromEntries(
        Object.entries(msg.mapInt32Message)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMapJSON.MapInt32Message._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Message_).length > 0) {
        json["mapInt32Message"] = _mapInt32Message_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _mapInt32Message_ =
      json["mapInt32Message"] ?? json["map_int32_message"];
    if (_mapInt32Message_) {
      msg.mapInt32Message = Object.fromEntries(
        Object.entries(_mapInt32Message_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMapJSON.MapInt32Message._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestAllTypesJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.TestAllTypes.initialize();
        googleProtobufUnittest.TestAllTypesJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestSameTypeMapJSON = {
  /**
   * Serializes TestSameTypeMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestSameTypeMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestSameTypeMap from JSON.
   */
  decode: function (json) {
    return TestSameTypeMapJSON._readMessage(
      TestSameTypeMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.map1) {
      const _map1_ = Object.fromEntries(
        Object.entries(msg.map1)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMapJSON.Map1._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_map1_).length > 0) {
        json["map1"] = _map1_;
      }
    }
    if (msg.map2) {
      const _map2_ = Object.fromEntries(
        Object.entries(msg.map2)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMapJSON.Map2._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_map2_).length > 0) {
        json["map2"] = _map2_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _map1_ = json["map1"];
    if (_map1_) {
      msg.map1 = Object.fromEntries(
        Object.entries(_map1_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMapJSON.Map1._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _map2_ = json["map2"];
    if (_map2_) {
      msg.map2 = Object.fromEntries(
        Object.entries(_map2_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMapJSON.Map2._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMapJSON = {
  /**
   * Serializes TestRequiredMessageMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredMessageMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredMessageMap from JSON.
   */
  decode: function (json) {
    return TestRequiredMessageMapJSON._readMessage(
      TestRequiredMessageMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.mapField) {
      const _mapField_ = Object.fromEntries(
        Object.entries(msg.mapField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMapJSON.MapField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapField_).length > 0) {
        json["mapField"] = _mapField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _mapField_ = json["mapField"] ?? json["map_field"];
    if (_mapField_) {
      msg.mapField = Object.fromEntries(
        Object.entries(_mapField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMapJSON.MapField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestRequiredJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.TestRequired.initialize();
        googleProtobufUnittest.TestRequiredJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestArenaMapJSON = {
  /**
   * Serializes TestArenaMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestArenaMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestArenaMap from JSON.
   */
  decode: function (json) {
    return TestArenaMapJSON._readMessage(
      TestArenaMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      const _mapInt32Int32_ = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Int32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Int32_).length > 0) {
        json["mapInt32Int32"] = _mapInt32Int32_;
      }
    }
    if (msg.mapInt64Int64) {
      const _mapInt64Int64_ = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt64Int64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt64Int64_).length > 0) {
        json["mapInt64Int64"] = _mapInt64Int64_;
      }
    }
    if (msg.mapUint32Uint32) {
      const _mapUint32Uint32_ = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapUint32Uint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint32Uint32_).length > 0) {
        json["mapUint32Uint32"] = _mapUint32Uint32_;
      }
    }
    if (msg.mapUint64Uint64) {
      const _mapUint64Uint64_ = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapUint64Uint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint64Uint64_).length > 0) {
        json["mapUint64Uint64"] = _mapUint64Uint64_;
      }
    }
    if (msg.mapSint32Sint32) {
      const _mapSint32Sint32_ = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSint32Sint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint32Sint32_).length > 0) {
        json["mapSint32Sint32"] = _mapSint32Sint32_;
      }
    }
    if (msg.mapSint64Sint64) {
      const _mapSint64Sint64_ = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSint64Sint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint64Sint64_).length > 0) {
        json["mapSint64Sint64"] = _mapSint64Sint64_;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const _mapFixed32Fixed32_ = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapFixed32Fixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed32Fixed32_).length > 0) {
        json["mapFixed32Fixed32"] = _mapFixed32Fixed32_;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const _mapFixed64Fixed64_ = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapFixed64Fixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed64Fixed64_).length > 0) {
        json["mapFixed64Fixed64"] = _mapFixed64Fixed64_;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const _mapSfixed32Sfixed32_ = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSfixed32Sfixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed32Sfixed32_).length > 0) {
        json["mapSfixed32Sfixed32"] = _mapSfixed32Sfixed32_;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const _mapSfixed64Sfixed64_ = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSfixed64Sfixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed64Sfixed64_).length > 0) {
        json["mapSfixed64Sfixed64"] = _mapSfixed64Sfixed64_;
      }
    }
    if (msg.mapInt32Float) {
      const _mapInt32Float_ = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Float._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Float_).length > 0) {
        json["mapInt32Float"] = _mapInt32Float_;
      }
    }
    if (msg.mapInt32Double) {
      const _mapInt32Double_ = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Double._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Double_).length > 0) {
        json["mapInt32Double"] = _mapInt32Double_;
      }
    }
    if (msg.mapBoolBool) {
      const _mapBoolBool_ = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapBoolBool._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapBoolBool_).length > 0) {
        json["mapBoolBool"] = _mapBoolBool_;
      }
    }
    if (msg.mapStringString) {
      const _mapStringString_ = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapStringString._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapStringString_).length > 0) {
        json["mapStringString"] = _mapStringString_;
      }
    }
    if (msg.mapInt32Bytes) {
      const _mapInt32Bytes_ = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Bytes._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Bytes_).length > 0) {
        json["mapInt32Bytes"] = _mapInt32Bytes_;
      }
    }
    if (msg.mapInt32Enum) {
      const _mapInt32Enum_ = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Enum._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Enum_).length > 0) {
        json["mapInt32Enum"] = _mapInt32Enum_;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const _mapInt32ForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32ForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32ForeignMessage_).length > 0) {
        json["mapInt32ForeignMessage"] = _mapInt32ForeignMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _mapInt32Int32_ = json["mapInt32Int32"] ?? json["map_int32_int32"];
    if (_mapInt32Int32_) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Int32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64_ = json["mapInt64Int64"] ?? json["map_int64_int64"];
    if (_mapInt64Int64_) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt64Int64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32_ =
      json["mapUint32Uint32"] ?? json["map_uint32_uint32"];
    if (_mapUint32Uint32_) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapUint32Uint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64_ =
      json["mapUint64Uint64"] ?? json["map_uint64_uint64"];
    if (_mapUint64Uint64_) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapUint64Uint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32_ =
      json["mapSint32Sint32"] ?? json["map_sint32_sint32"];
    if (_mapSint32Sint32_) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSint32Sint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64_ =
      json["mapSint64Sint64"] ?? json["map_sint64_sint64"];
    if (_mapSint64Sint64_) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSint64Sint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32_ =
      json["mapFixed32Fixed32"] ?? json["map_fixed32_fixed32"];
    if (_mapFixed32Fixed32_) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapFixed32Fixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64_ =
      json["mapFixed64Fixed64"] ?? json["map_fixed64_fixed64"];
    if (_mapFixed64Fixed64_) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapFixed64Fixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32_ =
      json["mapSfixed32Sfixed32"] ?? json["map_sfixed32_sfixed32"];
    if (_mapSfixed32Sfixed32_) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSfixed32Sfixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64_ =
      json["mapSfixed64Sfixed64"] ?? json["map_sfixed64_sfixed64"];
    if (_mapSfixed64Sfixed64_) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSfixed64Sfixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float_ = json["mapInt32Float"] ?? json["map_int32_float"];
    if (_mapInt32Float_) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Float._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double_ = json["mapInt32Double"] ?? json["map_int32_double"];
    if (_mapInt32Double_) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Double._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool_ = json["mapBoolBool"] ?? json["map_bool_bool"];
    if (_mapBoolBool_) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapBoolBool._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString_ =
      json["mapStringString"] ?? json["map_string_string"];
    if (_mapStringString_) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapStringString._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes_ = json["mapInt32Bytes"] ?? json["map_int32_bytes"];
    if (_mapInt32Bytes_) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Bytes._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum_ = json["mapInt32Enum"] ?? json["map_int32_enum"];
    if (_mapInt32Enum_) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Enum._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage_ =
      json["mapInt32ForeignMessage"] ?? json["map_int32_foreign_message"];
    if (_mapInt32ForeignMessage_) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32ForeignMessage._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value?.length) {
        json["value"] = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = decodeBase64Bytes(_value_);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && MapEnumJSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.ForeignMessage.initialize();
        googleProtobufUnittest.ForeignMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntryJSON = {
  /**
   * Serializes MessageContainingMapCalledEntry to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(
      MessageContainingMapCalledEntryJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes MessageContainingMapCalledEntry from JSON.
   */
  decode: function (json) {
    return MessageContainingMapCalledEntryJSON._readMessage(
      MessageContainingMapCalledEntryJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.entry) {
      const _entry_ = Object.fromEntries(
        Object.entries(msg.entry)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntryJSON.Entry._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_entry_).length > 0) {
        json["entry"] = _entry_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _entry_ = json["entry"];
    if (_entry_) {
      msg.entry = Object.fromEntries(
        Object.entries(_entry_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntryJSON.Entry._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessageJSON = {
  /**
   * Serializes TestRecursiveMapMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRecursiveMapMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRecursiveMapMessage from JSON.
   */
  decode: function (json) {
    return TestRecursiveMapMessageJSON._readMessage(
      TestRecursiveMapMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      const _a_ = Object.fromEntries(
        Object.entries(msg.a)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessageJSON.A._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = Object.fromEntries(
        Object.entries(_a_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessageJSON.A._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = TestRecursiveMapMessageJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = TestRecursiveMapMessage.initialize();
        TestRecursiveMapMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "google/protobuf/unittest_well_known_types.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_well_known_types.proto
/* eslint-disable */

import { BinaryReader, BinaryWriter } from "protoscript";

import * as protoscript from "protoscript";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const TestWellKnownTypes = {
  /**
   * Serializes TestWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return TestWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return TestWellKnownTypes._readMessage(
      TestWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: protoscript.Any.initialize(),
      apiField: protoscript.Api.initialize(),
      durationField: protoscript.Duration.initialize(),
      emptyField: protoscript.Empty.initialize(),
      fieldMaskField: protoscript.FieldMask.initialize(),
      sourceContextField: protoscript.SourceContext.initialize(),
      structField: protoscript.Struct.initialize(),
      timestampField: protoscript.Timestamp.initialize(),
      typeField: protoscript.Type.initialize(),
      doubleField: protoscript.DoubleValue.initialize(),
      floatField: protoscript.FloatValue.initialize(),
      int64Field: protoscript.Int64Value.initialize(),
      uint64Field: protoscript.UInt64Value.initialize(),
      int32Field: protoscript.Int32Value.initialize(),
      uint32Field: protoscript.UInt32Value.initialize(),
      boolField: protoscript.BoolValue.initialize(),
      stringField: protoscript.StringValue.initialize(),
      bytesField: protoscript.BytesValue.initialize(),
      valueField: protoscript.Value.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField) {
      writer.writeMessage(1, msg.anyField, protoscript.Any._writeMessage);
    }
    if (msg.apiField) {
      writer.writeMessage(2, msg.apiField, protoscript.Api._writeMessage);
    }
    if (msg.durationField) {
      writer.writeMessage(
        3,
        msg.durationField,
        protoscript.Duration._writeMessage
      );
    }
    if (msg.emptyField) {
      writer.writeMessage(4, msg.emptyField, protoscript.Empty._writeMessage);
    }
    if (msg.fieldMaskField) {
      writer.writeMessage(
        5,
        msg.fieldMaskField,
        protoscript.FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        protoscript.SourceContext._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeMessage(7, msg.structField, protoscript.Struct._writeMessage);
    }
    if (msg.timestampField) {
      writer.writeMessage(
        8,
        msg.timestampField,
        protoscript.Timestamp._writeMessage
      );
    }
    if (msg.typeField) {
      writer.writeMessage(9, msg.typeField, protoscript.Type._writeMessage);
    }
    if (msg.doubleField) {
      writer.writeMessage(
        10,
        msg.doubleField,
        protoscript.DoubleValue._writeMessage
      );
    }
    if (msg.floatField) {
      writer.writeMessage(
        11,
        msg.floatField,
        protoscript.FloatValue._writeMessage
      );
    }
    if (msg.int64Field) {
      writer.writeMessage(
        12,
        msg.int64Field,
        protoscript.Int64Value._writeMessage
      );
    }
    if (msg.uint64Field) {
      writer.writeMessage(
        13,
        msg.uint64Field,
        protoscript.UInt64Value._writeMessage
      );
    }
    if (msg.int32Field) {
      writer.writeMessage(
        14,
        msg.int32Field,
        protoscript.Int32Value._writeMessage
      );
    }
    if (msg.uint32Field) {
      writer.writeMessage(
        15,
        msg.uint32Field,
        protoscript.UInt32Value._writeMessage
      );
    }
    if (msg.boolField) {
      writer.writeMessage(
        16,
        msg.boolField,
        protoscript.BoolValue._writeMessage
      );
    }
    if (msg.stringField) {
      writer.writeMessage(
        17,
        msg.stringField,
        protoscript.StringValue._writeMessage
      );
    }
    if (msg.bytesField) {
      writer.writeMessage(
        18,
        msg.bytesField,
        protoscript.BytesValue._writeMessage
      );
    }
    if (msg.valueField) {
      writer.writeMessage(19, msg.valueField, protoscript.Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.anyField, protoscript.Any._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.apiField, protoscript.Api._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(
            msg.durationField,
            protoscript.Duration._readMessage
          );
          break;
        }
        case 4: {
          reader.readMessage(msg.emptyField, protoscript.Empty._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(
            msg.fieldMaskField,
            protoscript.FieldMask._readMessage
          );
          break;
        }
        case 6: {
          reader.readMessage(
            msg.sourceContextField,
            protoscript.SourceContext._readMessage
          );
          break;
        }
        case 7: {
          reader.readMessage(msg.structField, protoscript.Struct._readMessage);
          break;
        }
        case 8: {
          reader.readMessage(
            msg.timestampField,
            protoscript.Timestamp._readMessage
          );
          break;
        }
        case 9: {
          reader.readMessage(msg.typeField, protoscript.Type._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(
            msg.doubleField,
            protoscript.DoubleValue._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.floatField,
            protoscript.FloatValue._readMessage
          );
          break;
        }
        case 12: {
          reader.readMessage(
            msg.int64Field,
            protoscript.Int64Value._readMessage
          );
          break;
        }
        case 13: {
          reader.readMessage(
            msg.uint64Field,
            protoscript.UInt64Value._readMessage
          );
          break;
        }
        case 14: {
          reader.readMessage(
            msg.int32Field,
            protoscript.Int32Value._readMessage
          );
          break;
        }
        case 15: {
          reader.readMessage(
            msg.uint32Field,
            protoscript.UInt32Value._readMessage
          );
          break;
        }
        case 16: {
          reader.readMessage(msg.boolField, protoscript.BoolValue._readMessage);
          break;
        }
        case 17: {
          reader.readMessage(
            msg.stringField,
            protoscript.StringValue._readMessage
          );
          break;
        }
        case 18: {
          reader.readMessage(
            msg.bytesField,
            protoscript.BytesValue._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(msg.valueField, protoscript.Value._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedWellKnownTypes = {
  /**
   * Serializes RepeatedWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return RepeatedWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes RepeatedWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return RepeatedWellKnownTypes._readMessage(
      RepeatedWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes RepeatedWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: [],
      apiField: [],
      durationField: [],
      emptyField: [],
      fieldMaskField: [],
      sourceContextField: [],
      structField: [],
      timestampField: [],
      typeField: [],
      doubleField: [],
      floatField: [],
      int64Field: [],
      uint64Field: [],
      int32Field: [],
      uint32Field: [],
      boolField: [],
      stringField: [],
      bytesField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.anyField,
        protoscript.Any._writeMessage
      );
    }
    if (msg.apiField?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.apiField,
        protoscript.Api._writeMessage
      );
    }
    if (msg.durationField?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.durationField,
        protoscript.Duration._writeMessage
      );
    }
    if (msg.emptyField?.length) {
      writer.writeRepeatedMessage(
        4,
        msg.emptyField,
        protoscript.Empty._writeMessage
      );
    }
    if (msg.fieldMaskField?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.fieldMaskField,
        protoscript.FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField?.length) {
      writer.writeRepeatedMessage(
        6,
        msg.sourceContextField,
        protoscript.SourceContext._writeMessage
      );
    }
    if (msg.structField?.length) {
      writer.writeRepeatedMessage(
        7,
        msg.structField,
        protoscript.Struct._writeMessage
      );
    }
    if (msg.timestampField?.length) {
      writer.writeRepeatedMessage(
        8,
        msg.timestampField,
        protoscript.Timestamp._writeMessage
      );
    }
    if (msg.typeField?.length) {
      writer.writeRepeatedMessage(
        9,
        msg.typeField,
        protoscript.Type._writeMessage
      );
    }
    if (msg.doubleField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.doubleField,
        protoscript.DoubleValue._writeMessage
      );
    }
    if (msg.floatField?.length) {
      writer.writeRepeatedMessage(
        11,
        msg.floatField,
        protoscript.FloatValue._writeMessage
      );
    }
    if (msg.int64Field?.length) {
      writer.writeRepeatedMessage(
        12,
        msg.int64Field,
        protoscript.Int64Value._writeMessage
      );
    }
    if (msg.uint64Field?.length) {
      writer.writeRepeatedMessage(
        13,
        msg.uint64Field,
        protoscript.UInt64Value._writeMessage
      );
    }
    if (msg.int32Field?.length) {
      writer.writeRepeatedMessage(
        14,
        msg.int32Field,
        protoscript.Int32Value._writeMessage
      );
    }
    if (msg.uint32Field?.length) {
      writer.writeRepeatedMessage(
        15,
        msg.uint32Field,
        protoscript.UInt32Value._writeMessage
      );
    }
    if (msg.boolField?.length) {
      writer.writeRepeatedMessage(
        16,
        msg.boolField,
        protoscript.BoolValue._writeMessage
      );
    }
    if (msg.stringField?.length) {
      writer.writeRepeatedMessage(
        17,
        msg.stringField,
        protoscript.StringValue._writeMessage
      );
    }
    if (msg.bytesField?.length) {
      writer.writeRepeatedMessage(
        18,
        msg.bytesField,
        protoscript.BytesValue._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoscript.Any.initialize();
          reader.readMessage(m, protoscript.Any._readMessage);
          msg.anyField.push(m);
          break;
        }
        case 2: {
          const m = protoscript.Api.initialize();
          reader.readMessage(m, protoscript.Api._readMessage);
          msg.apiField.push(m);
          break;
        }
        case 3: {
          const m = protoscript.Duration.initialize();
          reader.readMessage(m, protoscript.Duration._readMessage);
          msg.durationField.push(m);
          break;
        }
        case 4: {
          const m = protoscript.Empty.initialize();
          reader.readMessage(m, protoscript.Empty._readMessage);
          msg.emptyField.push(m);
          break;
        }
        case 5: {
          const m = protoscript.FieldMask.initialize();
          reader.readMessage(m, protoscript.FieldMask._readMessage);
          msg.fieldMaskField.push(m);
          break;
        }
        case 6: {
          const m = protoscript.SourceContext.initialize();
          reader.readMessage(m, protoscript.SourceContext._readMessage);
          msg.sourceContextField.push(m);
          break;
        }
        case 7: {
          const m = protoscript.Struct.initialize();
          reader.readMessage(m, protoscript.Struct._readMessage);
          msg.structField.push(m);
          break;
        }
        case 8: {
          const m = protoscript.Timestamp.initialize();
          reader.readMessage(m, protoscript.Timestamp._readMessage);
          msg.timestampField.push(m);
          break;
        }
        case 9: {
          const m = protoscript.Type.initialize();
          reader.readMessage(m, protoscript.Type._readMessage);
          msg.typeField.push(m);
          break;
        }
        case 10: {
          const m = protoscript.DoubleValue.initialize();
          reader.readMessage(m, protoscript.DoubleValue._readMessage);
          msg.doubleField.push(m);
          break;
        }
        case 11: {
          const m = protoscript.FloatValue.initialize();
          reader.readMessage(m, protoscript.FloatValue._readMessage);
          msg.floatField.push(m);
          break;
        }
        case 12: {
          const m = protoscript.Int64Value.initialize();
          reader.readMessage(m, protoscript.Int64Value._readMessage);
          msg.int64Field.push(m);
          break;
        }
        case 13: {
          const m = protoscript.UInt64Value.initialize();
          reader.readMessage(m, protoscript.UInt64Value._readMessage);
          msg.uint64Field.push(m);
          break;
        }
        case 14: {
          const m = protoscript.Int32Value.initialize();
          reader.readMessage(m, protoscript.Int32Value._readMessage);
          msg.int32Field.push(m);
          break;
        }
        case 15: {
          const m = protoscript.UInt32Value.initialize();
          reader.readMessage(m, protoscript.UInt32Value._readMessage);
          msg.uint32Field.push(m);
          break;
        }
        case 16: {
          const m = protoscript.BoolValue.initialize();
          reader.readMessage(m, protoscript.BoolValue._readMessage);
          msg.boolField.push(m);
          break;
        }
        case 17: {
          const m = protoscript.StringValue.initialize();
          reader.readMessage(m, protoscript.StringValue._readMessage);
          msg.stringField.push(m);
          break;
        }
        case 18: {
          const m = protoscript.BytesValue.initialize();
          reader.readMessage(m, protoscript.BytesValue._readMessage);
          msg.bytesField.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneofWellKnownTypes = {
  /**
   * Serializes OneofWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return OneofWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes OneofWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return OneofWellKnownTypes._readMessage(
      OneofWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OneofWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: undefined,
      apiField: undefined,
      durationField: undefined,
      emptyField: undefined,
      fieldMaskField: undefined,
      sourceContextField: undefined,
      structField: undefined,
      timestampField: undefined,
      typeField: undefined,
      doubleField: undefined,
      floatField: undefined,
      int64Field: undefined,
      uint64Field: undefined,
      int32Field: undefined,
      uint32Field: undefined,
      boolField: undefined,
      stringField: undefined,
      bytesField: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField != undefined) {
      writer.writeMessage(1, msg.anyField, protoscript.Any._writeMessage);
    }
    if (msg.apiField != undefined) {
      writer.writeMessage(2, msg.apiField, protoscript.Api._writeMessage);
    }
    if (msg.durationField != undefined) {
      writer.writeMessage(
        3,
        msg.durationField,
        protoscript.Duration._writeMessage
      );
    }
    if (msg.emptyField != undefined) {
      writer.writeMessage(4, msg.emptyField, protoscript.Empty._writeMessage);
    }
    if (msg.fieldMaskField != undefined) {
      writer.writeMessage(
        5,
        msg.fieldMaskField,
        protoscript.FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField != undefined) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        protoscript.SourceContext._writeMessage
      );
    }
    if (msg.structField != undefined) {
      writer.writeMessage(7, msg.structField, protoscript.Struct._writeMessage);
    }
    if (msg.timestampField != undefined) {
      writer.writeMessage(
        8,
        msg.timestampField,
        protoscript.Timestamp._writeMessage
      );
    }
    if (msg.typeField != undefined) {
      writer.writeMessage(9, msg.typeField, protoscript.Type._writeMessage);
    }
    if (msg.doubleField != undefined) {
      writer.writeMessage(
        10,
        msg.doubleField,
        protoscript.DoubleValue._writeMessage
      );
    }
    if (msg.floatField != undefined) {
      writer.writeMessage(
        11,
        msg.floatField,
        protoscript.FloatValue._writeMessage
      );
    }
    if (msg.int64Field != undefined) {
      writer.writeMessage(
        12,
        msg.int64Field,
        protoscript.Int64Value._writeMessage
      );
    }
    if (msg.uint64Field != undefined) {
      writer.writeMessage(
        13,
        msg.uint64Field,
        protoscript.UInt64Value._writeMessage
      );
    }
    if (msg.int32Field != undefined) {
      writer.writeMessage(
        14,
        msg.int32Field,
        protoscript.Int32Value._writeMessage
      );
    }
    if (msg.uint32Field != undefined) {
      writer.writeMessage(
        15,
        msg.uint32Field,
        protoscript.UInt32Value._writeMessage
      );
    }
    if (msg.boolField != undefined) {
      writer.writeMessage(
        16,
        msg.boolField,
        protoscript.BoolValue._writeMessage
      );
    }
    if (msg.stringField != undefined) {
      writer.writeMessage(
        17,
        msg.stringField,
        protoscript.StringValue._writeMessage
      );
    }
    if (msg.bytesField != undefined) {
      writer.writeMessage(
        18,
        msg.bytesField,
        protoscript.BytesValue._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.anyField = protoscript.Any.initialize();
          reader.readMessage(msg.anyField, protoscript.Any._readMessage);
          break;
        }
        case 2: {
          msg.apiField = protoscript.Api.initialize();
          reader.readMessage(msg.apiField, protoscript.Api._readMessage);
          break;
        }
        case 3: {
          msg.durationField = protoscript.Duration.initialize();
          reader.readMessage(
            msg.durationField,
            protoscript.Duration._readMessage
          );
          break;
        }
        case 4: {
          msg.emptyField = protoscript.Empty.initialize();
          reader.readMessage(msg.emptyField, protoscript.Empty._readMessage);
          break;
        }
        case 5: {
          msg.fieldMaskField = protoscript.FieldMask.initialize();
          reader.readMessage(
            msg.fieldMaskField,
            protoscript.FieldMask._readMessage
          );
          break;
        }
        case 6: {
          msg.sourceContextField = protoscript.SourceContext.initialize();
          reader.readMessage(
            msg.sourceContextField,
            protoscript.SourceContext._readMessage
          );
          break;
        }
        case 7: {
          msg.structField = protoscript.Struct.initialize();
          reader.readMessage(msg.structField, protoscript.Struct._readMessage);
          break;
        }
        case 8: {
          msg.timestampField = protoscript.Timestamp.initialize();
          reader.readMessage(
            msg.timestampField,
            protoscript.Timestamp._readMessage
          );
          break;
        }
        case 9: {
          msg.typeField = protoscript.Type.initialize();
          reader.readMessage(msg.typeField, protoscript.Type._readMessage);
          break;
        }
        case 10: {
          msg.doubleField = protoscript.DoubleValue.initialize();
          reader.readMessage(
            msg.doubleField,
            protoscript.DoubleValue._readMessage
          );
          break;
        }
        case 11: {
          msg.floatField = protoscript.FloatValue.initialize();
          reader.readMessage(
            msg.floatField,
            protoscript.FloatValue._readMessage
          );
          break;
        }
        case 12: {
          msg.int64Field = protoscript.Int64Value.initialize();
          reader.readMessage(
            msg.int64Field,
            protoscript.Int64Value._readMessage
          );
          break;
        }
        case 13: {
          msg.uint64Field = protoscript.UInt64Value.initialize();
          reader.readMessage(
            msg.uint64Field,
            protoscript.UInt64Value._readMessage
          );
          break;
        }
        case 14: {
          msg.int32Field = protoscript.Int32Value.initialize();
          reader.readMessage(
            msg.int32Field,
            protoscript.Int32Value._readMessage
          );
          break;
        }
        case 15: {
          msg.uint32Field = protoscript.UInt32Value.initialize();
          reader.readMessage(
            msg.uint32Field,
            protoscript.UInt32Value._readMessage
          );
          break;
        }
        case 16: {
          msg.boolField = protoscript.BoolValue.initialize();
          reader.readMessage(msg.boolField, protoscript.BoolValue._readMessage);
          break;
        }
        case 17: {
          msg.stringField = protoscript.StringValue.initialize();
          reader.readMessage(
            msg.stringField,
            protoscript.StringValue._readMessage
          );
          break;
        }
        case 18: {
          msg.bytesField = protoscript.BytesValue.initialize();
          reader.readMessage(
            msg.bytesField,
            protoscript.BytesValue._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MapWellKnownTypes = {
  /**
   * Serializes MapWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return MapWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes MapWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return MapWellKnownTypes._readMessage(
      MapWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MapWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: {},
      apiField: {},
      durationField: {},
      emptyField: {},
      fieldMaskField: {},
      sourceContextField: {},
      structField: {},
      timestampField: {},
      typeField: {},
      doubleField: {},
      floatField: {},
      int64Field: {},
      uint64Field: {},
      int32Field: {},
      uint32Field: {},
      boolField: {},
      stringField: {},
      bytesField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.anyField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.AnyField._writeMessage
      );
    }
    if (msg.apiField) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.apiField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.ApiField._writeMessage
      );
    }
    if (msg.durationField) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.durationField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.DurationField._writeMessage
      );
    }
    if (msg.emptyField) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.emptyField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.EmptyField._writeMessage
      );
    }
    if (msg.fieldMaskField) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.fieldMaskField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.FieldMaskField._writeMessage
      );
    }
    if (msg.sourceContextField) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.sourceContextField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.SourceContextField._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.structField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.StructField._writeMessage
      );
    }
    if (msg.timestampField) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.timestampField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.TimestampField._writeMessage
      );
    }
    if (msg.typeField) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.typeField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.TypeField._writeMessage
      );
    }
    if (msg.doubleField) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.doubleField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.DoubleField._writeMessage
      );
    }
    if (msg.floatField) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.floatField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.FloatField._writeMessage
      );
    }
    if (msg.int64Field) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.int64Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Int64Field._writeMessage
      );
    }
    if (msg.uint64Field) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.uint64Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Uint64Field._writeMessage
      );
    }
    if (msg.int32Field) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.int32Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Int32Field._writeMessage
      );
    }
    if (msg.uint32Field) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.uint32Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Uint32Field._writeMessage
      );
    }
    if (msg.boolField) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.boolField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.BoolField._writeMessage
      );
    }
    if (msg.stringField) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.stringField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.StringField._writeMessage
      );
    }
    if (msg.bytesField) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.bytesField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.BytesField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.AnyField._readMessage);
          msg.anyField[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.ApiField._readMessage);
          msg.apiField[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.DurationField._readMessage);
          msg.durationField[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.EmptyField._readMessage);
          msg.emptyField[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {};
          reader.readMessage(
            map,
            MapWellKnownTypes.FieldMaskField._readMessage
          );
          msg.fieldMaskField[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {};
          reader.readMessage(
            map,
            MapWellKnownTypes.SourceContextField._readMessage
          );
          msg.sourceContextField[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.StructField._readMessage);
          msg.structField[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {};
          reader.readMessage(
            map,
            MapWellKnownTypes.TimestampField._readMessage
          );
          msg.timestampField[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.TypeField._readMessage);
          msg.typeField[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.DoubleField._readMessage);
          msg.doubleField[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.FloatField._readMessage);
          msg.floatField[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.Int64Field._readMessage);
          msg.int64Field[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.Uint64Field._readMessage);
          msg.uint64Field[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.Int32Field._readMessage);
          msg.int32Field[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.Uint32Field._readMessage);
          msg.uint32Field[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.BoolField._readMessage);
          msg.boolField[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.StringField._readMessage);
          msg.stringField[map.key.toString()] = map.value;
          break;
        }
        case 18: {
          const map = {};
          reader.readMessage(map, MapWellKnownTypes.BytesField._readMessage);
          msg.bytesField[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  AnyField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Any._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Any.initialize();
            reader.readMessage(msg.value, protoscript.Any._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ApiField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Api._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Api.initialize();
            reader.readMessage(msg.value, protoscript.Api._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  DurationField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Duration._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Duration.initialize();
            reader.readMessage(msg.value, protoscript.Duration._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  EmptyField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Empty._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Empty.initialize();
            reader.readMessage(msg.value, protoscript.Empty._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FieldMaskField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.FieldMask._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.FieldMask.initialize();
            reader.readMessage(msg.value, protoscript.FieldMask._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SourceContextField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.SourceContext._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.SourceContext.initialize();
            reader.readMessage(
              msg.value,
              protoscript.SourceContext._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StructField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Struct._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Struct.initialize();
            reader.readMessage(msg.value, protoscript.Struct._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  TimestampField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Timestamp._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Timestamp.initialize();
            reader.readMessage(msg.value, protoscript.Timestamp._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  TypeField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Type._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Type.initialize();
            reader.readMessage(msg.value, protoscript.Type._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  DoubleField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.DoubleValue._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.DoubleValue.initialize();
            reader.readMessage(msg.value, protoscript.DoubleValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FloatField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.FloatValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.FloatValue.initialize();
            reader.readMessage(msg.value, protoscript.FloatValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Int64Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Int64Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Int64Value.initialize();
            reader.readMessage(msg.value, protoscript.Int64Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Uint64Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.UInt64Value._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.UInt64Value.initialize();
            reader.readMessage(msg.value, protoscript.UInt64Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Int32Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Int32Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Int32Value.initialize();
            reader.readMessage(msg.value, protoscript.Int32Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Uint32Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.UInt32Value._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.UInt32Value.initialize();
            reader.readMessage(msg.value, protoscript.UInt32Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  BoolField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.BoolValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.BoolValue.initialize();
            reader.readMessage(msg.value, protoscript.BoolValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StringField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.StringValue._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.StringValue.initialize();
            reader.readMessage(msg.value, protoscript.StringValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  BytesField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.BytesValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.BytesValue.initialize();
            reader.readMessage(msg.value, protoscript.BytesValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const TestWellKnownTypesJSON = {
  /**
   * Serializes TestWellKnownTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestWellKnownTypes from JSON.
   */
  decode: function (json) {
    return TestWellKnownTypesJSON._readMessage(
      TestWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: protoscript.AnyJSON.initialize(),
      apiField: protoscript.ApiJSON.initialize(),
      durationField: protoscript.DurationJSON.initialize(),
      emptyField: protoscript.EmptyJSON.initialize(),
      fieldMaskField: protoscript.FieldMaskJSON.initialize(),
      sourceContextField: protoscript.SourceContextJSON.initialize(),
      structField: protoscript.StructJSON.initialize(),
      timestampField: protoscript.TimestampJSON.initialize(),
      typeField: protoscript.TypeJSON.initialize(),
      doubleField: protoscript.DoubleValueJSON.initialize(),
      floatField: protoscript.FloatValueJSON.initialize(),
      int64Field: protoscript.Int64ValueJSON.initialize(),
      uint64Field: protoscript.UInt64ValueJSON.initialize(),
      int32Field: protoscript.Int32ValueJSON.initialize(),
      uint32Field: protoscript.UInt32ValueJSON.initialize(),
      boolField: protoscript.BoolValueJSON.initialize(),
      stringField: protoscript.StringValueJSON.initialize(),
      bytesField: protoscript.BytesValueJSON.initialize(),
      valueField: protoscript.ValueJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.anyField) {
      const _anyField_ = protoscript.AnyJSON._writeMessage(msg.anyField);
      if (Object.keys(_anyField_).length > 0) {
        json["anyField"] = _anyField_;
      }
    }
    if (msg.apiField) {
      const _apiField_ = protoscript.ApiJSON._writeMessage(msg.apiField);
      if (Object.keys(_apiField_).length > 0) {
        json["apiField"] = _apiField_;
      }
    }
    if (msg.durationField) {
      const _durationField_ = protoscript.DurationJSON._writeMessage(
        msg.durationField
      );
      if (Object.keys(_durationField_).length > 0) {
        json["durationField"] = _durationField_;
      }
    }
    if (msg.emptyField) {
      const _emptyField_ = protoscript.EmptyJSON._writeMessage(msg.emptyField);
      if (Object.keys(_emptyField_).length > 0) {
        json["emptyField"] = _emptyField_;
      }
    }
    if (msg.fieldMaskField) {
      const _fieldMaskField_ = protoscript.FieldMaskJSON._writeMessage(
        msg.fieldMaskField
      );
      if (Object.keys(_fieldMaskField_).length > 0) {
        json["fieldMaskField"] = _fieldMaskField_;
      }
    }
    if (msg.sourceContextField) {
      const _sourceContextField_ = protoscript.SourceContextJSON._writeMessage(
        msg.sourceContextField
      );
      if (Object.keys(_sourceContextField_).length > 0) {
        json["sourceContextField"] = _sourceContextField_;
      }
    }
    if (msg.structField) {
      const _structField_ = protoscript.StructJSON._writeMessage(
        msg.structField
      );
      if (Object.keys(_structField_).length > 0) {
        json["structField"] = _structField_;
      }
    }
    if (msg.timestampField) {
      const _timestampField_ = protoscript.TimestampJSON._writeMessage(
        msg.timestampField
      );
      if (Object.keys(_timestampField_).length > 0) {
        json["timestampField"] = _timestampField_;
      }
    }
    if (msg.typeField) {
      const _typeField_ = protoscript.TypeJSON._writeMessage(msg.typeField);
      if (Object.keys(_typeField_).length > 0) {
        json["typeField"] = _typeField_;
      }
    }
    if (msg.doubleField) {
      const _doubleField_ = protoscript.DoubleValueJSON._writeMessage(
        msg.doubleField
      );
      if (Object.keys(_doubleField_).length > 0) {
        json["doubleField"] = _doubleField_;
      }
    }
    if (msg.floatField) {
      const _floatField_ = protoscript.FloatValueJSON._writeMessage(
        msg.floatField
      );
      if (Object.keys(_floatField_).length > 0) {
        json["floatField"] = _floatField_;
      }
    }
    if (msg.int64Field) {
      const _int64Field_ = protoscript.Int64ValueJSON._writeMessage(
        msg.int64Field
      );
      if (Object.keys(_int64Field_).length > 0) {
        json["int64Field"] = _int64Field_;
      }
    }
    if (msg.uint64Field) {
      const _uint64Field_ = protoscript.UInt64ValueJSON._writeMessage(
        msg.uint64Field
      );
      if (Object.keys(_uint64Field_).length > 0) {
        json["uint64Field"] = _uint64Field_;
      }
    }
    if (msg.int32Field) {
      const _int32Field_ = protoscript.Int32ValueJSON._writeMessage(
        msg.int32Field
      );
      if (Object.keys(_int32Field_).length > 0) {
        json["int32Field"] = _int32Field_;
      }
    }
    if (msg.uint32Field) {
      const _uint32Field_ = protoscript.UInt32ValueJSON._writeMessage(
        msg.uint32Field
      );
      if (Object.keys(_uint32Field_).length > 0) {
        json["uint32Field"] = _uint32Field_;
      }
    }
    if (msg.boolField) {
      const _boolField_ = protoscript.BoolValueJSON._writeMessage(
        msg.boolField
      );
      if (Object.keys(_boolField_).length > 0) {
        json["boolField"] = _boolField_;
      }
    }
    if (msg.stringField) {
      const _stringField_ = protoscript.StringValueJSON._writeMessage(
        msg.stringField
      );
      if (Object.keys(_stringField_).length > 0) {
        json["stringField"] = _stringField_;
      }
    }
    if (msg.bytesField) {
      const _bytesField_ = protoscript.BytesValueJSON._writeMessage(
        msg.bytesField
      );
      if (Object.keys(_bytesField_).length > 0) {
        json["bytesField"] = _bytesField_;
      }
    }
    if (msg.valueField) {
      const _valueField_ = protoscript.ValueJSON._writeMessage(msg.valueField);
      if (Object.keys(_valueField_).length > 0) {
        json["valueField"] = _valueField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      const m = protoscript.Any.initialize();
      protoscript.AnyJSON._readMessage(m, _anyField_);
      msg.anyField = m;
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      const m = protoscript.Api.initialize();
      protoscript.ApiJSON._readMessage(m, _apiField_);
      msg.apiField = m;
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      const m = protoscript.Duration.initialize();
      protoscript.DurationJSON._readMessage(m, _durationField_);
      msg.durationField = m;
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      const m = protoscript.Empty.initialize();
      protoscript.EmptyJSON._readMessage(m, _emptyField_);
      msg.emptyField = m;
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      const m = protoscript.FieldMask.initialize();
      protoscript.FieldMaskJSON._readMessage(m, _fieldMaskField_);
      msg.fieldMaskField = m;
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      const m = protoscript.SourceContext.initialize();
      protoscript.SourceContextJSON._readMessage(m, _sourceContextField_);
      msg.sourceContextField = m;
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      const m = protoscript.Struct.initialize();
      protoscript.StructJSON._readMessage(m, _structField_);
      msg.structField = m;
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      const m = protoscript.Timestamp.initialize();
      protoscript.TimestampJSON._readMessage(m, _timestampField_);
      msg.timestampField = m;
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      const m = protoscript.Type.initialize();
      protoscript.TypeJSON._readMessage(m, _typeField_);
      msg.typeField = m;
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      const m = protoscript.DoubleValue.initialize();
      protoscript.DoubleValueJSON._readMessage(m, _doubleField_);
      msg.doubleField = m;
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      const m = protoscript.FloatValue.initialize();
      protoscript.FloatValueJSON._readMessage(m, _floatField_);
      msg.floatField = m;
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      const m = protoscript.Int64Value.initialize();
      protoscript.Int64ValueJSON._readMessage(m, _int64Field_);
      msg.int64Field = m;
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      const m = protoscript.UInt64Value.initialize();
      protoscript.UInt64ValueJSON._readMessage(m, _uint64Field_);
      msg.uint64Field = m;
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      const m = protoscript.Int32Value.initialize();
      protoscript.Int32ValueJSON._readMessage(m, _int32Field_);
      msg.int32Field = m;
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      const m = protoscript.UInt32Value.initialize();
      protoscript.UInt32ValueJSON._readMessage(m, _uint32Field_);
      msg.uint32Field = m;
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      const m = protoscript.BoolValue.initialize();
      protoscript.BoolValueJSON._readMessage(m, _boolField_);
      msg.boolField = m;
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      const m = protoscript.StringValue.initialize();
      protoscript.StringValueJSON._readMessage(m, _stringField_);
      msg.stringField = m;
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      const m = protoscript.BytesValue.initialize();
      protoscript.BytesValueJSON._readMessage(m, _bytesField_);
      msg.bytesField = m;
    }
    const _valueField_ = json["valueField"] ?? json["value_field"];
    if (_valueField_) {
      const m = protoscript.Value.initialize();
      protoscript.ValueJSON._readMessage(m, _valueField_);
      msg.valueField = m;
    }
    return msg;
  },
};

export const RepeatedWellKnownTypesJSON = {
  /**
   * Serializes RepeatedWellKnownTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(RepeatedWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes RepeatedWellKnownTypes from JSON.
   */
  decode: function (json) {
    return RepeatedWellKnownTypesJSON._readMessage(
      RepeatedWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes RepeatedWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: [],
      apiField: [],
      durationField: [],
      emptyField: [],
      fieldMaskField: [],
      sourceContextField: [],
      structField: [],
      timestampField: [],
      typeField: [],
      doubleField: [],
      floatField: [],
      int64Field: [],
      uint64Field: [],
      int32Field: [],
      uint32Field: [],
      boolField: [],
      stringField: [],
      bytesField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.anyField?.length) {
      json["anyField"] = msg.anyField.map(protoscript.AnyJSON._writeMessage);
    }
    if (msg.apiField?.length) {
      json["apiField"] = msg.apiField.map(protoscript.ApiJSON._writeMessage);
    }
    if (msg.durationField?.length) {
      json["durationField"] = msg.durationField.map(
        protoscript.DurationJSON._writeMessage
      );
    }
    if (msg.emptyField?.length) {
      json["emptyField"] = msg.emptyField.map(
        protoscript.EmptyJSON._writeMessage
      );
    }
    if (msg.fieldMaskField?.length) {
      json["fieldMaskField"] = msg.fieldMaskField.map(
        protoscript.FieldMaskJSON._writeMessage
      );
    }
    if (msg.sourceContextField?.length) {
      json["sourceContextField"] = msg.sourceContextField.map(
        protoscript.SourceContextJSON._writeMessage
      );
    }
    if (msg.structField?.length) {
      json["structField"] = msg.structField.map(
        protoscript.StructJSON._writeMessage
      );
    }
    if (msg.timestampField?.length) {
      json["timestampField"] = msg.timestampField.map(
        protoscript.TimestampJSON._writeMessage
      );
    }
    if (msg.typeField?.length) {
      json["typeField"] = msg.typeField.map(protoscript.TypeJSON._writeMessage);
    }
    if (msg.doubleField?.length) {
      json["doubleField"] = msg.doubleField.map(
        protoscript.DoubleValueJSON._writeMessage
      );
    }
    if (msg.floatField?.length) {
      json["floatField"] = msg.floatField.map(
        protoscript.FloatValueJSON._writeMessage
      );
    }
    if (msg.int64Field?.length) {
      json["int64Field"] = msg.int64Field.map(
        protoscript.Int64ValueJSON._writeMessage
      );
    }
    if (msg.uint64Field?.length) {
      json["uint64Field"] = msg.uint64Field.map(
        protoscript.UInt64ValueJSON._writeMessage
      );
    }
    if (msg.int32Field?.length) {
      json["int32Field"] = msg.int32Field.map(
        protoscript.Int32ValueJSON._writeMessage
      );
    }
    if (msg.uint32Field?.length) {
      json["uint32Field"] = msg.uint32Field.map(
        protoscript.UInt32ValueJSON._writeMessage
      );
    }
    if (msg.boolField?.length) {
      json["boolField"] = msg.boolField.map(
        protoscript.BoolValueJSON._writeMessage
      );
    }
    if (msg.stringField?.length) {
      json["stringField"] = msg.stringField.map(
        protoscript.StringValueJSON._writeMessage
      );
    }
    if (msg.bytesField?.length) {
      json["bytesField"] = msg.bytesField.map(
        protoscript.BytesValueJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      for (const item of _anyField_) {
        const m = protoscript.Any.initialize();
        protoscript.AnyJSON._readMessage(m, item);
        msg.anyField.push(m);
      }
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      for (const item of _apiField_) {
        const m = protoscript.Api.initialize();
        protoscript.ApiJSON._readMessage(m, item);
        msg.apiField.push(m);
      }
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      for (const item of _durationField_) {
        const m = protoscript.Duration.initialize();
        protoscript.DurationJSON._readMessage(m, item);
        msg.durationField.push(m);
      }
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      for (const item of _emptyField_) {
        const m = protoscript.Empty.initialize();
        protoscript.EmptyJSON._readMessage(m, item);
        msg.emptyField.push(m);
      }
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      for (const item of _fieldMaskField_) {
        const m = protoscript.FieldMask.initialize();
        protoscript.FieldMaskJSON._readMessage(m, item);
        msg.fieldMaskField.push(m);
      }
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      for (const item of _sourceContextField_) {
        const m = protoscript.SourceContext.initialize();
        protoscript.SourceContextJSON._readMessage(m, item);
        msg.sourceContextField.push(m);
      }
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      for (const item of _structField_) {
        const m = protoscript.Struct.initialize();
        protoscript.StructJSON._readMessage(m, item);
        msg.structField.push(m);
      }
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      for (const item of _timestampField_) {
        const m = protoscript.Timestamp.initialize();
        protoscript.TimestampJSON._readMessage(m, item);
        msg.timestampField.push(m);
      }
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      for (const item of _typeField_) {
        const m = protoscript.Type.initialize();
        protoscript.TypeJSON._readMessage(m, item);
        msg.typeField.push(m);
      }
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      for (const item of _doubleField_) {
        const m = protoscript.DoubleValue.initialize();
        protoscript.DoubleValueJSON._readMessage(m, item);
        msg.doubleField.push(m);
      }
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      for (const item of _floatField_) {
        const m = protoscript.FloatValue.initialize();
        protoscript.FloatValueJSON._readMessage(m, item);
        msg.floatField.push(m);
      }
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      for (const item of _int64Field_) {
        const m = protoscript.Int64Value.initialize();
        protoscript.Int64ValueJSON._readMessage(m, item);
        msg.int64Field.push(m);
      }
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      for (const item of _uint64Field_) {
        const m = protoscript.UInt64Value.initialize();
        protoscript.UInt64ValueJSON._readMessage(m, item);
        msg.uint64Field.push(m);
      }
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      for (const item of _int32Field_) {
        const m = protoscript.Int32Value.initialize();
        protoscript.Int32ValueJSON._readMessage(m, item);
        msg.int32Field.push(m);
      }
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      for (const item of _uint32Field_) {
        const m = protoscript.UInt32Value.initialize();
        protoscript.UInt32ValueJSON._readMessage(m, item);
        msg.uint32Field.push(m);
      }
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      for (const item of _boolField_) {
        const m = protoscript.BoolValue.initialize();
        protoscript.BoolValueJSON._readMessage(m, item);
        msg.boolField.push(m);
      }
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      for (const item of _stringField_) {
        const m = protoscript.StringValue.initialize();
        protoscript.StringValueJSON._readMessage(m, item);
        msg.stringField.push(m);
      }
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      for (const item of _bytesField_) {
        const m = protoscript.BytesValue.initialize();
        protoscript.BytesValueJSON._readMessage(m, item);
        msg.bytesField.push(m);
      }
    }
    return msg;
  },
};

export const OneofWellKnownTypesJSON = {
  /**
   * Serializes OneofWellKnownTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(OneofWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneofWellKnownTypes from JSON.
   */
  decode: function (json) {
    return OneofWellKnownTypesJSON._readMessage(
      OneofWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OneofWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: undefined,
      apiField: undefined,
      durationField: undefined,
      emptyField: undefined,
      fieldMaskField: undefined,
      sourceContextField: undefined,
      structField: undefined,
      timestampField: undefined,
      typeField: undefined,
      doubleField: undefined,
      floatField: undefined,
      int64Field: undefined,
      uint64Field: undefined,
      int32Field: undefined,
      uint32Field: undefined,
      boolField: undefined,
      stringField: undefined,
      bytesField: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.anyField != undefined) {
      const _anyField_ = protoscript.AnyJSON._writeMessage(msg.anyField);
      json["anyField"] = _anyField_;
    }
    if (msg.apiField != undefined) {
      const _apiField_ = protoscript.ApiJSON._writeMessage(msg.apiField);
      json["apiField"] = _apiField_;
    }
    if (msg.durationField != undefined) {
      const _durationField_ = protoscript.DurationJSON._writeMessage(
        msg.durationField
      );
      json["durationField"] = _durationField_;
    }
    if (msg.emptyField != undefined) {
      const _emptyField_ = protoscript.EmptyJSON._writeMessage(msg.emptyField);
      json["emptyField"] = _emptyField_;
    }
    if (msg.fieldMaskField != undefined) {
      const _fieldMaskField_ = protoscript.FieldMaskJSON._writeMessage(
        msg.fieldMaskField
      );
      json["fieldMaskField"] = _fieldMaskField_;
    }
    if (msg.sourceContextField != undefined) {
      const _sourceContextField_ = protoscript.SourceContextJSON._writeMessage(
        msg.sourceContextField
      );
      json["sourceContextField"] = _sourceContextField_;
    }
    if (msg.structField != undefined) {
      const _structField_ = protoscript.StructJSON._writeMessage(
        msg.structField
      );
      json["structField"] = _structField_;
    }
    if (msg.timestampField != undefined) {
      const _timestampField_ = protoscript.TimestampJSON._writeMessage(
        msg.timestampField
      );
      json["timestampField"] = _timestampField_;
    }
    if (msg.typeField != undefined) {
      const _typeField_ = protoscript.TypeJSON._writeMessage(msg.typeField);
      json["typeField"] = _typeField_;
    }
    if (msg.doubleField != undefined) {
      const _doubleField_ = protoscript.DoubleValueJSON._writeMessage(
        msg.doubleField
      );
      json["doubleField"] = _doubleField_;
    }
    if (msg.floatField != undefined) {
      const _floatField_ = protoscript.FloatValueJSON._writeMessage(
        msg.floatField
      );
      json["floatField"] = _floatField_;
    }
    if (msg.int64Field != undefined) {
      const _int64Field_ = protoscript.Int64ValueJSON._writeMessage(
        msg.int64Field
      );
      json["int64Field"] = _int64Field_;
    }
    if (msg.uint64Field != undefined) {
      const _uint64Field_ = protoscript.UInt64ValueJSON._writeMessage(
        msg.uint64Field
      );
      json["uint64Field"] = _uint64Field_;
    }
    if (msg.int32Field != undefined) {
      const _int32Field_ = protoscript.Int32ValueJSON._writeMessage(
        msg.int32Field
      );
      json["int32Field"] = _int32Field_;
    }
    if (msg.uint32Field != undefined) {
      const _uint32Field_ = protoscript.UInt32ValueJSON._writeMessage(
        msg.uint32Field
      );
      json["uint32Field"] = _uint32Field_;
    }
    if (msg.boolField != undefined) {
      const _boolField_ = protoscript.BoolValueJSON._writeMessage(
        msg.boolField
      );
      json["boolField"] = _boolField_;
    }
    if (msg.stringField != undefined) {
      const _stringField_ = protoscript.StringValueJSON._writeMessage(
        msg.stringField
      );
      json["stringField"] = _stringField_;
    }
    if (msg.bytesField != undefined) {
      const _bytesField_ = protoscript.BytesValueJSON._writeMessage(
        msg.bytesField
      );
      json["bytesField"] = _bytesField_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      const m = protoscript.Any.initialize();
      protoscript.AnyJSON._readMessage(m, _anyField_);
      msg.anyField = m;
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      const m = protoscript.Api.initialize();
      protoscript.ApiJSON._readMessage(m, _apiField_);
      msg.apiField = m;
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      const m = protoscript.Duration.initialize();
      protoscript.DurationJSON._readMessage(m, _durationField_);
      msg.durationField = m;
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      const m = protoscript.Empty.initialize();
      protoscript.EmptyJSON._readMessage(m, _emptyField_);
      msg.emptyField = m;
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      const m = protoscript.FieldMask.initialize();
      protoscript.FieldMaskJSON._readMessage(m, _fieldMaskField_);
      msg.fieldMaskField = m;
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      const m = protoscript.SourceContext.initialize();
      protoscript.SourceContextJSON._readMessage(m, _sourceContextField_);
      msg.sourceContextField = m;
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      const m = protoscript.Struct.initialize();
      protoscript.StructJSON._readMessage(m, _structField_);
      msg.structField = m;
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      const m = protoscript.Timestamp.initialize();
      protoscript.TimestampJSON._readMessage(m, _timestampField_);
      msg.timestampField = m;
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      const m = protoscript.Type.initialize();
      protoscript.TypeJSON._readMessage(m, _typeField_);
      msg.typeField = m;
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      const m = protoscript.DoubleValue.initialize();
      protoscript.DoubleValueJSON._readMessage(m, _doubleField_);
      msg.doubleField = m;
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      const m = protoscript.FloatValue.initialize();
      protoscript.FloatValueJSON._readMessage(m, _floatField_);
      msg.floatField = m;
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      const m = protoscript.Int64Value.initialize();
      protoscript.Int64ValueJSON._readMessage(m, _int64Field_);
      msg.int64Field = m;
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      const m = protoscript.UInt64Value.initialize();
      protoscript.UInt64ValueJSON._readMessage(m, _uint64Field_);
      msg.uint64Field = m;
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      const m = protoscript.Int32Value.initialize();
      protoscript.Int32ValueJSON._readMessage(m, _int32Field_);
      msg.int32Field = m;
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      const m = protoscript.UInt32Value.initialize();
      protoscript.UInt32ValueJSON._readMessage(m, _uint32Field_);
      msg.uint32Field = m;
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      const m = protoscript.BoolValue.initialize();
      protoscript.BoolValueJSON._readMessage(m, _boolField_);
      msg.boolField = m;
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      const m = protoscript.StringValue.initialize();
      protoscript.StringValueJSON._readMessage(m, _stringField_);
      msg.stringField = m;
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      const m = protoscript.BytesValue.initialize();
      protoscript.BytesValueJSON._readMessage(m, _bytesField_);
      msg.bytesField = m;
    }
    return msg;
  },
};

export const MapWellKnownTypesJSON = {
  /**
   * Serializes MapWellKnownTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(MapWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes MapWellKnownTypes from JSON.
   */
  decode: function (json) {
    return MapWellKnownTypesJSON._readMessage(
      MapWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MapWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: {},
      apiField: {},
      durationField: {},
      emptyField: {},
      fieldMaskField: {},
      sourceContextField: {},
      structField: {},
      timestampField: {},
      typeField: {},
      doubleField: {},
      floatField: {},
      int64Field: {},
      uint64Field: {},
      int32Field: {},
      uint32Field: {},
      boolField: {},
      stringField: {},
      bytesField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.anyField) {
      const _anyField_ = Object.fromEntries(
        Object.entries(msg.anyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.AnyField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_anyField_).length > 0) {
        json["anyField"] = _anyField_;
      }
    }
    if (msg.apiField) {
      const _apiField_ = Object.fromEntries(
        Object.entries(msg.apiField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.ApiField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_apiField_).length > 0) {
        json["apiField"] = _apiField_;
      }
    }
    if (msg.durationField) {
      const _durationField_ = Object.fromEntries(
        Object.entries(msg.durationField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.DurationField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_durationField_).length > 0) {
        json["durationField"] = _durationField_;
      }
    }
    if (msg.emptyField) {
      const _emptyField_ = Object.fromEntries(
        Object.entries(msg.emptyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.EmptyField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_emptyField_).length > 0) {
        json["emptyField"] = _emptyField_;
      }
    }
    if (msg.fieldMaskField) {
      const _fieldMaskField_ = Object.fromEntries(
        Object.entries(msg.fieldMaskField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.FieldMaskField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_fieldMaskField_).length > 0) {
        json["fieldMaskField"] = _fieldMaskField_;
      }
    }
    if (msg.sourceContextField) {
      const _sourceContextField_ = Object.fromEntries(
        Object.entries(msg.sourceContextField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.SourceContextField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_sourceContextField_).length > 0) {
        json["sourceContextField"] = _sourceContextField_;
      }
    }
    if (msg.structField) {
      const _structField_ = Object.fromEntries(
        Object.entries(msg.structField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.StructField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_structField_).length > 0) {
        json["structField"] = _structField_;
      }
    }
    if (msg.timestampField) {
      const _timestampField_ = Object.fromEntries(
        Object.entries(msg.timestampField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.TimestampField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_timestampField_).length > 0) {
        json["timestampField"] = _timestampField_;
      }
    }
    if (msg.typeField) {
      const _typeField_ = Object.fromEntries(
        Object.entries(msg.typeField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.TypeField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_typeField_).length > 0) {
        json["typeField"] = _typeField_;
      }
    }
    if (msg.doubleField) {
      const _doubleField_ = Object.fromEntries(
        Object.entries(msg.doubleField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.DoubleField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_doubleField_).length > 0) {
        json["doubleField"] = _doubleField_;
      }
    }
    if (msg.floatField) {
      const _floatField_ = Object.fromEntries(
        Object.entries(msg.floatField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.FloatField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_floatField_).length > 0) {
        json["floatField"] = _floatField_;
      }
    }
    if (msg.int64Field) {
      const _int64Field_ = Object.fromEntries(
        Object.entries(msg.int64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Int64Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_int64Field_).length > 0) {
        json["int64Field"] = _int64Field_;
      }
    }
    if (msg.uint64Field) {
      const _uint64Field_ = Object.fromEntries(
        Object.entries(msg.uint64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Uint64Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_uint64Field_).length > 0) {
        json["uint64Field"] = _uint64Field_;
      }
    }
    if (msg.int32Field) {
      const _int32Field_ = Object.fromEntries(
        Object.entries(msg.int32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Int32Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_int32Field_).length > 0) {
        json["int32Field"] = _int32Field_;
      }
    }
    if (msg.uint32Field) {
      const _uint32Field_ = Object.fromEntries(
        Object.entries(msg.uint32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Uint32Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_uint32Field_).length > 0) {
        json["uint32Field"] = _uint32Field_;
      }
    }
    if (msg.boolField) {
      const _boolField_ = Object.fromEntries(
        Object.entries(msg.boolField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.BoolField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_boolField_).length > 0) {
        json["boolField"] = _boolField_;
      }
    }
    if (msg.stringField) {
      const _stringField_ = Object.fromEntries(
        Object.entries(msg.stringField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.StringField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_stringField_).length > 0) {
        json["stringField"] = _stringField_;
      }
    }
    if (msg.bytesField) {
      const _bytesField_ = Object.fromEntries(
        Object.entries(msg.bytesField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.BytesField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_bytesField_).length > 0) {
        json["bytesField"] = _bytesField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      msg.anyField = Object.fromEntries(
        Object.entries(_anyField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.AnyField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      msg.apiField = Object.fromEntries(
        Object.entries(_apiField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.ApiField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      msg.durationField = Object.fromEntries(
        Object.entries(_durationField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.DurationField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      msg.emptyField = Object.fromEntries(
        Object.entries(_emptyField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.EmptyField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      msg.fieldMaskField = Object.fromEntries(
        Object.entries(_fieldMaskField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.FieldMaskField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      msg.sourceContextField = Object.fromEntries(
        Object.entries(_sourceContextField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.SourceContextField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      msg.structField = Object.fromEntries(
        Object.entries(_structField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.StructField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      msg.timestampField = Object.fromEntries(
        Object.entries(_timestampField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.TimestampField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      msg.typeField = Object.fromEntries(
        Object.entries(_typeField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.TypeField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      msg.doubleField = Object.fromEntries(
        Object.entries(_doubleField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.DoubleField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      msg.floatField = Object.fromEntries(
        Object.entries(_floatField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.FloatField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      msg.int64Field = Object.fromEntries(
        Object.entries(_int64Field_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Int64Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      msg.uint64Field = Object.fromEntries(
        Object.entries(_uint64Field_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Uint64Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      msg.int32Field = Object.fromEntries(
        Object.entries(_int32Field_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Int32Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      msg.uint32Field = Object.fromEntries(
        Object.entries(_uint32Field_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.Uint32Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      msg.boolField = Object.fromEntries(
        Object.entries(_boolField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.BoolField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      msg.stringField = Object.fromEntries(
        Object.entries(_stringField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.StringField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      msg.bytesField = Object.fromEntries(
        Object.entries(_bytesField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypesJSON.BytesField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  AnyField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.AnyJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Any.initialize();
        protoscript.AnyJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  ApiField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.ApiJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Api.initialize();
        protoscript.ApiJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  DurationField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.DurationJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Duration.initialize();
        protoscript.DurationJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  EmptyField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.EmptyJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Empty.initialize();
        protoscript.EmptyJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  FieldMaskField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.FieldMaskJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.FieldMask.initialize();
        protoscript.FieldMaskJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  SourceContextField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.SourceContextJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.SourceContext.initialize();
        protoscript.SourceContextJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  StructField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.StructJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Struct.initialize();
        protoscript.StructJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  TimestampField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.TimestampJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Timestamp.initialize();
        protoscript.TimestampJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  TypeField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.TypeJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Type.initialize();
        protoscript.TypeJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  DoubleField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.DoubleValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.DoubleValue.initialize();
        protoscript.DoubleValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  FloatField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.FloatValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.FloatValue.initialize();
        protoscript.FloatValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Int64Field: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.Int64ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Int64Value.initialize();
        protoscript.Int64ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint64Field: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.UInt64ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.UInt64Value.initialize();
        protoscript.UInt64ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Int32Field: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.Int32ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Int32Value.initialize();
        protoscript.Int32ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint32Field: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.UInt32ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.UInt32Value.initialize();
        protoscript.UInt32ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  BoolField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.BoolValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.BoolValue.initialize();
        protoscript.BoolValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  StringField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.StringValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.StringValue.initialize();
        protoscript.StringValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  BytesField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.BytesValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.BytesValue.initialize();
        protoscript.BytesValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "google/protobuf/unittest_proto3.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto
/* eslint-disable */

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";

import * as googleProtobufUnittest_import from "./unittest_import.pb.js";
import * as googleProtobufUnittest_import_public from "./unittest_import_public.pb.js";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: "FOREIGN_ZERO",
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "FOREIGN_ZERO";
      }
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOREIGN_ZERO": {
        return 0;
      }
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestAllTypes = {
  /**
   * Serializes TestAllTypes to protobuf.
   */
  encode: function (msg) {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64String(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
      );
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        googleProtobufUnittest_import_public.PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        40,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writePackedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnum._toInt)
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            googleProtobufUnittest_import_public.PublicImportMessage
              ._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 32: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 33: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 34: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 35: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 36: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 37: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 38: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 39: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 40: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 41: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 42: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 43: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = googleProtobufUnittest_import.ImportMessage.initialize();
          reader.readMessage(
            m,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt)
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 52: {
          if (reader.isDelimited()) {
            msg.repeatedForeignEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.repeatedForeignEnum.push(
              ForeignEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          msg.oneofNestedMessage = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    ZERO: "ZERO",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 0: {
          return "ZERO";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "ZERO": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes TestPackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString())
      );
    }
    if (msg.packedUint32?.length) {
      writer.writePackedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString())
      );
    }
    if (msg.packedSint32?.length) {
      writer.writePackedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString())
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writePackedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString())
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.packedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.packedFloat?.length) {
      writer.writePackedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writePackedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writePackedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writePackedEnum(103, msg.packedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.packedInt64.push(...reader.readPackedInt64String().map(BigInt));
          } else {
            msg.packedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.packedUint32.push(...reader.readPackedUint32());
          } else {
            msg.packedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.packedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.packedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.packedSint32.push(...reader.readPackedSint32());
          } else {
            msg.packedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.packedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.packedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.packedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.packedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.packedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.packedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.packedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.packedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.packedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.packedFloat.push(...reader.readPackedFloat());
          } else {
            msg.packedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.packedDouble.push(...reader.readPackedDouble());
          } else {
            msg.packedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.packedBool.push(...reader.readPackedBool());
          } else {
            msg.packedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.packedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.packedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes TestUnpackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        2,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        4,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        6,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        8,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        10,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        14,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt)
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 2: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 3: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 4: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 5: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 6: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 7: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 8: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 9: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 10: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 11: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 12: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 13: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 14: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt)
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes NestedTestAllTypes to protobuf.
   */
  encode: function (msg) {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes ForeignMessage to protobuf.
   */
  encode: function (msg) {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes TestEmptyMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes TestMessageWithDummy to protobuf.
   */
  encode: function (msg) {
    return TestMessageWithDummy._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMessageWithDummy from protobuf.
   */
  decode: function (bytes) {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function () {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes TestOneof2 to protobuf.
   */
  encode: function (msg) {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooEnum: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnum._toInt(msg.fooEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    UNKNOWN: "UNKNOWN",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 0: {
          return "UNKNOWN";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "UNKNOWN": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ForeignEnumJSON = {
  FOREIGN_ZERO: "FOREIGN_ZERO",
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "FOREIGN_ZERO";
      }
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOREIGN_ZERO": {
        return 0;
      }
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestAllTypesJSON = {
  /**
   * Serializes TestAllTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestAllTypes from JSON.
   */
  decode: function (json) {
    return TestAllTypesJSON._readMessage(
      TestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessageJSON.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessageJSON.initialize(),
      optionalLazyMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalLazyImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json["optionalInt64"] = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json["optionalUint32"] = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json["optionalUint64"] = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json["optionalSint32"] = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json["optionalSint64"] = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json["optionalFixed32"] = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json["optionalFixed64"] = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json["optionalSfixed32"] = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json["optionalSfixed64"] = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json["optionalFloat"] = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json["optionalDouble"] = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json["optionalBool"] = msg.optionalBool;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalNestedMessage);
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    if (msg.optionalForeignMessage) {
      const _optionalForeignMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalForeignMessage
      );
      if (Object.keys(_optionalForeignMessage_).length > 0) {
        json["optionalForeignMessage"] = _optionalForeignMessage_;
      }
    }
    if (msg.optionalImportMessage) {
      const _optionalImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalImportMessage
        );
      if (Object.keys(_optionalImportMessage_).length > 0) {
        json["optionalImportMessage"] = _optionalImportMessage_;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      json["optionalNestedEnum"] = msg.optionalNestedEnum;
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json["optionalStringPiece"] = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json["optionalCord"] = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const _optionalPublicImportMessage_ =
        googleProtobufUnittest_import_public.PublicImportMessageJSON._writeMessage(
          msg.optionalPublicImportMessage
        );
      if (Object.keys(_optionalPublicImportMessage_).length > 0) {
        json["optionalPublicImportMessage"] = _optionalPublicImportMessage_;
      }
    }
    if (msg.optionalLazyMessage) {
      const _optionalLazyMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalLazyMessage);
      if (Object.keys(_optionalLazyMessage_).length > 0) {
        json["optionalLazyMessage"] = _optionalLazyMessage_;
      }
    }
    if (msg.optionalLazyImportMessage) {
      const _optionalLazyImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalLazyImportMessage
        );
      if (Object.keys(_optionalLazyImportMessage_).length > 0) {
        json["optionalLazyImportMessage"] = _optionalLazyImportMessage_;
      }
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json["repeatedString"] = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json["repeatedBytes"] = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json["repeatedNestedMessage"] = msg.repeatedNestedMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json["repeatedForeignMessage"] = msg.repeatedForeignMessage.map(
        ForeignMessageJSON._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json["repeatedImportMessage"] = msg.repeatedImportMessage.map(
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json["repeatedForeignEnum"] = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json["repeatedStringPiece"] = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json["repeatedCord"] = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json["repeatedLazyMessage"] = msg.repeatedLazyMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const _oneofNestedMessage_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.oneofNestedMessage
      );
      json["oneofNestedMessage"] = _oneofNestedMessage_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _optionalInt64_ = json["optionalInt64"] ?? json["optional_int64"];
    if (_optionalInt64_) {
      msg.optionalInt64 = BigInt(_optionalInt64_);
    }
    const _optionalUint32_ = json["optionalUint32"] ?? json["optional_uint32"];
    if (_optionalUint32_) {
      msg.optionalUint32 = _optionalUint32_;
    }
    const _optionalUint64_ = json["optionalUint64"] ?? json["optional_uint64"];
    if (_optionalUint64_) {
      msg.optionalUint64 = BigInt(_optionalUint64_);
    }
    const _optionalSint32_ = json["optionalSint32"] ?? json["optional_sint32"];
    if (_optionalSint32_) {
      msg.optionalSint32 = _optionalSint32_;
    }
    const _optionalSint64_ = json["optionalSint64"] ?? json["optional_sint64"];
    if (_optionalSint64_) {
      msg.optionalSint64 = BigInt(_optionalSint64_);
    }
    const _optionalFixed32_ =
      json["optionalFixed32"] ?? json["optional_fixed32"];
    if (_optionalFixed32_) {
      msg.optionalFixed32 = _optionalFixed32_;
    }
    const _optionalFixed64_ =
      json["optionalFixed64"] ?? json["optional_fixed64"];
    if (_optionalFixed64_) {
      msg.optionalFixed64 = BigInt(_optionalFixed64_);
    }
    const _optionalSfixed32_ =
      json["optionalSfixed32"] ?? json["optional_sfixed32"];
    if (_optionalSfixed32_) {
      msg.optionalSfixed32 = _optionalSfixed32_;
    }
    const _optionalSfixed64_ =
      json["optionalSfixed64"] ?? json["optional_sfixed64"];
    if (_optionalSfixed64_) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64_);
    }
    const _optionalFloat_ = json["optionalFloat"] ?? json["optional_float"];
    if (_optionalFloat_) {
      msg.optionalFloat = _optionalFloat_;
    }
    const _optionalDouble_ = json["optionalDouble"] ?? json["optional_double"];
    if (_optionalDouble_) {
      msg.optionalDouble = _optionalDouble_;
    }
    const _optionalBool_ = json["optionalBool"] ?? json["optional_bool"];
    if (_optionalBool_) {
      msg.optionalBool = _optionalBool_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalNestedMessage_);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage_ =
      json["optionalForeignMessage"] ?? json["optional_foreign_message"];
    if (_optionalForeignMessage_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _optionalForeignMessage_);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage_ =
      json["optionalImportMessage"] ?? json["optional_import_message"];
    if (_optionalImportMessage_) {
      const m = googleProtobufUnittest_import.ImportMessage.initialize();
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        m,
        _optionalImportMessage_
      );
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum_ =
      json["optionalNestedEnum"] ?? json["optional_nested_enum"];
    if (_optionalNestedEnum_) {
      msg.optionalNestedEnum = _optionalNestedEnum_;
    }
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    const _optionalStringPiece_ =
      json["optionalStringPiece"] ?? json["optional_string_piece"];
    if (_optionalStringPiece_) {
      msg.optionalStringPiece = _optionalStringPiece_;
    }
    const _optionalCord_ = json["optionalCord"] ?? json["optional_cord"];
    if (_optionalCord_) {
      msg.optionalCord = _optionalCord_;
    }
    const _optionalPublicImportMessage_ =
      json["optionalPublicImportMessage"] ??
      json["optional_public_import_message"];
    if (_optionalPublicImportMessage_) {
      const m =
        googleProtobufUnittest_import_public.PublicImportMessage.initialize();
      googleProtobufUnittest_import_public.PublicImportMessageJSON._readMessage(
        m,
        _optionalPublicImportMessage_
      );
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage_ =
      json["optionalLazyMessage"] ?? json["optional_lazy_message"];
    if (_optionalLazyMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalLazyMessage_);
      msg.optionalLazyMessage = m;
    }
    const _optionalLazyImportMessage_ =
      json["optionalLazyImportMessage"] ?? json["optional_lazy_import_message"];
    if (_optionalLazyImportMessage_) {
      const m = googleProtobufUnittest_import.ImportMessage.initialize();
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        m,
        _optionalLazyImportMessage_
      );
      msg.optionalLazyImportMessage = m;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedString_ = json["repeatedString"] ?? json["repeated_string"];
    if (_repeatedString_) {
      msg.repeatedString = _repeatedString_;
    }
    const _repeatedBytes_ = json["repeatedBytes"] ?? json["repeated_bytes"];
    if (_repeatedBytes_) {
      msg.repeatedBytes = _repeatedBytes_.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage_ =
      json["repeatedNestedMessage"] ?? json["repeated_nested_message"];
    if (_repeatedNestedMessage_) {
      for (const item of _repeatedNestedMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage_ =
      json["repeatedForeignMessage"] ?? json["repeated_foreign_message"];
    if (_repeatedForeignMessage_) {
      for (const item of _repeatedForeignMessage_) {
        const m = ForeignMessage.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage_ =
      json["repeatedImportMessage"] ?? json["repeated_import_message"];
    if (_repeatedImportMessage_) {
      for (const item of _repeatedImportMessage_) {
        const m = googleProtobufUnittest_import.ImportMessage.initialize();
        googleProtobufUnittest_import.ImportMessageJSON._readMessage(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    const _repeatedForeignEnum_ =
      json["repeatedForeignEnum"] ?? json["repeated_foreign_enum"];
    if (_repeatedForeignEnum_) {
      msg.repeatedForeignEnum = _repeatedForeignEnum_;
    }
    const _repeatedStringPiece_ =
      json["repeatedStringPiece"] ?? json["repeated_string_piece"];
    if (_repeatedStringPiece_) {
      msg.repeatedStringPiece = _repeatedStringPiece_;
    }
    const _repeatedCord_ = json["repeatedCord"] ?? json["repeated_cord"];
    if (_repeatedCord_) {
      msg.repeatedCord = _repeatedCord_;
    }
    const _repeatedLazyMessage_ =
      json["repeatedLazyMessage"] ?? json["repeated_lazy_message"];
    if (_repeatedLazyMessage_) {
      for (const item of _repeatedLazyMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofNestedMessage_ =
      json["oneofNestedMessage"] ?? json["oneof_nested_message"];
    if (_oneofNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _oneofNestedMessage_);
      msg.oneofNestedMessage = m;
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  NestedEnum: {
    ZERO: "ZERO",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 0: {
          return "ZERO";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "ZERO": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestAllTypesJSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestAllTypesJSON.NestedMessage._readMessage(
        TestAllTypesJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },
};

export const TestPackedTypesJSON = {
  /**
   * Serializes TestPackedTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestPackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestPackedTypes from JSON.
   */
  decode: function (json) {
    return TestPackedTypesJSON._readMessage(
      TestPackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json["packedInt64"] = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json["packedUint32"] = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json["packedUint64"] = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json["packedSint32"] = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json["packedSint64"] = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json["packedFixed32"] = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json["packedFixed64"] = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json["packedSfixed32"] = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json["packedSfixed64"] = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json["packedFloat"] = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json["packedDouble"] = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json["packedBool"] = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json["packedEnum"] = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _packedInt64_ = json["packedInt64"] ?? json["packed_int64"];
    if (_packedInt64_) {
      msg.packedInt64 = _packedInt64_.map(BigInt);
    }
    const _packedUint32_ = json["packedUint32"] ?? json["packed_uint32"];
    if (_packedUint32_) {
      msg.packedUint32 = _packedUint32_;
    }
    const _packedUint64_ = json["packedUint64"] ?? json["packed_uint64"];
    if (_packedUint64_) {
      msg.packedUint64 = _packedUint64_.map(BigInt);
    }
    const _packedSint32_ = json["packedSint32"] ?? json["packed_sint32"];
    if (_packedSint32_) {
      msg.packedSint32 = _packedSint32_;
    }
    const _packedSint64_ = json["packedSint64"] ?? json["packed_sint64"];
    if (_packedSint64_) {
      msg.packedSint64 = _packedSint64_.map(BigInt);
    }
    const _packedFixed32_ = json["packedFixed32"] ?? json["packed_fixed32"];
    if (_packedFixed32_) {
      msg.packedFixed32 = _packedFixed32_;
    }
    const _packedFixed64_ = json["packedFixed64"] ?? json["packed_fixed64"];
    if (_packedFixed64_) {
      msg.packedFixed64 = _packedFixed64_.map(BigInt);
    }
    const _packedSfixed32_ = json["packedSfixed32"] ?? json["packed_sfixed32"];
    if (_packedSfixed32_) {
      msg.packedSfixed32 = _packedSfixed32_;
    }
    const _packedSfixed64_ = json["packedSfixed64"] ?? json["packed_sfixed64"];
    if (_packedSfixed64_) {
      msg.packedSfixed64 = _packedSfixed64_.map(BigInt);
    }
    const _packedFloat_ = json["packedFloat"] ?? json["packed_float"];
    if (_packedFloat_) {
      msg.packedFloat = _packedFloat_;
    }
    const _packedDouble_ = json["packedDouble"] ?? json["packed_double"];
    if (_packedDouble_) {
      msg.packedDouble = _packedDouble_;
    }
    const _packedBool_ = json["packedBool"] ?? json["packed_bool"];
    if (_packedBool_) {
      msg.packedBool = _packedBool_;
    }
    const _packedEnum_ = json["packedEnum"] ?? json["packed_enum"];
    if (_packedEnum_) {
      msg.packedEnum = _packedEnum_;
    }
    return msg;
  },
};

export const TestUnpackedTypesJSON = {
  /**
   * Serializes TestUnpackedTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestUnpackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestUnpackedTypes from JSON.
   */
  decode: function (json) {
    return TestUnpackedTypesJSON._readMessage(
      TestUnpackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    return msg;
  },
};

export const NestedTestAllTypesJSON = {
  /**
   * Serializes NestedTestAllTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(NestedTestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes NestedTestAllTypes from JSON.
   */
  decode: function (json) {
    return NestedTestAllTypesJSON._readMessage(
      NestedTestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypesJSON.initialize(),
      payload: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.child) {
      const _child_ = NestedTestAllTypesJSON._writeMessage(msg.child);
      if (Object.keys(_child_).length > 0) {
        json["child"] = _child_;
      }
    }
    if (msg.payload) {
      const _payload_ = TestAllTypesJSON._writeMessage(msg.payload);
      if (Object.keys(_payload_).length > 0) {
        json["payload"] = _payload_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _child_ = json["child"];
    if (_child_) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypesJSON._readMessage(m, _child_);
      msg.child = m;
    }
    const _payload_ = json["payload"];
    if (_payload_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _payload_);
      msg.payload = m;
    }
    return msg;
  },
};

export const ForeignMessageJSON = {
  /**
   * Serializes ForeignMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(ForeignMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ForeignMessage from JSON.
   */
  decode: function (json) {
    return ForeignMessageJSON._readMessage(
      ForeignMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.c) {
      json["c"] = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    return msg;
  },
};

export const TestEmptyMessageJSON = {
  /**
   * Serializes TestEmptyMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestMessageWithDummyJSON = {
  /**
   * Serializes TestMessageWithDummy to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMessageWithDummyJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMessageWithDummy from JSON.
   */
  decode: function (json) {
    return TestMessageWithDummyJSON._readMessage(
      TestMessageWithDummyJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function () {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.dummy) {
      json["dummy"] = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _dummy_ = json["dummy"];
    if (_dummy_) {
      msg.dummy = _dummy_;
    }
    return msg;
  },
};

export const TestOneof2JSON = {
  /**
   * Serializes TestOneof2 to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestOneof2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof2 from JSON.
   */
  decode: function (json) {
    return TestOneof2JSON._readMessage(
      TestOneof2JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooEnum: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooEnum != undefined) {
      json["fooEnum"] = msg.fooEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooEnum_ = json["fooEnum"] ?? json["foo_enum"];
    if (_fooEnum_) {
      msg.fooEnum = _fooEnum_;
    }
    return msg;
  },

  NestedEnum: {
    UNKNOWN: "UNKNOWN",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 0: {
          return "UNKNOWN";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "UNKNOWN": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
    ],
  },
}
`;

exports[`TwirpScript Compiler generates TypeScript 1`] = `
{
  "array": [
    ,
    1,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    [
      [
        "twirpscript/services.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: twirpscript/services.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

/**
 * Size of a Hat, in inches.
 */
export interface Req {}

export declare namespace Req {
  export interface MakeHat {
    inches: number;
  }
}

/**
 * A Hat is a piece of headwear made by a Haberdasher.
 */
export interface Hat {
  inches: number;
  color: string;
  name: string;
}

//========================================//
//      Haberdasher Protobuf Client       //
//========================================//

/**
 * MakeHat produces a hat of mysterious, randomly-selected color!
 */
export async function MakeHat(
  makeHat: Req.MakeHat,
  config?: ClientConfiguration
): Promise<Hat> {
  const response = await PBrequest(
    "/Haberdasher/MakeHat",
    Req.MakeHat.encode(makeHat),
    config
  );
  return Hat.decode(response);
}

//========================================//
//        Haberdasher JSON Client         //
//========================================//

/**
 * MakeHat produces a hat of mysterious, randomly-selected color!
 */
export async function MakeHatJSON(
  makeHat: Req.MakeHat,
  config?: ClientConfiguration
): Promise<Hat> {
  const response = await JSONrequest(
    "/Haberdasher/MakeHat",
    ReqJSON.MakeHat.encode(makeHat),
    config
  );
  return HatJSON.decode(response);
}

//========================================//
//              Haberdasher               //
//========================================//

/**
 * Haberdasher service makes hats for clients.
 */
export interface Haberdasher<Context = unknown> {
  /**
   * MakeHat produces a hat of mysterious, randomly-selected color!
   */
  MakeHat: (makeHat: Req.MakeHat, context: Context) => Promise<Hat> | Hat;
}

export function createHaberdasher<Context>(service: Haberdasher<Context>) {
  return {
    name: "Haberdasher",
    methods: {
      MakeHat: {
        name: "MakeHat",
        handler: service.MakeHat,
        input: { protobuf: Req.MakeHat, json: ReqJSON.MakeHat },
        output: { protobuf: Hat, json: HatJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Req = {
  /**
   * Serializes Req to protobuf.
   */
  encode: function (_msg?: Partial<Req>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes Req from protobuf.
   */
  decode: function (_bytes?: ByteSource): Req {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function (): Req {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<Req>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg: Req, _reader: BinaryReader): Req {
    return _msg;
  },

  MakeHat: {
    /**
     * Serializes Req.MakeHat to protobuf.
     */
    encode: function (msg: Partial<Req.MakeHat>): Uint8Array {
      return Req.MakeHat._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.MakeHat from protobuf.
     */
    decode: function (bytes: ByteSource): Req.MakeHat {
      return Req.MakeHat._readMessage(
        Req.MakeHat.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.MakeHat with all fields set to their default value.
     */
    initialize: function (): Req.MakeHat {
      return {
        inches: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.MakeHat>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.inches) {
        writer.writeInt32(1, msg.inches);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.MakeHat,
      reader: BinaryReader
    ): Req.MakeHat {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.inches = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Hat = {
  /**
   * Serializes Hat to protobuf.
   */
  encode: function (msg: Partial<Hat>): Uint8Array {
    return Hat._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Hat from protobuf.
   */
  decode: function (bytes: ByteSource): Hat {
    return Hat._readMessage(Hat.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Hat with all fields set to their default value.
   */
  initialize: function (): Hat {
    return {
      inches: 0,
      color: "",
      name: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Hat>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.inches) {
      writer.writeInt32(1, msg.inches);
    }
    if (msg.color) {
      writer.writeString(2, msg.color);
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Hat, reader: BinaryReader): Hat {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.inches = reader.readInt32();
          break;
        }
        case 2: {
          msg.color = reader.readString();
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ReqJSON = {
  /**
   * Serializes Req to JSON.
   */
  encode: function (_msg?: Partial<Req>): string {
    return "{}";
  },

  /**
   * Deserializes Req from JSON.
   */
  decode: function (_json?: string): Req {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function (): Req {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg: Partial<Req>): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: Req, _json: any): Req {
    return msg;
  },

  MakeHat: {
    /**
     * Serializes Req.MakeHat to JSON.
     */
    encode: function (msg: Partial<Req.MakeHat>): string {
      return JSON.stringify(ReqJSON.MakeHat._writeMessage(msg));
    },

    /**
     * Deserializes Req.MakeHat from JSON.
     */
    decode: function (json: string): Req.MakeHat {
      return ReqJSON.MakeHat._readMessage(
        ReqJSON.MakeHat.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.MakeHat with all fields set to their default value.
     */
    initialize: function (): Req.MakeHat {
      return {
        inches: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.MakeHat>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.inches) {
        json["inches"] = msg.inches;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.MakeHat, json: any): Req.MakeHat {
      const _inches_ = json["inches"];
      if (_inches_) {
        msg.inches = _inches_;
      }
      return msg;
    },
  },
};

export const HatJSON = {
  /**
   * Serializes Hat to JSON.
   */
  encode: function (msg: Partial<Hat>): string {
    return JSON.stringify(HatJSON._writeMessage(msg));
  },

  /**
   * Deserializes Hat from JSON.
   */
  decode: function (json: string): Hat {
    return HatJSON._readMessage(HatJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Hat with all fields set to their default value.
   */
  initialize: function (): Hat {
    return {
      inches: 0,
      color: "",
      name: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Hat>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.inches) {
      json["inches"] = msg.inches;
    }
    if (msg.color) {
      json["color"] = msg.color;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Hat, json: any): Hat {
    const _inches_ = json["inches"];
    if (_inches_) {
      msg.inches = _inches_;
    }
    const _color_ = json["color"];
    if (_color_) {
      msg.color = _color_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    return msg;
  },
};
",
      ],
      [
        "twirpscript/empty.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: twirpscript/empty.proto
/* eslint-disable */

import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";
import * as protoscript from "protoscript";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(
  empty: protoscript.Empty,
  config?: ClientConfiguration
): Promise<protoscript.Empty> {
  const response = await PBrequest(
    "/Foo/Bar",
    protoscript.Empty.encode(empty),
    config
  );
  return protoscript.Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(
  empty: protoscript.Empty,
  config?: ClientConfiguration
): Promise<protoscript.Empty> {
  const response = await JSONrequest(
    "/Foo/Bar",
    protoscript.EmptyJSON.encode(empty),
    config
  );
  return protoscript.EmptyJSON.decode(response);
}

//========================================//
//                  Foo                   //
//========================================//

export interface Foo<Context = unknown> {
  Bar: (
    empty: protoscript.Empty,
    context: Context
  ) => Promise<protoscript.Empty> | protoscript.Empty;
}

export function createFoo<Context>(service: Foo<Context>) {
  return {
    name: "Foo",
    methods: {
      Bar: {
        name: "Bar",
        handler: service.Bar,
        input: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
        output: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
      },
    },
  } as const;
}
",
      ],
      [
        "google/protobuf/unittest_import_public.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";

//========================================//
//                 Types                  //
//========================================//

export interface PublicImportMessage {
  e: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes PublicImportMessage to protobuf.
   */
  encode: function (msg: Partial<PublicImportMessage>): Uint8Array {
    return PublicImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes PublicImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): PublicImportMessage {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes PublicImportMessage with all fields set to their default value.
   */
  initialize: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PublicImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PublicImportMessage,
    reader: BinaryReader
  ): PublicImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const PublicImportMessageJSON = {
  /**
   * Serializes PublicImportMessage to JSON.
   */
  encode: function (msg: Partial<PublicImportMessage>): string {
    return JSON.stringify(PublicImportMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes PublicImportMessage from JSON.
   */
  decode: function (json: string): PublicImportMessage {
    return PublicImportMessageJSON._readMessage(
      PublicImportMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes PublicImportMessage with all fields set to their default value.
   */
  initialize: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PublicImportMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.e) {
      json["e"] = msg.e;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PublicImportMessage,
    json: any
  ): PublicImportMessage {
    const _e_ = json["e"];
    if (_e_) {
      msg.e = _e_;
    }
    return msg;
  },
};
",
      ],
      [
        "google/protobuf/unittest_import.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = "IMPORT_FOO" | "IMPORT_BAR" | "IMPORT_BAZ";

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap = "UNKNOWN" | "FOO" | "BAR";

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: "IMPORT_FOO",
  IMPORT_BAR: "IMPORT_BAR",
  IMPORT_BAZ: "IMPORT_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ImportEnum {
    switch (i) {
      case 7: {
        return "IMPORT_FOO";
      }
      case 8: {
        return "IMPORT_BAR";
      }
      case 9: {
        return "IMPORT_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ImportEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ImportEnum): number {
    switch (i) {
      case "IMPORT_FOO": {
        return 7;
      }
      case "IMPORT_BAR": {
        return 8;
      }
      case "IMPORT_BAZ": {
        return 9;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ImportEnumForMap = {
  UNKNOWN: "UNKNOWN",
  FOO: "FOO",
  BAR: "BAR",
  /**
   * @private
   */
  _fromInt: function (i: number): ImportEnumForMap {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "FOO";
      }
      case 2: {
        return "BAR";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ImportEnumForMap;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ImportEnumForMap): number {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "FOO": {
        return 1;
      }
      case "BAR": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ImportMessage = {
  /**
   * Serializes ImportMessage to protobuf.
   */
  encode: function (msg: Partial<ImportMessage>): Uint8Array {
    return ImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ImportMessage {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ImportMessage,
    reader: BinaryReader
  ): ImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ImportEnumJSON = {
  IMPORT_FOO: "IMPORT_FOO",
  IMPORT_BAR: "IMPORT_BAR",
  IMPORT_BAZ: "IMPORT_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ImportEnum {
    switch (i) {
      case 7: {
        return "IMPORT_FOO";
      }
      case 8: {
        return "IMPORT_BAR";
      }
      case 9: {
        return "IMPORT_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ImportEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ImportEnum): number {
    switch (i) {
      case "IMPORT_FOO": {
        return 7;
      }
      case "IMPORT_BAR": {
        return 8;
      }
      case "IMPORT_BAZ": {
        return 9;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ImportEnumForMapJSON = {
  UNKNOWN: "UNKNOWN",
  FOO: "FOO",
  BAR: "BAR",
  /**
   * @private
   */
  _fromInt: function (i: number): ImportEnumForMap {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "FOO";
      }
      case 2: {
        return "BAR";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ImportEnumForMap;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ImportEnumForMap): number {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "FOO": {
        return 1;
      }
      case "BAR": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ImportMessageJSON = {
  /**
   * Serializes ImportMessage to JSON.
   */
  encode: function (msg: Partial<ImportMessage>): string {
    return JSON.stringify(ImportMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ImportMessage from JSON.
   */
  decode: function (json: string): ImportMessage {
    return ImportMessageJSON._readMessage(
      ImportMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ImportMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.d) {
      json["d"] = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ImportMessage, json: any): ImportMessage {
    const _d_ = json["d"];
    if (_d_) {
      msg.d = _d_;
    }
    return msg;
  },
};
",
      ],
      [
        "google/protobuf/unittest.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";
import * as googleProtobufUnittest_import from "./unittest_import.pb";
import * as googleProtobufUnittest_import_public from "./unittest_import_public.pb";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = "FOREIGN_FOO" | "FOREIGN_BAR" | "FOREIGN_BAZ";

/**
 * Test an enum that has multiple values with the same number.
 */
export type TestEnumWithDupValue = "FOO1" | "BAR1" | "BAZ" | "FOO2" | "BAR2";

/**
 * Test an enum with large, unordered values.
 */
export type TestSparseEnum =
  | "SPARSE_A"
  | "SPARSE_B"
  | "SPARSE_C"
  | "SPARSE_D"
  | "SPARSE_E"
  | "SPARSE_F"
  | "SPARSE_G";

export type VeryLargeEnum =
  | "ENUM_LABEL_DEFAULT"
  | "ENUM_LABEL_1"
  | "ENUM_LABEL_2"
  | "ENUM_LABEL_3"
  | "ENUM_LABEL_4"
  | "ENUM_LABEL_5"
  | "ENUM_LABEL_6"
  | "ENUM_LABEL_7"
  | "ENUM_LABEL_8"
  | "ENUM_LABEL_9"
  | "ENUM_LABEL_10"
  | "ENUM_LABEL_11"
  | "ENUM_LABEL_12"
  | "ENUM_LABEL_13"
  | "ENUM_LABEL_14"
  | "ENUM_LABEL_15"
  | "ENUM_LABEL_16"
  | "ENUM_LABEL_17"
  | "ENUM_LABEL_18"
  | "ENUM_LABEL_19"
  | "ENUM_LABEL_20"
  | "ENUM_LABEL_21"
  | "ENUM_LABEL_22"
  | "ENUM_LABEL_23"
  | "ENUM_LABEL_24"
  | "ENUM_LABEL_25"
  | "ENUM_LABEL_26"
  | "ENUM_LABEL_27"
  | "ENUM_LABEL_28"
  | "ENUM_LABEL_29"
  | "ENUM_LABEL_30"
  | "ENUM_LABEL_31"
  | "ENUM_LABEL_32"
  | "ENUM_LABEL_33"
  | "ENUM_LABEL_34"
  | "ENUM_LABEL_35"
  | "ENUM_LABEL_36"
  | "ENUM_LABEL_37"
  | "ENUM_LABEL_38"
  | "ENUM_LABEL_39"
  | "ENUM_LABEL_40"
  | "ENUM_LABEL_41"
  | "ENUM_LABEL_42"
  | "ENUM_LABEL_43"
  | "ENUM_LABEL_44"
  | "ENUM_LABEL_45"
  | "ENUM_LABEL_46"
  | "ENUM_LABEL_47"
  | "ENUM_LABEL_48"
  | "ENUM_LABEL_49"
  | "ENUM_LABEL_50"
  | "ENUM_LABEL_51"
  | "ENUM_LABEL_52"
  | "ENUM_LABEL_53"
  | "ENUM_LABEL_54"
  | "ENUM_LABEL_55"
  | "ENUM_LABEL_56"
  | "ENUM_LABEL_57"
  | "ENUM_LABEL_58"
  | "ENUM_LABEL_59"
  | "ENUM_LABEL_60"
  | "ENUM_LABEL_61"
  | "ENUM_LABEL_62"
  | "ENUM_LABEL_63"
  | "ENUM_LABEL_64"
  | "ENUM_LABEL_65"
  | "ENUM_LABEL_66"
  | "ENUM_LABEL_67"
  | "ENUM_LABEL_68"
  | "ENUM_LABEL_69"
  | "ENUM_LABEL_70"
  | "ENUM_LABEL_71"
  | "ENUM_LABEL_72"
  | "ENUM_LABEL_73"
  | "ENUM_LABEL_74"
  | "ENUM_LABEL_75"
  | "ENUM_LABEL_76"
  | "ENUM_LABEL_77"
  | "ENUM_LABEL_78"
  | "ENUM_LABEL_79"
  | "ENUM_LABEL_80"
  | "ENUM_LABEL_81"
  | "ENUM_LABEL_82"
  | "ENUM_LABEL_83"
  | "ENUM_LABEL_84"
  | "ENUM_LABEL_85"
  | "ENUM_LABEL_86"
  | "ENUM_LABEL_87"
  | "ENUM_LABEL_88"
  | "ENUM_LABEL_89"
  | "ENUM_LABEL_90"
  | "ENUM_LABEL_91"
  | "ENUM_LABEL_92"
  | "ENUM_LABEL_93"
  | "ENUM_LABEL_94"
  | "ENUM_LABEL_95"
  | "ENUM_LABEL_96"
  | "ENUM_LABEL_97"
  | "ENUM_LABEL_98"
  | "ENUM_LABEL_99"
  | "ENUM_LABEL_100";

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: googleProtobufUnittest_import.ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalImportEnum: googleProtobufUnittest_import.ImportEnum;
  optionalStringPiece: string;
  optionalCord: string;
  optionalPublicImportMessage: googleProtobufUnittest_import_public.PublicImportMessage;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalLazyMessage: TestAllTypes.NestedMessage;
  repeatedInt32: number[];
  /**
   * Repeated
   */
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: googleProtobufUnittest_import.ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedImportEnum: googleProtobufUnittest_import.ImportEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  defaultInt32: number;
  defaultInt64: bigint;
  /**
   * Singular with defaults
   */
  defaultUint32: number;
  defaultUint64: bigint;
  defaultSint32: number;
  defaultSint64: bigint;
  defaultFixed32: number;
  defaultFixed64: bigint;
  defaultSfixed32: number;
  defaultSfixed64: bigint;
  defaultFloat: number;
  defaultDouble: number;
  defaultBool: boolean;
  defaultString: string;
  defaultBytes: Uint8Array;
  defaultNestedEnum: TestAllTypes.NestedEnum;
  defaultForeignEnum: ForeignEnum;
  defaultImportEnum: googleProtobufUnittest_import.ImportEnum;
  defaultStringPiece: string;
  defaultCord: string;
  oneofUint32?: number | null | undefined;
  oneofNestedMessage?: TestAllTypes.NestedMessage | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

export declare namespace TestAllTypes {
  export type NestedEnum = "FOO" | "BAR" | "BAZ" | "NEG";

  export interface NestedMessage {
    /**
     * The field name "b" fails to compile in proto1 because it conflicts with
     * a local variable named "b" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }

  export interface OptionalGroup {
    a: number;
  }

  export interface RepeatedGroup {
    a: number;
  }
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
  repeatedChild: NestedTestAllTypes[];
}

export interface TestDeprecatedFields {
  deprecatedInt32: number;
  deprecatedInt32InOneof?: number | null | undefined;
}

export interface TestDeprecatedMessage {}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
  d: number;
}

export interface TestReservedFields {}

export interface TestAllExtensions {}

export interface OptionalGroup_extension {
  a: number;
}

export interface RepeatedGroup_extension {
  a: number;
}

export interface TestGroup {
  optionalForeignEnum: ForeignEnum;
}

export declare namespace TestGroup {
  export interface OptionalGroup {
    a: number;
  }
}

export interface TestGroupExtension {}

export interface TestNestedExtension {}

export declare namespace TestNestedExtension {
  export interface OptionalGroup_extension {
    a: number;
  }
}

export interface TestChildExtension {
  a: string;
  b: string;
  optionalExtension: TestAllExtensions;
}

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 */
export interface TestRequired {
  a: number;
  dummy2: number;
  b: number;
  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   */
  dummy4: number;
  dummy5: number;
  dummy6: number;
  dummy7: number;
  dummy8: number;
  dummy9: number;
  dummy10: number;
  dummy11: number;
  dummy12: number;
  dummy13: number;
  dummy14: number;
  dummy15: number;
  dummy16: number;
  dummy17: number;
  dummy18: number;
  dummy19: number;
  dummy20: number;
  dummy21: number;
  dummy22: number;
  dummy23: number;
  dummy24: number;
  dummy25: number;
  dummy26: number;
  dummy27: number;
  dummy28: number;
  dummy29: number;
  dummy30: number;
  dummy31: number;
  dummy32: number;
  c: number;
}

export interface TestRequiredForeign {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  dummy: number;
}

export interface TestRequiredMessage {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  requiredMessage: TestRequired;
}

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 */
export interface TestForeignNested {
  foreignNested: TestAllTypes.NestedMessage;
}

/**
 * TestEmptyMessage is used to test unknown field support.
 */
export interface TestEmptyMessage {}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 */
export interface TestEmptyMessageWithExtensions {}

/**
 * Needed for a Python test.
 */
export interface TestPickleNestedMessage {}

export declare namespace TestPickleNestedMessage {
  export interface NestedMessage {
    bb: number;
  }

  namespace NestedMessage {
    export interface NestedNestedMessage {
      cc: number;
    }
  }
}

export interface TestMultipleExtensionRanges {}

/**
 * Test that really large tag numbers don't break anything.
 */
export interface TestReallyLargeTagNumber {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   */
  a: number;
  bb: number;
}

export interface TestRecursiveMessage {
  a: TestRecursiveMessage;
  i: number;
}

/**
 * Test that mutual recursion works.
 */
export interface TestMutualRecursionA {
  bb: TestMutualRecursionB;
}

export declare namespace TestMutualRecursionA {
  export interface SubMessage {
    b: TestMutualRecursionB;
  }

  export interface SubGroup {
    subMessage: TestMutualRecursionA.SubMessage;
    notInThisScc: TestAllTypes;
  }
}

export interface TestMutualRecursionB {
  a: TestMutualRecursionA;
  optionalInt32: number;
}

export interface TestIsInitialized {
  subMessage: TestIsInitialized.SubMessage;
}

export declare namespace TestIsInitialized {
  export interface SubMessage {}

  namespace SubMessage {
    export interface SubGroup {
      i: number;
    }
  }
}

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 */
export interface TestDupFieldNumber {
  a: number;
}

export declare namespace TestDupFieldNumber {
  export interface Foo {
    a: number;
  }

  export interface Bar {
    a: number;
  }
}

/**
 * Additional messages for testing lazy fields.
 */
export interface TestEagerMessage {
  subMessage: TestAllTypes;
}

export interface TestLazyMessage {
  subMessage: TestAllTypes;
}

/**
 * Needed for a Python test.
 */
export interface TestNestedMessageHasBits {
  optionalNestedMessage: TestNestedMessageHasBits.NestedMessage;
}

export declare namespace TestNestedMessageHasBits {
  export interface NestedMessage {
    nestedmessageRepeatedInt32: number[];
    nestedmessageRepeatedForeignmessage: ForeignMessage[];
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 */
export interface TestCamelCaseFieldNames {
  PrimitiveField: number;
  StringField: string;
  EnumField: ForeignEnum;
  MessageField: ForeignMessage;
  StringPieceField: string;
  CordField: string;
  RepeatedPrimitiveField: number[];
  RepeatedStringField: string[];
  RepeatedEnumField: ForeignEnum[];
  RepeatedMessageField: ForeignMessage[];
  RepeatedStringPieceField: string[];
  RepeatedCordField: string[];
}

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 */
export interface TestFieldOrderings {
  myString: string;
  myInt: bigint;
  myFloat: number;
  optionalNestedMessage: TestFieldOrderings.NestedMessage;
}

export declare namespace TestFieldOrderings {
  export interface NestedMessage {
    oo: bigint;
    /**
     * The field name "b" fails to compile in proto1 because it conflicts with
     * a local variable named "b" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestExtensionOrderings1 {
  myString: string;
}

export interface TestExtensionOrderings2 {
  myString: string;
}

export declare namespace TestExtensionOrderings2 {
  export interface TestExtensionOrderings3 {
    myString: string;
  }
}

export interface TestExtremeDefaultValues {
  escapedBytes: Uint8Array;
  largeUint32: number;
  largeUint64: bigint;
  smallInt32: number;
  smallInt64: bigint;
  reallySmallInt32: number;
  reallySmallInt64: bigint;
  /**
   * The default value here is UTF-8 for "\\u1234".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   */
  utf8String: string;
  /**
   * Tests for single-precision floating-point values.
   */
  zeroFloat: number;
  oneFloat: number;
  smallFloat: number;
  negativeOneFloat: number;
  negativeFloat: number;
  /**
   * Using exponents
   */
  largeFloat: number;
  smallNegativeFloat: number;
  /**
   * Text for nonfinite floating-point values.
   */
  infDouble: number;
  negInfDouble: number;
  nanDouble: number;
  infFloat: number;
  negInfFloat: number;
  nanFloat: number;
  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, "\\?" is a valid way to escape ? in string
   * literals.
   */
  cppTrigraph: string;
  /**
   * String defaults containing the character '\\000'
   */
  stringWithZero: string;
  bytesWithZero: Uint8Array;
  stringPieceWithZero: string;
  cordWithZero: string;
  replacementString: string;
}

export interface SparseEnumMessage {
  sparseEnum: TestSparseEnum;
}

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 */
export interface OneString {
  data: string;
}

export interface MoreString {
  data: string[];
}

export interface OneBytes {
  data: Uint8Array;
}

export interface MoreBytes {
  data: Uint8Array[];
}

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 */
export interface Int32Message {
  data: number;
}

export interface Uint32Message {
  data: number;
}

export interface Int64Message {
  data: bigint;
}

export interface Uint64Message {
  data: bigint;
}

export interface BoolMessage {
  data: boolean;
}

/**
 * Test oneofs.
 */
export interface TestOneof {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooMessage?: TestAllTypes | null | undefined;
}

export declare namespace TestOneof {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneofBackwardsCompatible {
  fooInt: number;
  fooString: string;
  fooMessage: TestAllTypes;
}

export declare namespace TestOneofBackwardsCompatible {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneof2 {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooCord?: string | null | undefined;
  fooStringPiece?: string | null | undefined;
  fooBytes?: Uint8Array | null | undefined;
  fooEnum?: TestOneof2.NestedEnum | null | undefined;
  fooMessage?: TestOneof2.NestedMessage | null | undefined;
  fooLazyMessage?: TestOneof2.NestedMessage | null | undefined;
  barInt?: number | null | undefined;
  barString?: string | null | undefined;
  barCord?: string | null | undefined;
  barStringPiece?: string | null | undefined;
  barBytes?: Uint8Array | null | undefined;
  barEnum?: TestOneof2.NestedEnum | null | undefined;
  barStringWithEmptyDefault?: string | null | undefined;
  barCordWithEmptyDefault?: string | null | undefined;
  barStringPieceWithEmptyDefault?: string | null | undefined;
  barBytesWithEmptyDefault?: Uint8Array | null | undefined;
  bazInt: number;
  bazString: string;
}

export declare namespace TestOneof2 {
  export type NestedEnum = "FOO" | "BAR" | "BAZ";

  export interface FooGroup {
    a: number;
    b: string;
  }

  export interface NestedMessage {
    quxInt: bigint;
    corgeInt: number[];
  }
}

export interface TestRequiredOneof {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooMessage?: TestRequiredOneof.NestedMessage | null | undefined;
}

export declare namespace TestRequiredOneof {
  export interface NestedMessage {
    requiredDouble: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 */
export interface TestUnpackedTypes {
  unpackedInt32: number[];
  unpackedInt64: bigint[];
  unpackedUint32: number[];
  unpackedUint64: bigint[];
  unpackedSint32: number[];
  unpackedSint64: bigint[];
  unpackedFixed32: number[];
  unpackedFixed64: bigint[];
  unpackedSfixed32: number[];
  unpackedSfixed64: bigint[];
  unpackedFloat: number[];
  unpackedDouble: number[];
  unpackedBool: boolean[];
  unpackedEnum: ForeignEnum[];
}

export interface TestPackedExtensions {}

export interface TestUnpackedExtensions {}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 */
export interface TestDynamicExtensions {
  scalarExtension: number;
  enumExtension: ForeignEnum;
  dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType;
  messageExtension: ForeignMessage;
  dynamicMessageExtension: TestDynamicExtensions.DynamicMessageType;
  repeatedExtension: string[];
  packedExtension: number[];
}

export declare namespace TestDynamicExtensions {
  export type DynamicEnumType = "DYNAMIC_FOO" | "DYNAMIC_BAR" | "DYNAMIC_BAZ";

  export interface DynamicMessageType {
    dynamicField: number;
  }
}

export interface TestRepeatedScalarDifferentTagSizes {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   */
  repeatedFixed32: number[];
  /**
   * Check for a varint type, just for good measure.
   */
  repeatedInt32: number[];
  /**
   * These have two-byte tags.
   */
  repeatedFixed64: bigint[];
  repeatedInt64: bigint[];
  /**
   * Three byte tags.
   */
  repeatedFloat: number[];
  repeatedUint64: bigint[];
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 */
export interface TestParsingMerge {
  requiredAllTypes: TestAllTypes;
  optionalAllTypes: TestAllTypes;
  repeatedAllTypes: TestAllTypes[];
}

export declare namespace TestParsingMerge {
  /**
   * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
   * except that all fields are repeated. In the tests, we will serialize the
   * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
   * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
   * the corresponding required/optional fields in TestParsingMerge.
   */
  export interface RepeatedFieldsGenerator {
    field1: TestAllTypes[];
    field2: TestAllTypes[];
    field3: TestAllTypes[];
    ext1: TestAllTypes[];
    ext2: TestAllTypes[];
  }

  namespace RepeatedFieldsGenerator {
    export interface Group1 {
      field1: TestAllTypes;
    }

    export interface Group2 {
      field1: TestAllTypes;
    }
  }

  export interface OptionalGroup {
    optionalGroupAllTypes: TestAllTypes;
  }

  export interface RepeatedGroup {
    repeatedGroupAllTypes: TestAllTypes;
  }
}

export interface TestCommentInjectionMessage {
  /**
   * *\\/ <- This should not close the generated doc comment
   */
  a: string;
}

/**
 * Test that RPC services work.
 */
export interface FooRequest {}

export interface FooResponse {}

export interface FooClientMessage {}

export interface FooServerMessage {}

export interface BarRequest {}

export interface BarResponse {}

export interface TestJsonName {
  fieldName1: number;
  fieldName2: number;
  FieldName3: number;
  FieldName4: number;
  FIELDNAME5: number;
  fieldName6: number;
  fieldname7: number;
}

export interface TestHugeFieldNumbers {
  optionalInt32: number;
  fixed32: number;
  repeatedInt32: number[];
  packedInt32: number[];
  optionalEnum: ForeignEnum;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalMessage: ForeignMessage;
  stringStringMap: Record<
    string,
    TestHugeFieldNumbers.StringStringMap["value"] | undefined
  >;
  oneofUint32?: number | null | undefined;
  oneofTestAllTypes?: TestAllTypes | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

export declare namespace TestHugeFieldNumbers {
  export interface OptionalGroup {
    groupA: number;
  }

  interface StringStringMap {
    key: string;
    value: string;
  }
}

export interface TestExtensionInsideTable {
  field1: number;
  field2: number;
  field3: number;
  field4: number;
  field6: number;
  field7: number;
  field8: number;
  field9: number;
  field10: number;
}

export interface TestExtensionRangeSerialize {
  fooOne: number;
  fooTwo: number;
  fooThree: number;
  fooFour: number;
}

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await PBrequest(
    "/protobuf_unittest.TestService/Foo",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await PBrequest(
    "/protobuf_unittest.TestService/Bar",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await JSONrequest(
    "/protobuf_unittest.TestService/Foo",
    FooRequestJSON.encode(fooRequest),
    config
  );
  return FooResponseJSON.decode(response);
}

export async function BarJSON(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await JSONrequest(
    "/protobuf_unittest.TestService/Bar",
    BarRequestJSON.encode(barRequest),
    config
  );
  return BarResponseJSON.decode(response);
}

//========================================//
//              TestService               //
//========================================//

export interface TestService<Context = unknown> {
  Foo: (
    fooRequest: FooRequest,
    context: Context
  ) => Promise<FooResponse> | FooResponse;
  Bar: (
    barRequest: BarRequest,
    context: Context
  ) => Promise<BarResponse> | BarResponse;
}

export function createTestService<Context>(service: TestService<Context>) {
  return {
    name: "protobuf_unittest.TestService",
    methods: {
      Foo: {
        name: "Foo",
        handler: service.Foo,
        input: { protobuf: FooRequest, json: FooRequestJSON },
        output: { protobuf: FooResponse, json: FooResponseJSON },
      },
      Bar: {
        name: "Bar",
        handler: service.Bar,
        input: { protobuf: BarRequest, json: BarRequestJSON },
        output: { protobuf: BarResponse, json: BarResponseJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnum {
    switch (i) {
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnum): number {
    switch (i) {
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestEnumWithDupValue = {
  FOO1: "FOO1",
  BAR1: "BAR1",
  BAZ: "BAZ",
  FOO2: "FOO2",
  BAR2: "BAR2",
  /**
   * @private
   */
  _fromInt: function (i: number): TestEnumWithDupValue {
    switch (i) {
      case 1: {
        return "FOO1";
      }
      case 2: {
        return "BAR1";
      }
      case 3: {
        return "BAZ";
      }
      case 1: {
        return "FOO2";
      }
      case 2: {
        return "BAR2";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestEnumWithDupValue;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TestEnumWithDupValue): number {
    switch (i) {
      case "FOO1": {
        return 1;
      }
      case "BAR1": {
        return 2;
      }
      case "BAZ": {
        return 3;
      }
      case "FOO2": {
        return 1;
      }
      case "BAR2": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestSparseEnum = {
  SPARSE_A: "SPARSE_A",
  SPARSE_B: "SPARSE_B",
  SPARSE_C: "SPARSE_C",
  SPARSE_D: "SPARSE_D",
  SPARSE_E: "SPARSE_E",
  SPARSE_F: "SPARSE_F",
  SPARSE_G: "SPARSE_G",
  /**
   * @private
   */
  _fromInt: function (i: number): TestSparseEnum {
    switch (i) {
      case 123: {
        return "SPARSE_A";
      }
      case 62374: {
        return "SPARSE_B";
      }
      case 12589234: {
        return "SPARSE_C";
      }
      case -15: {
        return "SPARSE_D";
      }
      case -53452: {
        return "SPARSE_E";
      }
      case 0: {
        return "SPARSE_F";
      }
      case 2: {
        return "SPARSE_G";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestSparseEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TestSparseEnum): number {
    switch (i) {
      case "SPARSE_A": {
        return 123;
      }
      case "SPARSE_B": {
        return 62374;
      }
      case "SPARSE_C": {
        return 12589234;
      }
      case "SPARSE_D": {
        return -15;
      }
      case "SPARSE_E": {
        return -53452;
      }
      case "SPARSE_F": {
        return 0;
      }
      case "SPARSE_G": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: "ENUM_LABEL_DEFAULT",
  ENUM_LABEL_1: "ENUM_LABEL_1",
  ENUM_LABEL_2: "ENUM_LABEL_2",
  ENUM_LABEL_3: "ENUM_LABEL_3",
  ENUM_LABEL_4: "ENUM_LABEL_4",
  ENUM_LABEL_5: "ENUM_LABEL_5",
  ENUM_LABEL_6: "ENUM_LABEL_6",
  ENUM_LABEL_7: "ENUM_LABEL_7",
  ENUM_LABEL_8: "ENUM_LABEL_8",
  ENUM_LABEL_9: "ENUM_LABEL_9",
  ENUM_LABEL_10: "ENUM_LABEL_10",
  ENUM_LABEL_11: "ENUM_LABEL_11",
  ENUM_LABEL_12: "ENUM_LABEL_12",
  ENUM_LABEL_13: "ENUM_LABEL_13",
  ENUM_LABEL_14: "ENUM_LABEL_14",
  ENUM_LABEL_15: "ENUM_LABEL_15",
  ENUM_LABEL_16: "ENUM_LABEL_16",
  ENUM_LABEL_17: "ENUM_LABEL_17",
  ENUM_LABEL_18: "ENUM_LABEL_18",
  ENUM_LABEL_19: "ENUM_LABEL_19",
  ENUM_LABEL_20: "ENUM_LABEL_20",
  ENUM_LABEL_21: "ENUM_LABEL_21",
  ENUM_LABEL_22: "ENUM_LABEL_22",
  ENUM_LABEL_23: "ENUM_LABEL_23",
  ENUM_LABEL_24: "ENUM_LABEL_24",
  ENUM_LABEL_25: "ENUM_LABEL_25",
  ENUM_LABEL_26: "ENUM_LABEL_26",
  ENUM_LABEL_27: "ENUM_LABEL_27",
  ENUM_LABEL_28: "ENUM_LABEL_28",
  ENUM_LABEL_29: "ENUM_LABEL_29",
  ENUM_LABEL_30: "ENUM_LABEL_30",
  ENUM_LABEL_31: "ENUM_LABEL_31",
  ENUM_LABEL_32: "ENUM_LABEL_32",
  ENUM_LABEL_33: "ENUM_LABEL_33",
  ENUM_LABEL_34: "ENUM_LABEL_34",
  ENUM_LABEL_35: "ENUM_LABEL_35",
  ENUM_LABEL_36: "ENUM_LABEL_36",
  ENUM_LABEL_37: "ENUM_LABEL_37",
  ENUM_LABEL_38: "ENUM_LABEL_38",
  ENUM_LABEL_39: "ENUM_LABEL_39",
  ENUM_LABEL_40: "ENUM_LABEL_40",
  ENUM_LABEL_41: "ENUM_LABEL_41",
  ENUM_LABEL_42: "ENUM_LABEL_42",
  ENUM_LABEL_43: "ENUM_LABEL_43",
  ENUM_LABEL_44: "ENUM_LABEL_44",
  ENUM_LABEL_45: "ENUM_LABEL_45",
  ENUM_LABEL_46: "ENUM_LABEL_46",
  ENUM_LABEL_47: "ENUM_LABEL_47",
  ENUM_LABEL_48: "ENUM_LABEL_48",
  ENUM_LABEL_49: "ENUM_LABEL_49",
  ENUM_LABEL_50: "ENUM_LABEL_50",
  ENUM_LABEL_51: "ENUM_LABEL_51",
  ENUM_LABEL_52: "ENUM_LABEL_52",
  ENUM_LABEL_53: "ENUM_LABEL_53",
  ENUM_LABEL_54: "ENUM_LABEL_54",
  ENUM_LABEL_55: "ENUM_LABEL_55",
  ENUM_LABEL_56: "ENUM_LABEL_56",
  ENUM_LABEL_57: "ENUM_LABEL_57",
  ENUM_LABEL_58: "ENUM_LABEL_58",
  ENUM_LABEL_59: "ENUM_LABEL_59",
  ENUM_LABEL_60: "ENUM_LABEL_60",
  ENUM_LABEL_61: "ENUM_LABEL_61",
  ENUM_LABEL_62: "ENUM_LABEL_62",
  ENUM_LABEL_63: "ENUM_LABEL_63",
  ENUM_LABEL_64: "ENUM_LABEL_64",
  ENUM_LABEL_65: "ENUM_LABEL_65",
  ENUM_LABEL_66: "ENUM_LABEL_66",
  ENUM_LABEL_67: "ENUM_LABEL_67",
  ENUM_LABEL_68: "ENUM_LABEL_68",
  ENUM_LABEL_69: "ENUM_LABEL_69",
  ENUM_LABEL_70: "ENUM_LABEL_70",
  ENUM_LABEL_71: "ENUM_LABEL_71",
  ENUM_LABEL_72: "ENUM_LABEL_72",
  ENUM_LABEL_73: "ENUM_LABEL_73",
  ENUM_LABEL_74: "ENUM_LABEL_74",
  ENUM_LABEL_75: "ENUM_LABEL_75",
  ENUM_LABEL_76: "ENUM_LABEL_76",
  ENUM_LABEL_77: "ENUM_LABEL_77",
  ENUM_LABEL_78: "ENUM_LABEL_78",
  ENUM_LABEL_79: "ENUM_LABEL_79",
  ENUM_LABEL_80: "ENUM_LABEL_80",
  ENUM_LABEL_81: "ENUM_LABEL_81",
  ENUM_LABEL_82: "ENUM_LABEL_82",
  ENUM_LABEL_83: "ENUM_LABEL_83",
  ENUM_LABEL_84: "ENUM_LABEL_84",
  ENUM_LABEL_85: "ENUM_LABEL_85",
  ENUM_LABEL_86: "ENUM_LABEL_86",
  ENUM_LABEL_87: "ENUM_LABEL_87",
  ENUM_LABEL_88: "ENUM_LABEL_88",
  ENUM_LABEL_89: "ENUM_LABEL_89",
  ENUM_LABEL_90: "ENUM_LABEL_90",
  ENUM_LABEL_91: "ENUM_LABEL_91",
  ENUM_LABEL_92: "ENUM_LABEL_92",
  ENUM_LABEL_93: "ENUM_LABEL_93",
  ENUM_LABEL_94: "ENUM_LABEL_94",
  ENUM_LABEL_95: "ENUM_LABEL_95",
  ENUM_LABEL_96: "ENUM_LABEL_96",
  ENUM_LABEL_97: "ENUM_LABEL_97",
  ENUM_LABEL_98: "ENUM_LABEL_98",
  ENUM_LABEL_99: "ENUM_LABEL_99",
  ENUM_LABEL_100: "ENUM_LABEL_100",
  /**
   * @private
   */
  _fromInt: function (i: number): VeryLargeEnum {
    switch (i) {
      case 0: {
        return "ENUM_LABEL_DEFAULT";
      }
      case 1: {
        return "ENUM_LABEL_1";
      }
      case 2: {
        return "ENUM_LABEL_2";
      }
      case 3: {
        return "ENUM_LABEL_3";
      }
      case 4: {
        return "ENUM_LABEL_4";
      }
      case 5: {
        return "ENUM_LABEL_5";
      }
      case 6: {
        return "ENUM_LABEL_6";
      }
      case 7: {
        return "ENUM_LABEL_7";
      }
      case 8: {
        return "ENUM_LABEL_8";
      }
      case 9: {
        return "ENUM_LABEL_9";
      }
      case 10: {
        return "ENUM_LABEL_10";
      }
      case 11: {
        return "ENUM_LABEL_11";
      }
      case 12: {
        return "ENUM_LABEL_12";
      }
      case 13: {
        return "ENUM_LABEL_13";
      }
      case 14: {
        return "ENUM_LABEL_14";
      }
      case 15: {
        return "ENUM_LABEL_15";
      }
      case 16: {
        return "ENUM_LABEL_16";
      }
      case 17: {
        return "ENUM_LABEL_17";
      }
      case 18: {
        return "ENUM_LABEL_18";
      }
      case 19: {
        return "ENUM_LABEL_19";
      }
      case 20: {
        return "ENUM_LABEL_20";
      }
      case 21: {
        return "ENUM_LABEL_21";
      }
      case 22: {
        return "ENUM_LABEL_22";
      }
      case 23: {
        return "ENUM_LABEL_23";
      }
      case 24: {
        return "ENUM_LABEL_24";
      }
      case 25: {
        return "ENUM_LABEL_25";
      }
      case 26: {
        return "ENUM_LABEL_26";
      }
      case 27: {
        return "ENUM_LABEL_27";
      }
      case 28: {
        return "ENUM_LABEL_28";
      }
      case 29: {
        return "ENUM_LABEL_29";
      }
      case 30: {
        return "ENUM_LABEL_30";
      }
      case 31: {
        return "ENUM_LABEL_31";
      }
      case 32: {
        return "ENUM_LABEL_32";
      }
      case 33: {
        return "ENUM_LABEL_33";
      }
      case 34: {
        return "ENUM_LABEL_34";
      }
      case 35: {
        return "ENUM_LABEL_35";
      }
      case 36: {
        return "ENUM_LABEL_36";
      }
      case 37: {
        return "ENUM_LABEL_37";
      }
      case 38: {
        return "ENUM_LABEL_38";
      }
      case 39: {
        return "ENUM_LABEL_39";
      }
      case 40: {
        return "ENUM_LABEL_40";
      }
      case 41: {
        return "ENUM_LABEL_41";
      }
      case 42: {
        return "ENUM_LABEL_42";
      }
      case 43: {
        return "ENUM_LABEL_43";
      }
      case 44: {
        return "ENUM_LABEL_44";
      }
      case 45: {
        return "ENUM_LABEL_45";
      }
      case 46: {
        return "ENUM_LABEL_46";
      }
      case 47: {
        return "ENUM_LABEL_47";
      }
      case 48: {
        return "ENUM_LABEL_48";
      }
      case 49: {
        return "ENUM_LABEL_49";
      }
      case 50: {
        return "ENUM_LABEL_50";
      }
      case 51: {
        return "ENUM_LABEL_51";
      }
      case 52: {
        return "ENUM_LABEL_52";
      }
      case 53: {
        return "ENUM_LABEL_53";
      }
      case 54: {
        return "ENUM_LABEL_54";
      }
      case 55: {
        return "ENUM_LABEL_55";
      }
      case 56: {
        return "ENUM_LABEL_56";
      }
      case 57: {
        return "ENUM_LABEL_57";
      }
      case 58: {
        return "ENUM_LABEL_58";
      }
      case 59: {
        return "ENUM_LABEL_59";
      }
      case 60: {
        return "ENUM_LABEL_60";
      }
      case 61: {
        return "ENUM_LABEL_61";
      }
      case 62: {
        return "ENUM_LABEL_62";
      }
      case 63: {
        return "ENUM_LABEL_63";
      }
      case 64: {
        return "ENUM_LABEL_64";
      }
      case 65: {
        return "ENUM_LABEL_65";
      }
      case 66: {
        return "ENUM_LABEL_66";
      }
      case 67: {
        return "ENUM_LABEL_67";
      }
      case 68: {
        return "ENUM_LABEL_68";
      }
      case 69: {
        return "ENUM_LABEL_69";
      }
      case 70: {
        return "ENUM_LABEL_70";
      }
      case 71: {
        return "ENUM_LABEL_71";
      }
      case 72: {
        return "ENUM_LABEL_72";
      }
      case 73: {
        return "ENUM_LABEL_73";
      }
      case 74: {
        return "ENUM_LABEL_74";
      }
      case 75: {
        return "ENUM_LABEL_75";
      }
      case 76: {
        return "ENUM_LABEL_76";
      }
      case 77: {
        return "ENUM_LABEL_77";
      }
      case 78: {
        return "ENUM_LABEL_78";
      }
      case 79: {
        return "ENUM_LABEL_79";
      }
      case 80: {
        return "ENUM_LABEL_80";
      }
      case 81: {
        return "ENUM_LABEL_81";
      }
      case 82: {
        return "ENUM_LABEL_82";
      }
      case 83: {
        return "ENUM_LABEL_83";
      }
      case 84: {
        return "ENUM_LABEL_84";
      }
      case 85: {
        return "ENUM_LABEL_85";
      }
      case 86: {
        return "ENUM_LABEL_86";
      }
      case 87: {
        return "ENUM_LABEL_87";
      }
      case 88: {
        return "ENUM_LABEL_88";
      }
      case 89: {
        return "ENUM_LABEL_89";
      }
      case 90: {
        return "ENUM_LABEL_90";
      }
      case 91: {
        return "ENUM_LABEL_91";
      }
      case 92: {
        return "ENUM_LABEL_92";
      }
      case 93: {
        return "ENUM_LABEL_93";
      }
      case 94: {
        return "ENUM_LABEL_94";
      }
      case 95: {
        return "ENUM_LABEL_95";
      }
      case 96: {
        return "ENUM_LABEL_96";
      }
      case 97: {
        return "ENUM_LABEL_97";
      }
      case 98: {
        return "ENUM_LABEL_98";
      }
      case 99: {
        return "ENUM_LABEL_99";
      }
      case 100: {
        return "ENUM_LABEL_100";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as VeryLargeEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: VeryLargeEnum): number {
    switch (i) {
      case "ENUM_LABEL_DEFAULT": {
        return 0;
      }
      case "ENUM_LABEL_1": {
        return 1;
      }
      case "ENUM_LABEL_2": {
        return 2;
      }
      case "ENUM_LABEL_3": {
        return 3;
      }
      case "ENUM_LABEL_4": {
        return 4;
      }
      case "ENUM_LABEL_5": {
        return 5;
      }
      case "ENUM_LABEL_6": {
        return 6;
      }
      case "ENUM_LABEL_7": {
        return 7;
      }
      case "ENUM_LABEL_8": {
        return 8;
      }
      case "ENUM_LABEL_9": {
        return 9;
      }
      case "ENUM_LABEL_10": {
        return 10;
      }
      case "ENUM_LABEL_11": {
        return 11;
      }
      case "ENUM_LABEL_12": {
        return 12;
      }
      case "ENUM_LABEL_13": {
        return 13;
      }
      case "ENUM_LABEL_14": {
        return 14;
      }
      case "ENUM_LABEL_15": {
        return 15;
      }
      case "ENUM_LABEL_16": {
        return 16;
      }
      case "ENUM_LABEL_17": {
        return 17;
      }
      case "ENUM_LABEL_18": {
        return 18;
      }
      case "ENUM_LABEL_19": {
        return 19;
      }
      case "ENUM_LABEL_20": {
        return 20;
      }
      case "ENUM_LABEL_21": {
        return 21;
      }
      case "ENUM_LABEL_22": {
        return 22;
      }
      case "ENUM_LABEL_23": {
        return 23;
      }
      case "ENUM_LABEL_24": {
        return 24;
      }
      case "ENUM_LABEL_25": {
        return 25;
      }
      case "ENUM_LABEL_26": {
        return 26;
      }
      case "ENUM_LABEL_27": {
        return 27;
      }
      case "ENUM_LABEL_28": {
        return 28;
      }
      case "ENUM_LABEL_29": {
        return 29;
      }
      case "ENUM_LABEL_30": {
        return 30;
      }
      case "ENUM_LABEL_31": {
        return 31;
      }
      case "ENUM_LABEL_32": {
        return 32;
      }
      case "ENUM_LABEL_33": {
        return 33;
      }
      case "ENUM_LABEL_34": {
        return 34;
      }
      case "ENUM_LABEL_35": {
        return 35;
      }
      case "ENUM_LABEL_36": {
        return 36;
      }
      case "ENUM_LABEL_37": {
        return 37;
      }
      case "ENUM_LABEL_38": {
        return 38;
      }
      case "ENUM_LABEL_39": {
        return 39;
      }
      case "ENUM_LABEL_40": {
        return 40;
      }
      case "ENUM_LABEL_41": {
        return 41;
      }
      case "ENUM_LABEL_42": {
        return 42;
      }
      case "ENUM_LABEL_43": {
        return 43;
      }
      case "ENUM_LABEL_44": {
        return 44;
      }
      case "ENUM_LABEL_45": {
        return 45;
      }
      case "ENUM_LABEL_46": {
        return 46;
      }
      case "ENUM_LABEL_47": {
        return 47;
      }
      case "ENUM_LABEL_48": {
        return 48;
      }
      case "ENUM_LABEL_49": {
        return 49;
      }
      case "ENUM_LABEL_50": {
        return 50;
      }
      case "ENUM_LABEL_51": {
        return 51;
      }
      case "ENUM_LABEL_52": {
        return 52;
      }
      case "ENUM_LABEL_53": {
        return 53;
      }
      case "ENUM_LABEL_54": {
        return 54;
      }
      case "ENUM_LABEL_55": {
        return 55;
      }
      case "ENUM_LABEL_56": {
        return 56;
      }
      case "ENUM_LABEL_57": {
        return 57;
      }
      case "ENUM_LABEL_58": {
        return 58;
      }
      case "ENUM_LABEL_59": {
        return 59;
      }
      case "ENUM_LABEL_60": {
        return 60;
      }
      case "ENUM_LABEL_61": {
        return 61;
      }
      case "ENUM_LABEL_62": {
        return 62;
      }
      case "ENUM_LABEL_63": {
        return 63;
      }
      case "ENUM_LABEL_64": {
        return 64;
      }
      case "ENUM_LABEL_65": {
        return 65;
      }
      case "ENUM_LABEL_66": {
        return 66;
      }
      case "ENUM_LABEL_67": {
        return 67;
      }
      case "ENUM_LABEL_68": {
        return 68;
      }
      case "ENUM_LABEL_69": {
        return 69;
      }
      case "ENUM_LABEL_70": {
        return 70;
      }
      case "ENUM_LABEL_71": {
        return 71;
      }
      case "ENUM_LABEL_72": {
        return 72;
      }
      case "ENUM_LABEL_73": {
        return 73;
      }
      case "ENUM_LABEL_74": {
        return 74;
      }
      case "ENUM_LABEL_75": {
        return 75;
      }
      case "ENUM_LABEL_76": {
        return 76;
      }
      case "ENUM_LABEL_77": {
        return 77;
      }
      case "ENUM_LABEL_78": {
        return 78;
      }
      case "ENUM_LABEL_79": {
        return 79;
      }
      case "ENUM_LABEL_80": {
        return 80;
      }
      case "ENUM_LABEL_81": {
        return 81;
      }
      case "ENUM_LABEL_82": {
        return 82;
      }
      case "ENUM_LABEL_83": {
        return 83;
      }
      case "ENUM_LABEL_84": {
        return 84;
      }
      case "ENUM_LABEL_85": {
        return 85;
      }
      case "ENUM_LABEL_86": {
        return 86;
      }
      case "ENUM_LABEL_87": {
        return 87;
      }
      case "ENUM_LABEL_88": {
        return 88;
      }
      case "ENUM_LABEL_89": {
        return 89;
      }
      case "ENUM_LABEL_90": {
        return 90;
      }
      case "ENUM_LABEL_91": {
        return 91;
      }
      case "ENUM_LABEL_92": {
        return 92;
      }
      case "ENUM_LABEL_93": {
        return 93;
      }
      case "ENUM_LABEL_94": {
        return 94;
      }
      case "ENUM_LABEL_95": {
        return 95;
      }
      case "ENUM_LABEL_96": {
        return 96;
      }
      case "ENUM_LABEL_97": {
        return 97;
      }
      case "ENUM_LABEL_98": {
        return 98;
      }
      case "ENUM_LABEL_99": {
        return 99;
      }
      case "ENUM_LABEL_100": {
        return 100;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypes = {
  /**
   * Serializes TestAllTypes to protobuf.
   */
  encode: function (msg: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      defaultForeignEnum: ForeignEnum._fromInt(0),
      defaultImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      defaultStringPiece: "",
      defaultCord: "",
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString() as any);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString() as any);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString() as any);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString() as any);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64String(10, msg.optionalSfixed64.toString() as any);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
      );
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    if (
      msg.optionalImportEnum &&
      googleProtobufUnittest_import.ImportEnum._toInt(msg.optionalImportEnum)
    ) {
      writer.writeEnum(
        23,
        googleProtobufUnittest_import.ImportEnum._toInt(msg.optionalImportEnum)
      );
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        googleProtobufUnittest_import_public.PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        40,
        msg.repeatedSfixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writePackedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnum._toInt)
      );
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writePackedEnum(
        53,
        msg.repeatedImportEnum.map(
          googleProtobufUnittest_import.ImportEnum._toInt
        )
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString() as any);
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString() as any);
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString() as any);
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString() as any);
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64String(70, msg.defaultSfixed64.toString() as any);
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes?.length) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.defaultNestedEnum)
    ) {
      writer.writeEnum(
        81,
        TestAllTypes.NestedEnum._toInt(msg.defaultNestedEnum)
      );
    }
    if (msg.defaultForeignEnum && ForeignEnum._toInt(msg.defaultForeignEnum)) {
      writer.writeEnum(82, ForeignEnum._toInt(msg.defaultForeignEnum));
    }
    if (
      msg.defaultImportEnum &&
      googleProtobufUnittest_import.ImportEnum._toInt(msg.defaultImportEnum)
    ) {
      writer.writeEnum(
        83,
        googleProtobufUnittest_import.ImportEnum._toInt(msg.defaultImportEnum)
      );
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 23: {
          msg.optionalImportEnum =
            googleProtobufUnittest_import.ImportEnum._fromInt(
              reader.readEnum()
            );
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            googleProtobufUnittest_import_public.PublicImportMessage
              ._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 32: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 33: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 34: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 35: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 36: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 37: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 38: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 39: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 40: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 41: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 42: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 43: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = googleProtobufUnittest_import.ImportMessage.initialize();
          reader.readMessage(
            m,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt)
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 52: {
          if (reader.isDelimited()) {
            msg.repeatedForeignEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.repeatedForeignEnum.push(
              ForeignEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 53: {
          if (reader.isDelimited()) {
            msg.repeatedImportEnum.push(
              ...reader
                .readPackedEnum()
                .map(googleProtobufUnittest_import.ImportEnum._fromInt)
            );
          } else {
            msg.repeatedImportEnum.push(
              googleProtobufUnittest_import.ImportEnum._fromInt(
                reader.readEnum()
              )
            );
          }
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum()
          );
          break;
        }
        case 82: {
          msg.defaultForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 83: {
          msg.defaultImportEnum =
            googleProtobufUnittest_import.ImportEnum._fromInt(
              reader.readEnum()
            );
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          msg.oneofNestedMessage = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypes.NestedEnum {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypes.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypes.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.NestedMessage>): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.OptionalGroup>): Uint8Array {
      return TestAllTypes.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      reader: BinaryReader
    ): TestAllTypes.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.RepeatedGroup>): Uint8Array {
      return TestAllTypes.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      reader: BinaryReader
    ): TestAllTypes.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes NestedTestAllTypes to protobuf.
   */
  encode: function (msg: Partial<NestedTestAllTypes>): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild as any,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes TestDeprecatedFields to protobuf.
   */
  encode: function (msg: Partial<TestDeprecatedFields>): Uint8Array {
    return TestDeprecatedFields._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDeprecatedFields from protobuf.
   */
  decode: function (bytes: ByteSource): TestDeprecatedFields {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecatedInt32: 0,
      deprecatedInt32InOneof: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    reader: BinaryReader
  ): TestDeprecatedFields {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes TestDeprecatedMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestDeprecatedMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestDeprecatedMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestDeprecatedMessage {
    return {};
  },

  /**
   * Initializes TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestDeprecatedMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestDeprecatedMessage,
    _reader: BinaryReader
  ): TestDeprecatedMessage {
    return _msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes ForeignMessage to protobuf.
   */
  encode: function (msg: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes TestReservedFields to protobuf.
   */
  encode: function (_msg?: Partial<TestReservedFields>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestReservedFields from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestReservedFields {
    return {};
  },

  /**
   * Initializes TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestReservedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestReservedFields,
    _reader: BinaryReader
  ): TestReservedFields {
    return _msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes TestAllExtensions to protobuf.
   */
  encode: function (_msg?: Partial<TestAllExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestAllExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestAllExtensions {
    return {};
  },

  /**
   * Initializes TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestAllExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestAllExtensions,
    _reader: BinaryReader
  ): TestAllExtensions {
    return _msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes OptionalGroup_extension to protobuf.
   */
  encode: function (msg: Partial<OptionalGroup_extension>): Uint8Array {
    return OptionalGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes OptionalGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): OptionalGroup_extension {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OptionalGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    reader: BinaryReader
  ): OptionalGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes RepeatedGroup_extension to protobuf.
   */
  encode: function (msg: Partial<RepeatedGroup_extension>): Uint8Array {
    return RepeatedGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    reader: BinaryReader
  ): RepeatedGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes TestGroup to protobuf.
   */
  encode: function (msg: Partial<TestGroup>): Uint8Array {
    return TestGroup._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestGroup from protobuf.
   */
  decode: function (bytes: ByteSource): TestGroup {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optionalForeignEnum: ForeignEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestGroup>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, reader: BinaryReader): TestGroup {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestGroup.OptionalGroup to protobuf.
     */
    encode: function (msg: Partial<TestGroup.OptionalGroup>): Uint8Array {
      return TestGroup.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      reader: BinaryReader
    ): TestGroup.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes TestGroupExtension to protobuf.
   */
  encode: function (_msg?: Partial<TestGroupExtension>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestGroupExtension from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestGroupExtension {
    return {};
  },

  /**
   * Initializes TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestGroupExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestGroupExtension,
    _reader: BinaryReader
  ): TestGroupExtension {
    return _msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes TestNestedExtension to protobuf.
   */
  encode: function (_msg?: Partial<TestNestedExtension>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestNestedExtension from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestNestedExtension {
    return {};
  },

  /**
   * Initializes TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestNestedExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestNestedExtension,
    _reader: BinaryReader
  ): TestNestedExtension {
    return _msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Uint8Array {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      reader: BinaryReader
    ): TestNestedExtension.OptionalGroup_extension {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes TestChildExtension to protobuf.
   */
  encode: function (msg: Partial<TestChildExtension>): Uint8Array {
    return TestChildExtension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestChildExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestChildExtension {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: "",
      b: "",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestChildExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    reader: BinaryReader
  ): TestChildExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes TestRequired to protobuf.
   */
  encode: function (msg: Partial<TestRequired>): Uint8Array {
    return TestRequired._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequired from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequired {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequired>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequired,
    reader: BinaryReader
  ): TestRequired {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes TestRequiredForeign to protobuf.
   */
  encode: function (msg: Partial<TestRequiredForeign>): Uint8Array {
    return TestRequiredForeign._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredForeign from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredForeign {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredForeign>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    reader: BinaryReader
  ): TestRequiredForeign {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes TestRequiredMessage to protobuf.
   */
  encode: function (msg: Partial<TestRequiredMessage>): Uint8Array {
    return TestRequiredMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessage {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    reader: BinaryReader
  ): TestRequiredMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes TestForeignNested to protobuf.
   */
  encode: function (msg: Partial<TestForeignNested>): Uint8Array {
    return TestForeignNested._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestForeignNested from protobuf.
   */
  decode: function (bytes: ByteSource): TestForeignNested {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestForeignNested>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    reader: BinaryReader
  ): TestForeignNested {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes TestEmptyMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestEmptyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestEmptyMessage,
    _reader: BinaryReader
  ): TestEmptyMessage {
    return _msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (
    _msg?: Partial<TestEmptyMessageWithExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Initializes TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestEmptyMessageWithExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestEmptyMessageWithExtensions,
    _reader: BinaryReader
  ): TestEmptyMessageWithExtensions {
    return _msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes TestPickleNestedMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestPickleNestedMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestPickleNestedMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestPickleNestedMessage {
    return {};
  },

  /**
   * Initializes TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestPickleNestedMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestPickleNestedMessage,
    _reader: BinaryReader
  ): TestPickleNestedMessage {
    return _msg;
  },

  NestedMessage: {
    /**
     * Serializes TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): Uint8Array {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      reader: BinaryReader
    ): TestPickleNestedMessage.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Uint8Array {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        reader: BinaryReader
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes TestMultipleExtensionRanges to protobuf.
   */
  encode: function (_msg?: Partial<TestMultipleExtensionRanges>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestMultipleExtensionRanges from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Initializes TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestMultipleExtensionRanges>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestMultipleExtensionRanges,
    _reader: BinaryReader
  ): TestMultipleExtensionRanges {
    return _msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes TestReallyLargeTagNumber to protobuf.
   */
  encode: function (msg: Partial<TestReallyLargeTagNumber>): Uint8Array {
    return TestReallyLargeTagNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    reader: BinaryReader
  ): TestReallyLargeTagNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes TestRecursiveMessage to protobuf.
   */
  encode: function (msg: Partial<TestRecursiveMessage>): Uint8Array {
    return TestRecursiveMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRecursiveMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMessage {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    reader: BinaryReader
  ): TestRecursiveMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes TestMutualRecursionA to protobuf.
   */
  encode: function (msg: Partial<TestMutualRecursionA>): Uint8Array {
    return TestMutualRecursionA._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMutualRecursionA from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionA {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionA>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    reader: BinaryReader
  ): TestMutualRecursionA {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestMutualRecursionA.SubMessage>
    ): Uint8Array {
      return TestMutualRecursionA.SubMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      reader: BinaryReader
    ): TestMutualRecursionA.SubMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (msg: Partial<TestMutualRecursionA.SubGroup>): Uint8Array {
      return TestMutualRecursionA.SubGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      reader: BinaryReader
    ): TestMutualRecursionA.SubGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes TestMutualRecursionB to protobuf.
   */
  encode: function (msg: Partial<TestMutualRecursionB>): Uint8Array {
    return TestMutualRecursionB._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMutualRecursionB from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionB {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionB>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    reader: BinaryReader
  ): TestMutualRecursionB {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes TestIsInitialized to protobuf.
   */
  encode: function (msg: Partial<TestIsInitialized>): Uint8Array {
    return TestIsInitialized._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestIsInitialized from protobuf.
   */
  decode: function (bytes: ByteSource): TestIsInitialized {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestIsInitialized>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    reader: BinaryReader
  ): TestIsInitialized {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (
      _msg?: Partial<TestIsInitialized.SubMessage>
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (_bytes?: ByteSource): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Initializes TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: Partial<TestIsInitialized.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: TestIsInitialized.SubMessage,
      _reader: BinaryReader
    ): TestIsInitialized.SubMessage {
      return _msg;
    },

    SubGroup: {
      /**
       * Serializes TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Uint8Array {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        reader: BinaryReader
      ): TestIsInitialized.SubMessage.SubGroup {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes TestDupFieldNumber to protobuf.
   */
  encode: function (msg: Partial<TestDupFieldNumber>): Uint8Array {
    return TestDupFieldNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDupFieldNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestDupFieldNumber {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDupFieldNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    reader: BinaryReader
  ): TestDupFieldNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (msg: Partial<TestDupFieldNumber.Foo>): Uint8Array {
      return TestDupFieldNumber.Foo._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      reader: BinaryReader
    ): TestDupFieldNumber.Foo {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (msg: Partial<TestDupFieldNumber.Bar>): Uint8Array {
      return TestDupFieldNumber.Bar._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      reader: BinaryReader
    ): TestDupFieldNumber.Bar {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes TestEagerMessage to protobuf.
   */
  encode: function (msg: Partial<TestEagerMessage>): Uint8Array {
    return TestEagerMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestEagerMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEagerMessage {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEagerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEagerMessage,
    reader: BinaryReader
  ): TestEagerMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes TestLazyMessage to protobuf.
   */
  encode: function (msg: Partial<TestLazyMessage>): Uint8Array {
    return TestLazyMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestLazyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestLazyMessage {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestLazyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestLazyMessage,
    reader: BinaryReader
  ): TestLazyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes TestNestedMessageHasBits to protobuf.
   */
  encode: function (msg: Partial<TestNestedMessageHasBits>): Uint8Array {
    return TestNestedMessageHasBits._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes: ByteSource): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    reader: BinaryReader
  ): TestNestedMessageHasBits {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Uint8Array {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writePackedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage as any,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      reader: BinaryReader
    ): TestNestedMessageHasBits.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            if (reader.isDelimited()) {
              msg.nestedmessageRepeatedInt32.push(...reader.readPackedInt32());
            } else {
              msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            }
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes TestCamelCaseFieldNames to protobuf.
   */
  encode: function (msg: Partial<TestCamelCaseFieldNames>): Uint8Array {
    return TestCamelCaseFieldNames._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes: ByteSource): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: "",
      EnumField: ForeignEnum._fromInt(0),
      MessageField: ForeignMessage.initialize(),
      StringPieceField: "",
      CordField: "",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField && ForeignEnum._toInt(msg.EnumField)) {
      writer.writeEnum(3, ForeignEnum._toInt(msg.EnumField));
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writePackedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writePackedEnum(9, msg.RepeatedEnumField.map(ForeignEnum._toInt));
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    reader: BinaryReader
  ): TestCamelCaseFieldNames {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          if (reader.isDelimited()) {
            msg.RepeatedPrimitiveField.push(...reader.readPackedInt32());
          } else {
            msg.RepeatedPrimitiveField.push(reader.readInt32());
          }
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          if (reader.isDelimited()) {
            msg.RepeatedEnumField.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.RepeatedEnumField.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes TestFieldOrderings to protobuf.
   */
  encode: function (msg: Partial<TestFieldOrderings>): Uint8Array {
    return TestFieldOrderings._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestFieldOrderings from protobuf.
   */
  decode: function (bytes: ByteSource): TestFieldOrderings {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      myString: "",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestFieldOrderings>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString() as any);
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    reader: BinaryReader
  ): TestFieldOrderings {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestFieldOrderings.NestedMessage>
    ): Uint8Array {
      return TestFieldOrderings.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString() as any);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      reader: BinaryReader
    ): TestFieldOrderings.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes TestExtensionOrderings1 to protobuf.
   */
  encode: function (msg: Partial<TestExtensionOrderings1>): Uint8Array {
    return TestExtensionOrderings1._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    reader: BinaryReader
  ): TestExtensionOrderings1 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes TestExtensionOrderings2 to protobuf.
   */
  encode: function (msg: Partial<TestExtensionOrderings2>): Uint8Array {
    return TestExtensionOrderings2._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    reader: BinaryReader
  ): TestExtensionOrderings2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Uint8Array {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        myString: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      reader: BinaryReader
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes TestExtremeDefaultValues to protobuf.
   */
  encode: function (msg: Partial<TestExtremeDefaultValues>): Uint8Array {
    return TestExtremeDefaultValues._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: "",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: "",
      stringWithZero: "",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: "",
      cordWithZero: "",
      replacementString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.escapedBytes?.length) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString() as any);
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString() as any);
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString() as any);
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero?.length) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    reader: BinaryReader
  ): TestExtremeDefaultValues {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes SparseEnumMessage to protobuf.
   */
  encode: function (msg: Partial<SparseEnumMessage>): Uint8Array {
    return SparseEnumMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes SparseEnumMessage from protobuf.
   */
  decode: function (bytes: ByteSource): SparseEnumMessage {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparseEnum: TestSparseEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SparseEnumMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sparseEnum && TestSparseEnum._toInt(msg.sparseEnum)) {
      writer.writeEnum(1, TestSparseEnum._toInt(msg.sparseEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    reader: BinaryReader
  ): SparseEnumMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = TestSparseEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes OneString to protobuf.
   */
  encode: function (msg: Partial<OneString>): Uint8Array {
    return OneString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes OneString from protobuf.
   */
  decode: function (bytes: ByteSource): OneString {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, reader: BinaryReader): OneString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes MoreString to protobuf.
   */
  encode: function (msg: Partial<MoreString>): Uint8Array {
    return MoreString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes MoreString from protobuf.
   */
  decode: function (bytes: ByteSource): MoreString {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, reader: BinaryReader): MoreString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes OneBytes to protobuf.
   */
  encode: function (msg: Partial<OneBytes>): Uint8Array {
    return OneBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes OneBytes from protobuf.
   */
  decode: function (bytes: ByteSource): OneBytes {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, reader: BinaryReader): OneBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes MoreBytes to protobuf.
   */
  encode: function (msg: Partial<MoreBytes>): Uint8Array {
    return MoreBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes MoreBytes from protobuf.
   */
  decode: function (bytes: ByteSource): MoreBytes {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, reader: BinaryReader): MoreBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes Int32Message to protobuf.
   */
  encode: function (msg: Partial<Int32Message>): Uint8Array {
    return Int32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Int32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int32Message {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int32Message,
    reader: BinaryReader
  ): Int32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes Uint32Message to protobuf.
   */
  encode: function (msg: Partial<Uint32Message>): Uint8Array {
    return Uint32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Uint32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint32Message {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint32Message,
    reader: BinaryReader
  ): Uint32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes Int64Message to protobuf.
   */
  encode: function (msg: Partial<Int64Message>): Uint8Array {
    return Int64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Int64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int64Message {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int64Message,
    reader: BinaryReader
  ): Int64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes Uint64Message to protobuf.
   */
  encode: function (msg: Partial<Uint64Message>): Uint8Array {
    return Uint64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Uint64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint64Message {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint64Message,
    reader: BinaryReader
  ): Uint64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes BoolMessage to protobuf.
   */
  encode: function (msg: Partial<BoolMessage>): Uint8Array {
    return BoolMessage._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes BoolMessage from protobuf.
   */
  decode: function (bytes: ByteSource): BoolMessage {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BoolMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, reader: BinaryReader): BoolMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes TestOneof to protobuf.
   */
  encode: function (msg: Partial<TestOneof>): Uint8Array {
    return TestOneof._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, reader: BinaryReader): TestOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooMessage = TestAllTypes.initialize();
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneof.FooGroup to protobuf.
     */
    encode: function (msg: Partial<TestOneof.FooGroup>): Uint8Array {
      return TestOneof.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      reader: BinaryReader
    ): TestOneof.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (msg: Partial<TestOneofBackwardsCompatible>): Uint8Array {
    return TestOneofBackwardsCompatible._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      fooInt: 0,
      fooString: "",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    reader: BinaryReader
  ): TestOneofBackwardsCompatible {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Uint8Array {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      reader: BinaryReader
    ): TestOneofBackwardsCompatible.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes TestOneof2 to protobuf.
   */
  encode: function (msg: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooCord: undefined,
      fooStringPiece: undefined,
      fooBytes: undefined,
      fooEnum: undefined,
      fooMessage: undefined,
      fooLazyMessage: undefined,
      barInt: undefined,
      barString: undefined,
      barCord: undefined,
      barStringPiece: undefined,
      barBytes: undefined,
      barEnum: undefined,
      barStringWithEmptyDefault: undefined,
      barCordWithEmptyDefault: undefined,
      barStringPieceWithEmptyDefault: undefined,
      barBytesWithEmptyDefault: undefined,
      bazInt: 0,
      bazString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes?.length) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnum._toInt(msg.fooEnum));
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes?.length) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, TestOneof2.NestedEnum._toInt(msg.barEnum));
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.fooMessage = TestOneof2.NestedMessage.initialize();
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          msg.fooLazyMessage = TestOneof2.NestedMessage.initialize();
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestOneof2.NestedEnum {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestOneof2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestOneof2.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  FooGroup: {
    /**
     * Serializes TestOneof2.FooGroup to protobuf.
     */
    encode: function (msg: Partial<TestOneof2.FooGroup>): Uint8Array {
      return TestOneof2.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      reader: BinaryReader
    ): TestOneof2.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes TestOneof2.NestedMessage to protobuf.
     */
    encode: function (msg: Partial<TestOneof2.NestedMessage>): Uint8Array {
      return TestOneof2.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString() as any);
      }
      if (msg.corgeInt?.length) {
        writer.writePackedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      reader: BinaryReader
    ): TestOneof2.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            if (reader.isDelimited()) {
              msg.corgeInt.push(...reader.readPackedInt32());
            } else {
              msg.corgeInt.push(reader.readInt32());
            }
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes TestRequiredOneof to protobuf.
   */
  encode: function (msg: Partial<TestRequiredOneof>): Uint8Array {
    return TestRequiredOneof._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredOneof {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    reader: BinaryReader
  ): TestRequiredOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooMessage = TestRequiredOneof.NestedMessage.initialize();
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestRequiredOneof.NestedMessage>
    ): Uint8Array {
      return TestRequiredOneof.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      reader: BinaryReader
    ): TestRequiredOneof.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes TestPackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedUint32?.length) {
      writer.writePackedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedSint32?.length) {
      writer.writePackedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writePackedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.packedSfixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedFloat?.length) {
      writer.writePackedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writePackedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writePackedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writePackedEnum(103, msg.packedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.packedInt64.push(...reader.readPackedInt64String().map(BigInt));
          } else {
            msg.packedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.packedUint32.push(...reader.readPackedUint32());
          } else {
            msg.packedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.packedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.packedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.packedSint32.push(...reader.readPackedSint32());
          } else {
            msg.packedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.packedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.packedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.packedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.packedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.packedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.packedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.packedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.packedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.packedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.packedFloat.push(...reader.readPackedFloat());
          } else {
            msg.packedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.packedDouble.push(...reader.readPackedDouble());
          } else {
            msg.packedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.packedBool.push(...reader.readPackedBool());
          } else {
            msg.packedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.packedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.packedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes TestUnpackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.unpackedInt32?.length) {
      writer.writePackedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.unpackedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.unpackedUint32?.length) {
      writer.writePackedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.unpackedUint64.map((x) => x.toString() as any)
      );
    }
    if (msg.unpackedSint32?.length) {
      writer.writePackedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.unpackedSint64.map((x) => x.toString() as any)
      );
    }
    if (msg.unpackedFixed32?.length) {
      writer.writePackedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.unpackedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.unpackedSfixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.unpackedFloat?.length) {
      writer.writePackedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writePackedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writePackedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writePackedEnum(103, msg.unpackedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.unpackedInt32.push(...reader.readPackedInt32());
          } else {
            msg.unpackedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.unpackedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.unpackedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.unpackedUint32.push(...reader.readPackedUint32());
          } else {
            msg.unpackedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.unpackedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.unpackedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.unpackedSint32.push(...reader.readPackedSint32());
          } else {
            msg.unpackedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.unpackedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.unpackedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.unpackedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.unpackedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.unpackedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.unpackedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.unpackedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.unpackedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.unpackedFloat.push(...reader.readPackedFloat());
          } else {
            msg.unpackedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.unpackedDouble.push(...reader.readPackedDouble());
          } else {
            msg.unpackedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.unpackedBool.push(...reader.readPackedBool());
          } else {
            msg.unpackedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.unpackedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.unpackedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes TestPackedExtensions to protobuf.
   */
  encode: function (_msg?: Partial<TestPackedExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestPackedExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestPackedExtensions {
    return {};
  },

  /**
   * Initializes TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestPackedExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestPackedExtensions,
    _reader: BinaryReader
  ): TestPackedExtensions {
    return _msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes TestUnpackedExtensions to protobuf.
   */
  encode: function (_msg?: Partial<TestUnpackedExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestUnpackedExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestUnpackedExtensions {
    return {};
  },

  /**
   * Initializes TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestUnpackedExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestUnpackedExtensions,
    _reader: BinaryReader
  ): TestUnpackedExtensions {
    return _msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes TestDynamicExtensions to protobuf.
   */
  encode: function (msg: Partial<TestDynamicExtensions>): Uint8Array {
    return TestDynamicExtensions._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDynamicExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestDynamicExtensions {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnum._fromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType._fromInt(0),
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDynamicExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension && ForeignEnum._toInt(msg.enumExtension)) {
      writer.writeEnum(2001, ForeignEnum._toInt(msg.enumExtension));
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumType._toInt(msg.dynamicEnumExtension)
    ) {
      writer.writeEnum(
        2002,
        TestDynamicExtensions.DynamicEnumType._toInt(msg.dynamicEnumExtension)
      );
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writePackedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    reader: BinaryReader
  ): TestDynamicExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            TestDynamicExtensions.DynamicEnumType._fromInt(reader.readEnum());
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          if (reader.isDelimited()) {
            msg.packedExtension.push(...reader.readPackedSint32());
          } else {
            msg.packedExtension.push(reader.readSint32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: "DYNAMIC_FOO",
    DYNAMIC_BAR: "DYNAMIC_BAR",
    DYNAMIC_BAZ: "DYNAMIC_BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestDynamicExtensions.DynamicEnumType {
      switch (i) {
        case 2200: {
          return "DYNAMIC_FOO";
        }
        case 2201: {
          return "DYNAMIC_BAR";
        }
        case 2202: {
          return "DYNAMIC_BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestDynamicExtensions.DynamicEnumType;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestDynamicExtensions.DynamicEnumType): number {
      switch (i) {
        case "DYNAMIC_FOO": {
          return 2200;
        }
        case "DYNAMIC_BAR": {
          return 2201;
        }
        case "DYNAMIC_BAZ": {
          return 2202;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  DynamicMessageType: {
    /**
     * Serializes TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Uint8Array {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      reader: BinaryReader
    ): TestDynamicExtensions.DynamicMessageType {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Uint8Array {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes: ByteSource): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        2046,
        msg.repeatedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        2047,
        msg.repeatedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        262143,
        msg.repeatedUint64.map((x) => x.toString() as any)
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    reader: BinaryReader
  ): TestRepeatedScalarDifferentTagSizes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 13: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 2046: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 2047: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 262142: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 262143: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes TestParsingMerge to protobuf.
   */
  encode: function (msg: Partial<TestParsingMerge>): Uint8Array {
    return TestParsingMerge._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestParsingMerge from protobuf.
   */
  decode: function (bytes: ByteSource): TestParsingMerge {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestParsingMerge>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes as any,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestParsingMerge,
    reader: BinaryReader
  ): TestParsingMerge {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Uint8Array {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.field1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.field2 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(
          3,
          msg.field3 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(
          1000,
          msg.ext1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(
          1001,
          msg.ext2 as any,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedFieldsGenerator {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestParsingMerge.OptionalGroup>
    ): Uint8Array {
      return TestParsingMerge.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      reader: BinaryReader
    ): TestParsingMerge.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>
    ): Uint8Array {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes TestCommentInjectionMessage to protobuf.
   */
  encode: function (msg: Partial<TestCommentInjectionMessage>): Uint8Array {
    return TestCommentInjectionMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    reader: BinaryReader
  ): TestCommentInjectionMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes FooRequest to protobuf.
   */
  encode: function (_msg?: Partial<FooRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes FooRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooRequest {
    return {};
  },

  /**
   * Initializes FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg: FooRequest, _reader: BinaryReader): FooRequest {
    return _msg;
  },
};

export const FooResponse = {
  /**
   * Serializes FooResponse to protobuf.
   */
  encode: function (_msg?: Partial<FooResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes FooResponse from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooResponse {
    return {};
  },

  /**
   * Initializes FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: FooResponse,
    _reader: BinaryReader
  ): FooResponse {
    return _msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes FooClientMessage to protobuf.
   */
  encode: function (_msg?: Partial<FooClientMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes FooClientMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooClientMessage {
    return {};
  },

  /**
   * Initializes FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooClientMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: FooClientMessage,
    _reader: BinaryReader
  ): FooClientMessage {
    return _msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes FooServerMessage to protobuf.
   */
  encode: function (_msg?: Partial<FooServerMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes FooServerMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooServerMessage {
    return {};
  },

  /**
   * Initializes FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooServerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: FooServerMessage,
    _reader: BinaryReader
  ): FooServerMessage {
    return _msg;
  },
};

export const BarRequest = {
  /**
   * Serializes BarRequest to protobuf.
   */
  encode: function (_msg?: Partial<BarRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes BarRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): BarRequest {
    return {};
  },

  /**
   * Initializes BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<BarRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg: BarRequest, _reader: BinaryReader): BarRequest {
    return _msg;
  },
};

export const BarResponse = {
  /**
   * Serializes BarResponse to protobuf.
   */
  encode: function (_msg?: Partial<BarResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes BarResponse from protobuf.
   */
  decode: function (_bytes?: ByteSource): BarResponse {
    return {};
  },

  /**
   * Initializes BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<BarResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: BarResponse,
    _reader: BinaryReader
  ): BarResponse {
    return _msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes TestJsonName to protobuf.
   */
  encode: function (msg: Partial<TestJsonName>): Uint8Array {
    return TestJsonName._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestJsonName from protobuf.
   */
  decode: function (bytes: ByteSource): TestJsonName {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestJsonName>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestJsonName,
    reader: BinaryReader
  ): TestJsonName {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes TestHugeFieldNumbers to protobuf.
   */
  encode: function (msg: Partial<TestHugeFieldNumbers>): Uint8Array {
    return TestHugeFieldNumbers._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes: ByteSource): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnum._fromInt(0),
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofUint32: undefined,
      oneofTestAllTypes: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum && ForeignEnum._toInt(msg.optionalEnum)) {
      writer.writeEnum(536870004, ForeignEnum._toInt(msg.optionalEnum));
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      writer.writeRepeatedMessage(
        536870010,
        Object.entries(msg.stringStringMap).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestHugeFieldNumbers.StringStringMap._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    reader: BinaryReader
  ): TestHugeFieldNumbers {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 536870003: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 536870004: {
          msg.optionalEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          const map = {} as TestHugeFieldNumbers.StringStringMap;
          reader.readMessage(
            map,
            TestHugeFieldNumbers.StringStringMap._readMessage
          );
          msg.stringStringMap[map.key.toString()] = map.value;
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          msg.oneofTestAllTypes = TestAllTypes.initialize();
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Uint8Array {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      reader: BinaryReader
    ): TestHugeFieldNumbers.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.StringStringMap>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.StringStringMap,
      reader: BinaryReader
    ): TestHugeFieldNumbers.StringStringMap {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes TestExtensionInsideTable to protobuf.
   */
  encode: function (msg: Partial<TestExtensionInsideTable>): Uint8Array {
    return TestExtensionInsideTable._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    reader: BinaryReader
  ): TestExtensionInsideTable {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes TestExtensionRangeSerialize to protobuf.
   */
  encode: function (msg: Partial<TestExtensionRangeSerialize>): Uint8Array {
    return TestExtensionRangeSerialize._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    reader: BinaryReader
  ): TestExtensionRangeSerialize {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ForeignEnumJSON = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnum {
    switch (i) {
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnum): number {
    switch (i) {
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestEnumWithDupValueJSON = {
  FOO1: "FOO1",
  BAR1: "BAR1",
  BAZ: "BAZ",
  FOO2: "FOO2",
  BAR2: "BAR2",
  /**
   * @private
   */
  _fromInt: function (i: number): TestEnumWithDupValue {
    switch (i) {
      case 1: {
        return "FOO1";
      }
      case 2: {
        return "BAR1";
      }
      case 3: {
        return "BAZ";
      }
      case 1: {
        return "FOO2";
      }
      case 2: {
        return "BAR2";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestEnumWithDupValue;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TestEnumWithDupValue): number {
    switch (i) {
      case "FOO1": {
        return 1;
      }
      case "BAR1": {
        return 2;
      }
      case "BAZ": {
        return 3;
      }
      case "FOO2": {
        return 1;
      }
      case "BAR2": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestSparseEnumJSON = {
  SPARSE_A: "SPARSE_A",
  SPARSE_B: "SPARSE_B",
  SPARSE_C: "SPARSE_C",
  SPARSE_D: "SPARSE_D",
  SPARSE_E: "SPARSE_E",
  SPARSE_F: "SPARSE_F",
  SPARSE_G: "SPARSE_G",
  /**
   * @private
   */
  _fromInt: function (i: number): TestSparseEnum {
    switch (i) {
      case 123: {
        return "SPARSE_A";
      }
      case 62374: {
        return "SPARSE_B";
      }
      case 12589234: {
        return "SPARSE_C";
      }
      case -15: {
        return "SPARSE_D";
      }
      case -53452: {
        return "SPARSE_E";
      }
      case 0: {
        return "SPARSE_F";
      }
      case 2: {
        return "SPARSE_G";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestSparseEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TestSparseEnum): number {
    switch (i) {
      case "SPARSE_A": {
        return 123;
      }
      case "SPARSE_B": {
        return 62374;
      }
      case "SPARSE_C": {
        return 12589234;
      }
      case "SPARSE_D": {
        return -15;
      }
      case "SPARSE_E": {
        return -53452;
      }
      case "SPARSE_F": {
        return 0;
      }
      case "SPARSE_G": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const VeryLargeEnumJSON = {
  ENUM_LABEL_DEFAULT: "ENUM_LABEL_DEFAULT",
  ENUM_LABEL_1: "ENUM_LABEL_1",
  ENUM_LABEL_2: "ENUM_LABEL_2",
  ENUM_LABEL_3: "ENUM_LABEL_3",
  ENUM_LABEL_4: "ENUM_LABEL_4",
  ENUM_LABEL_5: "ENUM_LABEL_5",
  ENUM_LABEL_6: "ENUM_LABEL_6",
  ENUM_LABEL_7: "ENUM_LABEL_7",
  ENUM_LABEL_8: "ENUM_LABEL_8",
  ENUM_LABEL_9: "ENUM_LABEL_9",
  ENUM_LABEL_10: "ENUM_LABEL_10",
  ENUM_LABEL_11: "ENUM_LABEL_11",
  ENUM_LABEL_12: "ENUM_LABEL_12",
  ENUM_LABEL_13: "ENUM_LABEL_13",
  ENUM_LABEL_14: "ENUM_LABEL_14",
  ENUM_LABEL_15: "ENUM_LABEL_15",
  ENUM_LABEL_16: "ENUM_LABEL_16",
  ENUM_LABEL_17: "ENUM_LABEL_17",
  ENUM_LABEL_18: "ENUM_LABEL_18",
  ENUM_LABEL_19: "ENUM_LABEL_19",
  ENUM_LABEL_20: "ENUM_LABEL_20",
  ENUM_LABEL_21: "ENUM_LABEL_21",
  ENUM_LABEL_22: "ENUM_LABEL_22",
  ENUM_LABEL_23: "ENUM_LABEL_23",
  ENUM_LABEL_24: "ENUM_LABEL_24",
  ENUM_LABEL_25: "ENUM_LABEL_25",
  ENUM_LABEL_26: "ENUM_LABEL_26",
  ENUM_LABEL_27: "ENUM_LABEL_27",
  ENUM_LABEL_28: "ENUM_LABEL_28",
  ENUM_LABEL_29: "ENUM_LABEL_29",
  ENUM_LABEL_30: "ENUM_LABEL_30",
  ENUM_LABEL_31: "ENUM_LABEL_31",
  ENUM_LABEL_32: "ENUM_LABEL_32",
  ENUM_LABEL_33: "ENUM_LABEL_33",
  ENUM_LABEL_34: "ENUM_LABEL_34",
  ENUM_LABEL_35: "ENUM_LABEL_35",
  ENUM_LABEL_36: "ENUM_LABEL_36",
  ENUM_LABEL_37: "ENUM_LABEL_37",
  ENUM_LABEL_38: "ENUM_LABEL_38",
  ENUM_LABEL_39: "ENUM_LABEL_39",
  ENUM_LABEL_40: "ENUM_LABEL_40",
  ENUM_LABEL_41: "ENUM_LABEL_41",
  ENUM_LABEL_42: "ENUM_LABEL_42",
  ENUM_LABEL_43: "ENUM_LABEL_43",
  ENUM_LABEL_44: "ENUM_LABEL_44",
  ENUM_LABEL_45: "ENUM_LABEL_45",
  ENUM_LABEL_46: "ENUM_LABEL_46",
  ENUM_LABEL_47: "ENUM_LABEL_47",
  ENUM_LABEL_48: "ENUM_LABEL_48",
  ENUM_LABEL_49: "ENUM_LABEL_49",
  ENUM_LABEL_50: "ENUM_LABEL_50",
  ENUM_LABEL_51: "ENUM_LABEL_51",
  ENUM_LABEL_52: "ENUM_LABEL_52",
  ENUM_LABEL_53: "ENUM_LABEL_53",
  ENUM_LABEL_54: "ENUM_LABEL_54",
  ENUM_LABEL_55: "ENUM_LABEL_55",
  ENUM_LABEL_56: "ENUM_LABEL_56",
  ENUM_LABEL_57: "ENUM_LABEL_57",
  ENUM_LABEL_58: "ENUM_LABEL_58",
  ENUM_LABEL_59: "ENUM_LABEL_59",
  ENUM_LABEL_60: "ENUM_LABEL_60",
  ENUM_LABEL_61: "ENUM_LABEL_61",
  ENUM_LABEL_62: "ENUM_LABEL_62",
  ENUM_LABEL_63: "ENUM_LABEL_63",
  ENUM_LABEL_64: "ENUM_LABEL_64",
  ENUM_LABEL_65: "ENUM_LABEL_65",
  ENUM_LABEL_66: "ENUM_LABEL_66",
  ENUM_LABEL_67: "ENUM_LABEL_67",
  ENUM_LABEL_68: "ENUM_LABEL_68",
  ENUM_LABEL_69: "ENUM_LABEL_69",
  ENUM_LABEL_70: "ENUM_LABEL_70",
  ENUM_LABEL_71: "ENUM_LABEL_71",
  ENUM_LABEL_72: "ENUM_LABEL_72",
  ENUM_LABEL_73: "ENUM_LABEL_73",
  ENUM_LABEL_74: "ENUM_LABEL_74",
  ENUM_LABEL_75: "ENUM_LABEL_75",
  ENUM_LABEL_76: "ENUM_LABEL_76",
  ENUM_LABEL_77: "ENUM_LABEL_77",
  ENUM_LABEL_78: "ENUM_LABEL_78",
  ENUM_LABEL_79: "ENUM_LABEL_79",
  ENUM_LABEL_80: "ENUM_LABEL_80",
  ENUM_LABEL_81: "ENUM_LABEL_81",
  ENUM_LABEL_82: "ENUM_LABEL_82",
  ENUM_LABEL_83: "ENUM_LABEL_83",
  ENUM_LABEL_84: "ENUM_LABEL_84",
  ENUM_LABEL_85: "ENUM_LABEL_85",
  ENUM_LABEL_86: "ENUM_LABEL_86",
  ENUM_LABEL_87: "ENUM_LABEL_87",
  ENUM_LABEL_88: "ENUM_LABEL_88",
  ENUM_LABEL_89: "ENUM_LABEL_89",
  ENUM_LABEL_90: "ENUM_LABEL_90",
  ENUM_LABEL_91: "ENUM_LABEL_91",
  ENUM_LABEL_92: "ENUM_LABEL_92",
  ENUM_LABEL_93: "ENUM_LABEL_93",
  ENUM_LABEL_94: "ENUM_LABEL_94",
  ENUM_LABEL_95: "ENUM_LABEL_95",
  ENUM_LABEL_96: "ENUM_LABEL_96",
  ENUM_LABEL_97: "ENUM_LABEL_97",
  ENUM_LABEL_98: "ENUM_LABEL_98",
  ENUM_LABEL_99: "ENUM_LABEL_99",
  ENUM_LABEL_100: "ENUM_LABEL_100",
  /**
   * @private
   */
  _fromInt: function (i: number): VeryLargeEnum {
    switch (i) {
      case 0: {
        return "ENUM_LABEL_DEFAULT";
      }
      case 1: {
        return "ENUM_LABEL_1";
      }
      case 2: {
        return "ENUM_LABEL_2";
      }
      case 3: {
        return "ENUM_LABEL_3";
      }
      case 4: {
        return "ENUM_LABEL_4";
      }
      case 5: {
        return "ENUM_LABEL_5";
      }
      case 6: {
        return "ENUM_LABEL_6";
      }
      case 7: {
        return "ENUM_LABEL_7";
      }
      case 8: {
        return "ENUM_LABEL_8";
      }
      case 9: {
        return "ENUM_LABEL_9";
      }
      case 10: {
        return "ENUM_LABEL_10";
      }
      case 11: {
        return "ENUM_LABEL_11";
      }
      case 12: {
        return "ENUM_LABEL_12";
      }
      case 13: {
        return "ENUM_LABEL_13";
      }
      case 14: {
        return "ENUM_LABEL_14";
      }
      case 15: {
        return "ENUM_LABEL_15";
      }
      case 16: {
        return "ENUM_LABEL_16";
      }
      case 17: {
        return "ENUM_LABEL_17";
      }
      case 18: {
        return "ENUM_LABEL_18";
      }
      case 19: {
        return "ENUM_LABEL_19";
      }
      case 20: {
        return "ENUM_LABEL_20";
      }
      case 21: {
        return "ENUM_LABEL_21";
      }
      case 22: {
        return "ENUM_LABEL_22";
      }
      case 23: {
        return "ENUM_LABEL_23";
      }
      case 24: {
        return "ENUM_LABEL_24";
      }
      case 25: {
        return "ENUM_LABEL_25";
      }
      case 26: {
        return "ENUM_LABEL_26";
      }
      case 27: {
        return "ENUM_LABEL_27";
      }
      case 28: {
        return "ENUM_LABEL_28";
      }
      case 29: {
        return "ENUM_LABEL_29";
      }
      case 30: {
        return "ENUM_LABEL_30";
      }
      case 31: {
        return "ENUM_LABEL_31";
      }
      case 32: {
        return "ENUM_LABEL_32";
      }
      case 33: {
        return "ENUM_LABEL_33";
      }
      case 34: {
        return "ENUM_LABEL_34";
      }
      case 35: {
        return "ENUM_LABEL_35";
      }
      case 36: {
        return "ENUM_LABEL_36";
      }
      case 37: {
        return "ENUM_LABEL_37";
      }
      case 38: {
        return "ENUM_LABEL_38";
      }
      case 39: {
        return "ENUM_LABEL_39";
      }
      case 40: {
        return "ENUM_LABEL_40";
      }
      case 41: {
        return "ENUM_LABEL_41";
      }
      case 42: {
        return "ENUM_LABEL_42";
      }
      case 43: {
        return "ENUM_LABEL_43";
      }
      case 44: {
        return "ENUM_LABEL_44";
      }
      case 45: {
        return "ENUM_LABEL_45";
      }
      case 46: {
        return "ENUM_LABEL_46";
      }
      case 47: {
        return "ENUM_LABEL_47";
      }
      case 48: {
        return "ENUM_LABEL_48";
      }
      case 49: {
        return "ENUM_LABEL_49";
      }
      case 50: {
        return "ENUM_LABEL_50";
      }
      case 51: {
        return "ENUM_LABEL_51";
      }
      case 52: {
        return "ENUM_LABEL_52";
      }
      case 53: {
        return "ENUM_LABEL_53";
      }
      case 54: {
        return "ENUM_LABEL_54";
      }
      case 55: {
        return "ENUM_LABEL_55";
      }
      case 56: {
        return "ENUM_LABEL_56";
      }
      case 57: {
        return "ENUM_LABEL_57";
      }
      case 58: {
        return "ENUM_LABEL_58";
      }
      case 59: {
        return "ENUM_LABEL_59";
      }
      case 60: {
        return "ENUM_LABEL_60";
      }
      case 61: {
        return "ENUM_LABEL_61";
      }
      case 62: {
        return "ENUM_LABEL_62";
      }
      case 63: {
        return "ENUM_LABEL_63";
      }
      case 64: {
        return "ENUM_LABEL_64";
      }
      case 65: {
        return "ENUM_LABEL_65";
      }
      case 66: {
        return "ENUM_LABEL_66";
      }
      case 67: {
        return "ENUM_LABEL_67";
      }
      case 68: {
        return "ENUM_LABEL_68";
      }
      case 69: {
        return "ENUM_LABEL_69";
      }
      case 70: {
        return "ENUM_LABEL_70";
      }
      case 71: {
        return "ENUM_LABEL_71";
      }
      case 72: {
        return "ENUM_LABEL_72";
      }
      case 73: {
        return "ENUM_LABEL_73";
      }
      case 74: {
        return "ENUM_LABEL_74";
      }
      case 75: {
        return "ENUM_LABEL_75";
      }
      case 76: {
        return "ENUM_LABEL_76";
      }
      case 77: {
        return "ENUM_LABEL_77";
      }
      case 78: {
        return "ENUM_LABEL_78";
      }
      case 79: {
        return "ENUM_LABEL_79";
      }
      case 80: {
        return "ENUM_LABEL_80";
      }
      case 81: {
        return "ENUM_LABEL_81";
      }
      case 82: {
        return "ENUM_LABEL_82";
      }
      case 83: {
        return "ENUM_LABEL_83";
      }
      case 84: {
        return "ENUM_LABEL_84";
      }
      case 85: {
        return "ENUM_LABEL_85";
      }
      case 86: {
        return "ENUM_LABEL_86";
      }
      case 87: {
        return "ENUM_LABEL_87";
      }
      case 88: {
        return "ENUM_LABEL_88";
      }
      case 89: {
        return "ENUM_LABEL_89";
      }
      case 90: {
        return "ENUM_LABEL_90";
      }
      case 91: {
        return "ENUM_LABEL_91";
      }
      case 92: {
        return "ENUM_LABEL_92";
      }
      case 93: {
        return "ENUM_LABEL_93";
      }
      case 94: {
        return "ENUM_LABEL_94";
      }
      case 95: {
        return "ENUM_LABEL_95";
      }
      case 96: {
        return "ENUM_LABEL_96";
      }
      case 97: {
        return "ENUM_LABEL_97";
      }
      case 98: {
        return "ENUM_LABEL_98";
      }
      case 99: {
        return "ENUM_LABEL_99";
      }
      case 100: {
        return "ENUM_LABEL_100";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as VeryLargeEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: VeryLargeEnum): number {
    switch (i) {
      case "ENUM_LABEL_DEFAULT": {
        return 0;
      }
      case "ENUM_LABEL_1": {
        return 1;
      }
      case "ENUM_LABEL_2": {
        return 2;
      }
      case "ENUM_LABEL_3": {
        return 3;
      }
      case "ENUM_LABEL_4": {
        return 4;
      }
      case "ENUM_LABEL_5": {
        return 5;
      }
      case "ENUM_LABEL_6": {
        return 6;
      }
      case "ENUM_LABEL_7": {
        return 7;
      }
      case "ENUM_LABEL_8": {
        return 8;
      }
      case "ENUM_LABEL_9": {
        return 9;
      }
      case "ENUM_LABEL_10": {
        return 10;
      }
      case "ENUM_LABEL_11": {
        return 11;
      }
      case "ENUM_LABEL_12": {
        return 12;
      }
      case "ENUM_LABEL_13": {
        return 13;
      }
      case "ENUM_LABEL_14": {
        return 14;
      }
      case "ENUM_LABEL_15": {
        return 15;
      }
      case "ENUM_LABEL_16": {
        return 16;
      }
      case "ENUM_LABEL_17": {
        return 17;
      }
      case "ENUM_LABEL_18": {
        return 18;
      }
      case "ENUM_LABEL_19": {
        return 19;
      }
      case "ENUM_LABEL_20": {
        return 20;
      }
      case "ENUM_LABEL_21": {
        return 21;
      }
      case "ENUM_LABEL_22": {
        return 22;
      }
      case "ENUM_LABEL_23": {
        return 23;
      }
      case "ENUM_LABEL_24": {
        return 24;
      }
      case "ENUM_LABEL_25": {
        return 25;
      }
      case "ENUM_LABEL_26": {
        return 26;
      }
      case "ENUM_LABEL_27": {
        return 27;
      }
      case "ENUM_LABEL_28": {
        return 28;
      }
      case "ENUM_LABEL_29": {
        return 29;
      }
      case "ENUM_LABEL_30": {
        return 30;
      }
      case "ENUM_LABEL_31": {
        return 31;
      }
      case "ENUM_LABEL_32": {
        return 32;
      }
      case "ENUM_LABEL_33": {
        return 33;
      }
      case "ENUM_LABEL_34": {
        return 34;
      }
      case "ENUM_LABEL_35": {
        return 35;
      }
      case "ENUM_LABEL_36": {
        return 36;
      }
      case "ENUM_LABEL_37": {
        return 37;
      }
      case "ENUM_LABEL_38": {
        return 38;
      }
      case "ENUM_LABEL_39": {
        return 39;
      }
      case "ENUM_LABEL_40": {
        return 40;
      }
      case "ENUM_LABEL_41": {
        return 41;
      }
      case "ENUM_LABEL_42": {
        return 42;
      }
      case "ENUM_LABEL_43": {
        return 43;
      }
      case "ENUM_LABEL_44": {
        return 44;
      }
      case "ENUM_LABEL_45": {
        return 45;
      }
      case "ENUM_LABEL_46": {
        return 46;
      }
      case "ENUM_LABEL_47": {
        return 47;
      }
      case "ENUM_LABEL_48": {
        return 48;
      }
      case "ENUM_LABEL_49": {
        return 49;
      }
      case "ENUM_LABEL_50": {
        return 50;
      }
      case "ENUM_LABEL_51": {
        return 51;
      }
      case "ENUM_LABEL_52": {
        return 52;
      }
      case "ENUM_LABEL_53": {
        return 53;
      }
      case "ENUM_LABEL_54": {
        return 54;
      }
      case "ENUM_LABEL_55": {
        return 55;
      }
      case "ENUM_LABEL_56": {
        return 56;
      }
      case "ENUM_LABEL_57": {
        return 57;
      }
      case "ENUM_LABEL_58": {
        return 58;
      }
      case "ENUM_LABEL_59": {
        return 59;
      }
      case "ENUM_LABEL_60": {
        return 60;
      }
      case "ENUM_LABEL_61": {
        return 61;
      }
      case "ENUM_LABEL_62": {
        return 62;
      }
      case "ENUM_LABEL_63": {
        return 63;
      }
      case "ENUM_LABEL_64": {
        return 64;
      }
      case "ENUM_LABEL_65": {
        return 65;
      }
      case "ENUM_LABEL_66": {
        return 66;
      }
      case "ENUM_LABEL_67": {
        return 67;
      }
      case "ENUM_LABEL_68": {
        return 68;
      }
      case "ENUM_LABEL_69": {
        return 69;
      }
      case "ENUM_LABEL_70": {
        return 70;
      }
      case "ENUM_LABEL_71": {
        return 71;
      }
      case "ENUM_LABEL_72": {
        return 72;
      }
      case "ENUM_LABEL_73": {
        return 73;
      }
      case "ENUM_LABEL_74": {
        return 74;
      }
      case "ENUM_LABEL_75": {
        return 75;
      }
      case "ENUM_LABEL_76": {
        return 76;
      }
      case "ENUM_LABEL_77": {
        return 77;
      }
      case "ENUM_LABEL_78": {
        return 78;
      }
      case "ENUM_LABEL_79": {
        return 79;
      }
      case "ENUM_LABEL_80": {
        return 80;
      }
      case "ENUM_LABEL_81": {
        return 81;
      }
      case "ENUM_LABEL_82": {
        return 82;
      }
      case "ENUM_LABEL_83": {
        return 83;
      }
      case "ENUM_LABEL_84": {
        return 84;
      }
      case "ENUM_LABEL_85": {
        return 85;
      }
      case "ENUM_LABEL_86": {
        return 86;
      }
      case "ENUM_LABEL_87": {
        return 87;
      }
      case "ENUM_LABEL_88": {
        return 88;
      }
      case "ENUM_LABEL_89": {
        return 89;
      }
      case "ENUM_LABEL_90": {
        return 90;
      }
      case "ENUM_LABEL_91": {
        return 91;
      }
      case "ENUM_LABEL_92": {
        return 92;
      }
      case "ENUM_LABEL_93": {
        return 93;
      }
      case "ENUM_LABEL_94": {
        return 94;
      }
      case "ENUM_LABEL_95": {
        return 95;
      }
      case "ENUM_LABEL_96": {
        return 96;
      }
      case "ENUM_LABEL_97": {
        return 97;
      }
      case "ENUM_LABEL_98": {
        return 98;
      }
      case "ENUM_LABEL_99": {
        return 99;
      }
      case "ENUM_LABEL_100": {
        return 100;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypesJSON = {
  /**
   * Serializes TestAllTypes to JSON.
   */
  encode: function (msg: Partial<TestAllTypes>): string {
    return JSON.stringify(TestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestAllTypes from JSON.
   */
  decode: function (json: string): TestAllTypes {
    return TestAllTypesJSON._readMessage(
      TestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessageJSON.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessageJSON.initialize(),
      optionalLazyMessage: TestAllTypesJSON.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      defaultForeignEnum: ForeignEnum._fromInt(0),
      defaultImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      defaultStringPiece: "",
      defaultCord: "",
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json["optionalInt64"] = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json["optionalUint32"] = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json["optionalUint64"] = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json["optionalSint32"] = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json["optionalSint64"] = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json["optionalFixed32"] = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json["optionalFixed64"] = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json["optionalSfixed32"] = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json["optionalSfixed64"] = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json["optionalFloat"] = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json["optionalDouble"] = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json["optionalBool"] = msg.optionalBool;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalNestedMessage);
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    if (msg.optionalForeignMessage) {
      const _optionalForeignMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalForeignMessage
      );
      if (Object.keys(_optionalForeignMessage_).length > 0) {
        json["optionalForeignMessage"] = _optionalForeignMessage_;
      }
    }
    if (msg.optionalImportMessage) {
      const _optionalImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalImportMessage
        );
      if (Object.keys(_optionalImportMessage_).length > 0) {
        json["optionalImportMessage"] = _optionalImportMessage_;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      json["optionalNestedEnum"] = msg.optionalNestedEnum;
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    if (
      msg.optionalImportEnum &&
      googleProtobufUnittest_import.ImportEnumJSON._toInt(
        msg.optionalImportEnum
      )
    ) {
      json["optionalImportEnum"] = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json["optionalStringPiece"] = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json["optionalCord"] = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const _optionalPublicImportMessage_ =
        googleProtobufUnittest_import_public.PublicImportMessageJSON._writeMessage(
          msg.optionalPublicImportMessage
        );
      if (Object.keys(_optionalPublicImportMessage_).length > 0) {
        json["optionalPublicImportMessage"] = _optionalPublicImportMessage_;
      }
    }
    if (msg.optionalLazyMessage) {
      const _optionalLazyMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalLazyMessage);
      if (Object.keys(_optionalLazyMessage_).length > 0) {
        json["optionalLazyMessage"] = _optionalLazyMessage_;
      }
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json["repeatedString"] = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json["repeatedBytes"] = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json["repeatedNestedMessage"] = msg.repeatedNestedMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json["repeatedForeignMessage"] = msg.repeatedForeignMessage.map(
        ForeignMessageJSON._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json["repeatedImportMessage"] = msg.repeatedImportMessage.map(
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json["repeatedForeignEnum"] = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json["repeatedImportEnum"] = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json["repeatedStringPiece"] = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json["repeatedCord"] = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json["repeatedLazyMessage"] = msg.repeatedLazyMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      json["defaultInt32"] = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json["defaultInt64"] = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json["defaultUint32"] = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json["defaultUint64"] = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json["defaultSint32"] = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json["defaultSint64"] = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json["defaultFixed32"] = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json["defaultFixed64"] = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json["defaultSfixed32"] = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json["defaultSfixed64"] = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json["defaultFloat"] = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json["defaultDouble"] = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json["defaultBool"] = msg.defaultBool;
    }
    if (msg.defaultString) {
      json["defaultString"] = msg.defaultString;
    }
    if (msg.defaultBytes?.length) {
      json["defaultBytes"] = encodeBase64Bytes(msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.defaultNestedEnum)
    ) {
      json["defaultNestedEnum"] = msg.defaultNestedEnum;
    }
    if (
      msg.defaultForeignEnum &&
      ForeignEnumJSON._toInt(msg.defaultForeignEnum)
    ) {
      json["defaultForeignEnum"] = msg.defaultForeignEnum;
    }
    if (
      msg.defaultImportEnum &&
      googleProtobufUnittest_import.ImportEnumJSON._toInt(msg.defaultImportEnum)
    ) {
      json["defaultImportEnum"] = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json["defaultStringPiece"] = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json["defaultCord"] = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const _oneofNestedMessage_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.oneofNestedMessage
      );
      json["oneofNestedMessage"] = _oneofNestedMessage_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestAllTypes, json: any): TestAllTypes {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _optionalInt64_ = json["optionalInt64"] ?? json["optional_int64"];
    if (_optionalInt64_) {
      msg.optionalInt64 = BigInt(_optionalInt64_);
    }
    const _optionalUint32_ = json["optionalUint32"] ?? json["optional_uint32"];
    if (_optionalUint32_) {
      msg.optionalUint32 = _optionalUint32_;
    }
    const _optionalUint64_ = json["optionalUint64"] ?? json["optional_uint64"];
    if (_optionalUint64_) {
      msg.optionalUint64 = BigInt(_optionalUint64_);
    }
    const _optionalSint32_ = json["optionalSint32"] ?? json["optional_sint32"];
    if (_optionalSint32_) {
      msg.optionalSint32 = _optionalSint32_;
    }
    const _optionalSint64_ = json["optionalSint64"] ?? json["optional_sint64"];
    if (_optionalSint64_) {
      msg.optionalSint64 = BigInt(_optionalSint64_);
    }
    const _optionalFixed32_ =
      json["optionalFixed32"] ?? json["optional_fixed32"];
    if (_optionalFixed32_) {
      msg.optionalFixed32 = _optionalFixed32_;
    }
    const _optionalFixed64_ =
      json["optionalFixed64"] ?? json["optional_fixed64"];
    if (_optionalFixed64_) {
      msg.optionalFixed64 = BigInt(_optionalFixed64_);
    }
    const _optionalSfixed32_ =
      json["optionalSfixed32"] ?? json["optional_sfixed32"];
    if (_optionalSfixed32_) {
      msg.optionalSfixed32 = _optionalSfixed32_;
    }
    const _optionalSfixed64_ =
      json["optionalSfixed64"] ?? json["optional_sfixed64"];
    if (_optionalSfixed64_) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64_);
    }
    const _optionalFloat_ = json["optionalFloat"] ?? json["optional_float"];
    if (_optionalFloat_) {
      msg.optionalFloat = _optionalFloat_;
    }
    const _optionalDouble_ = json["optionalDouble"] ?? json["optional_double"];
    if (_optionalDouble_) {
      msg.optionalDouble = _optionalDouble_;
    }
    const _optionalBool_ = json["optionalBool"] ?? json["optional_bool"];
    if (_optionalBool_) {
      msg.optionalBool = _optionalBool_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalNestedMessage_);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage_ =
      json["optionalForeignMessage"] ?? json["optional_foreign_message"];
    if (_optionalForeignMessage_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _optionalForeignMessage_);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage_ =
      json["optionalImportMessage"] ?? json["optional_import_message"];
    if (_optionalImportMessage_) {
      const m = googleProtobufUnittest_import.ImportMessage.initialize();
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        m,
        _optionalImportMessage_
      );
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum_ =
      json["optionalNestedEnum"] ?? json["optional_nested_enum"];
    if (_optionalNestedEnum_) {
      msg.optionalNestedEnum = _optionalNestedEnum_;
    }
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    const _optionalImportEnum_ =
      json["optionalImportEnum"] ?? json["optional_import_enum"];
    if (_optionalImportEnum_) {
      msg.optionalImportEnum = _optionalImportEnum_;
    }
    const _optionalStringPiece_ =
      json["optionalStringPiece"] ?? json["optional_string_piece"];
    if (_optionalStringPiece_) {
      msg.optionalStringPiece = _optionalStringPiece_;
    }
    const _optionalCord_ = json["optionalCord"] ?? json["optional_cord"];
    if (_optionalCord_) {
      msg.optionalCord = _optionalCord_;
    }
    const _optionalPublicImportMessage_ =
      json["optionalPublicImportMessage"] ??
      json["optional_public_import_message"];
    if (_optionalPublicImportMessage_) {
      const m =
        googleProtobufUnittest_import_public.PublicImportMessage.initialize();
      googleProtobufUnittest_import_public.PublicImportMessageJSON._readMessage(
        m,
        _optionalPublicImportMessage_
      );
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage_ =
      json["optionalLazyMessage"] ?? json["optional_lazy_message"];
    if (_optionalLazyMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalLazyMessage_);
      msg.optionalLazyMessage = m;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedString_ = json["repeatedString"] ?? json["repeated_string"];
    if (_repeatedString_) {
      msg.repeatedString = _repeatedString_;
    }
    const _repeatedBytes_ = json["repeatedBytes"] ?? json["repeated_bytes"];
    if (_repeatedBytes_) {
      msg.repeatedBytes = _repeatedBytes_.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage_ =
      json["repeatedNestedMessage"] ?? json["repeated_nested_message"];
    if (_repeatedNestedMessage_) {
      for (const item of _repeatedNestedMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage_ =
      json["repeatedForeignMessage"] ?? json["repeated_foreign_message"];
    if (_repeatedForeignMessage_) {
      for (const item of _repeatedForeignMessage_) {
        const m = ForeignMessage.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage_ =
      json["repeatedImportMessage"] ?? json["repeated_import_message"];
    if (_repeatedImportMessage_) {
      for (const item of _repeatedImportMessage_) {
        const m = googleProtobufUnittest_import.ImportMessage.initialize();
        googleProtobufUnittest_import.ImportMessageJSON._readMessage(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    const _repeatedForeignEnum_ =
      json["repeatedForeignEnum"] ?? json["repeated_foreign_enum"];
    if (_repeatedForeignEnum_) {
      msg.repeatedForeignEnum = _repeatedForeignEnum_;
    }
    const _repeatedImportEnum_ =
      json["repeatedImportEnum"] ?? json["repeated_import_enum"];
    if (_repeatedImportEnum_) {
      msg.repeatedImportEnum = _repeatedImportEnum_;
    }
    const _repeatedStringPiece_ =
      json["repeatedStringPiece"] ?? json["repeated_string_piece"];
    if (_repeatedStringPiece_) {
      msg.repeatedStringPiece = _repeatedStringPiece_;
    }
    const _repeatedCord_ = json["repeatedCord"] ?? json["repeated_cord"];
    if (_repeatedCord_) {
      msg.repeatedCord = _repeatedCord_;
    }
    const _repeatedLazyMessage_ =
      json["repeatedLazyMessage"] ?? json["repeated_lazy_message"];
    if (_repeatedLazyMessage_) {
      for (const item of _repeatedLazyMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _defaultInt32_ = json["defaultInt32"] ?? json["default_int32"];
    if (_defaultInt32_) {
      msg.defaultInt32 = _defaultInt32_;
    }
    const _defaultInt64_ = json["defaultInt64"] ?? json["default_int64"];
    if (_defaultInt64_) {
      msg.defaultInt64 = BigInt(_defaultInt64_);
    }
    const _defaultUint32_ = json["defaultUint32"] ?? json["default_uint32"];
    if (_defaultUint32_) {
      msg.defaultUint32 = _defaultUint32_;
    }
    const _defaultUint64_ = json["defaultUint64"] ?? json["default_uint64"];
    if (_defaultUint64_) {
      msg.defaultUint64 = BigInt(_defaultUint64_);
    }
    const _defaultSint32_ = json["defaultSint32"] ?? json["default_sint32"];
    if (_defaultSint32_) {
      msg.defaultSint32 = _defaultSint32_;
    }
    const _defaultSint64_ = json["defaultSint64"] ?? json["default_sint64"];
    if (_defaultSint64_) {
      msg.defaultSint64 = BigInt(_defaultSint64_);
    }
    const _defaultFixed32_ = json["defaultFixed32"] ?? json["default_fixed32"];
    if (_defaultFixed32_) {
      msg.defaultFixed32 = _defaultFixed32_;
    }
    const _defaultFixed64_ = json["defaultFixed64"] ?? json["default_fixed64"];
    if (_defaultFixed64_) {
      msg.defaultFixed64 = BigInt(_defaultFixed64_);
    }
    const _defaultSfixed32_ =
      json["defaultSfixed32"] ?? json["default_sfixed32"];
    if (_defaultSfixed32_) {
      msg.defaultSfixed32 = _defaultSfixed32_;
    }
    const _defaultSfixed64_ =
      json["defaultSfixed64"] ?? json["default_sfixed64"];
    if (_defaultSfixed64_) {
      msg.defaultSfixed64 = BigInt(_defaultSfixed64_);
    }
    const _defaultFloat_ = json["defaultFloat"] ?? json["default_float"];
    if (_defaultFloat_) {
      msg.defaultFloat = _defaultFloat_;
    }
    const _defaultDouble_ = json["defaultDouble"] ?? json["default_double"];
    if (_defaultDouble_) {
      msg.defaultDouble = _defaultDouble_;
    }
    const _defaultBool_ = json["defaultBool"] ?? json["default_bool"];
    if (_defaultBool_) {
      msg.defaultBool = _defaultBool_;
    }
    const _defaultString_ = json["defaultString"] ?? json["default_string"];
    if (_defaultString_) {
      msg.defaultString = _defaultString_;
    }
    const _defaultBytes_ = json["defaultBytes"] ?? json["default_bytes"];
    if (_defaultBytes_) {
      msg.defaultBytes = decodeBase64Bytes(_defaultBytes_);
    }
    const _defaultNestedEnum_ =
      json["defaultNestedEnum"] ?? json["default_nested_enum"];
    if (_defaultNestedEnum_) {
      msg.defaultNestedEnum = _defaultNestedEnum_;
    }
    const _defaultForeignEnum_ =
      json["defaultForeignEnum"] ?? json["default_foreign_enum"];
    if (_defaultForeignEnum_) {
      msg.defaultForeignEnum = _defaultForeignEnum_;
    }
    const _defaultImportEnum_ =
      json["defaultImportEnum"] ?? json["default_import_enum"];
    if (_defaultImportEnum_) {
      msg.defaultImportEnum = _defaultImportEnum_;
    }
    const _defaultStringPiece_ =
      json["defaultStringPiece"] ?? json["default_string_piece"];
    if (_defaultStringPiece_) {
      msg.defaultStringPiece = _defaultStringPiece_;
    }
    const _defaultCord_ = json["defaultCord"] ?? json["default_cord"];
    if (_defaultCord_) {
      msg.defaultCord = _defaultCord_;
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofNestedMessage_ =
      json["oneofNestedMessage"] ?? json["oneof_nested_message"];
    if (_oneofNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _oneofNestedMessage_);
      msg.oneofNestedMessage = m;
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypes.NestedEnum {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypes.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypes.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to JSON.
     */
    encode: function (msg: Partial<TestAllTypes.NestedMessage>): string {
      return JSON.stringify(TestAllTypesJSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from JSON.
     */
    decode: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypesJSON.NestedMessage._readMessage(
        TestAllTypesJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      json: any
    ): TestAllTypes.NestedMessage {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestAllTypes.OptionalGroup to JSON.
     */
    encode: function (msg: Partial<TestAllTypes.OptionalGroup>): string {
      return JSON.stringify(TestAllTypesJSON.OptionalGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.OptionalGroup from JSON.
     */
    decode: function (json: string): TestAllTypes.OptionalGroup {
      return TestAllTypesJSON.OptionalGroup._readMessage(
        TestAllTypesJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      json: any
    ): TestAllTypes.OptionalGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestAllTypes.RepeatedGroup to JSON.
     */
    encode: function (msg: Partial<TestAllTypes.RepeatedGroup>): string {
      return JSON.stringify(TestAllTypesJSON.RepeatedGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.RepeatedGroup from JSON.
     */
    decode: function (json: string): TestAllTypes.RepeatedGroup {
      return TestAllTypesJSON.RepeatedGroup._readMessage(
        TestAllTypesJSON.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      json: any
    ): TestAllTypes.RepeatedGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypesJSON = {
  /**
   * Serializes NestedTestAllTypes to JSON.
   */
  encode: function (msg: Partial<NestedTestAllTypes>): string {
    return JSON.stringify(NestedTestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes NestedTestAllTypes from JSON.
   */
  decode: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypesJSON._readMessage(
      NestedTestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypesJSON.initialize(),
      payload: TestAllTypesJSON.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const _child_ = NestedTestAllTypesJSON._writeMessage(msg.child);
      if (Object.keys(_child_).length > 0) {
        json["child"] = _child_;
      }
    }
    if (msg.payload) {
      const _payload_ = TestAllTypesJSON._writeMessage(msg.payload);
      if (Object.keys(_payload_).length > 0) {
        json["payload"] = _payload_;
      }
    }
    if (msg.repeatedChild?.length) {
      json["repeatedChild"] = msg.repeatedChild.map(
        NestedTestAllTypesJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    json: any
  ): NestedTestAllTypes {
    const _child_ = json["child"];
    if (_child_) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypesJSON._readMessage(m, _child_);
      msg.child = m;
    }
    const _payload_ = json["payload"];
    if (_payload_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _payload_);
      msg.payload = m;
    }
    const _repeatedChild_ = json["repeatedChild"] ?? json["repeated_child"];
    if (_repeatedChild_) {
      for (const item of _repeatedChild_) {
        const m = NestedTestAllTypes.initialize();
        NestedTestAllTypesJSON._readMessage(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFieldsJSON = {
  /**
   * Serializes TestDeprecatedFields to JSON.
   */
  encode: function (msg: Partial<TestDeprecatedFields>): string {
    return JSON.stringify(TestDeprecatedFieldsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDeprecatedFields from JSON.
   */
  decode: function (json: string): TestDeprecatedFields {
    return TestDeprecatedFieldsJSON._readMessage(
      TestDeprecatedFieldsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecatedInt32: 0,
      deprecatedInt32InOneof: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedFields>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.deprecatedInt32) {
      json["deprecatedInt32"] = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json["deprecatedInt32InOneof"] = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    json: any
  ): TestDeprecatedFields {
    const _deprecatedInt32_ =
      json["deprecatedInt32"] ?? json["deprecated_int32"];
    if (_deprecatedInt32_) {
      msg.deprecatedInt32 = _deprecatedInt32_;
    }
    const _deprecatedInt32InOneof_ =
      json["deprecatedInt32InOneof"] ?? json["deprecated_int32_in_oneof"];
    if (_deprecatedInt32InOneof_) {
      msg.deprecatedInt32InOneof = _deprecatedInt32InOneof_;
    }
    return msg;
  },
};

export const TestDeprecatedMessageJSON = {
  /**
   * Serializes TestDeprecatedMessage to JSON.
   */
  encode: function (_msg?: Partial<TestDeprecatedMessage>): string {
    return "{}";
  },

  /**
   * Deserializes TestDeprecatedMessage from JSON.
   */
  decode: function (_json?: string): TestDeprecatedMessage {
    return {};
  },

  /**
   * Initializes TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestDeprecatedMessage>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedMessage,
    _json: any
  ): TestDeprecatedMessage {
    return msg;
  },
};

export const ForeignMessageJSON = {
  /**
   * Serializes ForeignMessage to JSON.
   */
  encode: function (msg: Partial<ForeignMessage>): string {
    return JSON.stringify(ForeignMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ForeignMessage from JSON.
   */
  decode: function (json: string): ForeignMessage {
    return ForeignMessageJSON._readMessage(
      ForeignMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json["c"] = msg.c;
    }
    if (msg.d) {
      json["d"] = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ForeignMessage, json: any): ForeignMessage {
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    const _d_ = json["d"];
    if (_d_) {
      msg.d = _d_;
    }
    return msg;
  },
};

export const TestReservedFieldsJSON = {
  /**
   * Serializes TestReservedFields to JSON.
   */
  encode: function (_msg?: Partial<TestReservedFields>): string {
    return "{}";
  },

  /**
   * Deserializes TestReservedFields from JSON.
   */
  decode: function (_json?: string): TestReservedFields {
    return {};
  },

  /**
   * Initializes TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestReservedFields>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReservedFields,
    _json: any
  ): TestReservedFields {
    return msg;
  },
};

export const TestAllExtensionsJSON = {
  /**
   * Serializes TestAllExtensions to JSON.
   */
  encode: function (_msg?: Partial<TestAllExtensions>): string {
    return "{}";
  },

  /**
   * Deserializes TestAllExtensions from JSON.
   */
  decode: function (_json?: string): TestAllExtensions {
    return {};
  },

  /**
   * Initializes TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestAllExtensions>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllExtensions,
    _json: any
  ): TestAllExtensions {
    return msg;
  },
};

export const OptionalGroup_extensionJSON = {
  /**
   * Serializes OptionalGroup_extension to JSON.
   */
  encode: function (msg: Partial<OptionalGroup_extension>): string {
    return JSON.stringify(OptionalGroup_extensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes OptionalGroup_extension from JSON.
   */
  decode: function (json: string): OptionalGroup_extension {
    return OptionalGroup_extensionJSON._readMessage(
      OptionalGroup_extensionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OptionalGroup_extension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    json: any
  ): OptionalGroup_extension {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const RepeatedGroup_extensionJSON = {
  /**
   * Serializes RepeatedGroup_extension to JSON.
   */
  encode: function (msg: Partial<RepeatedGroup_extension>): string {
    return JSON.stringify(RepeatedGroup_extensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes RepeatedGroup_extension from JSON.
   */
  decode: function (json: string): RepeatedGroup_extension {
    return RepeatedGroup_extensionJSON._readMessage(
      RepeatedGroup_extensionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedGroup_extension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    json: any
  ): RepeatedGroup_extension {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const TestGroupJSON = {
  /**
   * Serializes TestGroup to JSON.
   */
  encode: function (msg: Partial<TestGroup>): string {
    return JSON.stringify(TestGroupJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestGroup from JSON.
   */
  decode: function (json: string): TestGroup {
    return TestGroupJSON._readMessage(
      TestGroupJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optionalForeignEnum: ForeignEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<TestGroup>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, json: any): TestGroup {
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestGroup.OptionalGroup to JSON.
     */
    encode: function (msg: Partial<TestGroup.OptionalGroup>): string {
      return JSON.stringify(TestGroupJSON.OptionalGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestGroup.OptionalGroup from JSON.
     */
    decode: function (json: string): TestGroup.OptionalGroup {
      return TestGroupJSON.OptionalGroup._readMessage(
        TestGroupJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      json: any
    ): TestGroup.OptionalGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestGroupExtensionJSON = {
  /**
   * Serializes TestGroupExtension to JSON.
   */
  encode: function (_msg?: Partial<TestGroupExtension>): string {
    return "{}";
  },

  /**
   * Deserializes TestGroupExtension from JSON.
   */
  decode: function (_json?: string): TestGroupExtension {
    return {};
  },

  /**
   * Initializes TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestGroupExtension>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestGroupExtension,
    _json: any
  ): TestGroupExtension {
    return msg;
  },
};

export const TestNestedExtensionJSON = {
  /**
   * Serializes TestNestedExtension to JSON.
   */
  encode: function (_msg?: Partial<TestNestedExtension>): string {
    return "{}";
  },

  /**
   * Deserializes TestNestedExtension from JSON.
   */
  decode: function (_json?: string): TestNestedExtension {
    return {};
  },

  /**
   * Initializes TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestNestedExtension>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedExtension,
    _json: any
  ): TestNestedExtension {
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encode: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): string {
      return JSON.stringify(
        TestNestedExtensionJSON.OptionalGroup_extension._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decode: function (
      json: string
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtensionJSON.OptionalGroup_extension._readMessage(
        TestNestedExtensionJSON.OptionalGroup_extension.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      json: any
    ): TestNestedExtension.OptionalGroup_extension {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestChildExtensionJSON = {
  /**
   * Serializes TestChildExtension to JSON.
   */
  encode: function (msg: Partial<TestChildExtension>): string {
    return JSON.stringify(TestChildExtensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestChildExtension from JSON.
   */
  decode: function (json: string): TestChildExtension {
    return TestChildExtensionJSON._readMessage(
      TestChildExtensionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: "",
      b: "",
      optionalExtension: TestAllExtensionsJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestChildExtension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.b) {
      json["b"] = msg.b;
    }
    if (msg.optionalExtension) {
      const _optionalExtension_ = TestAllExtensionsJSON._writeMessage(
        msg.optionalExtension
      );
      if (Object.keys(_optionalExtension_).length > 0) {
        json["optionalExtension"] = _optionalExtension_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    json: any
  ): TestChildExtension {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _b_ = json["b"];
    if (_b_) {
      msg.b = _b_;
    }
    const _optionalExtension_ =
      json["optionalExtension"] ?? json["optional_extension"];
    if (_optionalExtension_) {
      const m = TestAllExtensions.initialize();
      TestAllExtensionsJSON._readMessage(m, _optionalExtension_);
      msg.optionalExtension = m;
    }
    return msg;
  },
};

export const TestRequiredJSON = {
  /**
   * Serializes TestRequired to JSON.
   */
  encode: function (msg: Partial<TestRequired>): string {
    return JSON.stringify(TestRequiredJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequired from JSON.
   */
  decode: function (json: string): TestRequired {
    return TestRequiredJSON._readMessage(
      TestRequiredJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequired>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.dummy2) {
      json["dummy2"] = msg.dummy2;
    }
    if (msg.b) {
      json["b"] = msg.b;
    }
    if (msg.dummy4) {
      json["dummy4"] = msg.dummy4;
    }
    if (msg.dummy5) {
      json["dummy5"] = msg.dummy5;
    }
    if (msg.dummy6) {
      json["dummy6"] = msg.dummy6;
    }
    if (msg.dummy7) {
      json["dummy7"] = msg.dummy7;
    }
    if (msg.dummy8) {
      json["dummy8"] = msg.dummy8;
    }
    if (msg.dummy9) {
      json["dummy9"] = msg.dummy9;
    }
    if (msg.dummy10) {
      json["dummy10"] = msg.dummy10;
    }
    if (msg.dummy11) {
      json["dummy11"] = msg.dummy11;
    }
    if (msg.dummy12) {
      json["dummy12"] = msg.dummy12;
    }
    if (msg.dummy13) {
      json["dummy13"] = msg.dummy13;
    }
    if (msg.dummy14) {
      json["dummy14"] = msg.dummy14;
    }
    if (msg.dummy15) {
      json["dummy15"] = msg.dummy15;
    }
    if (msg.dummy16) {
      json["dummy16"] = msg.dummy16;
    }
    if (msg.dummy17) {
      json["dummy17"] = msg.dummy17;
    }
    if (msg.dummy18) {
      json["dummy18"] = msg.dummy18;
    }
    if (msg.dummy19) {
      json["dummy19"] = msg.dummy19;
    }
    if (msg.dummy20) {
      json["dummy20"] = msg.dummy20;
    }
    if (msg.dummy21) {
      json["dummy21"] = msg.dummy21;
    }
    if (msg.dummy22) {
      json["dummy22"] = msg.dummy22;
    }
    if (msg.dummy23) {
      json["dummy23"] = msg.dummy23;
    }
    if (msg.dummy24) {
      json["dummy24"] = msg.dummy24;
    }
    if (msg.dummy25) {
      json["dummy25"] = msg.dummy25;
    }
    if (msg.dummy26) {
      json["dummy26"] = msg.dummy26;
    }
    if (msg.dummy27) {
      json["dummy27"] = msg.dummy27;
    }
    if (msg.dummy28) {
      json["dummy28"] = msg.dummy28;
    }
    if (msg.dummy29) {
      json["dummy29"] = msg.dummy29;
    }
    if (msg.dummy30) {
      json["dummy30"] = msg.dummy30;
    }
    if (msg.dummy31) {
      json["dummy31"] = msg.dummy31;
    }
    if (msg.dummy32) {
      json["dummy32"] = msg.dummy32;
    }
    if (msg.c) {
      json["c"] = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestRequired, json: any): TestRequired {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _dummy2_ = json["dummy2"];
    if (_dummy2_) {
      msg.dummy2 = _dummy2_;
    }
    const _b_ = json["b"];
    if (_b_) {
      msg.b = _b_;
    }
    const _dummy4_ = json["dummy4"];
    if (_dummy4_) {
      msg.dummy4 = _dummy4_;
    }
    const _dummy5_ = json["dummy5"];
    if (_dummy5_) {
      msg.dummy5 = _dummy5_;
    }
    const _dummy6_ = json["dummy6"];
    if (_dummy6_) {
      msg.dummy6 = _dummy6_;
    }
    const _dummy7_ = json["dummy7"];
    if (_dummy7_) {
      msg.dummy7 = _dummy7_;
    }
    const _dummy8_ = json["dummy8"];
    if (_dummy8_) {
      msg.dummy8 = _dummy8_;
    }
    const _dummy9_ = json["dummy9"];
    if (_dummy9_) {
      msg.dummy9 = _dummy9_;
    }
    const _dummy10_ = json["dummy10"];
    if (_dummy10_) {
      msg.dummy10 = _dummy10_;
    }
    const _dummy11_ = json["dummy11"];
    if (_dummy11_) {
      msg.dummy11 = _dummy11_;
    }
    const _dummy12_ = json["dummy12"];
    if (_dummy12_) {
      msg.dummy12 = _dummy12_;
    }
    const _dummy13_ = json["dummy13"];
    if (_dummy13_) {
      msg.dummy13 = _dummy13_;
    }
    const _dummy14_ = json["dummy14"];
    if (_dummy14_) {
      msg.dummy14 = _dummy14_;
    }
    const _dummy15_ = json["dummy15"];
    if (_dummy15_) {
      msg.dummy15 = _dummy15_;
    }
    const _dummy16_ = json["dummy16"];
    if (_dummy16_) {
      msg.dummy16 = _dummy16_;
    }
    const _dummy17_ = json["dummy17"];
    if (_dummy17_) {
      msg.dummy17 = _dummy17_;
    }
    const _dummy18_ = json["dummy18"];
    if (_dummy18_) {
      msg.dummy18 = _dummy18_;
    }
    const _dummy19_ = json["dummy19"];
    if (_dummy19_) {
      msg.dummy19 = _dummy19_;
    }
    const _dummy20_ = json["dummy20"];
    if (_dummy20_) {
      msg.dummy20 = _dummy20_;
    }
    const _dummy21_ = json["dummy21"];
    if (_dummy21_) {
      msg.dummy21 = _dummy21_;
    }
    const _dummy22_ = json["dummy22"];
    if (_dummy22_) {
      msg.dummy22 = _dummy22_;
    }
    const _dummy23_ = json["dummy23"];
    if (_dummy23_) {
      msg.dummy23 = _dummy23_;
    }
    const _dummy24_ = json["dummy24"];
    if (_dummy24_) {
      msg.dummy24 = _dummy24_;
    }
    const _dummy25_ = json["dummy25"];
    if (_dummy25_) {
      msg.dummy25 = _dummy25_;
    }
    const _dummy26_ = json["dummy26"];
    if (_dummy26_) {
      msg.dummy26 = _dummy26_;
    }
    const _dummy27_ = json["dummy27"];
    if (_dummy27_) {
      msg.dummy27 = _dummy27_;
    }
    const _dummy28_ = json["dummy28"];
    if (_dummy28_) {
      msg.dummy28 = _dummy28_;
    }
    const _dummy29_ = json["dummy29"];
    if (_dummy29_) {
      msg.dummy29 = _dummy29_;
    }
    const _dummy30_ = json["dummy30"];
    if (_dummy30_) {
      msg.dummy30 = _dummy30_;
    }
    const _dummy31_ = json["dummy31"];
    if (_dummy31_) {
      msg.dummy31 = _dummy31_;
    }
    const _dummy32_ = json["dummy32"];
    if (_dummy32_) {
      msg.dummy32 = _dummy32_;
    }
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    return msg;
  },
};

export const TestRequiredForeignJSON = {
  /**
   * Serializes TestRequiredForeign to JSON.
   */
  encode: function (msg: Partial<TestRequiredForeign>): string {
    return JSON.stringify(TestRequiredForeignJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredForeign from JSON.
   */
  decode: function (json: string): TestRequiredForeign {
    return TestRequiredForeignJSON._readMessage(
      TestRequiredForeignJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optionalMessage: TestRequiredJSON.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredForeign>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const _optionalMessage_ = TestRequiredJSON._writeMessage(
        msg.optionalMessage
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.repeatedMessage?.length) {
      json["repeatedMessage"] = msg.repeatedMessage.map(
        TestRequiredJSON._writeMessage
      );
    }
    if (msg.dummy) {
      json["dummy"] = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    json: any
  ): TestRequiredForeign {
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      const m = TestRequired.initialize();
      TestRequiredJSON._readMessage(m, _optionalMessage_);
      msg.optionalMessage = m;
    }
    const _repeatedMessage_ =
      json["repeatedMessage"] ?? json["repeated_message"];
    if (_repeatedMessage_) {
      for (const item of _repeatedMessage_) {
        const m = TestRequired.initialize();
        TestRequiredJSON._readMessage(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _dummy_ = json["dummy"];
    if (_dummy_) {
      msg.dummy = _dummy_;
    }
    return msg;
  },
};

export const TestRequiredMessageJSON = {
  /**
   * Serializes TestRequiredMessage to JSON.
   */
  encode: function (msg: Partial<TestRequiredMessage>): string {
    return JSON.stringify(TestRequiredMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredMessage from JSON.
   */
  decode: function (json: string): TestRequiredMessage {
    return TestRequiredMessageJSON._readMessage(
      TestRequiredMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optionalMessage: TestRequiredJSON.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequiredJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const _optionalMessage_ = TestRequiredJSON._writeMessage(
        msg.optionalMessage
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.repeatedMessage?.length) {
      json["repeatedMessage"] = msg.repeatedMessage.map(
        TestRequiredJSON._writeMessage
      );
    }
    if (msg.requiredMessage) {
      const _requiredMessage_ = TestRequiredJSON._writeMessage(
        msg.requiredMessage
      );
      if (Object.keys(_requiredMessage_).length > 0) {
        json["requiredMessage"] = _requiredMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    json: any
  ): TestRequiredMessage {
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      const m = TestRequired.initialize();
      TestRequiredJSON._readMessage(m, _optionalMessage_);
      msg.optionalMessage = m;
    }
    const _repeatedMessage_ =
      json["repeatedMessage"] ?? json["repeated_message"];
    if (_repeatedMessage_) {
      for (const item of _repeatedMessage_) {
        const m = TestRequired.initialize();
        TestRequiredJSON._readMessage(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _requiredMessage_ =
      json["requiredMessage"] ?? json["required_message"];
    if (_requiredMessage_) {
      const m = TestRequired.initialize();
      TestRequiredJSON._readMessage(m, _requiredMessage_);
      msg.requiredMessage = m;
    }
    return msg;
  },
};

export const TestForeignNestedJSON = {
  /**
   * Serializes TestForeignNested to JSON.
   */
  encode: function (msg: Partial<TestForeignNested>): string {
    return JSON.stringify(TestForeignNestedJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestForeignNested from JSON.
   */
  decode: function (json: string): TestForeignNested {
    return TestForeignNestedJSON._readMessage(
      TestForeignNestedJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreignNested: TestAllTypesJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestForeignNested>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.foreignNested) {
      const _foreignNested_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.foreignNested
      );
      if (Object.keys(_foreignNested_).length > 0) {
        json["foreignNested"] = _foreignNested_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    json: any
  ): TestForeignNested {
    const _foreignNested_ = json["foreignNested"] ?? json["foreign_nested"];
    if (_foreignNested_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _foreignNested_);
      msg.foreignNested = m;
    }
    return msg;
  },
};

export const TestEmptyMessageJSON = {
  /**
   * Serializes TestEmptyMessage to JSON.
   */
  encode: function (_msg?: Partial<TestEmptyMessage>): string {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessage from JSON.
   */
  decode: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestEmptyMessage>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestEmptyMessage, _json: any): TestEmptyMessage {
    return msg;
  },
};

export const TestEmptyMessageWithExtensionsJSON = {
  /**
   * Serializes TestEmptyMessageWithExtensions to JSON.
   */
  encode: function (_msg?: Partial<TestEmptyMessageWithExtensions>): string {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessageWithExtensions from JSON.
   */
  decode: function (_json?: string): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Initializes TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestEmptyMessageWithExtensions>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEmptyMessageWithExtensions,
    _json: any
  ): TestEmptyMessageWithExtensions {
    return msg;
  },
};

export const TestPickleNestedMessageJSON = {
  /**
   * Serializes TestPickleNestedMessage to JSON.
   */
  encode: function (_msg?: Partial<TestPickleNestedMessage>): string {
    return "{}";
  },

  /**
   * Deserializes TestPickleNestedMessage from JSON.
   */
  decode: function (_json?: string): TestPickleNestedMessage {
    return {};
  },

  /**
   * Initializes TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestPickleNestedMessage>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPickleNestedMessage,
    _json: any
  ): TestPickleNestedMessage {
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestPickleNestedMessage.NestedMessage to JSON.
     */
    encode: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): string {
      return JSON.stringify(
        TestPickleNestedMessageJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestPickleNestedMessage.NestedMessage from JSON.
     */
    decode: function (json: string): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessageJSON.NestedMessage._readMessage(
        TestPickleNestedMessageJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      json: any
    ): TestPickleNestedMessage.NestedMessage {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encode: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): string {
        return JSON.stringify(
          TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage._writeMessage(
            msg
          )
        );
      },

      /**
       * Deserializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decode: function (
        json: string
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.cc) {
          json["cc"] = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        json: any
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        const _cc_ = json["cc"];
        if (_cc_) {
          msg.cc = _cc_;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRangesJSON = {
  /**
   * Serializes TestMultipleExtensionRanges to JSON.
   */
  encode: function (_msg?: Partial<TestMultipleExtensionRanges>): string {
    return "{}";
  },

  /**
   * Deserializes TestMultipleExtensionRanges from JSON.
   */
  decode: function (_json?: string): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Initializes TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestMultipleExtensionRanges>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMultipleExtensionRanges,
    _json: any
  ): TestMultipleExtensionRanges {
    return msg;
  },
};

export const TestReallyLargeTagNumberJSON = {
  /**
   * Serializes TestReallyLargeTagNumber to JSON.
   */
  encode: function (msg: Partial<TestReallyLargeTagNumber>): string {
    return JSON.stringify(TestReallyLargeTagNumberJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestReallyLargeTagNumber from JSON.
   */
  decode: function (json: string): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumberJSON._readMessage(
      TestReallyLargeTagNumberJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.bb) {
      json["bb"] = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    json: any
  ): TestReallyLargeTagNumber {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _bb_ = json["bb"];
    if (_bb_) {
      msg.bb = _bb_;
    }
    return msg;
  },
};

export const TestRecursiveMessageJSON = {
  /**
   * Serializes TestRecursiveMessage to JSON.
   */
  encode: function (msg: Partial<TestRecursiveMessage>): string {
    return JSON.stringify(TestRecursiveMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRecursiveMessage from JSON.
   */
  decode: function (json: string): TestRecursiveMessage {
    return TestRecursiveMessageJSON._readMessage(
      TestRecursiveMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessageJSON.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const _a_ = TestRecursiveMessageJSON._writeMessage(msg.a);
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    if (msg.i) {
      json["i"] = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    json: any
  ): TestRecursiveMessage {
    const _a_ = json["a"];
    if (_a_) {
      const m = TestRecursiveMessage.initialize();
      TestRecursiveMessageJSON._readMessage(m, _a_);
      msg.a = m;
    }
    const _i_ = json["i"];
    if (_i_) {
      msg.i = _i_;
    }
    return msg;
  },
};

export const TestMutualRecursionAJSON = {
  /**
   * Serializes TestMutualRecursionA to JSON.
   */
  encode: function (msg: Partial<TestMutualRecursionA>): string {
    return JSON.stringify(TestMutualRecursionAJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMutualRecursionA from JSON.
   */
  decode: function (json: string): TestMutualRecursionA {
    return TestMutualRecursionAJSON._readMessage(
      TestMutualRecursionAJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionBJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionA>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.bb) {
      const _bb_ = TestMutualRecursionBJSON._writeMessage(msg.bb);
      if (Object.keys(_bb_).length > 0) {
        json["bb"] = _bb_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    json: any
  ): TestMutualRecursionA {
    const _bb_ = json["bb"];
    if (_bb_) {
      const m = TestMutualRecursionB.initialize();
      TestMutualRecursionBJSON._readMessage(m, _bb_);
      msg.bb = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestMutualRecursionA.SubMessage to JSON.
     */
    encode: function (msg: Partial<TestMutualRecursionA.SubMessage>): string {
      return JSON.stringify(
        TestMutualRecursionAJSON.SubMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestMutualRecursionA.SubMessage from JSON.
     */
    decode: function (json: string): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionAJSON.SubMessage._readMessage(
        TestMutualRecursionAJSON.SubMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionBJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.b) {
        const _b_ = TestMutualRecursionBJSON._writeMessage(msg.b);
        if (Object.keys(_b_).length > 0) {
          json["b"] = _b_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      json: any
    ): TestMutualRecursionA.SubMessage {
      const _b_ = json["b"];
      if (_b_) {
        const m = TestMutualRecursionB.initialize();
        TestMutualRecursionBJSON._readMessage(m, _b_);
        msg.b = m;
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes TestMutualRecursionA.SubGroup to JSON.
     */
    encode: function (msg: Partial<TestMutualRecursionA.SubGroup>): string {
      return JSON.stringify(
        TestMutualRecursionAJSON.SubGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestMutualRecursionA.SubGroup from JSON.
     */
    decode: function (json: string): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionAJSON.SubGroup._readMessage(
        TestMutualRecursionAJSON.SubGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        subMessage: TestMutualRecursionAJSON.SubMessage.initialize(),
        notInThisScc: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.subMessage) {
        const _subMessage_ = TestMutualRecursionAJSON.SubMessage._writeMessage(
          msg.subMessage
        );
        if (Object.keys(_subMessage_).length > 0) {
          json["subMessage"] = _subMessage_;
        }
      }
      if (msg.notInThisScc) {
        const _notInThisScc_ = TestAllTypesJSON._writeMessage(msg.notInThisScc);
        if (Object.keys(_notInThisScc_).length > 0) {
          json["notInThisScc"] = _notInThisScc_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      json: any
    ): TestMutualRecursionA.SubGroup {
      const _subMessage_ = json["subMessage"] ?? json["sub_message"];
      if (_subMessage_) {
        const m = TestMutualRecursionA.SubMessage.initialize();
        TestMutualRecursionAJSON.SubMessage._readMessage(m, _subMessage_);
        msg.subMessage = m;
      }
      const _notInThisScc_ = json["notInThisScc"] ?? json["not_in_this_scc"];
      if (_notInThisScc_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, _notInThisScc_);
        msg.notInThisScc = m;
      }
      return msg;
    },
  },
};

export const TestMutualRecursionBJSON = {
  /**
   * Serializes TestMutualRecursionB to JSON.
   */
  encode: function (msg: Partial<TestMutualRecursionB>): string {
    return JSON.stringify(TestMutualRecursionBJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMutualRecursionB from JSON.
   */
  decode: function (json: string): TestMutualRecursionB {
    return TestMutualRecursionBJSON._readMessage(
      TestMutualRecursionBJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionAJSON.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionB>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const _a_ = TestMutualRecursionAJSON._writeMessage(msg.a);
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    json: any
  ): TestMutualRecursionB {
    const _a_ = json["a"];
    if (_a_) {
      const m = TestMutualRecursionA.initialize();
      TestMutualRecursionAJSON._readMessage(m, _a_);
      msg.a = m;
    }
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    return msg;
  },
};

export const TestIsInitializedJSON = {
  /**
   * Serializes TestIsInitialized to JSON.
   */
  encode: function (msg: Partial<TestIsInitialized>): string {
    return JSON.stringify(TestIsInitializedJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestIsInitialized from JSON.
   */
  decode: function (json: string): TestIsInitialized {
    return TestIsInitializedJSON._readMessage(
      TestIsInitializedJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      subMessage: TestIsInitializedJSON.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestIsInitialized>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const _subMessage_ = TestIsInitializedJSON.SubMessage._writeMessage(
        msg.subMessage
      );
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    json: any
  ): TestIsInitialized {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      const m = TestIsInitialized.SubMessage.initialize();
      TestIsInitializedJSON.SubMessage._readMessage(m, _subMessage_);
      msg.subMessage = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestIsInitialized.SubMessage to JSON.
     */
    encode: function (_msg?: Partial<TestIsInitialized.SubMessage>): string {
      return "{}";
    },

    /**
     * Deserializes TestIsInitialized.SubMessage from JSON.
     */
    decode: function (_json?: string): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Initializes TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: Partial<TestIsInitialized.SubMessage>
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestIsInitialized.SubMessage,
      _json: any
    ): TestIsInitialized.SubMessage {
      return msg;
    },

    SubGroup: {
      /**
       * Serializes TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encode: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): string {
        return JSON.stringify(
          TestIsInitializedJSON.SubMessage.SubGroup._writeMessage(msg)
        );
      },

      /**
       * Deserializes TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decode: function (json: string): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitializedJSON.SubMessage.SubGroup._readMessage(
          TestIsInitializedJSON.SubMessage.SubGroup.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.i) {
          json["i"] = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        json: any
      ): TestIsInitialized.SubMessage.SubGroup {
        const _i_ = json["i"];
        if (_i_) {
          msg.i = _i_;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumberJSON = {
  /**
   * Serializes TestDupFieldNumber to JSON.
   */
  encode: function (msg: Partial<TestDupFieldNumber>): string {
    return JSON.stringify(TestDupFieldNumberJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDupFieldNumber from JSON.
   */
  decode: function (json: string): TestDupFieldNumber {
    return TestDupFieldNumberJSON._readMessage(
      TestDupFieldNumberJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDupFieldNumber>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    json: any
  ): TestDupFieldNumber {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes TestDupFieldNumber.Foo to JSON.
     */
    encode: function (msg: Partial<TestDupFieldNumber.Foo>): string {
      return JSON.stringify(TestDupFieldNumberJSON.Foo._writeMessage(msg));
    },

    /**
     * Deserializes TestDupFieldNumber.Foo from JSON.
     */
    decode: function (json: string): TestDupFieldNumber.Foo {
      return TestDupFieldNumberJSON.Foo._readMessage(
        TestDupFieldNumberJSON.Foo.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      json: any
    ): TestDupFieldNumber.Foo {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes TestDupFieldNumber.Bar to JSON.
     */
    encode: function (msg: Partial<TestDupFieldNumber.Bar>): string {
      return JSON.stringify(TestDupFieldNumberJSON.Bar._writeMessage(msg));
    },

    /**
     * Deserializes TestDupFieldNumber.Bar from JSON.
     */
    decode: function (json: string): TestDupFieldNumber.Bar {
      return TestDupFieldNumberJSON.Bar._readMessage(
        TestDupFieldNumberJSON.Bar.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      json: any
    ): TestDupFieldNumber.Bar {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestEagerMessageJSON = {
  /**
   * Serializes TestEagerMessage to JSON.
   */
  encode: function (msg: Partial<TestEagerMessage>): string {
    return JSON.stringify(TestEagerMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestEagerMessage from JSON.
   */
  decode: function (json: string): TestEagerMessage {
    return TestEagerMessageJSON._readMessage(
      TestEagerMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      subMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEagerMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const _subMessage_ = TestAllTypesJSON._writeMessage(msg.subMessage);
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestEagerMessage, json: any): TestEagerMessage {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _subMessage_);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestLazyMessageJSON = {
  /**
   * Serializes TestLazyMessage to JSON.
   */
  encode: function (msg: Partial<TestLazyMessage>): string {
    return JSON.stringify(TestLazyMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestLazyMessage from JSON.
   */
  decode: function (json: string): TestLazyMessage {
    return TestLazyMessageJSON._readMessage(
      TestLazyMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      subMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestLazyMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const _subMessage_ = TestAllTypesJSON._writeMessage(msg.subMessage);
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestLazyMessage, json: any): TestLazyMessage {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _subMessage_);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestNestedMessageHasBitsJSON = {
  /**
   * Serializes TestNestedMessageHasBits to JSON.
   */
  encode: function (msg: Partial<TestNestedMessageHasBits>): string {
    return JSON.stringify(TestNestedMessageHasBitsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestNestedMessageHasBits from JSON.
   */
  decode: function (json: string): TestNestedMessageHasBits {
    return TestNestedMessageHasBitsJSON._readMessage(
      TestNestedMessageHasBitsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBitsJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestNestedMessageHasBitsJSON.NestedMessage._writeMessage(
          msg.optionalNestedMessage
        );
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    json: any
  ): TestNestedMessageHasBits {
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestNestedMessageHasBits.NestedMessage.initialize();
      TestNestedMessageHasBitsJSON.NestedMessage._readMessage(
        m,
        _optionalNestedMessage_
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encode: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): string {
      return JSON.stringify(
        TestNestedMessageHasBitsJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decode: function (json: string): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBitsJSON.NestedMessage._readMessage(
        TestNestedMessageHasBitsJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json["nestedmessageRepeatedInt32"] = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json["nestedmessageRepeatedForeignmessage"] =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessageJSON._writeMessage
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      json: any
    ): TestNestedMessageHasBits.NestedMessage {
      const _nestedmessageRepeatedInt32_ =
        json["nestedmessageRepeatedInt32"] ??
        json["nestedmessage_repeated_int32"];
      if (_nestedmessageRepeatedInt32_) {
        msg.nestedmessageRepeatedInt32 = _nestedmessageRepeatedInt32_;
      }
      const _nestedmessageRepeatedForeignmessage_ =
        json["nestedmessageRepeatedForeignmessage"] ??
        json["nestedmessage_repeated_foreignmessage"];
      if (_nestedmessageRepeatedForeignmessage_) {
        for (const item of _nestedmessageRepeatedForeignmessage_) {
          const m = ForeignMessage.initialize();
          ForeignMessageJSON._readMessage(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNamesJSON = {
  /**
   * Serializes TestCamelCaseFieldNames to JSON.
   */
  encode: function (msg: Partial<TestCamelCaseFieldNames>): string {
    return JSON.stringify(TestCamelCaseFieldNamesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestCamelCaseFieldNames from JSON.
   */
  decode: function (json: string): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNamesJSON._readMessage(
      TestCamelCaseFieldNamesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: "",
      EnumField: ForeignEnum._fromInt(0),
      MessageField: ForeignMessageJSON.initialize(),
      StringPieceField: "",
      CordField: "",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.PrimitiveField) {
      json["PrimitiveField"] = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json["StringField"] = msg.StringField;
    }
    if (msg.EnumField && ForeignEnumJSON._toInt(msg.EnumField)) {
      json["EnumField"] = msg.EnumField;
    }
    if (msg.MessageField) {
      const _MessageField_ = ForeignMessageJSON._writeMessage(msg.MessageField);
      if (Object.keys(_MessageField_).length > 0) {
        json["MessageField"] = _MessageField_;
      }
    }
    if (msg.StringPieceField) {
      json["StringPieceField"] = msg.StringPieceField;
    }
    if (msg.CordField) {
      json["CordField"] = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json["RepeatedPrimitiveField"] = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json["RepeatedStringField"] = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json["RepeatedEnumField"] = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json["RepeatedMessageField"] = msg.RepeatedMessageField.map(
        ForeignMessageJSON._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json["RepeatedStringPieceField"] = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json["RepeatedCordField"] = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    json: any
  ): TestCamelCaseFieldNames {
    const _PrimitiveField_ = json["PrimitiveField"];
    if (_PrimitiveField_) {
      msg.PrimitiveField = _PrimitiveField_;
    }
    const _StringField_ = json["StringField"];
    if (_StringField_) {
      msg.StringField = _StringField_;
    }
    const _EnumField_ = json["EnumField"];
    if (_EnumField_) {
      msg.EnumField = _EnumField_;
    }
    const _MessageField_ = json["MessageField"];
    if (_MessageField_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _MessageField_);
      msg.MessageField = m;
    }
    const _StringPieceField_ = json["StringPieceField"];
    if (_StringPieceField_) {
      msg.StringPieceField = _StringPieceField_;
    }
    const _CordField_ = json["CordField"];
    if (_CordField_) {
      msg.CordField = _CordField_;
    }
    const _RepeatedPrimitiveField_ = json["RepeatedPrimitiveField"];
    if (_RepeatedPrimitiveField_) {
      msg.RepeatedPrimitiveField = _RepeatedPrimitiveField_;
    }
    const _RepeatedStringField_ = json["RepeatedStringField"];
    if (_RepeatedStringField_) {
      msg.RepeatedStringField = _RepeatedStringField_;
    }
    const _RepeatedEnumField_ = json["RepeatedEnumField"];
    if (_RepeatedEnumField_) {
      msg.RepeatedEnumField = _RepeatedEnumField_;
    }
    const _RepeatedMessageField_ = json["RepeatedMessageField"];
    if (_RepeatedMessageField_) {
      for (const item of _RepeatedMessageField_) {
        const m = ForeignMessage.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const _RepeatedStringPieceField_ = json["RepeatedStringPieceField"];
    if (_RepeatedStringPieceField_) {
      msg.RepeatedStringPieceField = _RepeatedStringPieceField_;
    }
    const _RepeatedCordField_ = json["RepeatedCordField"];
    if (_RepeatedCordField_) {
      msg.RepeatedCordField = _RepeatedCordField_;
    }
    return msg;
  },
};

export const TestFieldOrderingsJSON = {
  /**
   * Serializes TestFieldOrderings to JSON.
   */
  encode: function (msg: Partial<TestFieldOrderings>): string {
    return JSON.stringify(TestFieldOrderingsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestFieldOrderings from JSON.
   */
  decode: function (json: string): TestFieldOrderings {
    return TestFieldOrderingsJSON._readMessage(
      TestFieldOrderingsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      myString: "",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderingsJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestFieldOrderings>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    if (msg.myInt) {
      json["myInt"] = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json["myFloat"] = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestFieldOrderingsJSON.NestedMessage._writeMessage(
          msg.optionalNestedMessage
        );
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    json: any
  ): TestFieldOrderings {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    const _myInt_ = json["myInt"] ?? json["my_int"];
    if (_myInt_) {
      msg.myInt = BigInt(_myInt_);
    }
    const _myFloat_ = json["myFloat"] ?? json["my_float"];
    if (_myFloat_) {
      msg.myFloat = _myFloat_;
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestFieldOrderings.NestedMessage.initialize();
      TestFieldOrderingsJSON.NestedMessage._readMessage(
        m,
        _optionalNestedMessage_
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestFieldOrderings.NestedMessage to JSON.
     */
    encode: function (msg: Partial<TestFieldOrderings.NestedMessage>): string {
      return JSON.stringify(
        TestFieldOrderingsJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestFieldOrderings.NestedMessage from JSON.
     */
    decode: function (json: string): TestFieldOrderings.NestedMessage {
      return TestFieldOrderingsJSON.NestedMessage._readMessage(
        TestFieldOrderingsJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.oo) {
        json["oo"] = msg.oo.toString();
      }
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      json: any
    ): TestFieldOrderings.NestedMessage {
      const _oo_ = json["oo"];
      if (_oo_) {
        msg.oo = BigInt(_oo_);
      }
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1JSON = {
  /**
   * Serializes TestExtensionOrderings1 to JSON.
   */
  encode: function (msg: Partial<TestExtensionOrderings1>): string {
    return JSON.stringify(TestExtensionOrderings1JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionOrderings1 from JSON.
   */
  decode: function (json: string): TestExtensionOrderings1 {
    return TestExtensionOrderings1JSON._readMessage(
      TestExtensionOrderings1JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings1>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    json: any
  ): TestExtensionOrderings1 {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    return msg;
  },
};

export const TestExtensionOrderings2JSON = {
  /**
   * Serializes TestExtensionOrderings2 to JSON.
   */
  encode: function (msg: Partial<TestExtensionOrderings2>): string {
    return JSON.stringify(TestExtensionOrderings2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionOrderings2 from JSON.
   */
  decode: function (json: string): TestExtensionOrderings2 {
    return TestExtensionOrderings2JSON._readMessage(
      TestExtensionOrderings2JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    json: any
  ): TestExtensionOrderings2 {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encode: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): string {
      return JSON.stringify(
        TestExtensionOrderings2JSON.TestExtensionOrderings3._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decode: function (
      json: string
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2JSON.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2JSON.TestExtensionOrderings3.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        myString: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.myString) {
        json["myString"] = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      json: any
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      const _myString_ = json["myString"] ?? json["my_string"];
      if (_myString_) {
        msg.myString = _myString_;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValuesJSON = {
  /**
   * Serializes TestExtremeDefaultValues to JSON.
   */
  encode: function (msg: Partial<TestExtremeDefaultValues>): string {
    return JSON.stringify(TestExtremeDefaultValuesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtremeDefaultValues from JSON.
   */
  decode: function (json: string): TestExtremeDefaultValues {
    return TestExtremeDefaultValuesJSON._readMessage(
      TestExtremeDefaultValuesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: "",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: "",
      stringWithZero: "",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: "",
      cordWithZero: "",
      replacementString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.escapedBytes?.length) {
      json["escapedBytes"] = encodeBase64Bytes(msg.escapedBytes);
    }
    if (msg.largeUint32) {
      json["largeUint32"] = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json["largeUint64"] = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json["smallInt32"] = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json["smallInt64"] = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json["reallySmallInt32"] = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json["reallySmallInt64"] = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json["utf8String"] = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json["zeroFloat"] = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json["oneFloat"] = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json["smallFloat"] = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json["negativeOneFloat"] = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json["negativeFloat"] = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json["largeFloat"] = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json["smallNegativeFloat"] = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json["infDouble"] = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json["negInfDouble"] = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json["nanDouble"] = msg.nanDouble;
    }
    if (msg.infFloat) {
      json["infFloat"] = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json["negInfFloat"] = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json["nanFloat"] = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json["cppTrigraph"] = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json["stringWithZero"] = msg.stringWithZero;
    }
    if (msg.bytesWithZero?.length) {
      json["bytesWithZero"] = encodeBase64Bytes(msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      json["stringPieceWithZero"] = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json["cordWithZero"] = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json["replacementString"] = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    json: any
  ): TestExtremeDefaultValues {
    const _escapedBytes_ = json["escapedBytes"] ?? json["escaped_bytes"];
    if (_escapedBytes_) {
      msg.escapedBytes = decodeBase64Bytes(_escapedBytes_);
    }
    const _largeUint32_ = json["largeUint32"] ?? json["large_uint32"];
    if (_largeUint32_) {
      msg.largeUint32 = _largeUint32_;
    }
    const _largeUint64_ = json["largeUint64"] ?? json["large_uint64"];
    if (_largeUint64_) {
      msg.largeUint64 = BigInt(_largeUint64_);
    }
    const _smallInt32_ = json["smallInt32"] ?? json["small_int32"];
    if (_smallInt32_) {
      msg.smallInt32 = _smallInt32_;
    }
    const _smallInt64_ = json["smallInt64"] ?? json["small_int64"];
    if (_smallInt64_) {
      msg.smallInt64 = BigInt(_smallInt64_);
    }
    const _reallySmallInt32_ =
      json["reallySmallInt32"] ?? json["really_small_int32"];
    if (_reallySmallInt32_) {
      msg.reallySmallInt32 = _reallySmallInt32_;
    }
    const _reallySmallInt64_ =
      json["reallySmallInt64"] ?? json["really_small_int64"];
    if (_reallySmallInt64_) {
      msg.reallySmallInt64 = BigInt(_reallySmallInt64_);
    }
    const _utf8String_ = json["utf8String"] ?? json["utf8_string"];
    if (_utf8String_) {
      msg.utf8String = _utf8String_;
    }
    const _zeroFloat_ = json["zeroFloat"] ?? json["zero_float"];
    if (_zeroFloat_) {
      msg.zeroFloat = _zeroFloat_;
    }
    const _oneFloat_ = json["oneFloat"] ?? json["one_float"];
    if (_oneFloat_) {
      msg.oneFloat = _oneFloat_;
    }
    const _smallFloat_ = json["smallFloat"] ?? json["small_float"];
    if (_smallFloat_) {
      msg.smallFloat = _smallFloat_;
    }
    const _negativeOneFloat_ =
      json["negativeOneFloat"] ?? json["negative_one_float"];
    if (_negativeOneFloat_) {
      msg.negativeOneFloat = _negativeOneFloat_;
    }
    const _negativeFloat_ = json["negativeFloat"] ?? json["negative_float"];
    if (_negativeFloat_) {
      msg.negativeFloat = _negativeFloat_;
    }
    const _largeFloat_ = json["largeFloat"] ?? json["large_float"];
    if (_largeFloat_) {
      msg.largeFloat = _largeFloat_;
    }
    const _smallNegativeFloat_ =
      json["smallNegativeFloat"] ?? json["small_negative_float"];
    if (_smallNegativeFloat_) {
      msg.smallNegativeFloat = _smallNegativeFloat_;
    }
    const _infDouble_ = json["infDouble"] ?? json["inf_double"];
    if (_infDouble_) {
      msg.infDouble = _infDouble_;
    }
    const _negInfDouble_ = json["negInfDouble"] ?? json["neg_inf_double"];
    if (_negInfDouble_) {
      msg.negInfDouble = _negInfDouble_;
    }
    const _nanDouble_ = json["nanDouble"] ?? json["nan_double"];
    if (_nanDouble_) {
      msg.nanDouble = _nanDouble_;
    }
    const _infFloat_ = json["infFloat"] ?? json["inf_float"];
    if (_infFloat_) {
      msg.infFloat = _infFloat_;
    }
    const _negInfFloat_ = json["negInfFloat"] ?? json["neg_inf_float"];
    if (_negInfFloat_) {
      msg.negInfFloat = _negInfFloat_;
    }
    const _nanFloat_ = json["nanFloat"] ?? json["nan_float"];
    if (_nanFloat_) {
      msg.nanFloat = _nanFloat_;
    }
    const _cppTrigraph_ = json["cppTrigraph"] ?? json["cpp_trigraph"];
    if (_cppTrigraph_) {
      msg.cppTrigraph = _cppTrigraph_;
    }
    const _stringWithZero_ = json["stringWithZero"] ?? json["string_with_zero"];
    if (_stringWithZero_) {
      msg.stringWithZero = _stringWithZero_;
    }
    const _bytesWithZero_ = json["bytesWithZero"] ?? json["bytes_with_zero"];
    if (_bytesWithZero_) {
      msg.bytesWithZero = decodeBase64Bytes(_bytesWithZero_);
    }
    const _stringPieceWithZero_ =
      json["stringPieceWithZero"] ?? json["string_piece_with_zero"];
    if (_stringPieceWithZero_) {
      msg.stringPieceWithZero = _stringPieceWithZero_;
    }
    const _cordWithZero_ = json["cordWithZero"] ?? json["cord_with_zero"];
    if (_cordWithZero_) {
      msg.cordWithZero = _cordWithZero_;
    }
    const _replacementString_ =
      json["replacementString"] ?? json["replacement_string"];
    if (_replacementString_) {
      msg.replacementString = _replacementString_;
    }
    return msg;
  },
};

export const SparseEnumMessageJSON = {
  /**
   * Serializes SparseEnumMessage to JSON.
   */
  encode: function (msg: Partial<SparseEnumMessage>): string {
    return JSON.stringify(SparseEnumMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes SparseEnumMessage from JSON.
   */
  decode: function (json: string): SparseEnumMessage {
    return SparseEnumMessageJSON._readMessage(
      SparseEnumMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparseEnum: TestSparseEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SparseEnumMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sparseEnum && TestSparseEnumJSON._toInt(msg.sparseEnum)) {
      json["sparseEnum"] = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    json: any
  ): SparseEnumMessage {
    const _sparseEnum_ = json["sparseEnum"] ?? json["sparse_enum"];
    if (_sparseEnum_) {
      msg.sparseEnum = _sparseEnum_;
    }
    return msg;
  },
};

export const OneStringJSON = {
  /**
   * Serializes OneString to JSON.
   */
  encode: function (msg: Partial<OneString>): string {
    return JSON.stringify(OneStringJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneString from JSON.
   */
  decode: function (json: string): OneString {
    return OneStringJSON._readMessage(
      OneStringJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<OneString>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, json: any): OneString {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const MoreStringJSON = {
  /**
   * Serializes MoreString to JSON.
   */
  encode: function (msg: Partial<MoreString>): string {
    return JSON.stringify(MoreStringJSON._writeMessage(msg));
  },

  /**
   * Deserializes MoreString from JSON.
   */
  decode: function (json: string): MoreString {
    return MoreStringJSON._readMessage(
      MoreStringJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<MoreString>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, json: any): MoreString {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const OneBytesJSON = {
  /**
   * Serializes OneBytes to JSON.
   */
  encode: function (msg: Partial<OneBytes>): string {
    return JSON.stringify(OneBytesJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneBytes from JSON.
   */
  decode: function (json: string): OneBytes {
    return OneBytesJSON._readMessage(
      OneBytesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<OneBytes>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json["data"] = encodeBase64Bytes(msg.data);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, json: any): OneBytes {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = decodeBase64Bytes(_data_);
    }
    return msg;
  },
};

export const MoreBytesJSON = {
  /**
   * Serializes MoreBytes to JSON.
   */
  encode: function (msg: Partial<MoreBytes>): string {
    return JSON.stringify(MoreBytesJSON._writeMessage(msg));
  },

  /**
   * Deserializes MoreBytes from JSON.
   */
  decode: function (json: string): MoreBytes {
    return MoreBytesJSON._readMessage(
      MoreBytesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<MoreBytes>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json["data"] = msg.data.map(encodeBase64Bytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, json: any): MoreBytes {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_.map(decodeBase64Bytes);
    }
    return msg;
  },
};

export const Int32MessageJSON = {
  /**
   * Serializes Int32Message to JSON.
   */
  encode: function (msg: Partial<Int32Message>): string {
    return JSON.stringify(Int32MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Int32Message from JSON.
   */
  decode: function (json: string): Int32Message {
    return Int32MessageJSON._readMessage(
      Int32MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Int32Message, json: any): Int32Message {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const Uint32MessageJSON = {
  /**
   * Serializes Uint32Message to JSON.
   */
  encode: function (msg: Partial<Uint32Message>): string {
    return JSON.stringify(Uint32MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Uint32Message from JSON.
   */
  decode: function (json: string): Uint32Message {
    return Uint32MessageJSON._readMessage(
      Uint32MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint32Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Uint32Message, json: any): Uint32Message {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const Int64MessageJSON = {
  /**
   * Serializes Int64Message to JSON.
   */
  encode: function (msg: Partial<Int64Message>): string {
    return JSON.stringify(Int64MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Int64Message from JSON.
   */
  decode: function (json: string): Int64Message {
    return Int64MessageJSON._readMessage(
      Int64MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Int64Message, json: any): Int64Message {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = BigInt(_data_);
    }
    return msg;
  },
};

export const Uint64MessageJSON = {
  /**
   * Serializes Uint64Message to JSON.
   */
  encode: function (msg: Partial<Uint64Message>): string {
    return JSON.stringify(Uint64MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Uint64Message from JSON.
   */
  decode: function (json: string): Uint64Message {
    return Uint64MessageJSON._readMessage(
      Uint64MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint64Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Uint64Message, json: any): Uint64Message {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = BigInt(_data_);
    }
    return msg;
  },
};

export const BoolMessageJSON = {
  /**
   * Serializes BoolMessage to JSON.
   */
  encode: function (msg: Partial<BoolMessage>): string {
    return JSON.stringify(BoolMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes BoolMessage from JSON.
   */
  decode: function (json: string): BoolMessage {
    return BoolMessageJSON._readMessage(
      BoolMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<BoolMessage>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, json: any): BoolMessage {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const TestOneofJSON = {
  /**
   * Serializes TestOneof to JSON.
   */
  encode: function (msg: Partial<TestOneof>): string {
    return JSON.stringify(TestOneofJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof from JSON.
   */
  decode: function (json: string): TestOneof {
    return TestOneofJSON._readMessage(
      TestOneofJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<TestOneof>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestAllTypesJSON._writeMessage(msg.fooMessage);
      json["fooMessage"] = _fooMessage_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, json: any): TestOneof {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneof.FooGroup to JSON.
     */
    encode: function (msg: Partial<TestOneof.FooGroup>): string {
      return JSON.stringify(TestOneofJSON.FooGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof.FooGroup from JSON.
     */
    decode: function (json: string): TestOneof.FooGroup {
      return TestOneofJSON.FooGroup._readMessage(
        TestOneofJSON.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      json: any
    ): TestOneof.FooGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatibleJSON = {
  /**
   * Serializes TestOneofBackwardsCompatible to JSON.
   */
  encode: function (msg: Partial<TestOneofBackwardsCompatible>): string {
    return JSON.stringify(TestOneofBackwardsCompatibleJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneofBackwardsCompatible from JSON.
   */
  decode: function (json: string): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatibleJSON._readMessage(
      TestOneofBackwardsCompatibleJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      fooInt: 0,
      fooString: "",
      fooMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage) {
      const _fooMessage_ = TestAllTypesJSON._writeMessage(msg.fooMessage);
      if (Object.keys(_fooMessage_).length > 0) {
        json["fooMessage"] = _fooMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    json: any
  ): TestOneofBackwardsCompatible {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encode: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): string {
      return JSON.stringify(
        TestOneofBackwardsCompatibleJSON.FooGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decode: function (json: string): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatibleJSON.FooGroup._readMessage(
        TestOneofBackwardsCompatibleJSON.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      json: any
    ): TestOneofBackwardsCompatible.FooGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },
};

export const TestOneof2JSON = {
  /**
   * Serializes TestOneof2 to JSON.
   */
  encode: function (msg: Partial<TestOneof2>): string {
    return JSON.stringify(TestOneof2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof2 from JSON.
   */
  decode: function (json: string): TestOneof2 {
    return TestOneof2JSON._readMessage(
      TestOneof2JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooCord: undefined,
      fooStringPiece: undefined,
      fooBytes: undefined,
      fooEnum: undefined,
      fooMessage: undefined,
      fooLazyMessage: undefined,
      barInt: undefined,
      barString: undefined,
      barCord: undefined,
      barStringPiece: undefined,
      barBytes: undefined,
      barEnum: undefined,
      barStringWithEmptyDefault: undefined,
      barCordWithEmptyDefault: undefined,
      barStringPieceWithEmptyDefault: undefined,
      barBytesWithEmptyDefault: undefined,
      bazInt: 0,
      bazString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<TestOneof2>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json["fooCord"] = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json["fooStringPiece"] = msg.fooStringPiece;
    }
    if (msg.fooBytes?.length) {
      json["fooBytes"] = encodeBase64Bytes(msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      json["fooEnum"] = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestOneof2JSON.NestedMessage._writeMessage(
        msg.fooMessage
      );
      json["fooMessage"] = _fooMessage_;
    }
    if (msg.fooLazyMessage != undefined) {
      const _fooLazyMessage_ = TestOneof2JSON.NestedMessage._writeMessage(
        msg.fooLazyMessage
      );
      json["fooLazyMessage"] = _fooLazyMessage_;
    }
    if (msg.barInt != undefined) {
      json["barInt"] = msg.barInt;
    }
    if (msg.barString != undefined) {
      json["barString"] = msg.barString;
    }
    if (msg.barCord != undefined) {
      json["barCord"] = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json["barStringPiece"] = msg.barStringPiece;
    }
    if (msg.barBytes?.length) {
      json["barBytes"] = encodeBase64Bytes(msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      json["barEnum"] = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json["barStringWithEmptyDefault"] = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json["barCordWithEmptyDefault"] = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json["barStringPieceWithEmptyDefault"] =
        msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      json["barBytesWithEmptyDefault"] = encodeBase64Bytes(
        msg.barBytesWithEmptyDefault
      );
    }
    if (msg.bazInt) {
      json["bazInt"] = msg.bazInt;
    }
    if (msg.bazString) {
      json["bazString"] = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, json: any): TestOneof2 {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooCord_ = json["fooCord"] ?? json["foo_cord"];
    if (_fooCord_) {
      msg.fooCord = _fooCord_;
    }
    const _fooStringPiece_ = json["fooStringPiece"] ?? json["foo_string_piece"];
    if (_fooStringPiece_) {
      msg.fooStringPiece = _fooStringPiece_;
    }
    const _fooBytes_ = json["fooBytes"] ?? json["foo_bytes"];
    if (_fooBytes_) {
      msg.fooBytes = decodeBase64Bytes(_fooBytes_);
    }
    const _fooEnum_ = json["fooEnum"] ?? json["foo_enum"];
    if (_fooEnum_) {
      msg.fooEnum = _fooEnum_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2JSON.NestedMessage._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    const _fooLazyMessage_ = json["fooLazyMessage"] ?? json["foo_lazy_message"];
    if (_fooLazyMessage_) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2JSON.NestedMessage._readMessage(m, _fooLazyMessage_);
      msg.fooLazyMessage = m;
    }
    const _barInt_ = json["barInt"] ?? json["bar_int"];
    if (_barInt_) {
      msg.barInt = _barInt_;
    }
    const _barString_ = json["barString"] ?? json["bar_string"];
    if (_barString_) {
      msg.barString = _barString_;
    }
    const _barCord_ = json["barCord"] ?? json["bar_cord"];
    if (_barCord_) {
      msg.barCord = _barCord_;
    }
    const _barStringPiece_ = json["barStringPiece"] ?? json["bar_string_piece"];
    if (_barStringPiece_) {
      msg.barStringPiece = _barStringPiece_;
    }
    const _barBytes_ = json["barBytes"] ?? json["bar_bytes"];
    if (_barBytes_) {
      msg.barBytes = decodeBase64Bytes(_barBytes_);
    }
    const _barEnum_ = json["barEnum"] ?? json["bar_enum"];
    if (_barEnum_) {
      msg.barEnum = _barEnum_;
    }
    const _barStringWithEmptyDefault_ =
      json["barStringWithEmptyDefault"] ??
      json["bar_string_with_empty_default"];
    if (_barStringWithEmptyDefault_) {
      msg.barStringWithEmptyDefault = _barStringWithEmptyDefault_;
    }
    const _barCordWithEmptyDefault_ =
      json["barCordWithEmptyDefault"] ?? json["bar_cord_with_empty_default"];
    if (_barCordWithEmptyDefault_) {
      msg.barCordWithEmptyDefault = _barCordWithEmptyDefault_;
    }
    const _barStringPieceWithEmptyDefault_ =
      json["barStringPieceWithEmptyDefault"] ??
      json["bar_string_piece_with_empty_default"];
    if (_barStringPieceWithEmptyDefault_) {
      msg.barStringPieceWithEmptyDefault = _barStringPieceWithEmptyDefault_;
    }
    const _barBytesWithEmptyDefault_ =
      json["barBytesWithEmptyDefault"] ?? json["bar_bytes_with_empty_default"];
    if (_barBytesWithEmptyDefault_) {
      msg.barBytesWithEmptyDefault = decodeBase64Bytes(
        _barBytesWithEmptyDefault_
      );
    }
    const _bazInt_ = json["bazInt"] ?? json["baz_int"];
    if (_bazInt_) {
      msg.bazInt = _bazInt_;
    }
    const _bazString_ = json["bazString"] ?? json["baz_string"];
    if (_bazString_) {
      msg.bazString = _bazString_;
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestOneof2.NestedEnum {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestOneof2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestOneof2.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  FooGroup: {
    /**
     * Serializes TestOneof2.FooGroup to JSON.
     */
    encode: function (msg: Partial<TestOneof2.FooGroup>): string {
      return JSON.stringify(TestOneof2JSON.FooGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof2.FooGroup from JSON.
     */
    decode: function (json: string): TestOneof2.FooGroup {
      return TestOneof2JSON.FooGroup._readMessage(
        TestOneof2JSON.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      json: any
    ): TestOneof2.FooGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes TestOneof2.NestedMessage to JSON.
     */
    encode: function (msg: Partial<TestOneof2.NestedMessage>): string {
      return JSON.stringify(TestOneof2JSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof2.NestedMessage from JSON.
     */
    decode: function (json: string): TestOneof2.NestedMessage {
      return TestOneof2JSON.NestedMessage._readMessage(
        TestOneof2JSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.quxInt) {
        json["quxInt"] = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json["corgeInt"] = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      json: any
    ): TestOneof2.NestedMessage {
      const _quxInt_ = json["quxInt"] ?? json["qux_int"];
      if (_quxInt_) {
        msg.quxInt = BigInt(_quxInt_);
      }
      const _corgeInt_ = json["corgeInt"] ?? json["corge_int"];
      if (_corgeInt_) {
        msg.corgeInt = _corgeInt_;
      }
      return msg;
    },
  },
};

export const TestRequiredOneofJSON = {
  /**
   * Serializes TestRequiredOneof to JSON.
   */
  encode: function (msg: Partial<TestRequiredOneof>): string {
    return JSON.stringify(TestRequiredOneofJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredOneof from JSON.
   */
  decode: function (json: string): TestRequiredOneof {
    return TestRequiredOneofJSON._readMessage(
      TestRequiredOneofJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredOneof>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestRequiredOneofJSON.NestedMessage._writeMessage(
        msg.fooMessage
      );
      json["fooMessage"] = _fooMessage_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    json: any
  ): TestRequiredOneof {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestRequiredOneof.NestedMessage.initialize();
      TestRequiredOneofJSON.NestedMessage._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestRequiredOneof.NestedMessage to JSON.
     */
    encode: function (msg: Partial<TestRequiredOneof.NestedMessage>): string {
      return JSON.stringify(
        TestRequiredOneofJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestRequiredOneof.NestedMessage from JSON.
     */
    decode: function (json: string): TestRequiredOneof.NestedMessage {
      return TestRequiredOneofJSON.NestedMessage._readMessage(
        TestRequiredOneofJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.requiredDouble) {
        json["requiredDouble"] = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      json: any
    ): TestRequiredOneof.NestedMessage {
      const _requiredDouble_ =
        json["requiredDouble"] ?? json["required_double"];
      if (_requiredDouble_) {
        msg.requiredDouble = _requiredDouble_;
      }
      return msg;
    },
  },
};

export const TestPackedTypesJSON = {
  /**
   * Serializes TestPackedTypes to JSON.
   */
  encode: function (msg: Partial<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestPackedTypes from JSON.
   */
  decode: function (json: string): TestPackedTypes {
    return TestPackedTypesJSON._readMessage(
      TestPackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json["packedInt64"] = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json["packedUint32"] = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json["packedUint64"] = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json["packedSint32"] = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json["packedSint64"] = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json["packedFixed32"] = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json["packedFixed64"] = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json["packedSfixed32"] = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json["packedSfixed64"] = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json["packedFloat"] = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json["packedDouble"] = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json["packedBool"] = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json["packedEnum"] = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestPackedTypes, json: any): TestPackedTypes {
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _packedInt64_ = json["packedInt64"] ?? json["packed_int64"];
    if (_packedInt64_) {
      msg.packedInt64 = _packedInt64_.map(BigInt);
    }
    const _packedUint32_ = json["packedUint32"] ?? json["packed_uint32"];
    if (_packedUint32_) {
      msg.packedUint32 = _packedUint32_;
    }
    const _packedUint64_ = json["packedUint64"] ?? json["packed_uint64"];
    if (_packedUint64_) {
      msg.packedUint64 = _packedUint64_.map(BigInt);
    }
    const _packedSint32_ = json["packedSint32"] ?? json["packed_sint32"];
    if (_packedSint32_) {
      msg.packedSint32 = _packedSint32_;
    }
    const _packedSint64_ = json["packedSint64"] ?? json["packed_sint64"];
    if (_packedSint64_) {
      msg.packedSint64 = _packedSint64_.map(BigInt);
    }
    const _packedFixed32_ = json["packedFixed32"] ?? json["packed_fixed32"];
    if (_packedFixed32_) {
      msg.packedFixed32 = _packedFixed32_;
    }
    const _packedFixed64_ = json["packedFixed64"] ?? json["packed_fixed64"];
    if (_packedFixed64_) {
      msg.packedFixed64 = _packedFixed64_.map(BigInt);
    }
    const _packedSfixed32_ = json["packedSfixed32"] ?? json["packed_sfixed32"];
    if (_packedSfixed32_) {
      msg.packedSfixed32 = _packedSfixed32_;
    }
    const _packedSfixed64_ = json["packedSfixed64"] ?? json["packed_sfixed64"];
    if (_packedSfixed64_) {
      msg.packedSfixed64 = _packedSfixed64_.map(BigInt);
    }
    const _packedFloat_ = json["packedFloat"] ?? json["packed_float"];
    if (_packedFloat_) {
      msg.packedFloat = _packedFloat_;
    }
    const _packedDouble_ = json["packedDouble"] ?? json["packed_double"];
    if (_packedDouble_) {
      msg.packedDouble = _packedDouble_;
    }
    const _packedBool_ = json["packedBool"] ?? json["packed_bool"];
    if (_packedBool_) {
      msg.packedBool = _packedBool_;
    }
    const _packedEnum_ = json["packedEnum"] ?? json["packed_enum"];
    if (_packedEnum_) {
      msg.packedEnum = _packedEnum_;
    }
    return msg;
  },
};

export const TestUnpackedTypesJSON = {
  /**
   * Serializes TestUnpackedTypes to JSON.
   */
  encode: function (msg: Partial<TestUnpackedTypes>): string {
    return JSON.stringify(TestUnpackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestUnpackedTypes from JSON.
   */
  decode: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypesJSON._readMessage(
      TestUnpackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.unpackedInt32?.length) {
      json["unpackedInt32"] = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json["unpackedInt64"] = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json["unpackedUint32"] = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json["unpackedUint64"] = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json["unpackedSint32"] = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json["unpackedSint64"] = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json["unpackedFixed32"] = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json["unpackedFixed64"] = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json["unpackedSfixed32"] = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json["unpackedSfixed64"] = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json["unpackedFloat"] = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json["unpackedDouble"] = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json["unpackedBool"] = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json["unpackedEnum"] = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    json: any
  ): TestUnpackedTypes {
    const _unpackedInt32_ = json["unpackedInt32"] ?? json["unpacked_int32"];
    if (_unpackedInt32_) {
      msg.unpackedInt32 = _unpackedInt32_;
    }
    const _unpackedInt64_ = json["unpackedInt64"] ?? json["unpacked_int64"];
    if (_unpackedInt64_) {
      msg.unpackedInt64 = _unpackedInt64_.map(BigInt);
    }
    const _unpackedUint32_ = json["unpackedUint32"] ?? json["unpacked_uint32"];
    if (_unpackedUint32_) {
      msg.unpackedUint32 = _unpackedUint32_;
    }
    const _unpackedUint64_ = json["unpackedUint64"] ?? json["unpacked_uint64"];
    if (_unpackedUint64_) {
      msg.unpackedUint64 = _unpackedUint64_.map(BigInt);
    }
    const _unpackedSint32_ = json["unpackedSint32"] ?? json["unpacked_sint32"];
    if (_unpackedSint32_) {
      msg.unpackedSint32 = _unpackedSint32_;
    }
    const _unpackedSint64_ = json["unpackedSint64"] ?? json["unpacked_sint64"];
    if (_unpackedSint64_) {
      msg.unpackedSint64 = _unpackedSint64_.map(BigInt);
    }
    const _unpackedFixed32_ =
      json["unpackedFixed32"] ?? json["unpacked_fixed32"];
    if (_unpackedFixed32_) {
      msg.unpackedFixed32 = _unpackedFixed32_;
    }
    const _unpackedFixed64_ =
      json["unpackedFixed64"] ?? json["unpacked_fixed64"];
    if (_unpackedFixed64_) {
      msg.unpackedFixed64 = _unpackedFixed64_.map(BigInt);
    }
    const _unpackedSfixed32_ =
      json["unpackedSfixed32"] ?? json["unpacked_sfixed32"];
    if (_unpackedSfixed32_) {
      msg.unpackedSfixed32 = _unpackedSfixed32_;
    }
    const _unpackedSfixed64_ =
      json["unpackedSfixed64"] ?? json["unpacked_sfixed64"];
    if (_unpackedSfixed64_) {
      msg.unpackedSfixed64 = _unpackedSfixed64_.map(BigInt);
    }
    const _unpackedFloat_ = json["unpackedFloat"] ?? json["unpacked_float"];
    if (_unpackedFloat_) {
      msg.unpackedFloat = _unpackedFloat_;
    }
    const _unpackedDouble_ = json["unpackedDouble"] ?? json["unpacked_double"];
    if (_unpackedDouble_) {
      msg.unpackedDouble = _unpackedDouble_;
    }
    const _unpackedBool_ = json["unpackedBool"] ?? json["unpacked_bool"];
    if (_unpackedBool_) {
      msg.unpackedBool = _unpackedBool_;
    }
    const _unpackedEnum_ = json["unpackedEnum"] ?? json["unpacked_enum"];
    if (_unpackedEnum_) {
      msg.unpackedEnum = _unpackedEnum_;
    }
    return msg;
  },
};

export const TestPackedExtensionsJSON = {
  /**
   * Serializes TestPackedExtensions to JSON.
   */
  encode: function (_msg?: Partial<TestPackedExtensions>): string {
    return "{}";
  },

  /**
   * Deserializes TestPackedExtensions from JSON.
   */
  decode: function (_json?: string): TestPackedExtensions {
    return {};
  },

  /**
   * Initializes TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestPackedExtensions>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedExtensions,
    _json: any
  ): TestPackedExtensions {
    return msg;
  },
};

export const TestUnpackedExtensionsJSON = {
  /**
   * Serializes TestUnpackedExtensions to JSON.
   */
  encode: function (_msg?: Partial<TestUnpackedExtensions>): string {
    return "{}";
  },

  /**
   * Deserializes TestUnpackedExtensions from JSON.
   */
  decode: function (_json?: string): TestUnpackedExtensions {
    return {};
  },

  /**
   * Initializes TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestUnpackedExtensions>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedExtensions,
    _json: any
  ): TestUnpackedExtensions {
    return msg;
  },
};

export const TestDynamicExtensionsJSON = {
  /**
   * Serializes TestDynamicExtensions to JSON.
   */
  encode: function (msg: Partial<TestDynamicExtensions>): string {
    return JSON.stringify(TestDynamicExtensionsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDynamicExtensions from JSON.
   */
  decode: function (json: string): TestDynamicExtensions {
    return TestDynamicExtensionsJSON._readMessage(
      TestDynamicExtensionsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnum._fromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType._fromInt(0),
      messageExtension: ForeignMessageJSON.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensionsJSON.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDynamicExtensions>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.scalarExtension) {
      json["scalarExtension"] = msg.scalarExtension;
    }
    if (msg.enumExtension && ForeignEnumJSON._toInt(msg.enumExtension)) {
      json["enumExtension"] = msg.enumExtension;
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensionsJSON.DynamicEnumType._toInt(msg.dynamicEnumExtension)
    ) {
      json["dynamicEnumExtension"] = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const _messageExtension_ = ForeignMessageJSON._writeMessage(
        msg.messageExtension
      );
      if (Object.keys(_messageExtension_).length > 0) {
        json["messageExtension"] = _messageExtension_;
      }
    }
    if (msg.dynamicMessageExtension) {
      const _dynamicMessageExtension_ =
        TestDynamicExtensionsJSON.DynamicMessageType._writeMessage(
          msg.dynamicMessageExtension
        );
      if (Object.keys(_dynamicMessageExtension_).length > 0) {
        json["dynamicMessageExtension"] = _dynamicMessageExtension_;
      }
    }
    if (msg.repeatedExtension?.length) {
      json["repeatedExtension"] = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json["packedExtension"] = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    json: any
  ): TestDynamicExtensions {
    const _scalarExtension_ =
      json["scalarExtension"] ?? json["scalar_extension"];
    if (_scalarExtension_) {
      msg.scalarExtension = _scalarExtension_;
    }
    const _enumExtension_ = json["enumExtension"] ?? json["enum_extension"];
    if (_enumExtension_) {
      msg.enumExtension = _enumExtension_;
    }
    const _dynamicEnumExtension_ =
      json["dynamicEnumExtension"] ?? json["dynamic_enum_extension"];
    if (_dynamicEnumExtension_) {
      msg.dynamicEnumExtension = _dynamicEnumExtension_;
    }
    const _messageExtension_ =
      json["messageExtension"] ?? json["message_extension"];
    if (_messageExtension_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _messageExtension_);
      msg.messageExtension = m;
    }
    const _dynamicMessageExtension_ =
      json["dynamicMessageExtension"] ?? json["dynamic_message_extension"];
    if (_dynamicMessageExtension_) {
      const m = TestDynamicExtensions.DynamicMessageType.initialize();
      TestDynamicExtensionsJSON.DynamicMessageType._readMessage(
        m,
        _dynamicMessageExtension_
      );
      msg.dynamicMessageExtension = m;
    }
    const _repeatedExtension_ =
      json["repeatedExtension"] ?? json["repeated_extension"];
    if (_repeatedExtension_) {
      msg.repeatedExtension = _repeatedExtension_;
    }
    const _packedExtension_ =
      json["packedExtension"] ?? json["packed_extension"];
    if (_packedExtension_) {
      msg.packedExtension = _packedExtension_;
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: "DYNAMIC_FOO",
    DYNAMIC_BAR: "DYNAMIC_BAR",
    DYNAMIC_BAZ: "DYNAMIC_BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestDynamicExtensions.DynamicEnumType {
      switch (i) {
        case 2200: {
          return "DYNAMIC_FOO";
        }
        case 2201: {
          return "DYNAMIC_BAR";
        }
        case 2202: {
          return "DYNAMIC_BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestDynamicExtensions.DynamicEnumType;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestDynamicExtensions.DynamicEnumType): number {
      switch (i) {
        case "DYNAMIC_FOO": {
          return 2200;
        }
        case "DYNAMIC_BAR": {
          return 2201;
        }
        case "DYNAMIC_BAZ": {
          return 2202;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  DynamicMessageType: {
    /**
     * Serializes TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encode: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): string {
      return JSON.stringify(
        TestDynamicExtensionsJSON.DynamicMessageType._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decode: function (json: string): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensionsJSON.DynamicMessageType._readMessage(
        TestDynamicExtensionsJSON.DynamicMessageType.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.dynamicField) {
        json["dynamicField"] = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      json: any
    ): TestDynamicExtensions.DynamicMessageType {
      const _dynamicField_ = json["dynamicField"] ?? json["dynamic_field"];
      if (_dynamicField_) {
        msg.dynamicField = _dynamicField_;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizesJSON = {
  /**
   * Serializes TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encode: function (msg: Partial<TestRepeatedScalarDifferentTagSizes>): string {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizesJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decode: function (json: string): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizesJSON._readMessage(
      TestRepeatedScalarDifferentTagSizesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    json: any
  ): TestRepeatedScalarDifferentTagSizes {
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMergeJSON = {
  /**
   * Serializes TestParsingMerge to JSON.
   */
  encode: function (msg: Partial<TestParsingMerge>): string {
    return JSON.stringify(TestParsingMergeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestParsingMerge from JSON.
   */
  decode: function (json: string): TestParsingMerge {
    return TestParsingMergeJSON._readMessage(
      TestParsingMergeJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      requiredAllTypes: TestAllTypesJSON.initialize(),
      optionalAllTypes: TestAllTypesJSON.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestParsingMerge>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.requiredAllTypes) {
      const _requiredAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.requiredAllTypes
      );
      if (Object.keys(_requiredAllTypes_).length > 0) {
        json["requiredAllTypes"] = _requiredAllTypes_;
      }
    }
    if (msg.optionalAllTypes) {
      const _optionalAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.optionalAllTypes
      );
      if (Object.keys(_optionalAllTypes_).length > 0) {
        json["optionalAllTypes"] = _optionalAllTypes_;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json["repeatedAllTypes"] = msg.repeatedAllTypes.map(
        TestAllTypesJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestParsingMerge, json: any): TestParsingMerge {
    const _requiredAllTypes_ =
      json["requiredAllTypes"] ?? json["required_all_types"];
    if (_requiredAllTypes_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _requiredAllTypes_);
      msg.requiredAllTypes = m;
    }
    const _optionalAllTypes_ =
      json["optionalAllTypes"] ?? json["optional_all_types"];
    if (_optionalAllTypes_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _optionalAllTypes_);
      msg.optionalAllTypes = m;
    }
    const _repeatedAllTypes_ =
      json["repeatedAllTypes"] ?? json["repeated_all_types"];
    if (_repeatedAllTypes_) {
      for (const item of _repeatedAllTypes_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encode: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): string {
      return JSON.stringify(
        TestParsingMergeJSON.RepeatedFieldsGenerator._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decode: function (json: string): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMergeJSON.RepeatedFieldsGenerator._readMessage(
        TestParsingMergeJSON.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.field1?.length) {
        json["field1"] = msg.field1.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.field2?.length) {
        json["field2"] = msg.field2.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.field3?.length) {
        json["field3"] = msg.field3.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.ext1?.length) {
        json["ext1"] = msg.ext1.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.ext2?.length) {
        json["ext2"] = msg.ext2.map(TestAllTypesJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      json: any
    ): TestParsingMerge.RepeatedFieldsGenerator {
      const _field1_ = json["field1"];
      if (_field1_) {
        for (const item of _field1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field1.push(m);
        }
      }
      const _field2_ = json["field2"];
      if (_field2_) {
        for (const item of _field2_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field2.push(m);
        }
      }
      const _field3_ = json["field3"];
      if (_field3_) {
        for (const item of _field3_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field3.push(m);
        }
      }
      const _ext1_ = json["ext1"];
      if (_ext1_) {
        for (const item of _ext1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.ext1.push(m);
        }
      }
      const _ext2_ = json["ext2"];
      if (_ext2_) {
        for (const item of _ext2_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encode: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): string {
        return JSON.stringify(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group1._writeMessage(msg)
        );
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decode: function (
        json: string
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMergeJSON.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypesJSON.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const _field1_ = TestAllTypesJSON._writeMessage(msg.field1);
          if (Object.keys(_field1_).length > 0) {
            json["field1"] = _field1_;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        json: any
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        const _field1_ = json["field1"];
        if (_field1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, _field1_);
          msg.field1 = m;
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encode: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): string {
        return JSON.stringify(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group2._writeMessage(msg)
        );
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decode: function (
        json: string
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMergeJSON.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypesJSON.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const _field1_ = TestAllTypesJSON._writeMessage(msg.field1);
          if (Object.keys(_field1_).length > 0) {
            json["field1"] = _field1_;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        json: any
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        const _field1_ = json["field1"];
        if (_field1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, _field1_);
          msg.field1 = m;
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestParsingMerge.OptionalGroup to JSON.
     */
    encode: function (msg: Partial<TestParsingMerge.OptionalGroup>): string {
      return JSON.stringify(
        TestParsingMergeJSON.OptionalGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestParsingMerge.OptionalGroup from JSON.
     */
    decode: function (json: string): TestParsingMerge.OptionalGroup {
      return TestParsingMergeJSON.OptionalGroup._readMessage(
        TestParsingMergeJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optionalGroupAllTypes: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.optionalGroupAllTypes) {
        const _optionalGroupAllTypes_ = TestAllTypesJSON._writeMessage(
          msg.optionalGroupAllTypes
        );
        if (Object.keys(_optionalGroupAllTypes_).length > 0) {
          json["optionalGroupAllTypes"] = _optionalGroupAllTypes_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      json: any
    ): TestParsingMerge.OptionalGroup {
      const _optionalGroupAllTypes_ =
        json["optionalGroupAllTypes"] ?? json["optional_group_all_types"];
      if (_optionalGroupAllTypes_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, _optionalGroupAllTypes_);
        msg.optionalGroupAllTypes = m;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestParsingMerge.RepeatedGroup to JSON.
     */
    encode: function (msg: Partial<TestParsingMerge.RepeatedGroup>): string {
      return JSON.stringify(
        TestParsingMergeJSON.RepeatedGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestParsingMerge.RepeatedGroup from JSON.
     */
    decode: function (json: string): TestParsingMerge.RepeatedGroup {
      return TestParsingMergeJSON.RepeatedGroup._readMessage(
        TestParsingMergeJSON.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeatedGroupAllTypes: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.repeatedGroupAllTypes) {
        const _repeatedGroupAllTypes_ = TestAllTypesJSON._writeMessage(
          msg.repeatedGroupAllTypes
        );
        if (Object.keys(_repeatedGroupAllTypes_).length > 0) {
          json["repeatedGroupAllTypes"] = _repeatedGroupAllTypes_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      json: any
    ): TestParsingMerge.RepeatedGroup {
      const _repeatedGroupAllTypes_ =
        json["repeatedGroupAllTypes"] ?? json["repeated_group_all_types"];
      if (_repeatedGroupAllTypes_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, _repeatedGroupAllTypes_);
        msg.repeatedGroupAllTypes = m;
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessageJSON = {
  /**
   * Serializes TestCommentInjectionMessage to JSON.
   */
  encode: function (msg: Partial<TestCommentInjectionMessage>): string {
    return JSON.stringify(TestCommentInjectionMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestCommentInjectionMessage from JSON.
   */
  decode: function (json: string): TestCommentInjectionMessage {
    return TestCommentInjectionMessageJSON._readMessage(
      TestCommentInjectionMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    json: any
  ): TestCommentInjectionMessage {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const FooRequestJSON = {
  /**
   * Serializes FooRequest to JSON.
   */
  encode: function (_msg?: Partial<FooRequest>): string {
    return "{}";
  },

  /**
   * Deserializes FooRequest from JSON.
   */
  decode: function (_json?: string): FooRequest {
    return {};
  },

  /**
   * Initializes FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg: Partial<FooRequest>): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooRequest, _json: any): FooRequest {
    return msg;
  },
};

export const FooResponseJSON = {
  /**
   * Serializes FooResponse to JSON.
   */
  encode: function (_msg?: Partial<FooResponse>): string {
    return "{}";
  },

  /**
   * Deserializes FooResponse from JSON.
   */
  decode: function (_json?: string): FooResponse {
    return {};
  },

  /**
   * Initializes FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooResponse>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooResponse, _json: any): FooResponse {
    return msg;
  },
};

export const FooClientMessageJSON = {
  /**
   * Serializes FooClientMessage to JSON.
   */
  encode: function (_msg?: Partial<FooClientMessage>): string {
    return "{}";
  },

  /**
   * Deserializes FooClientMessage from JSON.
   */
  decode: function (_json?: string): FooClientMessage {
    return {};
  },

  /**
   * Initializes FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooClientMessage>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooClientMessage, _json: any): FooClientMessage {
    return msg;
  },
};

export const FooServerMessageJSON = {
  /**
   * Serializes FooServerMessage to JSON.
   */
  encode: function (_msg?: Partial<FooServerMessage>): string {
    return "{}";
  },

  /**
   * Deserializes FooServerMessage from JSON.
   */
  decode: function (_json?: string): FooServerMessage {
    return {};
  },

  /**
   * Initializes FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooServerMessage>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooServerMessage, _json: any): FooServerMessage {
    return msg;
  },
};

export const BarRequestJSON = {
  /**
   * Serializes BarRequest to JSON.
   */
  encode: function (_msg?: Partial<BarRequest>): string {
    return "{}";
  },

  /**
   * Deserializes BarRequest from JSON.
   */
  decode: function (_json?: string): BarRequest {
    return {};
  },

  /**
   * Initializes BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg: Partial<BarRequest>): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: BarRequest, _json: any): BarRequest {
    return msg;
  },
};

export const BarResponseJSON = {
  /**
   * Serializes BarResponse to JSON.
   */
  encode: function (_msg?: Partial<BarResponse>): string {
    return "{}";
  },

  /**
   * Deserializes BarResponse from JSON.
   */
  decode: function (_json?: string): BarResponse {
    return {};
  },

  /**
   * Initializes BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<BarResponse>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: BarResponse, _json: any): BarResponse {
    return msg;
  },
};

export const TestJsonNameJSON = {
  /**
   * Serializes TestJsonName to JSON.
   */
  encode: function (msg: Partial<TestJsonName>): string {
    return JSON.stringify(TestJsonNameJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestJsonName from JSON.
   */
  decode: function (json: string): TestJsonName {
    return TestJsonNameJSON._readMessage(
      TestJsonNameJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestJsonName>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fieldName1) {
      json["fieldName1"] = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json["fieldName2"] = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json["FieldName3"] = msg.FieldName3;
    }
    if (msg.FieldName4) {
      json["FieldName4"] = msg.FieldName4;
    }
    if (msg.FIELDNAME5) {
      json["FIELDNAME5"] = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json["@type"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json["fieldname7"] = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestJsonName, json: any): TestJsonName {
    const _fieldName1_ = json["fieldName1"] ?? json["field_name1"];
    if (_fieldName1_) {
      msg.fieldName1 = _fieldName1_;
    }
    const _fieldName2_ = json["fieldName2"];
    if (_fieldName2_) {
      msg.fieldName2 = _fieldName2_;
    }
    const _FieldName3_ = json["FieldName3"];
    if (_FieldName3_) {
      msg.FieldName3 = _FieldName3_;
    }
    const _FieldName4_ = json["FieldName4"] ?? json["_field_name4"];
    if (_FieldName4_) {
      msg.FieldName4 = _FieldName4_;
    }
    const _FIELDNAME5_ = json["FIELDNAME5"] ?? json["FIELD_NAME5"];
    if (_FIELDNAME5_) {
      msg.FIELDNAME5 = _FIELDNAME5_;
    }
    const _fieldName6_ =
      json["@type"] ?? json["fieldName6"] ?? json["field_name6"];
    if (_fieldName6_) {
      msg.fieldName6 = _fieldName6_;
    }
    const _fieldname7_ = json["fieldname7"];
    if (_fieldname7_) {
      msg.fieldname7 = _fieldname7_;
    }
    return msg;
  },
};

export const TestHugeFieldNumbersJSON = {
  /**
   * Serializes TestHugeFieldNumbers to JSON.
   */
  encode: function (msg: Partial<TestHugeFieldNumbers>): string {
    return JSON.stringify(TestHugeFieldNumbersJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestHugeFieldNumbers from JSON.
   */
  decode: function (json: string): TestHugeFieldNumbers {
    return TestHugeFieldNumbersJSON._readMessage(
      TestHugeFieldNumbersJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnum._fromInt(0),
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessageJSON.initialize(),
      stringStringMap: {},
      oneofUint32: undefined,
      oneofTestAllTypes: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json["fixed32"] = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.optionalEnum && ForeignEnumJSON._toInt(msg.optionalEnum)) {
      json["optionalEnum"] = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      const _optionalMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalMessage
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.stringStringMap) {
      const _stringStringMap_ = Object.fromEntries(
        Object.entries(msg.stringStringMap)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestHugeFieldNumbersJSON.StringStringMap._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_stringStringMap_).length > 0) {
        json["stringStringMap"] = _stringStringMap_;
      }
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const _oneofTestAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.oneofTestAllTypes
      );
      json["oneofTestAllTypes"] = _oneofTestAllTypes_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    json: any
  ): TestHugeFieldNumbers {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _fixed32_ = json["fixed32"] ?? json["fixed_32"];
    if (_fixed32_) {
      msg.fixed32 = _fixed32_;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _optionalEnum_ = json["optionalEnum"] ?? json["optional_enum"];
    if (_optionalEnum_) {
      msg.optionalEnum = _optionalEnum_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _optionalMessage_);
      msg.optionalMessage = m;
    }
    const _stringStringMap_ =
      json["stringStringMap"] ?? json["string_string_map"];
    if (_stringStringMap_) {
      msg.stringStringMap = Object.fromEntries(
        Object.entries(_stringStringMap_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestHugeFieldNumbersJSON.StringStringMap._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofTestAllTypes_ =
      json["oneofTestAllTypes"] ?? json["oneof_test_all_types"];
    if (_oneofTestAllTypes_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _oneofTestAllTypes_);
      msg.oneofTestAllTypes = m;
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encode: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestHugeFieldNumbersJSON.OptionalGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decode: function (json: string): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbersJSON.OptionalGroup._readMessage(
        TestHugeFieldNumbersJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.groupA) {
        json["groupA"] = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      json: any
    ): TestHugeFieldNumbers.OptionalGroup {
      const _groupA_ = json["groupA"] ?? json["group_a"];
      if (_groupA_) {
        msg.groupA = _groupA_;
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.StringStringMap>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.StringStringMap,
      json: any
    ): TestHugeFieldNumbers.StringStringMap {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTableJSON = {
  /**
   * Serializes TestExtensionInsideTable to JSON.
   */
  encode: function (msg: Partial<TestExtensionInsideTable>): string {
    return JSON.stringify(TestExtensionInsideTableJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionInsideTable from JSON.
   */
  decode: function (json: string): TestExtensionInsideTable {
    return TestExtensionInsideTableJSON._readMessage(
      TestExtensionInsideTableJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionInsideTable>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.field1) {
      json["field1"] = msg.field1;
    }
    if (msg.field2) {
      json["field2"] = msg.field2;
    }
    if (msg.field3) {
      json["field3"] = msg.field3;
    }
    if (msg.field4) {
      json["field4"] = msg.field4;
    }
    if (msg.field6) {
      json["field6"] = msg.field6;
    }
    if (msg.field7) {
      json["field7"] = msg.field7;
    }
    if (msg.field8) {
      json["field8"] = msg.field8;
    }
    if (msg.field9) {
      json["field9"] = msg.field9;
    }
    if (msg.field10) {
      json["field10"] = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    json: any
  ): TestExtensionInsideTable {
    const _field1_ = json["field1"];
    if (_field1_) {
      msg.field1 = _field1_;
    }
    const _field2_ = json["field2"];
    if (_field2_) {
      msg.field2 = _field2_;
    }
    const _field3_ = json["field3"];
    if (_field3_) {
      msg.field3 = _field3_;
    }
    const _field4_ = json["field4"];
    if (_field4_) {
      msg.field4 = _field4_;
    }
    const _field6_ = json["field6"];
    if (_field6_) {
      msg.field6 = _field6_;
    }
    const _field7_ = json["field7"];
    if (_field7_) {
      msg.field7 = _field7_;
    }
    const _field8_ = json["field8"];
    if (_field8_) {
      msg.field8 = _field8_;
    }
    const _field9_ = json["field9"];
    if (_field9_) {
      msg.field9 = _field9_;
    }
    const _field10_ = json["field10"];
    if (_field10_) {
      msg.field10 = _field10_;
    }
    return msg;
  },
};

export const TestExtensionRangeSerializeJSON = {
  /**
   * Serializes TestExtensionRangeSerialize to JSON.
   */
  encode: function (msg: Partial<TestExtensionRangeSerialize>): string {
    return JSON.stringify(TestExtensionRangeSerializeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionRangeSerialize from JSON.
   */
  decode: function (json: string): TestExtensionRangeSerialize {
    return TestExtensionRangeSerializeJSON._readMessage(
      TestExtensionRangeSerializeJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooOne) {
      json["fooOne"] = msg.fooOne;
    }
    if (msg.fooTwo) {
      json["fooTwo"] = msg.fooTwo;
    }
    if (msg.fooThree) {
      json["fooThree"] = msg.fooThree;
    }
    if (msg.fooFour) {
      json["fooFour"] = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    json: any
  ): TestExtensionRangeSerialize {
    const _fooOne_ = json["fooOne"] ?? json["foo_one"];
    if (_fooOne_) {
      msg.fooOne = _fooOne_;
    }
    const _fooTwo_ = json["fooTwo"] ?? json["foo_two"];
    if (_fooTwo_) {
      msg.fooTwo = _fooTwo_;
    }
    const _fooThree_ = json["fooThree"] ?? json["foo_three"];
    if (_fooThree_) {
      msg.fooThree = _fooThree_;
    }
    const _fooFour_ = json["fooFour"] ?? json["foo_four"];
    if (_fooFour_) {
      msg.fooFour = _fooFour_;
    }
    return msg;
  },
};
",
      ],
      [
        "google/protobuf/map_unittest.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";

import * as googleProtobufUnittest from "./unittest.pb";

//========================================//
//                 Types                  //
//========================================//

export type MapEnum = "MAP_ENUM_FOO" | "MAP_ENUM_BAR" | "MAP_ENUM_BAZ";

/**
 * Tests maps.
 */
export interface TestMap {
  mapInt32Int32: Record<string, TestMap.MapInt32Int32["value"] | undefined>;
  mapInt64Int64: Record<string, TestMap.MapInt64Int64["value"] | undefined>;
  mapUint32Uint32: Record<string, TestMap.MapUint32Uint32["value"] | undefined>;
  mapUint64Uint64: Record<string, TestMap.MapUint64Uint64["value"] | undefined>;
  mapSint32Sint32: Record<string, TestMap.MapSint32Sint32["value"] | undefined>;
  mapSint64Sint64: Record<string, TestMap.MapSint64Sint64["value"] | undefined>;
  mapFixed32Fixed32: Record<
    string,
    TestMap.MapFixed32Fixed32["value"] | undefined
  >;
  mapFixed64Fixed64: Record<
    string,
    TestMap.MapFixed64Fixed64["value"] | undefined
  >;
  mapSfixed32Sfixed32: Record<
    string,
    TestMap.MapSfixed32Sfixed32["value"] | undefined
  >;
  mapSfixed64Sfixed64: Record<
    string,
    TestMap.MapSfixed64Sfixed64["value"] | undefined
  >;
  mapInt32Float: Record<string, TestMap.MapInt32Float["value"] | undefined>;
  mapInt32Double: Record<string, TestMap.MapInt32Double["value"] | undefined>;
  mapBoolBool: Record<string, TestMap.MapBoolBool["value"] | undefined>;
  mapStringString: Record<string, TestMap.MapStringString["value"] | undefined>;
  mapInt32Bytes: Record<string, TestMap.MapInt32Bytes["value"] | undefined>;
  mapInt32Enum: Record<string, TestMap.MapInt32Enum["value"] | undefined>;
  mapInt32ForeignMessage: Record<
    string,
    TestMap.MapInt32ForeignMessage["value"] | undefined
  >;
  mapStringForeignMessage: Record<
    string,
    TestMap.MapStringForeignMessage["value"] | undefined
  >;
  mapInt32AllTypes: Record<
    string,
    TestMap.MapInt32AllTypes["value"] | undefined
  >;
}

export declare namespace TestMap {
  interface MapInt32Int32 {
    key: number;
    value: number;
  }

  interface MapInt64Int64 {
    key: bigint;
    value: bigint;
  }

  interface MapUint32Uint32 {
    key: number;
    value: number;
  }

  interface MapUint64Uint64 {
    key: bigint;
    value: bigint;
  }

  interface MapSint32Sint32 {
    key: number;
    value: number;
  }

  interface MapSint64Sint64 {
    key: bigint;
    value: bigint;
  }

  interface MapFixed32Fixed32 {
    key: number;
    value: number;
  }

  interface MapFixed64Fixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapSfixed32Sfixed32 {
    key: number;
    value: number;
  }

  interface MapSfixed64Sfixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapInt32Float {
    key: number;
    value: number;
  }

  interface MapInt32Double {
    key: number;
    value: number;
  }

  interface MapBoolBool {
    key: boolean;
    value: boolean;
  }

  interface MapStringString {
    key: string;
    value: string;
  }

  interface MapInt32Bytes {
    key: number;
    value: Uint8Array;
  }

  interface MapInt32Enum {
    key: number;
    value: MapEnum;
  }

  interface MapInt32ForeignMessage {
    key: number;
    value: googleProtobufUnittest.ForeignMessage;
  }

  interface MapStringForeignMessage {
    key: string;
    value: googleProtobufUnittest.ForeignMessage;
  }

  interface MapInt32AllTypes {
    key: number;
    value: googleProtobufUnittest.TestAllTypes;
  }
}

export interface TestMapSubmessage {
  testMap: TestMap;
}

export interface TestMessageMap {
  mapInt32Message: Record<
    string,
    TestMessageMap.MapInt32Message["value"] | undefined
  >;
}

export declare namespace TestMessageMap {
  interface MapInt32Message {
    key: number;
    value: googleProtobufUnittest.TestAllTypes;
  }
}

/**
 * Two map fields share the same entry default instance.
 */
export interface TestSameTypeMap {
  map1: Record<string, TestSameTypeMap.Map1["value"] | undefined>;
  map2: Record<string, TestSameTypeMap.Map2["value"] | undefined>;
}

export declare namespace TestSameTypeMap {
  interface Map1 {
    key: number;
    value: number;
  }

  interface Map2 {
    key: number;
    value: number;
  }
}

/**
 * Test embedded message with required fields
 */
export interface TestRequiredMessageMap {
  mapField: Record<
    string,
    TestRequiredMessageMap.MapField["value"] | undefined
  >;
}

export declare namespace TestRequiredMessageMap {
  interface MapField {
    key: number;
    value: googleProtobufUnittest.TestRequired;
  }
}

export interface TestArenaMap {
  mapInt32Int32: Record<
    string,
    TestArenaMap.MapInt32Int32["value"] | undefined
  >;
  mapInt64Int64: Record<
    string,
    TestArenaMap.MapInt64Int64["value"] | undefined
  >;
  mapUint32Uint32: Record<
    string,
    TestArenaMap.MapUint32Uint32["value"] | undefined
  >;
  mapUint64Uint64: Record<
    string,
    TestArenaMap.MapUint64Uint64["value"] | undefined
  >;
  mapSint32Sint32: Record<
    string,
    TestArenaMap.MapSint32Sint32["value"] | undefined
  >;
  mapSint64Sint64: Record<
    string,
    TestArenaMap.MapSint64Sint64["value"] | undefined
  >;
  mapFixed32Fixed32: Record<
    string,
    TestArenaMap.MapFixed32Fixed32["value"] | undefined
  >;
  mapFixed64Fixed64: Record<
    string,
    TestArenaMap.MapFixed64Fixed64["value"] | undefined
  >;
  mapSfixed32Sfixed32: Record<
    string,
    TestArenaMap.MapSfixed32Sfixed32["value"] | undefined
  >;
  mapSfixed64Sfixed64: Record<
    string,
    TestArenaMap.MapSfixed64Sfixed64["value"] | undefined
  >;
  mapInt32Float: Record<
    string,
    TestArenaMap.MapInt32Float["value"] | undefined
  >;
  mapInt32Double: Record<
    string,
    TestArenaMap.MapInt32Double["value"] | undefined
  >;
  mapBoolBool: Record<string, TestArenaMap.MapBoolBool["value"] | undefined>;
  mapStringString: Record<
    string,
    TestArenaMap.MapStringString["value"] | undefined
  >;
  mapInt32Bytes: Record<
    string,
    TestArenaMap.MapInt32Bytes["value"] | undefined
  >;
  mapInt32Enum: Record<string, TestArenaMap.MapInt32Enum["value"] | undefined>;
  mapInt32ForeignMessage: Record<
    string,
    TestArenaMap.MapInt32ForeignMessage["value"] | undefined
  >;
}

export declare namespace TestArenaMap {
  interface MapInt32Int32 {
    key: number;
    value: number;
  }

  interface MapInt64Int64 {
    key: bigint;
    value: bigint;
  }

  interface MapUint32Uint32 {
    key: number;
    value: number;
  }

  interface MapUint64Uint64 {
    key: bigint;
    value: bigint;
  }

  interface MapSint32Sint32 {
    key: number;
    value: number;
  }

  interface MapSint64Sint64 {
    key: bigint;
    value: bigint;
  }

  interface MapFixed32Fixed32 {
    key: number;
    value: number;
  }

  interface MapFixed64Fixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapSfixed32Sfixed32 {
    key: number;
    value: number;
  }

  interface MapSfixed64Sfixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapInt32Float {
    key: number;
    value: number;
  }

  interface MapInt32Double {
    key: number;
    value: number;
  }

  interface MapBoolBool {
    key: boolean;
    value: boolean;
  }

  interface MapStringString {
    key: string;
    value: string;
  }

  interface MapInt32Bytes {
    key: number;
    value: Uint8Array;
  }

  interface MapInt32Enum {
    key: number;
    value: MapEnum;
  }

  interface MapInt32ForeignMessage {
    key: number;
    value: googleProtobufUnittest.ForeignMessage;
  }
}

/**
 * Previously, message cannot contain map field called "entry".
 */
export interface MessageContainingMapCalledEntry {
  entry: Record<
    string,
    MessageContainingMapCalledEntry.Entry["value"] | undefined
  >;
}

export declare namespace MessageContainingMapCalledEntry {
  interface Entry {
    key: number;
    value: number;
  }
}

export interface TestRecursiveMapMessage {
  a: Record<string, TestRecursiveMapMessage.A["value"] | undefined>;
}

export declare namespace TestRecursiveMapMessage {
  interface A {
    key: string;
    value: TestRecursiveMapMessage;
  }
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: "MAP_ENUM_FOO",
  MAP_ENUM_BAR: "MAP_ENUM_BAR",
  MAP_ENUM_BAZ: "MAP_ENUM_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): MapEnum {
    switch (i) {
      case 0: {
        return "MAP_ENUM_FOO";
      }
      case 1: {
        return "MAP_ENUM_BAR";
      }
      case 2: {
        return "MAP_ENUM_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as MapEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: MapEnum): number {
    switch (i) {
      case "MAP_ENUM_FOO": {
        return 0;
      }
      case "MAP_ENUM_BAR": {
        return 1;
      }
      case "MAP_ENUM_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestMap = {
  /**
   * Serializes TestMap to protobuf.
   */
  encode: function (msg: Partial<TestMap>): Uint8Array {
    return TestMap._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMap {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32ForeignMessage._writeMessage
      );
    }
    if (msg.mapStringForeignMessage) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.mapStringForeignMessage).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapStringForeignMessage._writeMessage
      );
    }
    if (msg.mapInt32AllTypes) {
      writer.writeRepeatedMessage(
        19,
        Object.entries(msg.mapInt32AllTypes).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32AllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, reader: BinaryReader): TestMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestMap.MapInt32Int32;
          reader.readMessage(map, TestMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {} as TestMap.MapInt64Int64;
          reader.readMessage(map, TestMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {} as TestMap.MapUint32Uint32;
          reader.readMessage(map, TestMap.MapUint32Uint32._readMessage);
          msg.mapUint32Uint32[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {} as TestMap.MapUint64Uint64;
          reader.readMessage(map, TestMap.MapUint64Uint64._readMessage);
          msg.mapUint64Uint64[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {} as TestMap.MapSint32Sint32;
          reader.readMessage(map, TestMap.MapSint32Sint32._readMessage);
          msg.mapSint32Sint32[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {} as TestMap.MapSint64Sint64;
          reader.readMessage(map, TestMap.MapSint64Sint64._readMessage);
          msg.mapSint64Sint64[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {} as TestMap.MapFixed32Fixed32;
          reader.readMessage(map, TestMap.MapFixed32Fixed32._readMessage);
          msg.mapFixed32Fixed32[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {} as TestMap.MapFixed64Fixed64;
          reader.readMessage(map, TestMap.MapFixed64Fixed64._readMessage);
          msg.mapFixed64Fixed64[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {} as TestMap.MapSfixed32Sfixed32;
          reader.readMessage(map, TestMap.MapSfixed32Sfixed32._readMessage);
          msg.mapSfixed32Sfixed32[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {} as TestMap.MapSfixed64Sfixed64;
          reader.readMessage(map, TestMap.MapSfixed64Sfixed64._readMessage);
          msg.mapSfixed64Sfixed64[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {} as TestMap.MapInt32Float;
          reader.readMessage(map, TestMap.MapInt32Float._readMessage);
          msg.mapInt32Float[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {} as TestMap.MapInt32Double;
          reader.readMessage(map, TestMap.MapInt32Double._readMessage);
          msg.mapInt32Double[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {} as TestMap.MapBoolBool;
          reader.readMessage(map, TestMap.MapBoolBool._readMessage);
          msg.mapBoolBool[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {} as TestMap.MapStringString;
          reader.readMessage(map, TestMap.MapStringString._readMessage);
          msg.mapStringString[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {} as TestMap.MapInt32Bytes;
          reader.readMessage(map, TestMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {} as TestMap.MapInt32Enum;
          reader.readMessage(map, TestMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {} as TestMap.MapInt32ForeignMessage;
          reader.readMessage(map, TestMap.MapInt32ForeignMessage._readMessage);
          msg.mapInt32ForeignMessage[map.key.toString()] = map.value;
          break;
        }
        case 18: {
          const map = {} as TestMap.MapStringForeignMessage;
          reader.readMessage(map, TestMap.MapStringForeignMessage._readMessage);
          msg.mapStringForeignMessage[map.key.toString()] = map.value;
          break;
        }
        case 19: {
          const map = {} as TestMap.MapInt32AllTypes;
          reader.readMessage(map, TestMap.MapInt32AllTypes._readMessage);
          msg.mapInt32AllTypes[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Int32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Int32,
      reader: BinaryReader
    ): TestMap.MapInt32Int32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt64Int64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt64Int64,
      reader: BinaryReader
    ): TestMap.MapInt64Int64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapUint32Uint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapUint32Uint32,
      reader: BinaryReader
    ): TestMap.MapUint32Uint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapUint64Uint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapUint64Uint64,
      reader: BinaryReader
    ): TestMap.MapUint64Uint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSint32Sint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSint32Sint32,
      reader: BinaryReader
    ): TestMap.MapSint32Sint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSint64Sint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSint64Sint64,
      reader: BinaryReader
    ): TestMap.MapSint64Sint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapFixed32Fixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapFixed32Fixed32,
      reader: BinaryReader
    ): TestMap.MapFixed32Fixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapFixed64Fixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapFixed64Fixed64,
      reader: BinaryReader
    ): TestMap.MapFixed64Fixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSfixed32Sfixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSfixed32Sfixed32,
      reader: BinaryReader
    ): TestMap.MapSfixed32Sfixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSfixed64Sfixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSfixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSfixed64Sfixed64,
      reader: BinaryReader
    ): TestMap.MapSfixed64Sfixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Float>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Float,
      reader: BinaryReader
    ): TestMap.MapInt32Float {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Double>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Double,
      reader: BinaryReader
    ): TestMap.MapInt32Double {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapBoolBool>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapBoolBool,
      reader: BinaryReader
    ): TestMap.MapBoolBool {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapStringString>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapStringString,
      reader: BinaryReader
    ): TestMap.MapStringString {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Bytes>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Bytes,
      reader: BinaryReader
    ): TestMap.MapInt32Bytes {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Enum>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnum._toInt(msg.value)) {
        writer.writeEnum(2, MapEnum._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Enum,
      reader: BinaryReader
    ): TestMap.MapInt32Enum {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnum._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32ForeignMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32ForeignMessage,
      reader: BinaryReader
    ): TestMap.MapInt32ForeignMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapStringForeignMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapStringForeignMessage,
      reader: BinaryReader
    ): TestMap.MapStringForeignMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32AllTypes>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32AllTypes,
      reader: BinaryReader
    ): TestMap.MapInt32AllTypes {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestAllTypes.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes TestMapSubmessage to protobuf.
   */
  encode: function (msg: Partial<TestMapSubmessage>): Uint8Array {
    return TestMapSubmessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMapSubmessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestMapSubmessage {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMapSubmessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    reader: BinaryReader
  ): TestMapSubmessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes TestMessageMap to protobuf.
   */
  encode: function (msg: Partial<TestMessageMap>): Uint8Array {
    return TestMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageMap {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Message) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Message).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMessageMap.MapInt32Message._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageMap,
    reader: BinaryReader
  ): TestMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestMessageMap.MapInt32Message;
          reader.readMessage(map, TestMessageMap.MapInt32Message._readMessage);
          msg.mapInt32Message[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMessageMap.MapInt32Message>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMessageMap.MapInt32Message,
      reader: BinaryReader
    ): TestMessageMap.MapInt32Message {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestAllTypes.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes TestSameTypeMap to protobuf.
   */
  encode: function (msg: Partial<TestSameTypeMap>): Uint8Array {
    return TestSameTypeMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestSameTypeMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestSameTypeMap {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestSameTypeMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map1) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.map1).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestSameTypeMap.Map1._writeMessage
      );
    }
    if (msg.map2) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.map2).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestSameTypeMap.Map2._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestSameTypeMap,
    reader: BinaryReader
  ): TestSameTypeMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestSameTypeMap.Map1;
          reader.readMessage(map, TestSameTypeMap.Map1._readMessage);
          msg.map1[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {} as TestSameTypeMap.Map2;
          reader.readMessage(map, TestSameTypeMap.Map2._readMessage);
          msg.map2[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestSameTypeMap.Map1>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestSameTypeMap.Map1,
      reader: BinaryReader
    ): TestSameTypeMap.Map1 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestSameTypeMap.Map2>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestSameTypeMap.Map2,
      reader: BinaryReader
    ): TestSameTypeMap.Map2 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes TestRequiredMessageMap to protobuf.
   */
  encode: function (msg: Partial<TestRequiredMessageMap>): Uint8Array {
    return TestRequiredMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestRequiredMessageMap.MapField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    reader: BinaryReader
  ): TestRequiredMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestRequiredMessageMap.MapField;
          reader.readMessage(map, TestRequiredMessageMap.MapField._readMessage);
          msg.mapField[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredMessageMap.MapField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestRequired._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredMessageMap.MapField,
      reader: BinaryReader
    ): TestRequiredMessageMap.MapField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestRequired.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestRequired._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestArenaMap = {
  /**
   * Serializes TestArenaMap to protobuf.
   */
  encode: function (msg: Partial<TestArenaMap>): Uint8Array {
    return TestArenaMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestArenaMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestArenaMap {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestArenaMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32ForeignMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestArenaMap,
    reader: BinaryReader
  ): TestArenaMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestArenaMap.MapInt32Int32;
          reader.readMessage(map, TestArenaMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {} as TestArenaMap.MapInt64Int64;
          reader.readMessage(map, TestArenaMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {} as TestArenaMap.MapUint32Uint32;
          reader.readMessage(map, TestArenaMap.MapUint32Uint32._readMessage);
          msg.mapUint32Uint32[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {} as TestArenaMap.MapUint64Uint64;
          reader.readMessage(map, TestArenaMap.MapUint64Uint64._readMessage);
          msg.mapUint64Uint64[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {} as TestArenaMap.MapSint32Sint32;
          reader.readMessage(map, TestArenaMap.MapSint32Sint32._readMessage);
          msg.mapSint32Sint32[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {} as TestArenaMap.MapSint64Sint64;
          reader.readMessage(map, TestArenaMap.MapSint64Sint64._readMessage);
          msg.mapSint64Sint64[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {} as TestArenaMap.MapFixed32Fixed32;
          reader.readMessage(map, TestArenaMap.MapFixed32Fixed32._readMessage);
          msg.mapFixed32Fixed32[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {} as TestArenaMap.MapFixed64Fixed64;
          reader.readMessage(map, TestArenaMap.MapFixed64Fixed64._readMessage);
          msg.mapFixed64Fixed64[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {} as TestArenaMap.MapSfixed32Sfixed32;
          reader.readMessage(
            map,
            TestArenaMap.MapSfixed32Sfixed32._readMessage
          );
          msg.mapSfixed32Sfixed32[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {} as TestArenaMap.MapSfixed64Sfixed64;
          reader.readMessage(
            map,
            TestArenaMap.MapSfixed64Sfixed64._readMessage
          );
          msg.mapSfixed64Sfixed64[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {} as TestArenaMap.MapInt32Float;
          reader.readMessage(map, TestArenaMap.MapInt32Float._readMessage);
          msg.mapInt32Float[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {} as TestArenaMap.MapInt32Double;
          reader.readMessage(map, TestArenaMap.MapInt32Double._readMessage);
          msg.mapInt32Double[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {} as TestArenaMap.MapBoolBool;
          reader.readMessage(map, TestArenaMap.MapBoolBool._readMessage);
          msg.mapBoolBool[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {} as TestArenaMap.MapStringString;
          reader.readMessage(map, TestArenaMap.MapStringString._readMessage);
          msg.mapStringString[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {} as TestArenaMap.MapInt32Bytes;
          reader.readMessage(map, TestArenaMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {} as TestArenaMap.MapInt32Enum;
          reader.readMessage(map, TestArenaMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {} as TestArenaMap.MapInt32ForeignMessage;
          reader.readMessage(
            map,
            TestArenaMap.MapInt32ForeignMessage._readMessage
          );
          msg.mapInt32ForeignMessage[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Int32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Int32,
      reader: BinaryReader
    ): TestArenaMap.MapInt32Int32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt64Int64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt64Int64,
      reader: BinaryReader
    ): TestArenaMap.MapInt64Int64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapUint32Uint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapUint32Uint32,
      reader: BinaryReader
    ): TestArenaMap.MapUint32Uint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapUint64Uint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapUint64Uint64,
      reader: BinaryReader
    ): TestArenaMap.MapUint64Uint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSint32Sint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSint32Sint32,
      reader: BinaryReader
    ): TestArenaMap.MapSint32Sint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSint64Sint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSint64Sint64,
      reader: BinaryReader
    ): TestArenaMap.MapSint64Sint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapFixed32Fixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapFixed32Fixed32,
      reader: BinaryReader
    ): TestArenaMap.MapFixed32Fixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapFixed64Fixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapFixed64Fixed64,
      reader: BinaryReader
    ): TestArenaMap.MapFixed64Fixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSfixed32Sfixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSfixed32Sfixed32,
      reader: BinaryReader
    ): TestArenaMap.MapSfixed32Sfixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSfixed64Sfixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSfixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSfixed64Sfixed64,
      reader: BinaryReader
    ): TestArenaMap.MapSfixed64Sfixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Float>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Float,
      reader: BinaryReader
    ): TestArenaMap.MapInt32Float {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Double>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Double,
      reader: BinaryReader
    ): TestArenaMap.MapInt32Double {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapBoolBool>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapBoolBool,
      reader: BinaryReader
    ): TestArenaMap.MapBoolBool {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapStringString>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapStringString,
      reader: BinaryReader
    ): TestArenaMap.MapStringString {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Bytes>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Bytes,
      reader: BinaryReader
    ): TestArenaMap.MapInt32Bytes {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Enum>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnum._toInt(msg.value)) {
        writer.writeEnum(2, MapEnum._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Enum,
      reader: BinaryReader
    ): TestArenaMap.MapInt32Enum {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnum._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32ForeignMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32ForeignMessage,
      reader: BinaryReader
    ): TestArenaMap.MapInt32ForeignMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (msg: Partial<MessageContainingMapCalledEntry>): Uint8Array {
    return MessageContainingMapCalledEntry._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes: ByteSource): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.entry) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.entry).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MessageContainingMapCalledEntry.Entry._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    reader: BinaryReader
  ): MessageContainingMapCalledEntry {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as MessageContainingMapCalledEntry.Entry;
          reader.readMessage(
            map,
            MessageContainingMapCalledEntry.Entry._readMessage
          );
          msg.entry[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MessageContainingMapCalledEntry.Entry>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MessageContainingMapCalledEntry.Entry,
      reader: BinaryReader
    ): MessageContainingMapCalledEntry.Entry {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes TestRecursiveMapMessage to protobuf.
   */
  encode: function (msg: Partial<TestRecursiveMapMessage>): Uint8Array {
    return TestRecursiveMapMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.a).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestRecursiveMapMessage.A._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    reader: BinaryReader
  ): TestRecursiveMapMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestRecursiveMapMessage.A;
          reader.readMessage(map, TestRecursiveMapMessage.A._readMessage);
          msg.a[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRecursiveMapMessage.A>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          TestRecursiveMapMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRecursiveMapMessage.A,
      reader: BinaryReader
    ): TestRecursiveMapMessage.A {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = TestRecursiveMapMessage.initialize();
            reader.readMessage(msg.value, TestRecursiveMapMessage._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const MapEnumJSON = {
  MAP_ENUM_FOO: "MAP_ENUM_FOO",
  MAP_ENUM_BAR: "MAP_ENUM_BAR",
  MAP_ENUM_BAZ: "MAP_ENUM_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): MapEnum {
    switch (i) {
      case 0: {
        return "MAP_ENUM_FOO";
      }
      case 1: {
        return "MAP_ENUM_BAR";
      }
      case 2: {
        return "MAP_ENUM_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as MapEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: MapEnum): number {
    switch (i) {
      case "MAP_ENUM_FOO": {
        return 0;
      }
      case "MAP_ENUM_BAR": {
        return 1;
      }
      case "MAP_ENUM_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestMapJSON = {
  /**
   * Serializes TestMap to JSON.
   */
  encode: function (msg: Partial<TestMap>): string {
    return JSON.stringify(TestMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMap from JSON.
   */
  decode: function (json: string): TestMap {
    return TestMapJSON._readMessage(TestMapJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<TestMap>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      const _mapInt32Int32_ = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Int32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Int32_).length > 0) {
        json["mapInt32Int32"] = _mapInt32Int32_;
      }
    }
    if (msg.mapInt64Int64) {
      const _mapInt64Int64_ = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt64Int64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt64Int64_).length > 0) {
        json["mapInt64Int64"] = _mapInt64Int64_;
      }
    }
    if (msg.mapUint32Uint32) {
      const _mapUint32Uint32_ = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapUint32Uint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint32Uint32_).length > 0) {
        json["mapUint32Uint32"] = _mapUint32Uint32_;
      }
    }
    if (msg.mapUint64Uint64) {
      const _mapUint64Uint64_ = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapUint64Uint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint64Uint64_).length > 0) {
        json["mapUint64Uint64"] = _mapUint64Uint64_;
      }
    }
    if (msg.mapSint32Sint32) {
      const _mapSint32Sint32_ = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSint32Sint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint32Sint32_).length > 0) {
        json["mapSint32Sint32"] = _mapSint32Sint32_;
      }
    }
    if (msg.mapSint64Sint64) {
      const _mapSint64Sint64_ = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSint64Sint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint64Sint64_).length > 0) {
        json["mapSint64Sint64"] = _mapSint64Sint64_;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const _mapFixed32Fixed32_ = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapFixed32Fixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed32Fixed32_).length > 0) {
        json["mapFixed32Fixed32"] = _mapFixed32Fixed32_;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const _mapFixed64Fixed64_ = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapFixed64Fixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed64Fixed64_).length > 0) {
        json["mapFixed64Fixed64"] = _mapFixed64Fixed64_;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const _mapSfixed32Sfixed32_ = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSfixed32Sfixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed32Sfixed32_).length > 0) {
        json["mapSfixed32Sfixed32"] = _mapSfixed32Sfixed32_;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const _mapSfixed64Sfixed64_ = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSfixed64Sfixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed64Sfixed64_).length > 0) {
        json["mapSfixed64Sfixed64"] = _mapSfixed64Sfixed64_;
      }
    }
    if (msg.mapInt32Float) {
      const _mapInt32Float_ = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Float._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Float_).length > 0) {
        json["mapInt32Float"] = _mapInt32Float_;
      }
    }
    if (msg.mapInt32Double) {
      const _mapInt32Double_ = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Double._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Double_).length > 0) {
        json["mapInt32Double"] = _mapInt32Double_;
      }
    }
    if (msg.mapBoolBool) {
      const _mapBoolBool_ = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapBoolBool._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapBoolBool_).length > 0) {
        json["mapBoolBool"] = _mapBoolBool_;
      }
    }
    if (msg.mapStringString) {
      const _mapStringString_ = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapStringString._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapStringString_).length > 0) {
        json["mapStringString"] = _mapStringString_;
      }
    }
    if (msg.mapInt32Bytes) {
      const _mapInt32Bytes_ = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Bytes._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Bytes_).length > 0) {
        json["mapInt32Bytes"] = _mapInt32Bytes_;
      }
    }
    if (msg.mapInt32Enum) {
      const _mapInt32Enum_ = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Enum._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Enum_).length > 0) {
        json["mapInt32Enum"] = _mapInt32Enum_;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const _mapInt32ForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32ForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32ForeignMessage_).length > 0) {
        json["mapInt32ForeignMessage"] = _mapInt32ForeignMessage_;
      }
    }
    if (msg.mapStringForeignMessage) {
      const _mapStringForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapStringForeignMessage)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapStringForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapStringForeignMessage_).length > 0) {
        json["mapStringForeignMessage"] = _mapStringForeignMessage_;
      }
    }
    if (msg.mapInt32AllTypes) {
      const _mapInt32AllTypes_ = Object.fromEntries(
        Object.entries(msg.mapInt32AllTypes)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32AllTypes._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32AllTypes_).length > 0) {
        json["mapInt32AllTypes"] = _mapInt32AllTypes_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, json: any): TestMap {
    const _mapInt32Int32_ = json["mapInt32Int32"] ?? json["map_int32_int32"];
    if (_mapInt32Int32_) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Int32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64_ = json["mapInt64Int64"] ?? json["map_int64_int64"];
    if (_mapInt64Int64_) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt64Int64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32_ =
      json["mapUint32Uint32"] ?? json["map_uint32_uint32"];
    if (_mapUint32Uint32_) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapUint32Uint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64_ =
      json["mapUint64Uint64"] ?? json["map_uint64_uint64"];
    if (_mapUint64Uint64_) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapUint64Uint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32_ =
      json["mapSint32Sint32"] ?? json["map_sint32_sint32"];
    if (_mapSint32Sint32_) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSint32Sint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64_ =
      json["mapSint64Sint64"] ?? json["map_sint64_sint64"];
    if (_mapSint64Sint64_) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSint64Sint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32_ =
      json["mapFixed32Fixed32"] ?? json["map_fixed32_fixed32"];
    if (_mapFixed32Fixed32_) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapFixed32Fixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64_ =
      json["mapFixed64Fixed64"] ?? json["map_fixed64_fixed64"];
    if (_mapFixed64Fixed64_) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapFixed64Fixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32_ =
      json["mapSfixed32Sfixed32"] ?? json["map_sfixed32_sfixed32"];
    if (_mapSfixed32Sfixed32_) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSfixed32Sfixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64_ =
      json["mapSfixed64Sfixed64"] ?? json["map_sfixed64_sfixed64"];
    if (_mapSfixed64Sfixed64_) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSfixed64Sfixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float_ = json["mapInt32Float"] ?? json["map_int32_float"];
    if (_mapInt32Float_) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Float._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double_ = json["mapInt32Double"] ?? json["map_int32_double"];
    if (_mapInt32Double_) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Double._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool_ = json["mapBoolBool"] ?? json["map_bool_bool"];
    if (_mapBoolBool_) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapBoolBool._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString_ =
      json["mapStringString"] ?? json["map_string_string"];
    if (_mapStringString_) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapStringString._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes_ = json["mapInt32Bytes"] ?? json["map_int32_bytes"];
    if (_mapInt32Bytes_) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Bytes._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum_ = json["mapInt32Enum"] ?? json["map_int32_enum"];
    if (_mapInt32Enum_) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Enum._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage_ =
      json["mapInt32ForeignMessage"] ?? json["map_int32_foreign_message"];
    if (_mapInt32ForeignMessage_) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32ForeignMessage._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringForeignMessage_ =
      json["mapStringForeignMessage"] ?? json["map_string_foreign_message"];
    if (_mapStringForeignMessage_) {
      msg.mapStringForeignMessage = Object.fromEntries(
        Object.entries(_mapStringForeignMessage_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapStringForeignMessage._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32AllTypes_ =
      json["mapInt32AllTypes"] ?? json["map_int32_all_types"];
    if (_mapInt32AllTypes_) {
      msg.mapInt32AllTypes = Object.fromEntries(
        Object.entries(_mapInt32AllTypes_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32AllTypes._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Int32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Int32,
      json: any
    ): TestMap.MapInt32Int32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt64Int64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt64Int64,
      json: any
    ): TestMap.MapInt64Int64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapUint32Uint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapUint32Uint32,
      json: any
    ): TestMap.MapUint32Uint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapUint64Uint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapUint64Uint64,
      json: any
    ): TestMap.MapUint64Uint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSint32Sint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSint32Sint32,
      json: any
    ): TestMap.MapSint32Sint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSint64Sint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSint64Sint64,
      json: any
    ): TestMap.MapSint64Sint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapFixed32Fixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapFixed32Fixed32,
      json: any
    ): TestMap.MapFixed32Fixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapFixed64Fixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapFixed64Fixed64,
      json: any
    ): TestMap.MapFixed64Fixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSfixed32Sfixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSfixed32Sfixed32,
      json: any
    ): TestMap.MapSfixed32Sfixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSfixed64Sfixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSfixed64Sfixed64,
      json: any
    ): TestMap.MapSfixed64Sfixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Float>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Float,
      json: any
    ): TestMap.MapInt32Float {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Double>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Double,
      json: any
    ): TestMap.MapInt32Double {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapBoolBool>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapBoolBool,
      json: any
    ): TestMap.MapBoolBool {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapStringString>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapStringString,
      json: any
    ): TestMap.MapStringString {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Bytes>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value?.length) {
        json["value"] = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Bytes,
      json: any
    ): TestMap.MapInt32Bytes {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = decodeBase64Bytes(_value_);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Enum>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && MapEnumJSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Enum,
      json: any
    ): TestMap.MapInt32Enum {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32ForeignMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32ForeignMessage,
      json: any
    ): TestMap.MapInt32ForeignMessage {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.ForeignMessage.initialize();
        googleProtobufUnittest.ForeignMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapStringForeignMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapStringForeignMessage,
      json: any
    ): TestMap.MapStringForeignMessage {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.ForeignMessage.initialize();
        googleProtobufUnittest.ForeignMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32AllTypes>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestAllTypesJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32AllTypes,
      json: any
    ): TestMap.MapInt32AllTypes {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.TestAllTypes.initialize();
        googleProtobufUnittest.TestAllTypesJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestMapSubmessageJSON = {
  /**
   * Serializes TestMapSubmessage to JSON.
   */
  encode: function (msg: Partial<TestMapSubmessage>): string {
    return JSON.stringify(TestMapSubmessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMapSubmessage from JSON.
   */
  decode: function (json: string): TestMapSubmessage {
    return TestMapSubmessageJSON._readMessage(
      TestMapSubmessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      testMap: TestMapJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMapSubmessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.testMap) {
      const _testMap_ = TestMapJSON._writeMessage(msg.testMap);
      if (Object.keys(_testMap_).length > 0) {
        json["testMap"] = _testMap_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    json: any
  ): TestMapSubmessage {
    const _testMap_ = json["testMap"] ?? json["test_map"];
    if (_testMap_) {
      const m = TestMap.initialize();
      TestMapJSON._readMessage(m, _testMap_);
      msg.testMap = m;
    }
    return msg;
  },
};

export const TestMessageMapJSON = {
  /**
   * Serializes TestMessageMap to JSON.
   */
  encode: function (msg: Partial<TestMessageMap>): string {
    return JSON.stringify(TestMessageMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMessageMap from JSON.
   */
  decode: function (json: string): TestMessageMap {
    return TestMessageMapJSON._readMessage(
      TestMessageMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Message) {
      const _mapInt32Message_ = Object.fromEntries(
        Object.entries(msg.mapInt32Message)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMessageMapJSON.MapInt32Message._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Message_).length > 0) {
        json["mapInt32Message"] = _mapInt32Message_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMessageMap, json: any): TestMessageMap {
    const _mapInt32Message_ =
      json["mapInt32Message"] ?? json["map_int32_message"];
    if (_mapInt32Message_) {
      msg.mapInt32Message = Object.fromEntries(
        Object.entries(_mapInt32Message_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMessageMapJSON.MapInt32Message._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMessageMap.MapInt32Message>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestAllTypesJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMessageMap.MapInt32Message,
      json: any
    ): TestMessageMap.MapInt32Message {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.TestAllTypes.initialize();
        googleProtobufUnittest.TestAllTypesJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestSameTypeMapJSON = {
  /**
   * Serializes TestSameTypeMap to JSON.
   */
  encode: function (msg: Partial<TestSameTypeMap>): string {
    return JSON.stringify(TestSameTypeMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestSameTypeMap from JSON.
   */
  decode: function (json: string): TestSameTypeMap {
    return TestSameTypeMapJSON._readMessage(
      TestSameTypeMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestSameTypeMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.map1) {
      const _map1_ = Object.fromEntries(
        Object.entries(msg.map1)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestSameTypeMapJSON.Map1._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_map1_).length > 0) {
        json["map1"] = _map1_;
      }
    }
    if (msg.map2) {
      const _map2_ = Object.fromEntries(
        Object.entries(msg.map2)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestSameTypeMapJSON.Map2._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_map2_).length > 0) {
        json["map2"] = _map2_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestSameTypeMap, json: any): TestSameTypeMap {
    const _map1_ = json["map1"];
    if (_map1_) {
      msg.map1 = Object.fromEntries(
        Object.entries(_map1_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestSameTypeMapJSON.Map1._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _map2_ = json["map2"];
    if (_map2_) {
      msg.map2 = Object.fromEntries(
        Object.entries(_map2_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestSameTypeMapJSON.Map2._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestSameTypeMap.Map1>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestSameTypeMap.Map1,
      json: any
    ): TestSameTypeMap.Map1 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestSameTypeMap.Map2>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestSameTypeMap.Map2,
      json: any
    ): TestSameTypeMap.Map2 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMapJSON = {
  /**
   * Serializes TestRequiredMessageMap to JSON.
   */
  encode: function (msg: Partial<TestRequiredMessageMap>): string {
    return JSON.stringify(TestRequiredMessageMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredMessageMap from JSON.
   */
  decode: function (json: string): TestRequiredMessageMap {
    return TestRequiredMessageMapJSON._readMessage(
      TestRequiredMessageMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessageMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapField) {
      const _mapField_ = Object.fromEntries(
        Object.entries(msg.mapField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestRequiredMessageMapJSON.MapField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapField_).length > 0) {
        json["mapField"] = _mapField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    json: any
  ): TestRequiredMessageMap {
    const _mapField_ = json["mapField"] ?? json["map_field"];
    if (_mapField_) {
      msg.mapField = Object.fromEntries(
        Object.entries(_mapField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestRequiredMessageMapJSON.MapField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredMessageMap.MapField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestRequiredJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredMessageMap.MapField,
      json: any
    ): TestRequiredMessageMap.MapField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.TestRequired.initialize();
        googleProtobufUnittest.TestRequiredJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestArenaMapJSON = {
  /**
   * Serializes TestArenaMap to JSON.
   */
  encode: function (msg: Partial<TestArenaMap>): string {
    return JSON.stringify(TestArenaMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestArenaMap from JSON.
   */
  decode: function (json: string): TestArenaMap {
    return TestArenaMapJSON._readMessage(
      TestArenaMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestArenaMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      const _mapInt32Int32_ = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Int32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Int32_).length > 0) {
        json["mapInt32Int32"] = _mapInt32Int32_;
      }
    }
    if (msg.mapInt64Int64) {
      const _mapInt64Int64_ = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt64Int64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt64Int64_).length > 0) {
        json["mapInt64Int64"] = _mapInt64Int64_;
      }
    }
    if (msg.mapUint32Uint32) {
      const _mapUint32Uint32_ = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapUint32Uint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint32Uint32_).length > 0) {
        json["mapUint32Uint32"] = _mapUint32Uint32_;
      }
    }
    if (msg.mapUint64Uint64) {
      const _mapUint64Uint64_ = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapUint64Uint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint64Uint64_).length > 0) {
        json["mapUint64Uint64"] = _mapUint64Uint64_;
      }
    }
    if (msg.mapSint32Sint32) {
      const _mapSint32Sint32_ = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSint32Sint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint32Sint32_).length > 0) {
        json["mapSint32Sint32"] = _mapSint32Sint32_;
      }
    }
    if (msg.mapSint64Sint64) {
      const _mapSint64Sint64_ = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSint64Sint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint64Sint64_).length > 0) {
        json["mapSint64Sint64"] = _mapSint64Sint64_;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const _mapFixed32Fixed32_ = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapFixed32Fixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed32Fixed32_).length > 0) {
        json["mapFixed32Fixed32"] = _mapFixed32Fixed32_;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const _mapFixed64Fixed64_ = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapFixed64Fixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed64Fixed64_).length > 0) {
        json["mapFixed64Fixed64"] = _mapFixed64Fixed64_;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const _mapSfixed32Sfixed32_ = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSfixed32Sfixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed32Sfixed32_).length > 0) {
        json["mapSfixed32Sfixed32"] = _mapSfixed32Sfixed32_;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const _mapSfixed64Sfixed64_ = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSfixed64Sfixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed64Sfixed64_).length > 0) {
        json["mapSfixed64Sfixed64"] = _mapSfixed64Sfixed64_;
      }
    }
    if (msg.mapInt32Float) {
      const _mapInt32Float_ = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Float._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Float_).length > 0) {
        json["mapInt32Float"] = _mapInt32Float_;
      }
    }
    if (msg.mapInt32Double) {
      const _mapInt32Double_ = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Double._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Double_).length > 0) {
        json["mapInt32Double"] = _mapInt32Double_;
      }
    }
    if (msg.mapBoolBool) {
      const _mapBoolBool_ = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapBoolBool._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapBoolBool_).length > 0) {
        json["mapBoolBool"] = _mapBoolBool_;
      }
    }
    if (msg.mapStringString) {
      const _mapStringString_ = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapStringString._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapStringString_).length > 0) {
        json["mapStringString"] = _mapStringString_;
      }
    }
    if (msg.mapInt32Bytes) {
      const _mapInt32Bytes_ = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Bytes._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Bytes_).length > 0) {
        json["mapInt32Bytes"] = _mapInt32Bytes_;
      }
    }
    if (msg.mapInt32Enum) {
      const _mapInt32Enum_ = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Enum._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Enum_).length > 0) {
        json["mapInt32Enum"] = _mapInt32Enum_;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const _mapInt32ForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32ForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32ForeignMessage_).length > 0) {
        json["mapInt32ForeignMessage"] = _mapInt32ForeignMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestArenaMap, json: any): TestArenaMap {
    const _mapInt32Int32_ = json["mapInt32Int32"] ?? json["map_int32_int32"];
    if (_mapInt32Int32_) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Int32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64_ = json["mapInt64Int64"] ?? json["map_int64_int64"];
    if (_mapInt64Int64_) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt64Int64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32_ =
      json["mapUint32Uint32"] ?? json["map_uint32_uint32"];
    if (_mapUint32Uint32_) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapUint32Uint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64_ =
      json["mapUint64Uint64"] ?? json["map_uint64_uint64"];
    if (_mapUint64Uint64_) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapUint64Uint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32_ =
      json["mapSint32Sint32"] ?? json["map_sint32_sint32"];
    if (_mapSint32Sint32_) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSint32Sint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64_ =
      json["mapSint64Sint64"] ?? json["map_sint64_sint64"];
    if (_mapSint64Sint64_) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSint64Sint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32_ =
      json["mapFixed32Fixed32"] ?? json["map_fixed32_fixed32"];
    if (_mapFixed32Fixed32_) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapFixed32Fixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64_ =
      json["mapFixed64Fixed64"] ?? json["map_fixed64_fixed64"];
    if (_mapFixed64Fixed64_) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapFixed64Fixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32_ =
      json["mapSfixed32Sfixed32"] ?? json["map_sfixed32_sfixed32"];
    if (_mapSfixed32Sfixed32_) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSfixed32Sfixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64_ =
      json["mapSfixed64Sfixed64"] ?? json["map_sfixed64_sfixed64"];
    if (_mapSfixed64Sfixed64_) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSfixed64Sfixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float_ = json["mapInt32Float"] ?? json["map_int32_float"];
    if (_mapInt32Float_) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Float._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double_ = json["mapInt32Double"] ?? json["map_int32_double"];
    if (_mapInt32Double_) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Double._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool_ = json["mapBoolBool"] ?? json["map_bool_bool"];
    if (_mapBoolBool_) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapBoolBool._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString_ =
      json["mapStringString"] ?? json["map_string_string"];
    if (_mapStringString_) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapStringString._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes_ = json["mapInt32Bytes"] ?? json["map_int32_bytes"];
    if (_mapInt32Bytes_) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Bytes._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum_ = json["mapInt32Enum"] ?? json["map_int32_enum"];
    if (_mapInt32Enum_) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Enum._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage_ =
      json["mapInt32ForeignMessage"] ?? json["map_int32_foreign_message"];
    if (_mapInt32ForeignMessage_) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32ForeignMessage._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Int32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Int32,
      json: any
    ): TestArenaMap.MapInt32Int32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt64Int64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt64Int64,
      json: any
    ): TestArenaMap.MapInt64Int64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapUint32Uint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapUint32Uint32,
      json: any
    ): TestArenaMap.MapUint32Uint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapUint64Uint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapUint64Uint64,
      json: any
    ): TestArenaMap.MapUint64Uint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSint32Sint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSint32Sint32,
      json: any
    ): TestArenaMap.MapSint32Sint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSint64Sint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSint64Sint64,
      json: any
    ): TestArenaMap.MapSint64Sint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapFixed32Fixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapFixed32Fixed32,
      json: any
    ): TestArenaMap.MapFixed32Fixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapFixed64Fixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapFixed64Fixed64,
      json: any
    ): TestArenaMap.MapFixed64Fixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSfixed32Sfixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSfixed32Sfixed32,
      json: any
    ): TestArenaMap.MapSfixed32Sfixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSfixed64Sfixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSfixed64Sfixed64,
      json: any
    ): TestArenaMap.MapSfixed64Sfixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Float>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Float,
      json: any
    ): TestArenaMap.MapInt32Float {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Double>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Double,
      json: any
    ): TestArenaMap.MapInt32Double {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapBoolBool>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapBoolBool,
      json: any
    ): TestArenaMap.MapBoolBool {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapStringString>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapStringString,
      json: any
    ): TestArenaMap.MapStringString {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Bytes>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value?.length) {
        json["value"] = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Bytes,
      json: any
    ): TestArenaMap.MapInt32Bytes {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = decodeBase64Bytes(_value_);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Enum>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && MapEnumJSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Enum,
      json: any
    ): TestArenaMap.MapInt32Enum {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32ForeignMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32ForeignMessage,
      json: any
    ): TestArenaMap.MapInt32ForeignMessage {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.ForeignMessage.initialize();
        googleProtobufUnittest.ForeignMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntryJSON = {
  /**
   * Serializes MessageContainingMapCalledEntry to JSON.
   */
  encode: function (msg: Partial<MessageContainingMapCalledEntry>): string {
    return JSON.stringify(
      MessageContainingMapCalledEntryJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes MessageContainingMapCalledEntry from JSON.
   */
  decode: function (json: string): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntryJSON._readMessage(
      MessageContainingMapCalledEntryJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.entry) {
      const _entry_ = Object.fromEntries(
        Object.entries(msg.entry)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MessageContainingMapCalledEntryJSON.Entry._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_entry_).length > 0) {
        json["entry"] = _entry_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    json: any
  ): MessageContainingMapCalledEntry {
    const _entry_ = json["entry"];
    if (_entry_) {
      msg.entry = Object.fromEntries(
        Object.entries(_entry_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MessageContainingMapCalledEntryJSON.Entry._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MessageContainingMapCalledEntry.Entry>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MessageContainingMapCalledEntry.Entry,
      json: any
    ): MessageContainingMapCalledEntry.Entry {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessageJSON = {
  /**
   * Serializes TestRecursiveMapMessage to JSON.
   */
  encode: function (msg: Partial<TestRecursiveMapMessage>): string {
    return JSON.stringify(TestRecursiveMapMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRecursiveMapMessage from JSON.
   */
  decode: function (json: string): TestRecursiveMapMessage {
    return TestRecursiveMapMessageJSON._readMessage(
      TestRecursiveMapMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const _a_ = Object.fromEntries(
        Object.entries(msg.a)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestRecursiveMapMessageJSON.A._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    json: any
  ): TestRecursiveMapMessage {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = Object.fromEntries(
        Object.entries(_a_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestRecursiveMapMessageJSON.A._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRecursiveMapMessage.A>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = TestRecursiveMapMessageJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRecursiveMapMessage.A,
      json: any
    ): TestRecursiveMapMessage.A {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = TestRecursiveMapMessage.initialize();
        TestRecursiveMapMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
      ],
      [
        "google/protobuf/unittest_well_known_types.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_well_known_types.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";

import * as protoscript from "protoscript";

//========================================//
//                 Types                  //
//========================================//

/**
 * Test that we can include all well-known types.
 * Each wrapper type is included separately, as languages
 * map handle different wrappers in different ways.
 */
export interface TestWellKnownTypes {
  anyField: protoscript.Any;
  apiField: protoscript.Api;
  durationField: protoscript.Duration;
  emptyField: protoscript.Empty;
  fieldMaskField: protoscript.FieldMask;
  sourceContextField: protoscript.SourceContext;
  structField: protoscript.Struct;
  timestampField: protoscript.Timestamp;
  typeField: protoscript.Type;
  doubleField: protoscript.DoubleValue;
  floatField: protoscript.FloatValue;
  int64Field: protoscript.Int64Value;
  uint64Field: protoscript.UInt64Value;
  int32Field: protoscript.Int32Value;
  uint32Field: protoscript.UInt32Value;
  boolField: protoscript.BoolValue;
  stringField: protoscript.StringValue;
  bytesField: protoscript.BytesValue;
  /**
   * Part of struct, but useful to be able to test separately
   */
  valueField: protoscript.Value;
}

/**
 * A repeated field for each well-known type.
 */
export interface RepeatedWellKnownTypes {
  anyField: protoscript.Any[];
  apiField: protoscript.Api[];
  durationField: protoscript.Duration[];
  emptyField: protoscript.Empty[];
  fieldMaskField: protoscript.FieldMask[];
  sourceContextField: protoscript.SourceContext[];
  structField: protoscript.Struct[];
  timestampField: protoscript.Timestamp[];
  typeField: protoscript.Type[];
  /**
   * These don't actually make a lot of sense, but they're not prohibited...
   */
  doubleField: protoscript.DoubleValue[];
  floatField: protoscript.FloatValue[];
  int64Field: protoscript.Int64Value[];
  uint64Field: protoscript.UInt64Value[];
  int32Field: protoscript.Int32Value[];
  uint32Field: protoscript.UInt32Value[];
  boolField: protoscript.BoolValue[];
  stringField: protoscript.StringValue[];
  bytesField: protoscript.BytesValue[];
}

export interface OneofWellKnownTypes {
  anyField?: protoscript.Any | null | undefined;
  apiField?: protoscript.Api | null | undefined;
  durationField?: protoscript.Duration | null | undefined;
  emptyField?: protoscript.Empty | null | undefined;
  fieldMaskField?: protoscript.FieldMask | null | undefined;
  sourceContextField?: protoscript.SourceContext | null | undefined;
  structField?: protoscript.Struct | null | undefined;
  timestampField?: protoscript.Timestamp | null | undefined;
  typeField?: protoscript.Type | null | undefined;
  doubleField?: protoscript.DoubleValue | null | undefined;
  floatField?: protoscript.FloatValue | null | undefined;
  int64Field?: protoscript.Int64Value | null | undefined;
  uint64Field?: protoscript.UInt64Value | null | undefined;
  int32Field?: protoscript.Int32Value | null | undefined;
  uint32Field?: protoscript.UInt32Value | null | undefined;
  boolField?: protoscript.BoolValue | null | undefined;
  stringField?: protoscript.StringValue | null | undefined;
  bytesField?: protoscript.BytesValue | null | undefined;
}

/**
 * A map field for each well-known type. We only
 * need to worry about the value part of the map being the
 * well-known types, as messages can't be map keys.
 */
export interface MapWellKnownTypes {
  anyField: Record<string, MapWellKnownTypes.AnyField["value"] | undefined>;
  apiField: Record<string, MapWellKnownTypes.ApiField["value"] | undefined>;
  durationField: Record<
    string,
    MapWellKnownTypes.DurationField["value"] | undefined
  >;
  emptyField: Record<string, MapWellKnownTypes.EmptyField["value"] | undefined>;
  fieldMaskField: Record<
    string,
    MapWellKnownTypes.FieldMaskField["value"] | undefined
  >;
  sourceContextField: Record<
    string,
    MapWellKnownTypes.SourceContextField["value"] | undefined
  >;
  structField: Record<
    string,
    MapWellKnownTypes.StructField["value"] | undefined
  >;
  timestampField: Record<
    string,
    MapWellKnownTypes.TimestampField["value"] | undefined
  >;
  typeField: Record<string, MapWellKnownTypes.TypeField["value"] | undefined>;
  doubleField: Record<
    string,
    MapWellKnownTypes.DoubleField["value"] | undefined
  >;
  floatField: Record<string, MapWellKnownTypes.FloatField["value"] | undefined>;
  int64Field: Record<string, MapWellKnownTypes.Int64Field["value"] | undefined>;
  uint64Field: Record<
    string,
    MapWellKnownTypes.Uint64Field["value"] | undefined
  >;
  int32Field: Record<string, MapWellKnownTypes.Int32Field["value"] | undefined>;
  uint32Field: Record<
    string,
    MapWellKnownTypes.Uint32Field["value"] | undefined
  >;
  boolField: Record<string, MapWellKnownTypes.BoolField["value"] | undefined>;
  stringField: Record<
    string,
    MapWellKnownTypes.StringField["value"] | undefined
  >;
  bytesField: Record<string, MapWellKnownTypes.BytesField["value"] | undefined>;
}

export declare namespace MapWellKnownTypes {
  interface AnyField {
    key: number;
    value: protoscript.Any;
  }

  interface ApiField {
    key: number;
    value: protoscript.Api;
  }

  interface DurationField {
    key: number;
    value: protoscript.Duration;
  }

  interface EmptyField {
    key: number;
    value: protoscript.Empty;
  }

  interface FieldMaskField {
    key: number;
    value: protoscript.FieldMask;
  }

  interface SourceContextField {
    key: number;
    value: protoscript.SourceContext;
  }

  interface StructField {
    key: number;
    value: protoscript.Struct;
  }

  interface TimestampField {
    key: number;
    value: protoscript.Timestamp;
  }

  interface TypeField {
    key: number;
    value: protoscript.Type;
  }

  interface DoubleField {
    key: number;
    value: protoscript.DoubleValue;
  }

  interface FloatField {
    key: number;
    value: protoscript.FloatValue;
  }

  interface Int64Field {
    key: number;
    value: protoscript.Int64Value;
  }

  interface Uint64Field {
    key: number;
    value: protoscript.UInt64Value;
  }

  interface Int32Field {
    key: number;
    value: protoscript.Int32Value;
  }

  interface Uint32Field {
    key: number;
    value: protoscript.UInt32Value;
  }

  interface BoolField {
    key: number;
    value: protoscript.BoolValue;
  }

  interface StringField {
    key: number;
    value: protoscript.StringValue;
  }

  interface BytesField {
    key: number;
    value: protoscript.BytesValue;
  }
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const TestWellKnownTypes = {
  /**
   * Serializes TestWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<TestWellKnownTypes>): Uint8Array {
    return TestWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestWellKnownTypes {
    return TestWellKnownTypes._readMessage(
      TestWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): TestWellKnownTypes {
    return {
      anyField: protoscript.Any.initialize(),
      apiField: protoscript.Api.initialize(),
      durationField: protoscript.Duration.initialize(),
      emptyField: protoscript.Empty.initialize(),
      fieldMaskField: protoscript.FieldMask.initialize(),
      sourceContextField: protoscript.SourceContext.initialize(),
      structField: protoscript.Struct.initialize(),
      timestampField: protoscript.Timestamp.initialize(),
      typeField: protoscript.Type.initialize(),
      doubleField: protoscript.DoubleValue.initialize(),
      floatField: protoscript.FloatValue.initialize(),
      int64Field: protoscript.Int64Value.initialize(),
      uint64Field: protoscript.UInt64Value.initialize(),
      int32Field: protoscript.Int32Value.initialize(),
      uint32Field: protoscript.UInt32Value.initialize(),
      boolField: protoscript.BoolValue.initialize(),
      stringField: protoscript.StringValue.initialize(),
      bytesField: protoscript.BytesValue.initialize(),
      valueField: protoscript.Value.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField) {
      writer.writeMessage(1, msg.anyField, protoscript.Any._writeMessage);
    }
    if (msg.apiField) {
      writer.writeMessage(2, msg.apiField, protoscript.Api._writeMessage);
    }
    if (msg.durationField) {
      writer.writeMessage(
        3,
        msg.durationField,
        protoscript.Duration._writeMessage
      );
    }
    if (msg.emptyField) {
      writer.writeMessage(4, msg.emptyField, protoscript.Empty._writeMessage);
    }
    if (msg.fieldMaskField) {
      writer.writeMessage(
        5,
        msg.fieldMaskField,
        protoscript.FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        protoscript.SourceContext._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeMessage(7, msg.structField, protoscript.Struct._writeMessage);
    }
    if (msg.timestampField) {
      writer.writeMessage(
        8,
        msg.timestampField,
        protoscript.Timestamp._writeMessage
      );
    }
    if (msg.typeField) {
      writer.writeMessage(9, msg.typeField, protoscript.Type._writeMessage);
    }
    if (msg.doubleField) {
      writer.writeMessage(
        10,
        msg.doubleField,
        protoscript.DoubleValue._writeMessage
      );
    }
    if (msg.floatField) {
      writer.writeMessage(
        11,
        msg.floatField,
        protoscript.FloatValue._writeMessage
      );
    }
    if (msg.int64Field) {
      writer.writeMessage(
        12,
        msg.int64Field,
        protoscript.Int64Value._writeMessage
      );
    }
    if (msg.uint64Field) {
      writer.writeMessage(
        13,
        msg.uint64Field,
        protoscript.UInt64Value._writeMessage
      );
    }
    if (msg.int32Field) {
      writer.writeMessage(
        14,
        msg.int32Field,
        protoscript.Int32Value._writeMessage
      );
    }
    if (msg.uint32Field) {
      writer.writeMessage(
        15,
        msg.uint32Field,
        protoscript.UInt32Value._writeMessage
      );
    }
    if (msg.boolField) {
      writer.writeMessage(
        16,
        msg.boolField,
        protoscript.BoolValue._writeMessage
      );
    }
    if (msg.stringField) {
      writer.writeMessage(
        17,
        msg.stringField,
        protoscript.StringValue._writeMessage
      );
    }
    if (msg.bytesField) {
      writer.writeMessage(
        18,
        msg.bytesField,
        protoscript.BytesValue._writeMessage
      );
    }
    if (msg.valueField) {
      writer.writeMessage(19, msg.valueField, protoscript.Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestWellKnownTypes,
    reader: BinaryReader
  ): TestWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.anyField, protoscript.Any._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.apiField, protoscript.Api._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(
            msg.durationField,
            protoscript.Duration._readMessage
          );
          break;
        }
        case 4: {
          reader.readMessage(msg.emptyField, protoscript.Empty._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(
            msg.fieldMaskField,
            protoscript.FieldMask._readMessage
          );
          break;
        }
        case 6: {
          reader.readMessage(
            msg.sourceContextField,
            protoscript.SourceContext._readMessage
          );
          break;
        }
        case 7: {
          reader.readMessage(msg.structField, protoscript.Struct._readMessage);
          break;
        }
        case 8: {
          reader.readMessage(
            msg.timestampField,
            protoscript.Timestamp._readMessage
          );
          break;
        }
        case 9: {
          reader.readMessage(msg.typeField, protoscript.Type._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(
            msg.doubleField,
            protoscript.DoubleValue._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.floatField,
            protoscript.FloatValue._readMessage
          );
          break;
        }
        case 12: {
          reader.readMessage(
            msg.int64Field,
            protoscript.Int64Value._readMessage
          );
          break;
        }
        case 13: {
          reader.readMessage(
            msg.uint64Field,
            protoscript.UInt64Value._readMessage
          );
          break;
        }
        case 14: {
          reader.readMessage(
            msg.int32Field,
            protoscript.Int32Value._readMessage
          );
          break;
        }
        case 15: {
          reader.readMessage(
            msg.uint32Field,
            protoscript.UInt32Value._readMessage
          );
          break;
        }
        case 16: {
          reader.readMessage(msg.boolField, protoscript.BoolValue._readMessage);
          break;
        }
        case 17: {
          reader.readMessage(
            msg.stringField,
            protoscript.StringValue._readMessage
          );
          break;
        }
        case 18: {
          reader.readMessage(
            msg.bytesField,
            protoscript.BytesValue._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(msg.valueField, protoscript.Value._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedWellKnownTypes = {
  /**
   * Serializes RepeatedWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<RepeatedWellKnownTypes>): Uint8Array {
    return RepeatedWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes RepeatedWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedWellKnownTypes {
    return RepeatedWellKnownTypes._readMessage(
      RepeatedWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes RepeatedWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): RepeatedWellKnownTypes {
    return {
      anyField: [],
      apiField: [],
      durationField: [],
      emptyField: [],
      fieldMaskField: [],
      sourceContextField: [],
      structField: [],
      timestampField: [],
      typeField: [],
      doubleField: [],
      floatField: [],
      int64Field: [],
      uint64Field: [],
      int32Field: [],
      uint32Field: [],
      boolField: [],
      stringField: [],
      bytesField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.anyField as any,
        protoscript.Any._writeMessage
      );
    }
    if (msg.apiField?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.apiField as any,
        protoscript.Api._writeMessage
      );
    }
    if (msg.durationField?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.durationField as any,
        protoscript.Duration._writeMessage
      );
    }
    if (msg.emptyField?.length) {
      writer.writeRepeatedMessage(
        4,
        msg.emptyField as any,
        protoscript.Empty._writeMessage
      );
    }
    if (msg.fieldMaskField?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.fieldMaskField as any,
        protoscript.FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField?.length) {
      writer.writeRepeatedMessage(
        6,
        msg.sourceContextField as any,
        protoscript.SourceContext._writeMessage
      );
    }
    if (msg.structField?.length) {
      writer.writeRepeatedMessage(
        7,
        msg.structField as any,
        protoscript.Struct._writeMessage
      );
    }
    if (msg.timestampField?.length) {
      writer.writeRepeatedMessage(
        8,
        msg.timestampField as any,
        protoscript.Timestamp._writeMessage
      );
    }
    if (msg.typeField?.length) {
      writer.writeRepeatedMessage(
        9,
        msg.typeField as any,
        protoscript.Type._writeMessage
      );
    }
    if (msg.doubleField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.doubleField as any,
        protoscript.DoubleValue._writeMessage
      );
    }
    if (msg.floatField?.length) {
      writer.writeRepeatedMessage(
        11,
        msg.floatField as any,
        protoscript.FloatValue._writeMessage
      );
    }
    if (msg.int64Field?.length) {
      writer.writeRepeatedMessage(
        12,
        msg.int64Field as any,
        protoscript.Int64Value._writeMessage
      );
    }
    if (msg.uint64Field?.length) {
      writer.writeRepeatedMessage(
        13,
        msg.uint64Field as any,
        protoscript.UInt64Value._writeMessage
      );
    }
    if (msg.int32Field?.length) {
      writer.writeRepeatedMessage(
        14,
        msg.int32Field as any,
        protoscript.Int32Value._writeMessage
      );
    }
    if (msg.uint32Field?.length) {
      writer.writeRepeatedMessage(
        15,
        msg.uint32Field as any,
        protoscript.UInt32Value._writeMessage
      );
    }
    if (msg.boolField?.length) {
      writer.writeRepeatedMessage(
        16,
        msg.boolField as any,
        protoscript.BoolValue._writeMessage
      );
    }
    if (msg.stringField?.length) {
      writer.writeRepeatedMessage(
        17,
        msg.stringField as any,
        protoscript.StringValue._writeMessage
      );
    }
    if (msg.bytesField?.length) {
      writer.writeRepeatedMessage(
        18,
        msg.bytesField as any,
        protoscript.BytesValue._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedWellKnownTypes,
    reader: BinaryReader
  ): RepeatedWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoscript.Any.initialize();
          reader.readMessage(m, protoscript.Any._readMessage);
          msg.anyField.push(m);
          break;
        }
        case 2: {
          const m = protoscript.Api.initialize();
          reader.readMessage(m, protoscript.Api._readMessage);
          msg.apiField.push(m);
          break;
        }
        case 3: {
          const m = protoscript.Duration.initialize();
          reader.readMessage(m, protoscript.Duration._readMessage);
          msg.durationField.push(m);
          break;
        }
        case 4: {
          const m = protoscript.Empty.initialize();
          reader.readMessage(m, protoscript.Empty._readMessage);
          msg.emptyField.push(m);
          break;
        }
        case 5: {
          const m = protoscript.FieldMask.initialize();
          reader.readMessage(m, protoscript.FieldMask._readMessage);
          msg.fieldMaskField.push(m);
          break;
        }
        case 6: {
          const m = protoscript.SourceContext.initialize();
          reader.readMessage(m, protoscript.SourceContext._readMessage);
          msg.sourceContextField.push(m);
          break;
        }
        case 7: {
          const m = protoscript.Struct.initialize();
          reader.readMessage(m, protoscript.Struct._readMessage);
          msg.structField.push(m);
          break;
        }
        case 8: {
          const m = protoscript.Timestamp.initialize();
          reader.readMessage(m, protoscript.Timestamp._readMessage);
          msg.timestampField.push(m);
          break;
        }
        case 9: {
          const m = protoscript.Type.initialize();
          reader.readMessage(m, protoscript.Type._readMessage);
          msg.typeField.push(m);
          break;
        }
        case 10: {
          const m = protoscript.DoubleValue.initialize();
          reader.readMessage(m, protoscript.DoubleValue._readMessage);
          msg.doubleField.push(m);
          break;
        }
        case 11: {
          const m = protoscript.FloatValue.initialize();
          reader.readMessage(m, protoscript.FloatValue._readMessage);
          msg.floatField.push(m);
          break;
        }
        case 12: {
          const m = protoscript.Int64Value.initialize();
          reader.readMessage(m, protoscript.Int64Value._readMessage);
          msg.int64Field.push(m);
          break;
        }
        case 13: {
          const m = protoscript.UInt64Value.initialize();
          reader.readMessage(m, protoscript.UInt64Value._readMessage);
          msg.uint64Field.push(m);
          break;
        }
        case 14: {
          const m = protoscript.Int32Value.initialize();
          reader.readMessage(m, protoscript.Int32Value._readMessage);
          msg.int32Field.push(m);
          break;
        }
        case 15: {
          const m = protoscript.UInt32Value.initialize();
          reader.readMessage(m, protoscript.UInt32Value._readMessage);
          msg.uint32Field.push(m);
          break;
        }
        case 16: {
          const m = protoscript.BoolValue.initialize();
          reader.readMessage(m, protoscript.BoolValue._readMessage);
          msg.boolField.push(m);
          break;
        }
        case 17: {
          const m = protoscript.StringValue.initialize();
          reader.readMessage(m, protoscript.StringValue._readMessage);
          msg.stringField.push(m);
          break;
        }
        case 18: {
          const m = protoscript.BytesValue.initialize();
          reader.readMessage(m, protoscript.BytesValue._readMessage);
          msg.bytesField.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneofWellKnownTypes = {
  /**
   * Serializes OneofWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<OneofWellKnownTypes>): Uint8Array {
    return OneofWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes OneofWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): OneofWellKnownTypes {
    return OneofWellKnownTypes._readMessage(
      OneofWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OneofWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): OneofWellKnownTypes {
    return {
      anyField: undefined,
      apiField: undefined,
      durationField: undefined,
      emptyField: undefined,
      fieldMaskField: undefined,
      sourceContextField: undefined,
      structField: undefined,
      timestampField: undefined,
      typeField: undefined,
      doubleField: undefined,
      floatField: undefined,
      int64Field: undefined,
      uint64Field: undefined,
      int32Field: undefined,
      uint32Field: undefined,
      boolField: undefined,
      stringField: undefined,
      bytesField: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneofWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField != undefined) {
      writer.writeMessage(1, msg.anyField, protoscript.Any._writeMessage);
    }
    if (msg.apiField != undefined) {
      writer.writeMessage(2, msg.apiField, protoscript.Api._writeMessage);
    }
    if (msg.durationField != undefined) {
      writer.writeMessage(
        3,
        msg.durationField,
        protoscript.Duration._writeMessage
      );
    }
    if (msg.emptyField != undefined) {
      writer.writeMessage(4, msg.emptyField, protoscript.Empty._writeMessage);
    }
    if (msg.fieldMaskField != undefined) {
      writer.writeMessage(
        5,
        msg.fieldMaskField,
        protoscript.FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField != undefined) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        protoscript.SourceContext._writeMessage
      );
    }
    if (msg.structField != undefined) {
      writer.writeMessage(7, msg.structField, protoscript.Struct._writeMessage);
    }
    if (msg.timestampField != undefined) {
      writer.writeMessage(
        8,
        msg.timestampField,
        protoscript.Timestamp._writeMessage
      );
    }
    if (msg.typeField != undefined) {
      writer.writeMessage(9, msg.typeField, protoscript.Type._writeMessage);
    }
    if (msg.doubleField != undefined) {
      writer.writeMessage(
        10,
        msg.doubleField,
        protoscript.DoubleValue._writeMessage
      );
    }
    if (msg.floatField != undefined) {
      writer.writeMessage(
        11,
        msg.floatField,
        protoscript.FloatValue._writeMessage
      );
    }
    if (msg.int64Field != undefined) {
      writer.writeMessage(
        12,
        msg.int64Field,
        protoscript.Int64Value._writeMessage
      );
    }
    if (msg.uint64Field != undefined) {
      writer.writeMessage(
        13,
        msg.uint64Field,
        protoscript.UInt64Value._writeMessage
      );
    }
    if (msg.int32Field != undefined) {
      writer.writeMessage(
        14,
        msg.int32Field,
        protoscript.Int32Value._writeMessage
      );
    }
    if (msg.uint32Field != undefined) {
      writer.writeMessage(
        15,
        msg.uint32Field,
        protoscript.UInt32Value._writeMessage
      );
    }
    if (msg.boolField != undefined) {
      writer.writeMessage(
        16,
        msg.boolField,
        protoscript.BoolValue._writeMessage
      );
    }
    if (msg.stringField != undefined) {
      writer.writeMessage(
        17,
        msg.stringField,
        protoscript.StringValue._writeMessage
      );
    }
    if (msg.bytesField != undefined) {
      writer.writeMessage(
        18,
        msg.bytesField,
        protoscript.BytesValue._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OneofWellKnownTypes,
    reader: BinaryReader
  ): OneofWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.anyField = protoscript.Any.initialize();
          reader.readMessage(msg.anyField, protoscript.Any._readMessage);
          break;
        }
        case 2: {
          msg.apiField = protoscript.Api.initialize();
          reader.readMessage(msg.apiField, protoscript.Api._readMessage);
          break;
        }
        case 3: {
          msg.durationField = protoscript.Duration.initialize();
          reader.readMessage(
            msg.durationField,
            protoscript.Duration._readMessage
          );
          break;
        }
        case 4: {
          msg.emptyField = protoscript.Empty.initialize();
          reader.readMessage(msg.emptyField, protoscript.Empty._readMessage);
          break;
        }
        case 5: {
          msg.fieldMaskField = protoscript.FieldMask.initialize();
          reader.readMessage(
            msg.fieldMaskField,
            protoscript.FieldMask._readMessage
          );
          break;
        }
        case 6: {
          msg.sourceContextField = protoscript.SourceContext.initialize();
          reader.readMessage(
            msg.sourceContextField,
            protoscript.SourceContext._readMessage
          );
          break;
        }
        case 7: {
          msg.structField = protoscript.Struct.initialize();
          reader.readMessage(msg.structField, protoscript.Struct._readMessage);
          break;
        }
        case 8: {
          msg.timestampField = protoscript.Timestamp.initialize();
          reader.readMessage(
            msg.timestampField,
            protoscript.Timestamp._readMessage
          );
          break;
        }
        case 9: {
          msg.typeField = protoscript.Type.initialize();
          reader.readMessage(msg.typeField, protoscript.Type._readMessage);
          break;
        }
        case 10: {
          msg.doubleField = protoscript.DoubleValue.initialize();
          reader.readMessage(
            msg.doubleField,
            protoscript.DoubleValue._readMessage
          );
          break;
        }
        case 11: {
          msg.floatField = protoscript.FloatValue.initialize();
          reader.readMessage(
            msg.floatField,
            protoscript.FloatValue._readMessage
          );
          break;
        }
        case 12: {
          msg.int64Field = protoscript.Int64Value.initialize();
          reader.readMessage(
            msg.int64Field,
            protoscript.Int64Value._readMessage
          );
          break;
        }
        case 13: {
          msg.uint64Field = protoscript.UInt64Value.initialize();
          reader.readMessage(
            msg.uint64Field,
            protoscript.UInt64Value._readMessage
          );
          break;
        }
        case 14: {
          msg.int32Field = protoscript.Int32Value.initialize();
          reader.readMessage(
            msg.int32Field,
            protoscript.Int32Value._readMessage
          );
          break;
        }
        case 15: {
          msg.uint32Field = protoscript.UInt32Value.initialize();
          reader.readMessage(
            msg.uint32Field,
            protoscript.UInt32Value._readMessage
          );
          break;
        }
        case 16: {
          msg.boolField = protoscript.BoolValue.initialize();
          reader.readMessage(msg.boolField, protoscript.BoolValue._readMessage);
          break;
        }
        case 17: {
          msg.stringField = protoscript.StringValue.initialize();
          reader.readMessage(
            msg.stringField,
            protoscript.StringValue._readMessage
          );
          break;
        }
        case 18: {
          msg.bytesField = protoscript.BytesValue.initialize();
          reader.readMessage(
            msg.bytesField,
            protoscript.BytesValue._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MapWellKnownTypes = {
  /**
   * Serializes MapWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<MapWellKnownTypes>): Uint8Array {
    return MapWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes MapWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): MapWellKnownTypes {
    return MapWellKnownTypes._readMessage(
      MapWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MapWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): MapWellKnownTypes {
    return {
      anyField: {},
      apiField: {},
      durationField: {},
      emptyField: {},
      fieldMaskField: {},
      sourceContextField: {},
      structField: {},
      timestampField: {},
      typeField: {},
      doubleField: {},
      floatField: {},
      int64Field: {},
      uint64Field: {},
      int32Field: {},
      uint32Field: {},
      boolField: {},
      stringField: {},
      bytesField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MapWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.anyField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.AnyField._writeMessage
      );
    }
    if (msg.apiField) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.apiField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.ApiField._writeMessage
      );
    }
    if (msg.durationField) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.durationField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.DurationField._writeMessage
      );
    }
    if (msg.emptyField) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.emptyField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.EmptyField._writeMessage
      );
    }
    if (msg.fieldMaskField) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.fieldMaskField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.FieldMaskField._writeMessage
      );
    }
    if (msg.sourceContextField) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.sourceContextField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.SourceContextField._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.structField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.StructField._writeMessage
      );
    }
    if (msg.timestampField) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.timestampField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.TimestampField._writeMessage
      );
    }
    if (msg.typeField) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.typeField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.TypeField._writeMessage
      );
    }
    if (msg.doubleField) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.doubleField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.DoubleField._writeMessage
      );
    }
    if (msg.floatField) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.floatField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.FloatField._writeMessage
      );
    }
    if (msg.int64Field) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.int64Field).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.Int64Field._writeMessage
      );
    }
    if (msg.uint64Field) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.uint64Field).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.Uint64Field._writeMessage
      );
    }
    if (msg.int32Field) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.int32Field).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.Int32Field._writeMessage
      );
    }
    if (msg.uint32Field) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.uint32Field).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.Uint32Field._writeMessage
      );
    }
    if (msg.boolField) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.boolField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.BoolField._writeMessage
      );
    }
    if (msg.stringField) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.stringField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.StringField._writeMessage
      );
    }
    if (msg.bytesField) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.bytesField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.BytesField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MapWellKnownTypes,
    reader: BinaryReader
  ): MapWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as MapWellKnownTypes.AnyField;
          reader.readMessage(map, MapWellKnownTypes.AnyField._readMessage);
          msg.anyField[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {} as MapWellKnownTypes.ApiField;
          reader.readMessage(map, MapWellKnownTypes.ApiField._readMessage);
          msg.apiField[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {} as MapWellKnownTypes.DurationField;
          reader.readMessage(map, MapWellKnownTypes.DurationField._readMessage);
          msg.durationField[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {} as MapWellKnownTypes.EmptyField;
          reader.readMessage(map, MapWellKnownTypes.EmptyField._readMessage);
          msg.emptyField[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {} as MapWellKnownTypes.FieldMaskField;
          reader.readMessage(
            map,
            MapWellKnownTypes.FieldMaskField._readMessage
          );
          msg.fieldMaskField[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {} as MapWellKnownTypes.SourceContextField;
          reader.readMessage(
            map,
            MapWellKnownTypes.SourceContextField._readMessage
          );
          msg.sourceContextField[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {} as MapWellKnownTypes.StructField;
          reader.readMessage(map, MapWellKnownTypes.StructField._readMessage);
          msg.structField[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {} as MapWellKnownTypes.TimestampField;
          reader.readMessage(
            map,
            MapWellKnownTypes.TimestampField._readMessage
          );
          msg.timestampField[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {} as MapWellKnownTypes.TypeField;
          reader.readMessage(map, MapWellKnownTypes.TypeField._readMessage);
          msg.typeField[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {} as MapWellKnownTypes.DoubleField;
          reader.readMessage(map, MapWellKnownTypes.DoubleField._readMessage);
          msg.doubleField[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {} as MapWellKnownTypes.FloatField;
          reader.readMessage(map, MapWellKnownTypes.FloatField._readMessage);
          msg.floatField[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {} as MapWellKnownTypes.Int64Field;
          reader.readMessage(map, MapWellKnownTypes.Int64Field._readMessage);
          msg.int64Field[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {} as MapWellKnownTypes.Uint64Field;
          reader.readMessage(map, MapWellKnownTypes.Uint64Field._readMessage);
          msg.uint64Field[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {} as MapWellKnownTypes.Int32Field;
          reader.readMessage(map, MapWellKnownTypes.Int32Field._readMessage);
          msg.int32Field[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {} as MapWellKnownTypes.Uint32Field;
          reader.readMessage(map, MapWellKnownTypes.Uint32Field._readMessage);
          msg.uint32Field[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {} as MapWellKnownTypes.BoolField;
          reader.readMessage(map, MapWellKnownTypes.BoolField._readMessage);
          msg.boolField[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {} as MapWellKnownTypes.StringField;
          reader.readMessage(map, MapWellKnownTypes.StringField._readMessage);
          msg.stringField[map.key.toString()] = map.value;
          break;
        }
        case 18: {
          const map = {} as MapWellKnownTypes.BytesField;
          reader.readMessage(map, MapWellKnownTypes.BytesField._readMessage);
          msg.bytesField[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  AnyField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.AnyField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Any._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.AnyField,
      reader: BinaryReader
    ): MapWellKnownTypes.AnyField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Any.initialize();
            reader.readMessage(msg.value, protoscript.Any._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ApiField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.ApiField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Api._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.ApiField,
      reader: BinaryReader
    ): MapWellKnownTypes.ApiField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Api.initialize();
            reader.readMessage(msg.value, protoscript.Api._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  DurationField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.DurationField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Duration._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.DurationField,
      reader: BinaryReader
    ): MapWellKnownTypes.DurationField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Duration.initialize();
            reader.readMessage(msg.value, protoscript.Duration._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  EmptyField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.EmptyField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Empty._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.EmptyField,
      reader: BinaryReader
    ): MapWellKnownTypes.EmptyField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Empty.initialize();
            reader.readMessage(msg.value, protoscript.Empty._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FieldMaskField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.FieldMaskField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.FieldMask._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.FieldMaskField,
      reader: BinaryReader
    ): MapWellKnownTypes.FieldMaskField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.FieldMask.initialize();
            reader.readMessage(msg.value, protoscript.FieldMask._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SourceContextField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.SourceContextField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.SourceContext._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.SourceContextField,
      reader: BinaryReader
    ): MapWellKnownTypes.SourceContextField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.SourceContext.initialize();
            reader.readMessage(
              msg.value,
              protoscript.SourceContext._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StructField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.StructField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Struct._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.StructField,
      reader: BinaryReader
    ): MapWellKnownTypes.StructField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Struct.initialize();
            reader.readMessage(msg.value, protoscript.Struct._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  TimestampField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.TimestampField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Timestamp._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.TimestampField,
      reader: BinaryReader
    ): MapWellKnownTypes.TimestampField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Timestamp.initialize();
            reader.readMessage(msg.value, protoscript.Timestamp._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  TypeField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.TypeField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Type._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.TypeField,
      reader: BinaryReader
    ): MapWellKnownTypes.TypeField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Type.initialize();
            reader.readMessage(msg.value, protoscript.Type._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  DoubleField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.DoubleField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.DoubleValue._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.DoubleField,
      reader: BinaryReader
    ): MapWellKnownTypes.DoubleField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.DoubleValue.initialize();
            reader.readMessage(msg.value, protoscript.DoubleValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FloatField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.FloatField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.FloatValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.FloatField,
      reader: BinaryReader
    ): MapWellKnownTypes.FloatField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.FloatValue.initialize();
            reader.readMessage(msg.value, protoscript.FloatValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Int64Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Int64Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Int64Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Int64Field,
      reader: BinaryReader
    ): MapWellKnownTypes.Int64Field {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Int64Value.initialize();
            reader.readMessage(msg.value, protoscript.Int64Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Uint64Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Uint64Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.UInt64Value._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Uint64Field,
      reader: BinaryReader
    ): MapWellKnownTypes.Uint64Field {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.UInt64Value.initialize();
            reader.readMessage(msg.value, protoscript.UInt64Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Int32Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Int32Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Int32Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Int32Field,
      reader: BinaryReader
    ): MapWellKnownTypes.Int32Field {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Int32Value.initialize();
            reader.readMessage(msg.value, protoscript.Int32Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Uint32Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Uint32Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.UInt32Value._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Uint32Field,
      reader: BinaryReader
    ): MapWellKnownTypes.Uint32Field {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.UInt32Value.initialize();
            reader.readMessage(msg.value, protoscript.UInt32Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  BoolField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.BoolField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.BoolValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.BoolField,
      reader: BinaryReader
    ): MapWellKnownTypes.BoolField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.BoolValue.initialize();
            reader.readMessage(msg.value, protoscript.BoolValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StringField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.StringField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.StringValue._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.StringField,
      reader: BinaryReader
    ): MapWellKnownTypes.StringField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.StringValue.initialize();
            reader.readMessage(msg.value, protoscript.StringValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  BytesField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.BytesField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.BytesValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.BytesField,
      reader: BinaryReader
    ): MapWellKnownTypes.BytesField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.BytesValue.initialize();
            reader.readMessage(msg.value, protoscript.BytesValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const TestWellKnownTypesJSON = {
  /**
   * Serializes TestWellKnownTypes to JSON.
   */
  encode: function (msg: Partial<TestWellKnownTypes>): string {
    return JSON.stringify(TestWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestWellKnownTypes from JSON.
   */
  decode: function (json: string): TestWellKnownTypes {
    return TestWellKnownTypesJSON._readMessage(
      TestWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): TestWellKnownTypes {
    return {
      anyField: protoscript.AnyJSON.initialize(),
      apiField: protoscript.ApiJSON.initialize(),
      durationField: protoscript.DurationJSON.initialize(),
      emptyField: protoscript.EmptyJSON.initialize(),
      fieldMaskField: protoscript.FieldMaskJSON.initialize(),
      sourceContextField: protoscript.SourceContextJSON.initialize(),
      structField: protoscript.StructJSON.initialize(),
      timestampField: protoscript.TimestampJSON.initialize(),
      typeField: protoscript.TypeJSON.initialize(),
      doubleField: protoscript.DoubleValueJSON.initialize(),
      floatField: protoscript.FloatValueJSON.initialize(),
      int64Field: protoscript.Int64ValueJSON.initialize(),
      uint64Field: protoscript.UInt64ValueJSON.initialize(),
      int32Field: protoscript.Int32ValueJSON.initialize(),
      uint32Field: protoscript.UInt32ValueJSON.initialize(),
      boolField: protoscript.BoolValueJSON.initialize(),
      stringField: protoscript.StringValueJSON.initialize(),
      bytesField: protoscript.BytesValueJSON.initialize(),
      valueField: protoscript.ValueJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField) {
      const _anyField_ = protoscript.AnyJSON._writeMessage(msg.anyField);
      if (Object.keys(_anyField_).length > 0) {
        json["anyField"] = _anyField_;
      }
    }
    if (msg.apiField) {
      const _apiField_ = protoscript.ApiJSON._writeMessage(msg.apiField);
      if (Object.keys(_apiField_).length > 0) {
        json["apiField"] = _apiField_;
      }
    }
    if (msg.durationField) {
      const _durationField_ = protoscript.DurationJSON._writeMessage(
        msg.durationField
      );
      if (Object.keys(_durationField_).length > 0) {
        json["durationField"] = _durationField_;
      }
    }
    if (msg.emptyField) {
      const _emptyField_ = protoscript.EmptyJSON._writeMessage(msg.emptyField);
      if (Object.keys(_emptyField_).length > 0) {
        json["emptyField"] = _emptyField_;
      }
    }
    if (msg.fieldMaskField) {
      const _fieldMaskField_ = protoscript.FieldMaskJSON._writeMessage(
        msg.fieldMaskField
      );
      if (Object.keys(_fieldMaskField_).length > 0) {
        json["fieldMaskField"] = _fieldMaskField_;
      }
    }
    if (msg.sourceContextField) {
      const _sourceContextField_ = protoscript.SourceContextJSON._writeMessage(
        msg.sourceContextField
      );
      if (Object.keys(_sourceContextField_).length > 0) {
        json["sourceContextField"] = _sourceContextField_;
      }
    }
    if (msg.structField) {
      const _structField_ = protoscript.StructJSON._writeMessage(
        msg.structField
      );
      if (Object.keys(_structField_).length > 0) {
        json["structField"] = _structField_;
      }
    }
    if (msg.timestampField) {
      const _timestampField_ = protoscript.TimestampJSON._writeMessage(
        msg.timestampField
      );
      if (Object.keys(_timestampField_).length > 0) {
        json["timestampField"] = _timestampField_;
      }
    }
    if (msg.typeField) {
      const _typeField_ = protoscript.TypeJSON._writeMessage(msg.typeField);
      if (Object.keys(_typeField_).length > 0) {
        json["typeField"] = _typeField_;
      }
    }
    if (msg.doubleField) {
      const _doubleField_ = protoscript.DoubleValueJSON._writeMessage(
        msg.doubleField
      );
      if (Object.keys(_doubleField_).length > 0) {
        json["doubleField"] = _doubleField_;
      }
    }
    if (msg.floatField) {
      const _floatField_ = protoscript.FloatValueJSON._writeMessage(
        msg.floatField
      );
      if (Object.keys(_floatField_).length > 0) {
        json["floatField"] = _floatField_;
      }
    }
    if (msg.int64Field) {
      const _int64Field_ = protoscript.Int64ValueJSON._writeMessage(
        msg.int64Field
      );
      if (Object.keys(_int64Field_).length > 0) {
        json["int64Field"] = _int64Field_;
      }
    }
    if (msg.uint64Field) {
      const _uint64Field_ = protoscript.UInt64ValueJSON._writeMessage(
        msg.uint64Field
      );
      if (Object.keys(_uint64Field_).length > 0) {
        json["uint64Field"] = _uint64Field_;
      }
    }
    if (msg.int32Field) {
      const _int32Field_ = protoscript.Int32ValueJSON._writeMessage(
        msg.int32Field
      );
      if (Object.keys(_int32Field_).length > 0) {
        json["int32Field"] = _int32Field_;
      }
    }
    if (msg.uint32Field) {
      const _uint32Field_ = protoscript.UInt32ValueJSON._writeMessage(
        msg.uint32Field
      );
      if (Object.keys(_uint32Field_).length > 0) {
        json["uint32Field"] = _uint32Field_;
      }
    }
    if (msg.boolField) {
      const _boolField_ = protoscript.BoolValueJSON._writeMessage(
        msg.boolField
      );
      if (Object.keys(_boolField_).length > 0) {
        json["boolField"] = _boolField_;
      }
    }
    if (msg.stringField) {
      const _stringField_ = protoscript.StringValueJSON._writeMessage(
        msg.stringField
      );
      if (Object.keys(_stringField_).length > 0) {
        json["stringField"] = _stringField_;
      }
    }
    if (msg.bytesField) {
      const _bytesField_ = protoscript.BytesValueJSON._writeMessage(
        msg.bytesField
      );
      if (Object.keys(_bytesField_).length > 0) {
        json["bytesField"] = _bytesField_;
      }
    }
    if (msg.valueField) {
      const _valueField_ = protoscript.ValueJSON._writeMessage(msg.valueField);
      if (Object.keys(_valueField_).length > 0) {
        json["valueField"] = _valueField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestWellKnownTypes,
    json: any
  ): TestWellKnownTypes {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      const m = protoscript.Any.initialize();
      protoscript.AnyJSON._readMessage(m, _anyField_);
      msg.anyField = m;
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      const m = protoscript.Api.initialize();
      protoscript.ApiJSON._readMessage(m, _apiField_);
      msg.apiField = m;
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      const m = protoscript.Duration.initialize();
      protoscript.DurationJSON._readMessage(m, _durationField_);
      msg.durationField = m;
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      const m = protoscript.Empty.initialize();
      protoscript.EmptyJSON._readMessage(m, _emptyField_);
      msg.emptyField = m;
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      const m = protoscript.FieldMask.initialize();
      protoscript.FieldMaskJSON._readMessage(m, _fieldMaskField_);
      msg.fieldMaskField = m;
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      const m = protoscript.SourceContext.initialize();
      protoscript.SourceContextJSON._readMessage(m, _sourceContextField_);
      msg.sourceContextField = m;
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      const m = protoscript.Struct.initialize();
      protoscript.StructJSON._readMessage(m, _structField_);
      msg.structField = m;
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      const m = protoscript.Timestamp.initialize();
      protoscript.TimestampJSON._readMessage(m, _timestampField_);
      msg.timestampField = m;
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      const m = protoscript.Type.initialize();
      protoscript.TypeJSON._readMessage(m, _typeField_);
      msg.typeField = m;
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      const m = protoscript.DoubleValue.initialize();
      protoscript.DoubleValueJSON._readMessage(m, _doubleField_);
      msg.doubleField = m;
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      const m = protoscript.FloatValue.initialize();
      protoscript.FloatValueJSON._readMessage(m, _floatField_);
      msg.floatField = m;
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      const m = protoscript.Int64Value.initialize();
      protoscript.Int64ValueJSON._readMessage(m, _int64Field_);
      msg.int64Field = m;
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      const m = protoscript.UInt64Value.initialize();
      protoscript.UInt64ValueJSON._readMessage(m, _uint64Field_);
      msg.uint64Field = m;
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      const m = protoscript.Int32Value.initialize();
      protoscript.Int32ValueJSON._readMessage(m, _int32Field_);
      msg.int32Field = m;
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      const m = protoscript.UInt32Value.initialize();
      protoscript.UInt32ValueJSON._readMessage(m, _uint32Field_);
      msg.uint32Field = m;
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      const m = protoscript.BoolValue.initialize();
      protoscript.BoolValueJSON._readMessage(m, _boolField_);
      msg.boolField = m;
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      const m = protoscript.StringValue.initialize();
      protoscript.StringValueJSON._readMessage(m, _stringField_);
      msg.stringField = m;
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      const m = protoscript.BytesValue.initialize();
      protoscript.BytesValueJSON._readMessage(m, _bytesField_);
      msg.bytesField = m;
    }
    const _valueField_ = json["valueField"] ?? json["value_field"];
    if (_valueField_) {
      const m = protoscript.Value.initialize();
      protoscript.ValueJSON._readMessage(m, _valueField_);
      msg.valueField = m;
    }
    return msg;
  },
};

export const RepeatedWellKnownTypesJSON = {
  /**
   * Serializes RepeatedWellKnownTypes to JSON.
   */
  encode: function (msg: Partial<RepeatedWellKnownTypes>): string {
    return JSON.stringify(RepeatedWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes RepeatedWellKnownTypes from JSON.
   */
  decode: function (json: string): RepeatedWellKnownTypes {
    return RepeatedWellKnownTypesJSON._readMessage(
      RepeatedWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes RepeatedWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): RepeatedWellKnownTypes {
    return {
      anyField: [],
      apiField: [],
      durationField: [],
      emptyField: [],
      fieldMaskField: [],
      sourceContextField: [],
      structField: [],
      timestampField: [],
      typeField: [],
      doubleField: [],
      floatField: [],
      int64Field: [],
      uint64Field: [],
      int32Field: [],
      uint32Field: [],
      boolField: [],
      stringField: [],
      bytesField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField?.length) {
      json["anyField"] = msg.anyField.map(protoscript.AnyJSON._writeMessage);
    }
    if (msg.apiField?.length) {
      json["apiField"] = msg.apiField.map(protoscript.ApiJSON._writeMessage);
    }
    if (msg.durationField?.length) {
      json["durationField"] = msg.durationField.map(
        protoscript.DurationJSON._writeMessage
      );
    }
    if (msg.emptyField?.length) {
      json["emptyField"] = msg.emptyField.map(
        protoscript.EmptyJSON._writeMessage
      );
    }
    if (msg.fieldMaskField?.length) {
      json["fieldMaskField"] = msg.fieldMaskField.map(
        protoscript.FieldMaskJSON._writeMessage
      );
    }
    if (msg.sourceContextField?.length) {
      json["sourceContextField"] = msg.sourceContextField.map(
        protoscript.SourceContextJSON._writeMessage
      );
    }
    if (msg.structField?.length) {
      json["structField"] = msg.structField.map(
        protoscript.StructJSON._writeMessage
      );
    }
    if (msg.timestampField?.length) {
      json["timestampField"] = msg.timestampField.map(
        protoscript.TimestampJSON._writeMessage
      );
    }
    if (msg.typeField?.length) {
      json["typeField"] = msg.typeField.map(protoscript.TypeJSON._writeMessage);
    }
    if (msg.doubleField?.length) {
      json["doubleField"] = msg.doubleField.map(
        protoscript.DoubleValueJSON._writeMessage
      );
    }
    if (msg.floatField?.length) {
      json["floatField"] = msg.floatField.map(
        protoscript.FloatValueJSON._writeMessage
      );
    }
    if (msg.int64Field?.length) {
      json["int64Field"] = msg.int64Field.map(
        protoscript.Int64ValueJSON._writeMessage
      );
    }
    if (msg.uint64Field?.length) {
      json["uint64Field"] = msg.uint64Field.map(
        protoscript.UInt64ValueJSON._writeMessage
      );
    }
    if (msg.int32Field?.length) {
      json["int32Field"] = msg.int32Field.map(
        protoscript.Int32ValueJSON._writeMessage
      );
    }
    if (msg.uint32Field?.length) {
      json["uint32Field"] = msg.uint32Field.map(
        protoscript.UInt32ValueJSON._writeMessage
      );
    }
    if (msg.boolField?.length) {
      json["boolField"] = msg.boolField.map(
        protoscript.BoolValueJSON._writeMessage
      );
    }
    if (msg.stringField?.length) {
      json["stringField"] = msg.stringField.map(
        protoscript.StringValueJSON._writeMessage
      );
    }
    if (msg.bytesField?.length) {
      json["bytesField"] = msg.bytesField.map(
        protoscript.BytesValueJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedWellKnownTypes,
    json: any
  ): RepeatedWellKnownTypes {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      for (const item of _anyField_) {
        const m = protoscript.Any.initialize();
        protoscript.AnyJSON._readMessage(m, item);
        msg.anyField.push(m);
      }
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      for (const item of _apiField_) {
        const m = protoscript.Api.initialize();
        protoscript.ApiJSON._readMessage(m, item);
        msg.apiField.push(m);
      }
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      for (const item of _durationField_) {
        const m = protoscript.Duration.initialize();
        protoscript.DurationJSON._readMessage(m, item);
        msg.durationField.push(m);
      }
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      for (const item of _emptyField_) {
        const m = protoscript.Empty.initialize();
        protoscript.EmptyJSON._readMessage(m, item);
        msg.emptyField.push(m);
      }
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      for (const item of _fieldMaskField_) {
        const m = protoscript.FieldMask.initialize();
        protoscript.FieldMaskJSON._readMessage(m, item);
        msg.fieldMaskField.push(m);
      }
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      for (const item of _sourceContextField_) {
        const m = protoscript.SourceContext.initialize();
        protoscript.SourceContextJSON._readMessage(m, item);
        msg.sourceContextField.push(m);
      }
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      for (const item of _structField_) {
        const m = protoscript.Struct.initialize();
        protoscript.StructJSON._readMessage(m, item);
        msg.structField.push(m);
      }
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      for (const item of _timestampField_) {
        const m = protoscript.Timestamp.initialize();
        protoscript.TimestampJSON._readMessage(m, item);
        msg.timestampField.push(m);
      }
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      for (const item of _typeField_) {
        const m = protoscript.Type.initialize();
        protoscript.TypeJSON._readMessage(m, item);
        msg.typeField.push(m);
      }
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      for (const item of _doubleField_) {
        const m = protoscript.DoubleValue.initialize();
        protoscript.DoubleValueJSON._readMessage(m, item);
        msg.doubleField.push(m);
      }
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      for (const item of _floatField_) {
        const m = protoscript.FloatValue.initialize();
        protoscript.FloatValueJSON._readMessage(m, item);
        msg.floatField.push(m);
      }
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      for (const item of _int64Field_) {
        const m = protoscript.Int64Value.initialize();
        protoscript.Int64ValueJSON._readMessage(m, item);
        msg.int64Field.push(m);
      }
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      for (const item of _uint64Field_) {
        const m = protoscript.UInt64Value.initialize();
        protoscript.UInt64ValueJSON._readMessage(m, item);
        msg.uint64Field.push(m);
      }
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      for (const item of _int32Field_) {
        const m = protoscript.Int32Value.initialize();
        protoscript.Int32ValueJSON._readMessage(m, item);
        msg.int32Field.push(m);
      }
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      for (const item of _uint32Field_) {
        const m = protoscript.UInt32Value.initialize();
        protoscript.UInt32ValueJSON._readMessage(m, item);
        msg.uint32Field.push(m);
      }
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      for (const item of _boolField_) {
        const m = protoscript.BoolValue.initialize();
        protoscript.BoolValueJSON._readMessage(m, item);
        msg.boolField.push(m);
      }
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      for (const item of _stringField_) {
        const m = protoscript.StringValue.initialize();
        protoscript.StringValueJSON._readMessage(m, item);
        msg.stringField.push(m);
      }
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      for (const item of _bytesField_) {
        const m = protoscript.BytesValue.initialize();
        protoscript.BytesValueJSON._readMessage(m, item);
        msg.bytesField.push(m);
      }
    }
    return msg;
  },
};

export const OneofWellKnownTypesJSON = {
  /**
   * Serializes OneofWellKnownTypes to JSON.
   */
  encode: function (msg: Partial<OneofWellKnownTypes>): string {
    return JSON.stringify(OneofWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneofWellKnownTypes from JSON.
   */
  decode: function (json: string): OneofWellKnownTypes {
    return OneofWellKnownTypesJSON._readMessage(
      OneofWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OneofWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): OneofWellKnownTypes {
    return {
      anyField: undefined,
      apiField: undefined,
      durationField: undefined,
      emptyField: undefined,
      fieldMaskField: undefined,
      sourceContextField: undefined,
      structField: undefined,
      timestampField: undefined,
      typeField: undefined,
      doubleField: undefined,
      floatField: undefined,
      int64Field: undefined,
      uint64Field: undefined,
      int32Field: undefined,
      uint32Field: undefined,
      boolField: undefined,
      stringField: undefined,
      bytesField: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneofWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField != undefined) {
      const _anyField_ = protoscript.AnyJSON._writeMessage(msg.anyField);
      json["anyField"] = _anyField_;
    }
    if (msg.apiField != undefined) {
      const _apiField_ = protoscript.ApiJSON._writeMessage(msg.apiField);
      json["apiField"] = _apiField_;
    }
    if (msg.durationField != undefined) {
      const _durationField_ = protoscript.DurationJSON._writeMessage(
        msg.durationField
      );
      json["durationField"] = _durationField_;
    }
    if (msg.emptyField != undefined) {
      const _emptyField_ = protoscript.EmptyJSON._writeMessage(msg.emptyField);
      json["emptyField"] = _emptyField_;
    }
    if (msg.fieldMaskField != undefined) {
      const _fieldMaskField_ = protoscript.FieldMaskJSON._writeMessage(
        msg.fieldMaskField
      );
      json["fieldMaskField"] = _fieldMaskField_;
    }
    if (msg.sourceContextField != undefined) {
      const _sourceContextField_ = protoscript.SourceContextJSON._writeMessage(
        msg.sourceContextField
      );
      json["sourceContextField"] = _sourceContextField_;
    }
    if (msg.structField != undefined) {
      const _structField_ = protoscript.StructJSON._writeMessage(
        msg.structField
      );
      json["structField"] = _structField_;
    }
    if (msg.timestampField != undefined) {
      const _timestampField_ = protoscript.TimestampJSON._writeMessage(
        msg.timestampField
      );
      json["timestampField"] = _timestampField_;
    }
    if (msg.typeField != undefined) {
      const _typeField_ = protoscript.TypeJSON._writeMessage(msg.typeField);
      json["typeField"] = _typeField_;
    }
    if (msg.doubleField != undefined) {
      const _doubleField_ = protoscript.DoubleValueJSON._writeMessage(
        msg.doubleField
      );
      json["doubleField"] = _doubleField_;
    }
    if (msg.floatField != undefined) {
      const _floatField_ = protoscript.FloatValueJSON._writeMessage(
        msg.floatField
      );
      json["floatField"] = _floatField_;
    }
    if (msg.int64Field != undefined) {
      const _int64Field_ = protoscript.Int64ValueJSON._writeMessage(
        msg.int64Field
      );
      json["int64Field"] = _int64Field_;
    }
    if (msg.uint64Field != undefined) {
      const _uint64Field_ = protoscript.UInt64ValueJSON._writeMessage(
        msg.uint64Field
      );
      json["uint64Field"] = _uint64Field_;
    }
    if (msg.int32Field != undefined) {
      const _int32Field_ = protoscript.Int32ValueJSON._writeMessage(
        msg.int32Field
      );
      json["int32Field"] = _int32Field_;
    }
    if (msg.uint32Field != undefined) {
      const _uint32Field_ = protoscript.UInt32ValueJSON._writeMessage(
        msg.uint32Field
      );
      json["uint32Field"] = _uint32Field_;
    }
    if (msg.boolField != undefined) {
      const _boolField_ = protoscript.BoolValueJSON._writeMessage(
        msg.boolField
      );
      json["boolField"] = _boolField_;
    }
    if (msg.stringField != undefined) {
      const _stringField_ = protoscript.StringValueJSON._writeMessage(
        msg.stringField
      );
      json["stringField"] = _stringField_;
    }
    if (msg.bytesField != undefined) {
      const _bytesField_ = protoscript.BytesValueJSON._writeMessage(
        msg.bytesField
      );
      json["bytesField"] = _bytesField_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OneofWellKnownTypes,
    json: any
  ): OneofWellKnownTypes {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      const m = protoscript.Any.initialize();
      protoscript.AnyJSON._readMessage(m, _anyField_);
      msg.anyField = m;
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      const m = protoscript.Api.initialize();
      protoscript.ApiJSON._readMessage(m, _apiField_);
      msg.apiField = m;
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      const m = protoscript.Duration.initialize();
      protoscript.DurationJSON._readMessage(m, _durationField_);
      msg.durationField = m;
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      const m = protoscript.Empty.initialize();
      protoscript.EmptyJSON._readMessage(m, _emptyField_);
      msg.emptyField = m;
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      const m = protoscript.FieldMask.initialize();
      protoscript.FieldMaskJSON._readMessage(m, _fieldMaskField_);
      msg.fieldMaskField = m;
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      const m = protoscript.SourceContext.initialize();
      protoscript.SourceContextJSON._readMessage(m, _sourceContextField_);
      msg.sourceContextField = m;
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      const m = protoscript.Struct.initialize();
      protoscript.StructJSON._readMessage(m, _structField_);
      msg.structField = m;
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      const m = protoscript.Timestamp.initialize();
      protoscript.TimestampJSON._readMessage(m, _timestampField_);
      msg.timestampField = m;
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      const m = protoscript.Type.initialize();
      protoscript.TypeJSON._readMessage(m, _typeField_);
      msg.typeField = m;
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      const m = protoscript.DoubleValue.initialize();
      protoscript.DoubleValueJSON._readMessage(m, _doubleField_);
      msg.doubleField = m;
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      const m = protoscript.FloatValue.initialize();
      protoscript.FloatValueJSON._readMessage(m, _floatField_);
      msg.floatField = m;
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      const m = protoscript.Int64Value.initialize();
      protoscript.Int64ValueJSON._readMessage(m, _int64Field_);
      msg.int64Field = m;
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      const m = protoscript.UInt64Value.initialize();
      protoscript.UInt64ValueJSON._readMessage(m, _uint64Field_);
      msg.uint64Field = m;
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      const m = protoscript.Int32Value.initialize();
      protoscript.Int32ValueJSON._readMessage(m, _int32Field_);
      msg.int32Field = m;
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      const m = protoscript.UInt32Value.initialize();
      protoscript.UInt32ValueJSON._readMessage(m, _uint32Field_);
      msg.uint32Field = m;
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      const m = protoscript.BoolValue.initialize();
      protoscript.BoolValueJSON._readMessage(m, _boolField_);
      msg.boolField = m;
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      const m = protoscript.StringValue.initialize();
      protoscript.StringValueJSON._readMessage(m, _stringField_);
      msg.stringField = m;
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      const m = protoscript.BytesValue.initialize();
      protoscript.BytesValueJSON._readMessage(m, _bytesField_);
      msg.bytesField = m;
    }
    return msg;
  },
};

export const MapWellKnownTypesJSON = {
  /**
   * Serializes MapWellKnownTypes to JSON.
   */
  encode: function (msg: Partial<MapWellKnownTypes>): string {
    return JSON.stringify(MapWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes MapWellKnownTypes from JSON.
   */
  decode: function (json: string): MapWellKnownTypes {
    return MapWellKnownTypesJSON._readMessage(
      MapWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MapWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): MapWellKnownTypes {
    return {
      anyField: {},
      apiField: {},
      durationField: {},
      emptyField: {},
      fieldMaskField: {},
      sourceContextField: {},
      structField: {},
      timestampField: {},
      typeField: {},
      doubleField: {},
      floatField: {},
      int64Field: {},
      uint64Field: {},
      int32Field: {},
      uint32Field: {},
      boolField: {},
      stringField: {},
      bytesField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MapWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField) {
      const _anyField_ = Object.fromEntries(
        Object.entries(msg.anyField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.AnyField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_anyField_).length > 0) {
        json["anyField"] = _anyField_;
      }
    }
    if (msg.apiField) {
      const _apiField_ = Object.fromEntries(
        Object.entries(msg.apiField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.ApiField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_apiField_).length > 0) {
        json["apiField"] = _apiField_;
      }
    }
    if (msg.durationField) {
      const _durationField_ = Object.fromEntries(
        Object.entries(msg.durationField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.DurationField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_durationField_).length > 0) {
        json["durationField"] = _durationField_;
      }
    }
    if (msg.emptyField) {
      const _emptyField_ = Object.fromEntries(
        Object.entries(msg.emptyField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.EmptyField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_emptyField_).length > 0) {
        json["emptyField"] = _emptyField_;
      }
    }
    if (msg.fieldMaskField) {
      const _fieldMaskField_ = Object.fromEntries(
        Object.entries(msg.fieldMaskField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.FieldMaskField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_fieldMaskField_).length > 0) {
        json["fieldMaskField"] = _fieldMaskField_;
      }
    }
    if (msg.sourceContextField) {
      const _sourceContextField_ = Object.fromEntries(
        Object.entries(msg.sourceContextField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.SourceContextField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_sourceContextField_).length > 0) {
        json["sourceContextField"] = _sourceContextField_;
      }
    }
    if (msg.structField) {
      const _structField_ = Object.fromEntries(
        Object.entries(msg.structField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.StructField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_structField_).length > 0) {
        json["structField"] = _structField_;
      }
    }
    if (msg.timestampField) {
      const _timestampField_ = Object.fromEntries(
        Object.entries(msg.timestampField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.TimestampField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_timestampField_).length > 0) {
        json["timestampField"] = _timestampField_;
      }
    }
    if (msg.typeField) {
      const _typeField_ = Object.fromEntries(
        Object.entries(msg.typeField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.TypeField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_typeField_).length > 0) {
        json["typeField"] = _typeField_;
      }
    }
    if (msg.doubleField) {
      const _doubleField_ = Object.fromEntries(
        Object.entries(msg.doubleField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.DoubleField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_doubleField_).length > 0) {
        json["doubleField"] = _doubleField_;
      }
    }
    if (msg.floatField) {
      const _floatField_ = Object.fromEntries(
        Object.entries(msg.floatField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.FloatField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_floatField_).length > 0) {
        json["floatField"] = _floatField_;
      }
    }
    if (msg.int64Field) {
      const _int64Field_ = Object.fromEntries(
        Object.entries(msg.int64Field)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Int64Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_int64Field_).length > 0) {
        json["int64Field"] = _int64Field_;
      }
    }
    if (msg.uint64Field) {
      const _uint64Field_ = Object.fromEntries(
        Object.entries(msg.uint64Field)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Uint64Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_uint64Field_).length > 0) {
        json["uint64Field"] = _uint64Field_;
      }
    }
    if (msg.int32Field) {
      const _int32Field_ = Object.fromEntries(
        Object.entries(msg.int32Field)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Int32Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_int32Field_).length > 0) {
        json["int32Field"] = _int32Field_;
      }
    }
    if (msg.uint32Field) {
      const _uint32Field_ = Object.fromEntries(
        Object.entries(msg.uint32Field)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Uint32Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_uint32Field_).length > 0) {
        json["uint32Field"] = _uint32Field_;
      }
    }
    if (msg.boolField) {
      const _boolField_ = Object.fromEntries(
        Object.entries(msg.boolField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.BoolField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_boolField_).length > 0) {
        json["boolField"] = _boolField_;
      }
    }
    if (msg.stringField) {
      const _stringField_ = Object.fromEntries(
        Object.entries(msg.stringField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.StringField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_stringField_).length > 0) {
        json["stringField"] = _stringField_;
      }
    }
    if (msg.bytesField) {
      const _bytesField_ = Object.fromEntries(
        Object.entries(msg.bytesField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.BytesField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_bytesField_).length > 0) {
        json["bytesField"] = _bytesField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MapWellKnownTypes,
    json: any
  ): MapWellKnownTypes {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      msg.anyField = Object.fromEntries(
        Object.entries(_anyField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.AnyField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      msg.apiField = Object.fromEntries(
        Object.entries(_apiField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.ApiField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      msg.durationField = Object.fromEntries(
        Object.entries(_durationField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.DurationField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      msg.emptyField = Object.fromEntries(
        Object.entries(_emptyField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.EmptyField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      msg.fieldMaskField = Object.fromEntries(
        Object.entries(_fieldMaskField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.FieldMaskField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      msg.sourceContextField = Object.fromEntries(
        Object.entries(_sourceContextField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.SourceContextField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      msg.structField = Object.fromEntries(
        Object.entries(_structField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.StructField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      msg.timestampField = Object.fromEntries(
        Object.entries(_timestampField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.TimestampField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      msg.typeField = Object.fromEntries(
        Object.entries(_typeField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.TypeField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      msg.doubleField = Object.fromEntries(
        Object.entries(_doubleField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.DoubleField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      msg.floatField = Object.fromEntries(
        Object.entries(_floatField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.FloatField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      msg.int64Field = Object.fromEntries(
        Object.entries(_int64Field_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Int64Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      msg.uint64Field = Object.fromEntries(
        Object.entries(_uint64Field_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Uint64Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      msg.int32Field = Object.fromEntries(
        Object.entries(_int32Field_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Int32Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      msg.uint32Field = Object.fromEntries(
        Object.entries(_uint32Field_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Uint32Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      msg.boolField = Object.fromEntries(
        Object.entries(_boolField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.BoolField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      msg.stringField = Object.fromEntries(
        Object.entries(_stringField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.StringField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      msg.bytesField = Object.fromEntries(
        Object.entries(_bytesField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.BytesField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  AnyField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.AnyField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.AnyJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.AnyField,
      json: any
    ): MapWellKnownTypes.AnyField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Any.initialize();
        protoscript.AnyJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  ApiField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.ApiField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.ApiJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.ApiField,
      json: any
    ): MapWellKnownTypes.ApiField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Api.initialize();
        protoscript.ApiJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  DurationField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.DurationField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.DurationJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.DurationField,
      json: any
    ): MapWellKnownTypes.DurationField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Duration.initialize();
        protoscript.DurationJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  EmptyField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.EmptyField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.EmptyJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.EmptyField,
      json: any
    ): MapWellKnownTypes.EmptyField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Empty.initialize();
        protoscript.EmptyJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  FieldMaskField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.FieldMaskField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.FieldMaskJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.FieldMaskField,
      json: any
    ): MapWellKnownTypes.FieldMaskField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.FieldMask.initialize();
        protoscript.FieldMaskJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  SourceContextField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.SourceContextField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.SourceContextJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.SourceContextField,
      json: any
    ): MapWellKnownTypes.SourceContextField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.SourceContext.initialize();
        protoscript.SourceContextJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  StructField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.StructField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.StructJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.StructField,
      json: any
    ): MapWellKnownTypes.StructField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Struct.initialize();
        protoscript.StructJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  TimestampField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.TimestampField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.TimestampJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.TimestampField,
      json: any
    ): MapWellKnownTypes.TimestampField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Timestamp.initialize();
        protoscript.TimestampJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  TypeField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.TypeField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.TypeJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.TypeField,
      json: any
    ): MapWellKnownTypes.TypeField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Type.initialize();
        protoscript.TypeJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  DoubleField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.DoubleField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.DoubleValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.DoubleField,
      json: any
    ): MapWellKnownTypes.DoubleField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.DoubleValue.initialize();
        protoscript.DoubleValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  FloatField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.FloatField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.FloatValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.FloatField,
      json: any
    ): MapWellKnownTypes.FloatField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.FloatValue.initialize();
        protoscript.FloatValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Int64Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Int64Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.Int64ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Int64Field,
      json: any
    ): MapWellKnownTypes.Int64Field {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Int64Value.initialize();
        protoscript.Int64ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint64Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Uint64Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.UInt64ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Uint64Field,
      json: any
    ): MapWellKnownTypes.Uint64Field {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.UInt64Value.initialize();
        protoscript.UInt64ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Int32Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Int32Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.Int32ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Int32Field,
      json: any
    ): MapWellKnownTypes.Int32Field {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Int32Value.initialize();
        protoscript.Int32ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint32Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Uint32Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.UInt32ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Uint32Field,
      json: any
    ): MapWellKnownTypes.Uint32Field {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.UInt32Value.initialize();
        protoscript.UInt32ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  BoolField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.BoolField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.BoolValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.BoolField,
      json: any
    ): MapWellKnownTypes.BoolField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.BoolValue.initialize();
        protoscript.BoolValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  StringField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.StringField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.StringValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.StringField,
      json: any
    ): MapWellKnownTypes.StringField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.StringValue.initialize();
        protoscript.StringValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  BytesField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.BytesField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.BytesValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.BytesField,
      json: any
    ): MapWellKnownTypes.BytesField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.BytesValue.initialize();
        protoscript.BytesValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
      ],
      [
        "google/protobuf/unittest_proto3.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";

import * as googleProtobufUnittest_import from "./unittest_import.pb";
import * as googleProtobufUnittest_import_public from "./unittest_import_public.pb";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum =
  | "FOREIGN_ZERO"
  | "FOREIGN_FOO"
  | "FOREIGN_BAR"
  | "FOREIGN_BAZ";

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: googleProtobufUnittest_import.ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalStringPiece: string;
  optionalCord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalPublicImportMessage: googleProtobufUnittest_import_public.PublicImportMessage;
  optionalLazyMessage: TestAllTypes.NestedMessage;
  optionalLazyImportMessage: googleProtobufUnittest_import.ImportMessage;
  /**
   * Repeated
   */
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: googleProtobufUnittest_import.ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  oneofUint32?: number | null | undefined;
  oneofNestedMessage?: TestAllTypes.NestedMessage | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

export declare namespace TestAllTypes {
  export type NestedEnum = "ZERO" | "FOO" | "BAR" | "BAZ" | "NEG";

  export interface NestedMessage {
    /**
     * The field name "b" fails to compile in proto1 because it conflicts with
     * a local variable named "b" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  fooEnum?: TestOneof2.NestedEnum | null | undefined;
}

export declare namespace TestOneof2 {
  export type NestedEnum = "UNKNOWN" | "FOO" | "BAR" | "BAZ";
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: "FOREIGN_ZERO",
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnum {
    switch (i) {
      case 0: {
        return "FOREIGN_ZERO";
      }
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnum): number {
    switch (i) {
      case "FOREIGN_ZERO": {
        return 0;
      }
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypes = {
  /**
   * Serializes TestAllTypes to protobuf.
   */
  encode: function (msg: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString() as any);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString() as any);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString() as any);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString() as any);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64String(10, msg.optionalSfixed64.toString() as any);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
      );
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        googleProtobufUnittest_import_public.PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        40,
        msg.repeatedSfixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writePackedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnum._toInt)
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            googleProtobufUnittest_import_public.PublicImportMessage
              ._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 32: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 33: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 34: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 35: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 36: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 37: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 38: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 39: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 40: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 41: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 42: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 43: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = googleProtobufUnittest_import.ImportMessage.initialize();
          reader.readMessage(
            m,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt)
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 52: {
          if (reader.isDelimited()) {
            msg.repeatedForeignEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.repeatedForeignEnum.push(
              ForeignEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          msg.oneofNestedMessage = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    ZERO: "ZERO",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypes.NestedEnum {
      switch (i) {
        case 0: {
          return "ZERO";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypes.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypes.NestedEnum): number {
      switch (i) {
        case "ZERO": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.NestedMessage>): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes TestPackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedUint32?.length) {
      writer.writePackedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedSint32?.length) {
      writer.writePackedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writePackedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.packedSfixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedFloat?.length) {
      writer.writePackedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writePackedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writePackedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writePackedEnum(103, msg.packedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.packedInt64.push(...reader.readPackedInt64String().map(BigInt));
          } else {
            msg.packedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.packedUint32.push(...reader.readPackedUint32());
          } else {
            msg.packedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.packedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.packedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.packedSint32.push(...reader.readPackedSint32());
          } else {
            msg.packedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.packedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.packedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.packedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.packedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.packedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.packedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.packedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.packedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.packedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.packedFloat.push(...reader.readPackedFloat());
          } else {
            msg.packedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.packedDouble.push(...reader.readPackedDouble());
          } else {
            msg.packedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.packedBool.push(...reader.readPackedBool());
          } else {
            msg.packedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.packedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.packedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes TestUnpackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        2,
        msg.repeatedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        4,
        msg.repeatedUint64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        6,
        msg.repeatedSint64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        8,
        msg.repeatedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        10,
        msg.repeatedSfixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        14,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt)
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 2: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 3: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 4: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 5: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 6: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 7: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 8: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 9: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 10: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 11: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 12: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 13: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 14: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt)
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes NestedTestAllTypes to protobuf.
   */
  encode: function (msg: Partial<NestedTestAllTypes>): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes ForeignMessage to protobuf.
   */
  encode: function (msg: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes TestEmptyMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestEmptyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestEmptyMessage,
    _reader: BinaryReader
  ): TestEmptyMessage {
    return _msg;
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes TestMessageWithDummy to protobuf.
   */
  encode: function (msg: Partial<TestMessageWithDummy>): Uint8Array {
    return TestMessageWithDummy._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMessageWithDummy from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageWithDummy {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageWithDummy>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    reader: BinaryReader
  ): TestMessageWithDummy {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes TestOneof2 to protobuf.
   */
  encode: function (msg: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooEnum: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnum._toInt(msg.fooEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    UNKNOWN: "UNKNOWN",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestOneof2.NestedEnum {
      switch (i) {
        case 0: {
          return "UNKNOWN";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestOneof2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestOneof2.NestedEnum): number {
      switch (i) {
        case "UNKNOWN": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ForeignEnumJSON = {
  FOREIGN_ZERO: "FOREIGN_ZERO",
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnum {
    switch (i) {
      case 0: {
        return "FOREIGN_ZERO";
      }
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnum): number {
    switch (i) {
      case "FOREIGN_ZERO": {
        return 0;
      }
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypesJSON = {
  /**
   * Serializes TestAllTypes to JSON.
   */
  encode: function (msg: Partial<TestAllTypes>): string {
    return JSON.stringify(TestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestAllTypes from JSON.
   */
  decode: function (json: string): TestAllTypes {
    return TestAllTypesJSON._readMessage(
      TestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessageJSON.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessageJSON.initialize(),
      optionalLazyMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalLazyImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json["optionalInt64"] = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json["optionalUint32"] = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json["optionalUint64"] = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json["optionalSint32"] = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json["optionalSint64"] = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json["optionalFixed32"] = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json["optionalFixed64"] = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json["optionalSfixed32"] = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json["optionalSfixed64"] = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json["optionalFloat"] = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json["optionalDouble"] = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json["optionalBool"] = msg.optionalBool;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalNestedMessage);
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    if (msg.optionalForeignMessage) {
      const _optionalForeignMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalForeignMessage
      );
      if (Object.keys(_optionalForeignMessage_).length > 0) {
        json["optionalForeignMessage"] = _optionalForeignMessage_;
      }
    }
    if (msg.optionalImportMessage) {
      const _optionalImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalImportMessage
        );
      if (Object.keys(_optionalImportMessage_).length > 0) {
        json["optionalImportMessage"] = _optionalImportMessage_;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      json["optionalNestedEnum"] = msg.optionalNestedEnum;
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json["optionalStringPiece"] = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json["optionalCord"] = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const _optionalPublicImportMessage_ =
        googleProtobufUnittest_import_public.PublicImportMessageJSON._writeMessage(
          msg.optionalPublicImportMessage
        );
      if (Object.keys(_optionalPublicImportMessage_).length > 0) {
        json["optionalPublicImportMessage"] = _optionalPublicImportMessage_;
      }
    }
    if (msg.optionalLazyMessage) {
      const _optionalLazyMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalLazyMessage);
      if (Object.keys(_optionalLazyMessage_).length > 0) {
        json["optionalLazyMessage"] = _optionalLazyMessage_;
      }
    }
    if (msg.optionalLazyImportMessage) {
      const _optionalLazyImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalLazyImportMessage
        );
      if (Object.keys(_optionalLazyImportMessage_).length > 0) {
        json["optionalLazyImportMessage"] = _optionalLazyImportMessage_;
      }
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json["repeatedString"] = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json["repeatedBytes"] = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json["repeatedNestedMessage"] = msg.repeatedNestedMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json["repeatedForeignMessage"] = msg.repeatedForeignMessage.map(
        ForeignMessageJSON._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json["repeatedImportMessage"] = msg.repeatedImportMessage.map(
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json["repeatedForeignEnum"] = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json["repeatedStringPiece"] = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json["repeatedCord"] = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json["repeatedLazyMessage"] = msg.repeatedLazyMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const _oneofNestedMessage_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.oneofNestedMessage
      );
      json["oneofNestedMessage"] = _oneofNestedMessage_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestAllTypes, json: any): TestAllTypes {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _optionalInt64_ = json["optionalInt64"] ?? json["optional_int64"];
    if (_optionalInt64_) {
      msg.optionalInt64 = BigInt(_optionalInt64_);
    }
    const _optionalUint32_ = json["optionalUint32"] ?? json["optional_uint32"];
    if (_optionalUint32_) {
      msg.optionalUint32 = _optionalUint32_;
    }
    const _optionalUint64_ = json["optionalUint64"] ?? json["optional_uint64"];
    if (_optionalUint64_) {
      msg.optionalUint64 = BigInt(_optionalUint64_);
    }
    const _optionalSint32_ = json["optionalSint32"] ?? json["optional_sint32"];
    if (_optionalSint32_) {
      msg.optionalSint32 = _optionalSint32_;
    }
    const _optionalSint64_ = json["optionalSint64"] ?? json["optional_sint64"];
    if (_optionalSint64_) {
      msg.optionalSint64 = BigInt(_optionalSint64_);
    }
    const _optionalFixed32_ =
      json["optionalFixed32"] ?? json["optional_fixed32"];
    if (_optionalFixed32_) {
      msg.optionalFixed32 = _optionalFixed32_;
    }
    const _optionalFixed64_ =
      json["optionalFixed64"] ?? json["optional_fixed64"];
    if (_optionalFixed64_) {
      msg.optionalFixed64 = BigInt(_optionalFixed64_);
    }
    const _optionalSfixed32_ =
      json["optionalSfixed32"] ?? json["optional_sfixed32"];
    if (_optionalSfixed32_) {
      msg.optionalSfixed32 = _optionalSfixed32_;
    }
    const _optionalSfixed64_ =
      json["optionalSfixed64"] ?? json["optional_sfixed64"];
    if (_optionalSfixed64_) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64_);
    }
    const _optionalFloat_ = json["optionalFloat"] ?? json["optional_float"];
    if (_optionalFloat_) {
      msg.optionalFloat = _optionalFloat_;
    }
    const _optionalDouble_ = json["optionalDouble"] ?? json["optional_double"];
    if (_optionalDouble_) {
      msg.optionalDouble = _optionalDouble_;
    }
    const _optionalBool_ = json["optionalBool"] ?? json["optional_bool"];
    if (_optionalBool_) {
      msg.optionalBool = _optionalBool_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalNestedMessage_);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage_ =
      json["optionalForeignMessage"] ?? json["optional_foreign_message"];
    if (_optionalForeignMessage_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _optionalForeignMessage_);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage_ =
      json["optionalImportMessage"] ?? json["optional_import_message"];
    if (_optionalImportMessage_) {
      const m = googleProtobufUnittest_import.ImportMessage.initialize();
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        m,
        _optionalImportMessage_
      );
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum_ =
      json["optionalNestedEnum"] ?? json["optional_nested_enum"];
    if (_optionalNestedEnum_) {
      msg.optionalNestedEnum = _optionalNestedEnum_;
    }
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    const _optionalStringPiece_ =
      json["optionalStringPiece"] ?? json["optional_string_piece"];
    if (_optionalStringPiece_) {
      msg.optionalStringPiece = _optionalStringPiece_;
    }
    const _optionalCord_ = json["optionalCord"] ?? json["optional_cord"];
    if (_optionalCord_) {
      msg.optionalCord = _optionalCord_;
    }
    const _optionalPublicImportMessage_ =
      json["optionalPublicImportMessage"] ??
      json["optional_public_import_message"];
    if (_optionalPublicImportMessage_) {
      const m =
        googleProtobufUnittest_import_public.PublicImportMessage.initialize();
      googleProtobufUnittest_import_public.PublicImportMessageJSON._readMessage(
        m,
        _optionalPublicImportMessage_
      );
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage_ =
      json["optionalLazyMessage"] ?? json["optional_lazy_message"];
    if (_optionalLazyMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalLazyMessage_);
      msg.optionalLazyMessage = m;
    }
    const _optionalLazyImportMessage_ =
      json["optionalLazyImportMessage"] ?? json["optional_lazy_import_message"];
    if (_optionalLazyImportMessage_) {
      const m = googleProtobufUnittest_import.ImportMessage.initialize();
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        m,
        _optionalLazyImportMessage_
      );
      msg.optionalLazyImportMessage = m;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedString_ = json["repeatedString"] ?? json["repeated_string"];
    if (_repeatedString_) {
      msg.repeatedString = _repeatedString_;
    }
    const _repeatedBytes_ = json["repeatedBytes"] ?? json["repeated_bytes"];
    if (_repeatedBytes_) {
      msg.repeatedBytes = _repeatedBytes_.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage_ =
      json["repeatedNestedMessage"] ?? json["repeated_nested_message"];
    if (_repeatedNestedMessage_) {
      for (const item of _repeatedNestedMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage_ =
      json["repeatedForeignMessage"] ?? json["repeated_foreign_message"];
    if (_repeatedForeignMessage_) {
      for (const item of _repeatedForeignMessage_) {
        const m = ForeignMessage.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage_ =
      json["repeatedImportMessage"] ?? json["repeated_import_message"];
    if (_repeatedImportMessage_) {
      for (const item of _repeatedImportMessage_) {
        const m = googleProtobufUnittest_import.ImportMessage.initialize();
        googleProtobufUnittest_import.ImportMessageJSON._readMessage(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    const _repeatedForeignEnum_ =
      json["repeatedForeignEnum"] ?? json["repeated_foreign_enum"];
    if (_repeatedForeignEnum_) {
      msg.repeatedForeignEnum = _repeatedForeignEnum_;
    }
    const _repeatedStringPiece_ =
      json["repeatedStringPiece"] ?? json["repeated_string_piece"];
    if (_repeatedStringPiece_) {
      msg.repeatedStringPiece = _repeatedStringPiece_;
    }
    const _repeatedCord_ = json["repeatedCord"] ?? json["repeated_cord"];
    if (_repeatedCord_) {
      msg.repeatedCord = _repeatedCord_;
    }
    const _repeatedLazyMessage_ =
      json["repeatedLazyMessage"] ?? json["repeated_lazy_message"];
    if (_repeatedLazyMessage_) {
      for (const item of _repeatedLazyMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofNestedMessage_ =
      json["oneofNestedMessage"] ?? json["oneof_nested_message"];
    if (_oneofNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _oneofNestedMessage_);
      msg.oneofNestedMessage = m;
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  NestedEnum: {
    ZERO: "ZERO",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypes.NestedEnum {
      switch (i) {
        case 0: {
          return "ZERO";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypes.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypes.NestedEnum): number {
      switch (i) {
        case "ZERO": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to JSON.
     */
    encode: function (msg: Partial<TestAllTypes.NestedMessage>): string {
      return JSON.stringify(TestAllTypesJSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from JSON.
     */
    decode: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypesJSON.NestedMessage._readMessage(
        TestAllTypesJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      json: any
    ): TestAllTypes.NestedMessage {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },
};

export const TestPackedTypesJSON = {
  /**
   * Serializes TestPackedTypes to JSON.
   */
  encode: function (msg: Partial<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestPackedTypes from JSON.
   */
  decode: function (json: string): TestPackedTypes {
    return TestPackedTypesJSON._readMessage(
      TestPackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json["packedInt64"] = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json["packedUint32"] = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json["packedUint64"] = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json["packedSint32"] = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json["packedSint64"] = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json["packedFixed32"] = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json["packedFixed64"] = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json["packedSfixed32"] = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json["packedSfixed64"] = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json["packedFloat"] = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json["packedDouble"] = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json["packedBool"] = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json["packedEnum"] = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestPackedTypes, json: any): TestPackedTypes {
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _packedInt64_ = json["packedInt64"] ?? json["packed_int64"];
    if (_packedInt64_) {
      msg.packedInt64 = _packedInt64_.map(BigInt);
    }
    const _packedUint32_ = json["packedUint32"] ?? json["packed_uint32"];
    if (_packedUint32_) {
      msg.packedUint32 = _packedUint32_;
    }
    const _packedUint64_ = json["packedUint64"] ?? json["packed_uint64"];
    if (_packedUint64_) {
      msg.packedUint64 = _packedUint64_.map(BigInt);
    }
    const _packedSint32_ = json["packedSint32"] ?? json["packed_sint32"];
    if (_packedSint32_) {
      msg.packedSint32 = _packedSint32_;
    }
    const _packedSint64_ = json["packedSint64"] ?? json["packed_sint64"];
    if (_packedSint64_) {
      msg.packedSint64 = _packedSint64_.map(BigInt);
    }
    const _packedFixed32_ = json["packedFixed32"] ?? json["packed_fixed32"];
    if (_packedFixed32_) {
      msg.packedFixed32 = _packedFixed32_;
    }
    const _packedFixed64_ = json["packedFixed64"] ?? json["packed_fixed64"];
    if (_packedFixed64_) {
      msg.packedFixed64 = _packedFixed64_.map(BigInt);
    }
    const _packedSfixed32_ = json["packedSfixed32"] ?? json["packed_sfixed32"];
    if (_packedSfixed32_) {
      msg.packedSfixed32 = _packedSfixed32_;
    }
    const _packedSfixed64_ = json["packedSfixed64"] ?? json["packed_sfixed64"];
    if (_packedSfixed64_) {
      msg.packedSfixed64 = _packedSfixed64_.map(BigInt);
    }
    const _packedFloat_ = json["packedFloat"] ?? json["packed_float"];
    if (_packedFloat_) {
      msg.packedFloat = _packedFloat_;
    }
    const _packedDouble_ = json["packedDouble"] ?? json["packed_double"];
    if (_packedDouble_) {
      msg.packedDouble = _packedDouble_;
    }
    const _packedBool_ = json["packedBool"] ?? json["packed_bool"];
    if (_packedBool_) {
      msg.packedBool = _packedBool_;
    }
    const _packedEnum_ = json["packedEnum"] ?? json["packed_enum"];
    if (_packedEnum_) {
      msg.packedEnum = _packedEnum_;
    }
    return msg;
  },
};

export const TestUnpackedTypesJSON = {
  /**
   * Serializes TestUnpackedTypes to JSON.
   */
  encode: function (msg: Partial<TestUnpackedTypes>): string {
    return JSON.stringify(TestUnpackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestUnpackedTypes from JSON.
   */
  decode: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypesJSON._readMessage(
      TestUnpackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    json: any
  ): TestUnpackedTypes {
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    return msg;
  },
};

export const NestedTestAllTypesJSON = {
  /**
   * Serializes NestedTestAllTypes to JSON.
   */
  encode: function (msg: Partial<NestedTestAllTypes>): string {
    return JSON.stringify(NestedTestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes NestedTestAllTypes from JSON.
   */
  decode: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypesJSON._readMessage(
      NestedTestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypesJSON.initialize(),
      payload: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const _child_ = NestedTestAllTypesJSON._writeMessage(msg.child);
      if (Object.keys(_child_).length > 0) {
        json["child"] = _child_;
      }
    }
    if (msg.payload) {
      const _payload_ = TestAllTypesJSON._writeMessage(msg.payload);
      if (Object.keys(_payload_).length > 0) {
        json["payload"] = _payload_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    json: any
  ): NestedTestAllTypes {
    const _child_ = json["child"];
    if (_child_) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypesJSON._readMessage(m, _child_);
      msg.child = m;
    }
    const _payload_ = json["payload"];
    if (_payload_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _payload_);
      msg.payload = m;
    }
    return msg;
  },
};

export const ForeignMessageJSON = {
  /**
   * Serializes ForeignMessage to JSON.
   */
  encode: function (msg: Partial<ForeignMessage>): string {
    return JSON.stringify(ForeignMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ForeignMessage from JSON.
   */
  decode: function (json: string): ForeignMessage {
    return ForeignMessageJSON._readMessage(
      ForeignMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json["c"] = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ForeignMessage, json: any): ForeignMessage {
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    return msg;
  },
};

export const TestEmptyMessageJSON = {
  /**
   * Serializes TestEmptyMessage to JSON.
   */
  encode: function (_msg?: Partial<TestEmptyMessage>): string {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessage from JSON.
   */
  decode: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestEmptyMessage>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestEmptyMessage, _json: any): TestEmptyMessage {
    return msg;
  },
};

export const TestMessageWithDummyJSON = {
  /**
   * Serializes TestMessageWithDummy to JSON.
   */
  encode: function (msg: Partial<TestMessageWithDummy>): string {
    return JSON.stringify(TestMessageWithDummyJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMessageWithDummy from JSON.
   */
  decode: function (json: string): TestMessageWithDummy {
    return TestMessageWithDummyJSON._readMessage(
      TestMessageWithDummyJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageWithDummy>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.dummy) {
      json["dummy"] = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    json: any
  ): TestMessageWithDummy {
    const _dummy_ = json["dummy"];
    if (_dummy_) {
      msg.dummy = _dummy_;
    }
    return msg;
  },
};

export const TestOneof2JSON = {
  /**
   * Serializes TestOneof2 to JSON.
   */
  encode: function (msg: Partial<TestOneof2>): string {
    return JSON.stringify(TestOneof2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof2 from JSON.
   */
  decode: function (json: string): TestOneof2 {
    return TestOneof2JSON._readMessage(
      TestOneof2JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooEnum: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<TestOneof2>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooEnum != undefined) {
      json["fooEnum"] = msg.fooEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, json: any): TestOneof2 {
    const _fooEnum_ = json["fooEnum"] ?? json["foo_enum"];
    if (_fooEnum_) {
      msg.fooEnum = _fooEnum_;
    }
    return msg;
  },

  NestedEnum: {
    UNKNOWN: "UNKNOWN",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestOneof2.NestedEnum {
      switch (i) {
        case 0: {
          return "UNKNOWN";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestOneof2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestOneof2.NestedEnum): number {
      switch (i) {
        case "UNKNOWN": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};
",
      ],
    ],
  ],
  "arrayIndexOffset_": -1,
  "convertedPrimitiveFields_": {},
  "messageId_": undefined,
  "pivot_": 1.7976931348623157e+308,
  "wrappers_": {
    "15": [
      {
        "array": [
          "twirpscript/services.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: twirpscript/services.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

/**
 * Size of a Hat, in inches.
 */
export interface Req {}

export declare namespace Req {
  export interface MakeHat {
    inches: number;
  }
}

/**
 * A Hat is a piece of headwear made by a Haberdasher.
 */
export interface Hat {
  inches: number;
  color: string;
  name: string;
}

//========================================//
//      Haberdasher Protobuf Client       //
//========================================//

/**
 * MakeHat produces a hat of mysterious, randomly-selected color!
 */
export async function MakeHat(
  makeHat: Req.MakeHat,
  config?: ClientConfiguration
): Promise<Hat> {
  const response = await PBrequest(
    "/Haberdasher/MakeHat",
    Req.MakeHat.encode(makeHat),
    config
  );
  return Hat.decode(response);
}

//========================================//
//        Haberdasher JSON Client         //
//========================================//

/**
 * MakeHat produces a hat of mysterious, randomly-selected color!
 */
export async function MakeHatJSON(
  makeHat: Req.MakeHat,
  config?: ClientConfiguration
): Promise<Hat> {
  const response = await JSONrequest(
    "/Haberdasher/MakeHat",
    ReqJSON.MakeHat.encode(makeHat),
    config
  );
  return HatJSON.decode(response);
}

//========================================//
//              Haberdasher               //
//========================================//

/**
 * Haberdasher service makes hats for clients.
 */
export interface Haberdasher<Context = unknown> {
  /**
   * MakeHat produces a hat of mysterious, randomly-selected color!
   */
  MakeHat: (makeHat: Req.MakeHat, context: Context) => Promise<Hat> | Hat;
}

export function createHaberdasher<Context>(service: Haberdasher<Context>) {
  return {
    name: "Haberdasher",
    methods: {
      MakeHat: {
        name: "MakeHat",
        handler: service.MakeHat,
        input: { protobuf: Req.MakeHat, json: ReqJSON.MakeHat },
        output: { protobuf: Hat, json: HatJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Req = {
  /**
   * Serializes Req to protobuf.
   */
  encode: function (_msg?: Partial<Req>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes Req from protobuf.
   */
  decode: function (_bytes?: ByteSource): Req {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function (): Req {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<Req>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg: Req, _reader: BinaryReader): Req {
    return _msg;
  },

  MakeHat: {
    /**
     * Serializes Req.MakeHat to protobuf.
     */
    encode: function (msg: Partial<Req.MakeHat>): Uint8Array {
      return Req.MakeHat._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.MakeHat from protobuf.
     */
    decode: function (bytes: ByteSource): Req.MakeHat {
      return Req.MakeHat._readMessage(
        Req.MakeHat.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes Req.MakeHat with all fields set to their default value.
     */
    initialize: function (): Req.MakeHat {
      return {
        inches: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.MakeHat>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.inches) {
        writer.writeInt32(1, msg.inches);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.MakeHat,
      reader: BinaryReader
    ): Req.MakeHat {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.inches = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Hat = {
  /**
   * Serializes Hat to protobuf.
   */
  encode: function (msg: Partial<Hat>): Uint8Array {
    return Hat._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Hat from protobuf.
   */
  decode: function (bytes: ByteSource): Hat {
    return Hat._readMessage(Hat.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Hat with all fields set to their default value.
   */
  initialize: function (): Hat {
    return {
      inches: 0,
      color: "",
      name: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Hat>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.inches) {
      writer.writeInt32(1, msg.inches);
    }
    if (msg.color) {
      writer.writeString(2, msg.color);
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Hat, reader: BinaryReader): Hat {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.inches = reader.readInt32();
          break;
        }
        case 2: {
          msg.color = reader.readString();
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ReqJSON = {
  /**
   * Serializes Req to JSON.
   */
  encode: function (_msg?: Partial<Req>): string {
    return "{}";
  },

  /**
   * Deserializes Req from JSON.
   */
  decode: function (_json?: string): Req {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function (): Req {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg: Partial<Req>): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: Req, _json: any): Req {
    return msg;
  },

  MakeHat: {
    /**
     * Serializes Req.MakeHat to JSON.
     */
    encode: function (msg: Partial<Req.MakeHat>): string {
      return JSON.stringify(ReqJSON.MakeHat._writeMessage(msg));
    },

    /**
     * Deserializes Req.MakeHat from JSON.
     */
    decode: function (json: string): Req.MakeHat {
      return ReqJSON.MakeHat._readMessage(
        ReqJSON.MakeHat.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes Req.MakeHat with all fields set to their default value.
     */
    initialize: function (): Req.MakeHat {
      return {
        inches: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Req.MakeHat>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.inches) {
        json["inches"] = msg.inches;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.MakeHat, json: any): Req.MakeHat {
      const _inches_ = json["inches"];
      if (_inches_) {
        msg.inches = _inches_;
      }
      return msg;
    },
  },
};

export const HatJSON = {
  /**
   * Serializes Hat to JSON.
   */
  encode: function (msg: Partial<Hat>): string {
    return JSON.stringify(HatJSON._writeMessage(msg));
  },

  /**
   * Deserializes Hat from JSON.
   */
  decode: function (json: string): Hat {
    return HatJSON._readMessage(HatJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Hat with all fields set to their default value.
   */
  initialize: function (): Hat {
    return {
      inches: 0,
      color: "",
      name: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Hat>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.inches) {
      json["inches"] = msg.inches;
    }
    if (msg.color) {
      json["color"] = msg.color;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Hat, json: any): Hat {
    const _inches_ = json["inches"];
    if (_inches_) {
      msg.inches = _inches_;
    }
    const _color_ = json["color"];
    if (_color_) {
      msg.color = _color_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "twirpscript/empty.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: twirpscript/empty.proto
/* eslint-disable */

import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";
import * as protoscript from "protoscript";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(
  empty: protoscript.Empty,
  config?: ClientConfiguration
): Promise<protoscript.Empty> {
  const response = await PBrequest(
    "/Foo/Bar",
    protoscript.Empty.encode(empty),
    config
  );
  return protoscript.Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(
  empty: protoscript.Empty,
  config?: ClientConfiguration
): Promise<protoscript.Empty> {
  const response = await JSONrequest(
    "/Foo/Bar",
    protoscript.EmptyJSON.encode(empty),
    config
  );
  return protoscript.EmptyJSON.decode(response);
}

//========================================//
//                  Foo                   //
//========================================//

export interface Foo<Context = unknown> {
  Bar: (
    empty: protoscript.Empty,
    context: Context
  ) => Promise<protoscript.Empty> | protoscript.Empty;
}

export function createFoo<Context>(service: Foo<Context>) {
  return {
    name: "Foo",
    methods: {
      Bar: {
        name: "Bar",
        handler: service.Bar,
        input: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
        output: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
      },
    },
  } as const;
}
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "google/protobuf/unittest_import_public.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";

//========================================//
//                 Types                  //
//========================================//

export interface PublicImportMessage {
  e: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes PublicImportMessage to protobuf.
   */
  encode: function (msg: Partial<PublicImportMessage>): Uint8Array {
    return PublicImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes PublicImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): PublicImportMessage {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes PublicImportMessage with all fields set to their default value.
   */
  initialize: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PublicImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PublicImportMessage,
    reader: BinaryReader
  ): PublicImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const PublicImportMessageJSON = {
  /**
   * Serializes PublicImportMessage to JSON.
   */
  encode: function (msg: Partial<PublicImportMessage>): string {
    return JSON.stringify(PublicImportMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes PublicImportMessage from JSON.
   */
  decode: function (json: string): PublicImportMessage {
    return PublicImportMessageJSON._readMessage(
      PublicImportMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes PublicImportMessage with all fields set to their default value.
   */
  initialize: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PublicImportMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.e) {
      json["e"] = msg.e;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PublicImportMessage,
    json: any
  ): PublicImportMessage {
    const _e_ = json["e"];
    if (_e_) {
      msg.e = _e_;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "google/protobuf/unittest_import.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = "IMPORT_FOO" | "IMPORT_BAR" | "IMPORT_BAZ";

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap = "UNKNOWN" | "FOO" | "BAR";

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: "IMPORT_FOO",
  IMPORT_BAR: "IMPORT_BAR",
  IMPORT_BAZ: "IMPORT_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ImportEnum {
    switch (i) {
      case 7: {
        return "IMPORT_FOO";
      }
      case 8: {
        return "IMPORT_BAR";
      }
      case 9: {
        return "IMPORT_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ImportEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ImportEnum): number {
    switch (i) {
      case "IMPORT_FOO": {
        return 7;
      }
      case "IMPORT_BAR": {
        return 8;
      }
      case "IMPORT_BAZ": {
        return 9;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ImportEnumForMap = {
  UNKNOWN: "UNKNOWN",
  FOO: "FOO",
  BAR: "BAR",
  /**
   * @private
   */
  _fromInt: function (i: number): ImportEnumForMap {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "FOO";
      }
      case 2: {
        return "BAR";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ImportEnumForMap;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ImportEnumForMap): number {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "FOO": {
        return 1;
      }
      case "BAR": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ImportMessage = {
  /**
   * Serializes ImportMessage to protobuf.
   */
  encode: function (msg: Partial<ImportMessage>): Uint8Array {
    return ImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ImportMessage {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ImportMessage,
    reader: BinaryReader
  ): ImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ImportEnumJSON = {
  IMPORT_FOO: "IMPORT_FOO",
  IMPORT_BAR: "IMPORT_BAR",
  IMPORT_BAZ: "IMPORT_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ImportEnum {
    switch (i) {
      case 7: {
        return "IMPORT_FOO";
      }
      case 8: {
        return "IMPORT_BAR";
      }
      case 9: {
        return "IMPORT_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ImportEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ImportEnum): number {
    switch (i) {
      case "IMPORT_FOO": {
        return 7;
      }
      case "IMPORT_BAR": {
        return 8;
      }
      case "IMPORT_BAZ": {
        return 9;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ImportEnumForMapJSON = {
  UNKNOWN: "UNKNOWN",
  FOO: "FOO",
  BAR: "BAR",
  /**
   * @private
   */
  _fromInt: function (i: number): ImportEnumForMap {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "FOO";
      }
      case 2: {
        return "BAR";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ImportEnumForMap;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ImportEnumForMap): number {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "FOO": {
        return 1;
      }
      case "BAR": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ImportMessageJSON = {
  /**
   * Serializes ImportMessage to JSON.
   */
  encode: function (msg: Partial<ImportMessage>): string {
    return JSON.stringify(ImportMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ImportMessage from JSON.
   */
  decode: function (json: string): ImportMessage {
    return ImportMessageJSON._readMessage(
      ImportMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ImportMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.d) {
      json["d"] = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ImportMessage, json: any): ImportMessage {
    const _d_ = json["d"];
    if (_d_) {
      msg.d = _d_;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "google/protobuf/unittest.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";
import * as googleProtobufUnittest_import from "./unittest_import.pb";
import * as googleProtobufUnittest_import_public from "./unittest_import_public.pb";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = "FOREIGN_FOO" | "FOREIGN_BAR" | "FOREIGN_BAZ";

/**
 * Test an enum that has multiple values with the same number.
 */
export type TestEnumWithDupValue = "FOO1" | "BAR1" | "BAZ" | "FOO2" | "BAR2";

/**
 * Test an enum with large, unordered values.
 */
export type TestSparseEnum =
  | "SPARSE_A"
  | "SPARSE_B"
  | "SPARSE_C"
  | "SPARSE_D"
  | "SPARSE_E"
  | "SPARSE_F"
  | "SPARSE_G";

export type VeryLargeEnum =
  | "ENUM_LABEL_DEFAULT"
  | "ENUM_LABEL_1"
  | "ENUM_LABEL_2"
  | "ENUM_LABEL_3"
  | "ENUM_LABEL_4"
  | "ENUM_LABEL_5"
  | "ENUM_LABEL_6"
  | "ENUM_LABEL_7"
  | "ENUM_LABEL_8"
  | "ENUM_LABEL_9"
  | "ENUM_LABEL_10"
  | "ENUM_LABEL_11"
  | "ENUM_LABEL_12"
  | "ENUM_LABEL_13"
  | "ENUM_LABEL_14"
  | "ENUM_LABEL_15"
  | "ENUM_LABEL_16"
  | "ENUM_LABEL_17"
  | "ENUM_LABEL_18"
  | "ENUM_LABEL_19"
  | "ENUM_LABEL_20"
  | "ENUM_LABEL_21"
  | "ENUM_LABEL_22"
  | "ENUM_LABEL_23"
  | "ENUM_LABEL_24"
  | "ENUM_LABEL_25"
  | "ENUM_LABEL_26"
  | "ENUM_LABEL_27"
  | "ENUM_LABEL_28"
  | "ENUM_LABEL_29"
  | "ENUM_LABEL_30"
  | "ENUM_LABEL_31"
  | "ENUM_LABEL_32"
  | "ENUM_LABEL_33"
  | "ENUM_LABEL_34"
  | "ENUM_LABEL_35"
  | "ENUM_LABEL_36"
  | "ENUM_LABEL_37"
  | "ENUM_LABEL_38"
  | "ENUM_LABEL_39"
  | "ENUM_LABEL_40"
  | "ENUM_LABEL_41"
  | "ENUM_LABEL_42"
  | "ENUM_LABEL_43"
  | "ENUM_LABEL_44"
  | "ENUM_LABEL_45"
  | "ENUM_LABEL_46"
  | "ENUM_LABEL_47"
  | "ENUM_LABEL_48"
  | "ENUM_LABEL_49"
  | "ENUM_LABEL_50"
  | "ENUM_LABEL_51"
  | "ENUM_LABEL_52"
  | "ENUM_LABEL_53"
  | "ENUM_LABEL_54"
  | "ENUM_LABEL_55"
  | "ENUM_LABEL_56"
  | "ENUM_LABEL_57"
  | "ENUM_LABEL_58"
  | "ENUM_LABEL_59"
  | "ENUM_LABEL_60"
  | "ENUM_LABEL_61"
  | "ENUM_LABEL_62"
  | "ENUM_LABEL_63"
  | "ENUM_LABEL_64"
  | "ENUM_LABEL_65"
  | "ENUM_LABEL_66"
  | "ENUM_LABEL_67"
  | "ENUM_LABEL_68"
  | "ENUM_LABEL_69"
  | "ENUM_LABEL_70"
  | "ENUM_LABEL_71"
  | "ENUM_LABEL_72"
  | "ENUM_LABEL_73"
  | "ENUM_LABEL_74"
  | "ENUM_LABEL_75"
  | "ENUM_LABEL_76"
  | "ENUM_LABEL_77"
  | "ENUM_LABEL_78"
  | "ENUM_LABEL_79"
  | "ENUM_LABEL_80"
  | "ENUM_LABEL_81"
  | "ENUM_LABEL_82"
  | "ENUM_LABEL_83"
  | "ENUM_LABEL_84"
  | "ENUM_LABEL_85"
  | "ENUM_LABEL_86"
  | "ENUM_LABEL_87"
  | "ENUM_LABEL_88"
  | "ENUM_LABEL_89"
  | "ENUM_LABEL_90"
  | "ENUM_LABEL_91"
  | "ENUM_LABEL_92"
  | "ENUM_LABEL_93"
  | "ENUM_LABEL_94"
  | "ENUM_LABEL_95"
  | "ENUM_LABEL_96"
  | "ENUM_LABEL_97"
  | "ENUM_LABEL_98"
  | "ENUM_LABEL_99"
  | "ENUM_LABEL_100";

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: googleProtobufUnittest_import.ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalImportEnum: googleProtobufUnittest_import.ImportEnum;
  optionalStringPiece: string;
  optionalCord: string;
  optionalPublicImportMessage: googleProtobufUnittest_import_public.PublicImportMessage;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalLazyMessage: TestAllTypes.NestedMessage;
  repeatedInt32: number[];
  /**
   * Repeated
   */
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: googleProtobufUnittest_import.ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedImportEnum: googleProtobufUnittest_import.ImportEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  defaultInt32: number;
  defaultInt64: bigint;
  /**
   * Singular with defaults
   */
  defaultUint32: number;
  defaultUint64: bigint;
  defaultSint32: number;
  defaultSint64: bigint;
  defaultFixed32: number;
  defaultFixed64: bigint;
  defaultSfixed32: number;
  defaultSfixed64: bigint;
  defaultFloat: number;
  defaultDouble: number;
  defaultBool: boolean;
  defaultString: string;
  defaultBytes: Uint8Array;
  defaultNestedEnum: TestAllTypes.NestedEnum;
  defaultForeignEnum: ForeignEnum;
  defaultImportEnum: googleProtobufUnittest_import.ImportEnum;
  defaultStringPiece: string;
  defaultCord: string;
  oneofUint32?: number | null | undefined;
  oneofNestedMessage?: TestAllTypes.NestedMessage | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

export declare namespace TestAllTypes {
  export type NestedEnum = "FOO" | "BAR" | "BAZ" | "NEG";

  export interface NestedMessage {
    /**
     * The field name "b" fails to compile in proto1 because it conflicts with
     * a local variable named "b" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }

  export interface OptionalGroup {
    a: number;
  }

  export interface RepeatedGroup {
    a: number;
  }
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
  repeatedChild: NestedTestAllTypes[];
}

export interface TestDeprecatedFields {
  deprecatedInt32: number;
  deprecatedInt32InOneof?: number | null | undefined;
}

export interface TestDeprecatedMessage {}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
  d: number;
}

export interface TestReservedFields {}

export interface TestAllExtensions {}

export interface OptionalGroup_extension {
  a: number;
}

export interface RepeatedGroup_extension {
  a: number;
}

export interface TestGroup {
  optionalForeignEnum: ForeignEnum;
}

export declare namespace TestGroup {
  export interface OptionalGroup {
    a: number;
  }
}

export interface TestGroupExtension {}

export interface TestNestedExtension {}

export declare namespace TestNestedExtension {
  export interface OptionalGroup_extension {
    a: number;
  }
}

export interface TestChildExtension {
  a: string;
  b: string;
  optionalExtension: TestAllExtensions;
}

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 */
export interface TestRequired {
  a: number;
  dummy2: number;
  b: number;
  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   */
  dummy4: number;
  dummy5: number;
  dummy6: number;
  dummy7: number;
  dummy8: number;
  dummy9: number;
  dummy10: number;
  dummy11: number;
  dummy12: number;
  dummy13: number;
  dummy14: number;
  dummy15: number;
  dummy16: number;
  dummy17: number;
  dummy18: number;
  dummy19: number;
  dummy20: number;
  dummy21: number;
  dummy22: number;
  dummy23: number;
  dummy24: number;
  dummy25: number;
  dummy26: number;
  dummy27: number;
  dummy28: number;
  dummy29: number;
  dummy30: number;
  dummy31: number;
  dummy32: number;
  c: number;
}

export interface TestRequiredForeign {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  dummy: number;
}

export interface TestRequiredMessage {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  requiredMessage: TestRequired;
}

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 */
export interface TestForeignNested {
  foreignNested: TestAllTypes.NestedMessage;
}

/**
 * TestEmptyMessage is used to test unknown field support.
 */
export interface TestEmptyMessage {}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 */
export interface TestEmptyMessageWithExtensions {}

/**
 * Needed for a Python test.
 */
export interface TestPickleNestedMessage {}

export declare namespace TestPickleNestedMessage {
  export interface NestedMessage {
    bb: number;
  }

  namespace NestedMessage {
    export interface NestedNestedMessage {
      cc: number;
    }
  }
}

export interface TestMultipleExtensionRanges {}

/**
 * Test that really large tag numbers don't break anything.
 */
export interface TestReallyLargeTagNumber {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   */
  a: number;
  bb: number;
}

export interface TestRecursiveMessage {
  a: TestRecursiveMessage;
  i: number;
}

/**
 * Test that mutual recursion works.
 */
export interface TestMutualRecursionA {
  bb: TestMutualRecursionB;
}

export declare namespace TestMutualRecursionA {
  export interface SubMessage {
    b: TestMutualRecursionB;
  }

  export interface SubGroup {
    subMessage: TestMutualRecursionA.SubMessage;
    notInThisScc: TestAllTypes;
  }
}

export interface TestMutualRecursionB {
  a: TestMutualRecursionA;
  optionalInt32: number;
}

export interface TestIsInitialized {
  subMessage: TestIsInitialized.SubMessage;
}

export declare namespace TestIsInitialized {
  export interface SubMessage {}

  namespace SubMessage {
    export interface SubGroup {
      i: number;
    }
  }
}

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 */
export interface TestDupFieldNumber {
  a: number;
}

export declare namespace TestDupFieldNumber {
  export interface Foo {
    a: number;
  }

  export interface Bar {
    a: number;
  }
}

/**
 * Additional messages for testing lazy fields.
 */
export interface TestEagerMessage {
  subMessage: TestAllTypes;
}

export interface TestLazyMessage {
  subMessage: TestAllTypes;
}

/**
 * Needed for a Python test.
 */
export interface TestNestedMessageHasBits {
  optionalNestedMessage: TestNestedMessageHasBits.NestedMessage;
}

export declare namespace TestNestedMessageHasBits {
  export interface NestedMessage {
    nestedmessageRepeatedInt32: number[];
    nestedmessageRepeatedForeignmessage: ForeignMessage[];
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 */
export interface TestCamelCaseFieldNames {
  PrimitiveField: number;
  StringField: string;
  EnumField: ForeignEnum;
  MessageField: ForeignMessage;
  StringPieceField: string;
  CordField: string;
  RepeatedPrimitiveField: number[];
  RepeatedStringField: string[];
  RepeatedEnumField: ForeignEnum[];
  RepeatedMessageField: ForeignMessage[];
  RepeatedStringPieceField: string[];
  RepeatedCordField: string[];
}

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 */
export interface TestFieldOrderings {
  myString: string;
  myInt: bigint;
  myFloat: number;
  optionalNestedMessage: TestFieldOrderings.NestedMessage;
}

export declare namespace TestFieldOrderings {
  export interface NestedMessage {
    oo: bigint;
    /**
     * The field name "b" fails to compile in proto1 because it conflicts with
     * a local variable named "b" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestExtensionOrderings1 {
  myString: string;
}

export interface TestExtensionOrderings2 {
  myString: string;
}

export declare namespace TestExtensionOrderings2 {
  export interface TestExtensionOrderings3 {
    myString: string;
  }
}

export interface TestExtremeDefaultValues {
  escapedBytes: Uint8Array;
  largeUint32: number;
  largeUint64: bigint;
  smallInt32: number;
  smallInt64: bigint;
  reallySmallInt32: number;
  reallySmallInt64: bigint;
  /**
   * The default value here is UTF-8 for "\\u1234".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   */
  utf8String: string;
  /**
   * Tests for single-precision floating-point values.
   */
  zeroFloat: number;
  oneFloat: number;
  smallFloat: number;
  negativeOneFloat: number;
  negativeFloat: number;
  /**
   * Using exponents
   */
  largeFloat: number;
  smallNegativeFloat: number;
  /**
   * Text for nonfinite floating-point values.
   */
  infDouble: number;
  negInfDouble: number;
  nanDouble: number;
  infFloat: number;
  negInfFloat: number;
  nanFloat: number;
  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, "\\?" is a valid way to escape ? in string
   * literals.
   */
  cppTrigraph: string;
  /**
   * String defaults containing the character '\\000'
   */
  stringWithZero: string;
  bytesWithZero: Uint8Array;
  stringPieceWithZero: string;
  cordWithZero: string;
  replacementString: string;
}

export interface SparseEnumMessage {
  sparseEnum: TestSparseEnum;
}

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 */
export interface OneString {
  data: string;
}

export interface MoreString {
  data: string[];
}

export interface OneBytes {
  data: Uint8Array;
}

export interface MoreBytes {
  data: Uint8Array[];
}

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 */
export interface Int32Message {
  data: number;
}

export interface Uint32Message {
  data: number;
}

export interface Int64Message {
  data: bigint;
}

export interface Uint64Message {
  data: bigint;
}

export interface BoolMessage {
  data: boolean;
}

/**
 * Test oneofs.
 */
export interface TestOneof {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooMessage?: TestAllTypes | null | undefined;
}

export declare namespace TestOneof {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneofBackwardsCompatible {
  fooInt: number;
  fooString: string;
  fooMessage: TestAllTypes;
}

export declare namespace TestOneofBackwardsCompatible {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneof2 {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooCord?: string | null | undefined;
  fooStringPiece?: string | null | undefined;
  fooBytes?: Uint8Array | null | undefined;
  fooEnum?: TestOneof2.NestedEnum | null | undefined;
  fooMessage?: TestOneof2.NestedMessage | null | undefined;
  fooLazyMessage?: TestOneof2.NestedMessage | null | undefined;
  barInt?: number | null | undefined;
  barString?: string | null | undefined;
  barCord?: string | null | undefined;
  barStringPiece?: string | null | undefined;
  barBytes?: Uint8Array | null | undefined;
  barEnum?: TestOneof2.NestedEnum | null | undefined;
  barStringWithEmptyDefault?: string | null | undefined;
  barCordWithEmptyDefault?: string | null | undefined;
  barStringPieceWithEmptyDefault?: string | null | undefined;
  barBytesWithEmptyDefault?: Uint8Array | null | undefined;
  bazInt: number;
  bazString: string;
}

export declare namespace TestOneof2 {
  export type NestedEnum = "FOO" | "BAR" | "BAZ";

  export interface FooGroup {
    a: number;
    b: string;
  }

  export interface NestedMessage {
    quxInt: bigint;
    corgeInt: number[];
  }
}

export interface TestRequiredOneof {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooMessage?: TestRequiredOneof.NestedMessage | null | undefined;
}

export declare namespace TestRequiredOneof {
  export interface NestedMessage {
    requiredDouble: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 */
export interface TestUnpackedTypes {
  unpackedInt32: number[];
  unpackedInt64: bigint[];
  unpackedUint32: number[];
  unpackedUint64: bigint[];
  unpackedSint32: number[];
  unpackedSint64: bigint[];
  unpackedFixed32: number[];
  unpackedFixed64: bigint[];
  unpackedSfixed32: number[];
  unpackedSfixed64: bigint[];
  unpackedFloat: number[];
  unpackedDouble: number[];
  unpackedBool: boolean[];
  unpackedEnum: ForeignEnum[];
}

export interface TestPackedExtensions {}

export interface TestUnpackedExtensions {}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 */
export interface TestDynamicExtensions {
  scalarExtension: number;
  enumExtension: ForeignEnum;
  dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType;
  messageExtension: ForeignMessage;
  dynamicMessageExtension: TestDynamicExtensions.DynamicMessageType;
  repeatedExtension: string[];
  packedExtension: number[];
}

export declare namespace TestDynamicExtensions {
  export type DynamicEnumType = "DYNAMIC_FOO" | "DYNAMIC_BAR" | "DYNAMIC_BAZ";

  export interface DynamicMessageType {
    dynamicField: number;
  }
}

export interface TestRepeatedScalarDifferentTagSizes {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   */
  repeatedFixed32: number[];
  /**
   * Check for a varint type, just for good measure.
   */
  repeatedInt32: number[];
  /**
   * These have two-byte tags.
   */
  repeatedFixed64: bigint[];
  repeatedInt64: bigint[];
  /**
   * Three byte tags.
   */
  repeatedFloat: number[];
  repeatedUint64: bigint[];
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 */
export interface TestParsingMerge {
  requiredAllTypes: TestAllTypes;
  optionalAllTypes: TestAllTypes;
  repeatedAllTypes: TestAllTypes[];
}

export declare namespace TestParsingMerge {
  /**
   * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
   * except that all fields are repeated. In the tests, we will serialize the
   * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
   * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
   * the corresponding required/optional fields in TestParsingMerge.
   */
  export interface RepeatedFieldsGenerator {
    field1: TestAllTypes[];
    field2: TestAllTypes[];
    field3: TestAllTypes[];
    ext1: TestAllTypes[];
    ext2: TestAllTypes[];
  }

  namespace RepeatedFieldsGenerator {
    export interface Group1 {
      field1: TestAllTypes;
    }

    export interface Group2 {
      field1: TestAllTypes;
    }
  }

  export interface OptionalGroup {
    optionalGroupAllTypes: TestAllTypes;
  }

  export interface RepeatedGroup {
    repeatedGroupAllTypes: TestAllTypes;
  }
}

export interface TestCommentInjectionMessage {
  /**
   * *\\/ <- This should not close the generated doc comment
   */
  a: string;
}

/**
 * Test that RPC services work.
 */
export interface FooRequest {}

export interface FooResponse {}

export interface FooClientMessage {}

export interface FooServerMessage {}

export interface BarRequest {}

export interface BarResponse {}

export interface TestJsonName {
  fieldName1: number;
  fieldName2: number;
  FieldName3: number;
  FieldName4: number;
  FIELDNAME5: number;
  fieldName6: number;
  fieldname7: number;
}

export interface TestHugeFieldNumbers {
  optionalInt32: number;
  fixed32: number;
  repeatedInt32: number[];
  packedInt32: number[];
  optionalEnum: ForeignEnum;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalMessage: ForeignMessage;
  stringStringMap: Record<
    string,
    TestHugeFieldNumbers.StringStringMap["value"] | undefined
  >;
  oneofUint32?: number | null | undefined;
  oneofTestAllTypes?: TestAllTypes | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

export declare namespace TestHugeFieldNumbers {
  export interface OptionalGroup {
    groupA: number;
  }

  interface StringStringMap {
    key: string;
    value: string;
  }
}

export interface TestExtensionInsideTable {
  field1: number;
  field2: number;
  field3: number;
  field4: number;
  field6: number;
  field7: number;
  field8: number;
  field9: number;
  field10: number;
}

export interface TestExtensionRangeSerialize {
  fooOne: number;
  fooTwo: number;
  fooThree: number;
  fooFour: number;
}

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await PBrequest(
    "/protobuf_unittest.TestService/Foo",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await PBrequest(
    "/protobuf_unittest.TestService/Bar",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await JSONrequest(
    "/protobuf_unittest.TestService/Foo",
    FooRequestJSON.encode(fooRequest),
    config
  );
  return FooResponseJSON.decode(response);
}

export async function BarJSON(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await JSONrequest(
    "/protobuf_unittest.TestService/Bar",
    BarRequestJSON.encode(barRequest),
    config
  );
  return BarResponseJSON.decode(response);
}

//========================================//
//              TestService               //
//========================================//

export interface TestService<Context = unknown> {
  Foo: (
    fooRequest: FooRequest,
    context: Context
  ) => Promise<FooResponse> | FooResponse;
  Bar: (
    barRequest: BarRequest,
    context: Context
  ) => Promise<BarResponse> | BarResponse;
}

export function createTestService<Context>(service: TestService<Context>) {
  return {
    name: "protobuf_unittest.TestService",
    methods: {
      Foo: {
        name: "Foo",
        handler: service.Foo,
        input: { protobuf: FooRequest, json: FooRequestJSON },
        output: { protobuf: FooResponse, json: FooResponseJSON },
      },
      Bar: {
        name: "Bar",
        handler: service.Bar,
        input: { protobuf: BarRequest, json: BarRequestJSON },
        output: { protobuf: BarResponse, json: BarResponseJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnum {
    switch (i) {
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnum): number {
    switch (i) {
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestEnumWithDupValue = {
  FOO1: "FOO1",
  BAR1: "BAR1",
  BAZ: "BAZ",
  FOO2: "FOO2",
  BAR2: "BAR2",
  /**
   * @private
   */
  _fromInt: function (i: number): TestEnumWithDupValue {
    switch (i) {
      case 1: {
        return "FOO1";
      }
      case 2: {
        return "BAR1";
      }
      case 3: {
        return "BAZ";
      }
      case 1: {
        return "FOO2";
      }
      case 2: {
        return "BAR2";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestEnumWithDupValue;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TestEnumWithDupValue): number {
    switch (i) {
      case "FOO1": {
        return 1;
      }
      case "BAR1": {
        return 2;
      }
      case "BAZ": {
        return 3;
      }
      case "FOO2": {
        return 1;
      }
      case "BAR2": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestSparseEnum = {
  SPARSE_A: "SPARSE_A",
  SPARSE_B: "SPARSE_B",
  SPARSE_C: "SPARSE_C",
  SPARSE_D: "SPARSE_D",
  SPARSE_E: "SPARSE_E",
  SPARSE_F: "SPARSE_F",
  SPARSE_G: "SPARSE_G",
  /**
   * @private
   */
  _fromInt: function (i: number): TestSparseEnum {
    switch (i) {
      case 123: {
        return "SPARSE_A";
      }
      case 62374: {
        return "SPARSE_B";
      }
      case 12589234: {
        return "SPARSE_C";
      }
      case -15: {
        return "SPARSE_D";
      }
      case -53452: {
        return "SPARSE_E";
      }
      case 0: {
        return "SPARSE_F";
      }
      case 2: {
        return "SPARSE_G";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestSparseEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TestSparseEnum): number {
    switch (i) {
      case "SPARSE_A": {
        return 123;
      }
      case "SPARSE_B": {
        return 62374;
      }
      case "SPARSE_C": {
        return 12589234;
      }
      case "SPARSE_D": {
        return -15;
      }
      case "SPARSE_E": {
        return -53452;
      }
      case "SPARSE_F": {
        return 0;
      }
      case "SPARSE_G": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: "ENUM_LABEL_DEFAULT",
  ENUM_LABEL_1: "ENUM_LABEL_1",
  ENUM_LABEL_2: "ENUM_LABEL_2",
  ENUM_LABEL_3: "ENUM_LABEL_3",
  ENUM_LABEL_4: "ENUM_LABEL_4",
  ENUM_LABEL_5: "ENUM_LABEL_5",
  ENUM_LABEL_6: "ENUM_LABEL_6",
  ENUM_LABEL_7: "ENUM_LABEL_7",
  ENUM_LABEL_8: "ENUM_LABEL_8",
  ENUM_LABEL_9: "ENUM_LABEL_9",
  ENUM_LABEL_10: "ENUM_LABEL_10",
  ENUM_LABEL_11: "ENUM_LABEL_11",
  ENUM_LABEL_12: "ENUM_LABEL_12",
  ENUM_LABEL_13: "ENUM_LABEL_13",
  ENUM_LABEL_14: "ENUM_LABEL_14",
  ENUM_LABEL_15: "ENUM_LABEL_15",
  ENUM_LABEL_16: "ENUM_LABEL_16",
  ENUM_LABEL_17: "ENUM_LABEL_17",
  ENUM_LABEL_18: "ENUM_LABEL_18",
  ENUM_LABEL_19: "ENUM_LABEL_19",
  ENUM_LABEL_20: "ENUM_LABEL_20",
  ENUM_LABEL_21: "ENUM_LABEL_21",
  ENUM_LABEL_22: "ENUM_LABEL_22",
  ENUM_LABEL_23: "ENUM_LABEL_23",
  ENUM_LABEL_24: "ENUM_LABEL_24",
  ENUM_LABEL_25: "ENUM_LABEL_25",
  ENUM_LABEL_26: "ENUM_LABEL_26",
  ENUM_LABEL_27: "ENUM_LABEL_27",
  ENUM_LABEL_28: "ENUM_LABEL_28",
  ENUM_LABEL_29: "ENUM_LABEL_29",
  ENUM_LABEL_30: "ENUM_LABEL_30",
  ENUM_LABEL_31: "ENUM_LABEL_31",
  ENUM_LABEL_32: "ENUM_LABEL_32",
  ENUM_LABEL_33: "ENUM_LABEL_33",
  ENUM_LABEL_34: "ENUM_LABEL_34",
  ENUM_LABEL_35: "ENUM_LABEL_35",
  ENUM_LABEL_36: "ENUM_LABEL_36",
  ENUM_LABEL_37: "ENUM_LABEL_37",
  ENUM_LABEL_38: "ENUM_LABEL_38",
  ENUM_LABEL_39: "ENUM_LABEL_39",
  ENUM_LABEL_40: "ENUM_LABEL_40",
  ENUM_LABEL_41: "ENUM_LABEL_41",
  ENUM_LABEL_42: "ENUM_LABEL_42",
  ENUM_LABEL_43: "ENUM_LABEL_43",
  ENUM_LABEL_44: "ENUM_LABEL_44",
  ENUM_LABEL_45: "ENUM_LABEL_45",
  ENUM_LABEL_46: "ENUM_LABEL_46",
  ENUM_LABEL_47: "ENUM_LABEL_47",
  ENUM_LABEL_48: "ENUM_LABEL_48",
  ENUM_LABEL_49: "ENUM_LABEL_49",
  ENUM_LABEL_50: "ENUM_LABEL_50",
  ENUM_LABEL_51: "ENUM_LABEL_51",
  ENUM_LABEL_52: "ENUM_LABEL_52",
  ENUM_LABEL_53: "ENUM_LABEL_53",
  ENUM_LABEL_54: "ENUM_LABEL_54",
  ENUM_LABEL_55: "ENUM_LABEL_55",
  ENUM_LABEL_56: "ENUM_LABEL_56",
  ENUM_LABEL_57: "ENUM_LABEL_57",
  ENUM_LABEL_58: "ENUM_LABEL_58",
  ENUM_LABEL_59: "ENUM_LABEL_59",
  ENUM_LABEL_60: "ENUM_LABEL_60",
  ENUM_LABEL_61: "ENUM_LABEL_61",
  ENUM_LABEL_62: "ENUM_LABEL_62",
  ENUM_LABEL_63: "ENUM_LABEL_63",
  ENUM_LABEL_64: "ENUM_LABEL_64",
  ENUM_LABEL_65: "ENUM_LABEL_65",
  ENUM_LABEL_66: "ENUM_LABEL_66",
  ENUM_LABEL_67: "ENUM_LABEL_67",
  ENUM_LABEL_68: "ENUM_LABEL_68",
  ENUM_LABEL_69: "ENUM_LABEL_69",
  ENUM_LABEL_70: "ENUM_LABEL_70",
  ENUM_LABEL_71: "ENUM_LABEL_71",
  ENUM_LABEL_72: "ENUM_LABEL_72",
  ENUM_LABEL_73: "ENUM_LABEL_73",
  ENUM_LABEL_74: "ENUM_LABEL_74",
  ENUM_LABEL_75: "ENUM_LABEL_75",
  ENUM_LABEL_76: "ENUM_LABEL_76",
  ENUM_LABEL_77: "ENUM_LABEL_77",
  ENUM_LABEL_78: "ENUM_LABEL_78",
  ENUM_LABEL_79: "ENUM_LABEL_79",
  ENUM_LABEL_80: "ENUM_LABEL_80",
  ENUM_LABEL_81: "ENUM_LABEL_81",
  ENUM_LABEL_82: "ENUM_LABEL_82",
  ENUM_LABEL_83: "ENUM_LABEL_83",
  ENUM_LABEL_84: "ENUM_LABEL_84",
  ENUM_LABEL_85: "ENUM_LABEL_85",
  ENUM_LABEL_86: "ENUM_LABEL_86",
  ENUM_LABEL_87: "ENUM_LABEL_87",
  ENUM_LABEL_88: "ENUM_LABEL_88",
  ENUM_LABEL_89: "ENUM_LABEL_89",
  ENUM_LABEL_90: "ENUM_LABEL_90",
  ENUM_LABEL_91: "ENUM_LABEL_91",
  ENUM_LABEL_92: "ENUM_LABEL_92",
  ENUM_LABEL_93: "ENUM_LABEL_93",
  ENUM_LABEL_94: "ENUM_LABEL_94",
  ENUM_LABEL_95: "ENUM_LABEL_95",
  ENUM_LABEL_96: "ENUM_LABEL_96",
  ENUM_LABEL_97: "ENUM_LABEL_97",
  ENUM_LABEL_98: "ENUM_LABEL_98",
  ENUM_LABEL_99: "ENUM_LABEL_99",
  ENUM_LABEL_100: "ENUM_LABEL_100",
  /**
   * @private
   */
  _fromInt: function (i: number): VeryLargeEnum {
    switch (i) {
      case 0: {
        return "ENUM_LABEL_DEFAULT";
      }
      case 1: {
        return "ENUM_LABEL_1";
      }
      case 2: {
        return "ENUM_LABEL_2";
      }
      case 3: {
        return "ENUM_LABEL_3";
      }
      case 4: {
        return "ENUM_LABEL_4";
      }
      case 5: {
        return "ENUM_LABEL_5";
      }
      case 6: {
        return "ENUM_LABEL_6";
      }
      case 7: {
        return "ENUM_LABEL_7";
      }
      case 8: {
        return "ENUM_LABEL_8";
      }
      case 9: {
        return "ENUM_LABEL_9";
      }
      case 10: {
        return "ENUM_LABEL_10";
      }
      case 11: {
        return "ENUM_LABEL_11";
      }
      case 12: {
        return "ENUM_LABEL_12";
      }
      case 13: {
        return "ENUM_LABEL_13";
      }
      case 14: {
        return "ENUM_LABEL_14";
      }
      case 15: {
        return "ENUM_LABEL_15";
      }
      case 16: {
        return "ENUM_LABEL_16";
      }
      case 17: {
        return "ENUM_LABEL_17";
      }
      case 18: {
        return "ENUM_LABEL_18";
      }
      case 19: {
        return "ENUM_LABEL_19";
      }
      case 20: {
        return "ENUM_LABEL_20";
      }
      case 21: {
        return "ENUM_LABEL_21";
      }
      case 22: {
        return "ENUM_LABEL_22";
      }
      case 23: {
        return "ENUM_LABEL_23";
      }
      case 24: {
        return "ENUM_LABEL_24";
      }
      case 25: {
        return "ENUM_LABEL_25";
      }
      case 26: {
        return "ENUM_LABEL_26";
      }
      case 27: {
        return "ENUM_LABEL_27";
      }
      case 28: {
        return "ENUM_LABEL_28";
      }
      case 29: {
        return "ENUM_LABEL_29";
      }
      case 30: {
        return "ENUM_LABEL_30";
      }
      case 31: {
        return "ENUM_LABEL_31";
      }
      case 32: {
        return "ENUM_LABEL_32";
      }
      case 33: {
        return "ENUM_LABEL_33";
      }
      case 34: {
        return "ENUM_LABEL_34";
      }
      case 35: {
        return "ENUM_LABEL_35";
      }
      case 36: {
        return "ENUM_LABEL_36";
      }
      case 37: {
        return "ENUM_LABEL_37";
      }
      case 38: {
        return "ENUM_LABEL_38";
      }
      case 39: {
        return "ENUM_LABEL_39";
      }
      case 40: {
        return "ENUM_LABEL_40";
      }
      case 41: {
        return "ENUM_LABEL_41";
      }
      case 42: {
        return "ENUM_LABEL_42";
      }
      case 43: {
        return "ENUM_LABEL_43";
      }
      case 44: {
        return "ENUM_LABEL_44";
      }
      case 45: {
        return "ENUM_LABEL_45";
      }
      case 46: {
        return "ENUM_LABEL_46";
      }
      case 47: {
        return "ENUM_LABEL_47";
      }
      case 48: {
        return "ENUM_LABEL_48";
      }
      case 49: {
        return "ENUM_LABEL_49";
      }
      case 50: {
        return "ENUM_LABEL_50";
      }
      case 51: {
        return "ENUM_LABEL_51";
      }
      case 52: {
        return "ENUM_LABEL_52";
      }
      case 53: {
        return "ENUM_LABEL_53";
      }
      case 54: {
        return "ENUM_LABEL_54";
      }
      case 55: {
        return "ENUM_LABEL_55";
      }
      case 56: {
        return "ENUM_LABEL_56";
      }
      case 57: {
        return "ENUM_LABEL_57";
      }
      case 58: {
        return "ENUM_LABEL_58";
      }
      case 59: {
        return "ENUM_LABEL_59";
      }
      case 60: {
        return "ENUM_LABEL_60";
      }
      case 61: {
        return "ENUM_LABEL_61";
      }
      case 62: {
        return "ENUM_LABEL_62";
      }
      case 63: {
        return "ENUM_LABEL_63";
      }
      case 64: {
        return "ENUM_LABEL_64";
      }
      case 65: {
        return "ENUM_LABEL_65";
      }
      case 66: {
        return "ENUM_LABEL_66";
      }
      case 67: {
        return "ENUM_LABEL_67";
      }
      case 68: {
        return "ENUM_LABEL_68";
      }
      case 69: {
        return "ENUM_LABEL_69";
      }
      case 70: {
        return "ENUM_LABEL_70";
      }
      case 71: {
        return "ENUM_LABEL_71";
      }
      case 72: {
        return "ENUM_LABEL_72";
      }
      case 73: {
        return "ENUM_LABEL_73";
      }
      case 74: {
        return "ENUM_LABEL_74";
      }
      case 75: {
        return "ENUM_LABEL_75";
      }
      case 76: {
        return "ENUM_LABEL_76";
      }
      case 77: {
        return "ENUM_LABEL_77";
      }
      case 78: {
        return "ENUM_LABEL_78";
      }
      case 79: {
        return "ENUM_LABEL_79";
      }
      case 80: {
        return "ENUM_LABEL_80";
      }
      case 81: {
        return "ENUM_LABEL_81";
      }
      case 82: {
        return "ENUM_LABEL_82";
      }
      case 83: {
        return "ENUM_LABEL_83";
      }
      case 84: {
        return "ENUM_LABEL_84";
      }
      case 85: {
        return "ENUM_LABEL_85";
      }
      case 86: {
        return "ENUM_LABEL_86";
      }
      case 87: {
        return "ENUM_LABEL_87";
      }
      case 88: {
        return "ENUM_LABEL_88";
      }
      case 89: {
        return "ENUM_LABEL_89";
      }
      case 90: {
        return "ENUM_LABEL_90";
      }
      case 91: {
        return "ENUM_LABEL_91";
      }
      case 92: {
        return "ENUM_LABEL_92";
      }
      case 93: {
        return "ENUM_LABEL_93";
      }
      case 94: {
        return "ENUM_LABEL_94";
      }
      case 95: {
        return "ENUM_LABEL_95";
      }
      case 96: {
        return "ENUM_LABEL_96";
      }
      case 97: {
        return "ENUM_LABEL_97";
      }
      case 98: {
        return "ENUM_LABEL_98";
      }
      case 99: {
        return "ENUM_LABEL_99";
      }
      case 100: {
        return "ENUM_LABEL_100";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as VeryLargeEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: VeryLargeEnum): number {
    switch (i) {
      case "ENUM_LABEL_DEFAULT": {
        return 0;
      }
      case "ENUM_LABEL_1": {
        return 1;
      }
      case "ENUM_LABEL_2": {
        return 2;
      }
      case "ENUM_LABEL_3": {
        return 3;
      }
      case "ENUM_LABEL_4": {
        return 4;
      }
      case "ENUM_LABEL_5": {
        return 5;
      }
      case "ENUM_LABEL_6": {
        return 6;
      }
      case "ENUM_LABEL_7": {
        return 7;
      }
      case "ENUM_LABEL_8": {
        return 8;
      }
      case "ENUM_LABEL_9": {
        return 9;
      }
      case "ENUM_LABEL_10": {
        return 10;
      }
      case "ENUM_LABEL_11": {
        return 11;
      }
      case "ENUM_LABEL_12": {
        return 12;
      }
      case "ENUM_LABEL_13": {
        return 13;
      }
      case "ENUM_LABEL_14": {
        return 14;
      }
      case "ENUM_LABEL_15": {
        return 15;
      }
      case "ENUM_LABEL_16": {
        return 16;
      }
      case "ENUM_LABEL_17": {
        return 17;
      }
      case "ENUM_LABEL_18": {
        return 18;
      }
      case "ENUM_LABEL_19": {
        return 19;
      }
      case "ENUM_LABEL_20": {
        return 20;
      }
      case "ENUM_LABEL_21": {
        return 21;
      }
      case "ENUM_LABEL_22": {
        return 22;
      }
      case "ENUM_LABEL_23": {
        return 23;
      }
      case "ENUM_LABEL_24": {
        return 24;
      }
      case "ENUM_LABEL_25": {
        return 25;
      }
      case "ENUM_LABEL_26": {
        return 26;
      }
      case "ENUM_LABEL_27": {
        return 27;
      }
      case "ENUM_LABEL_28": {
        return 28;
      }
      case "ENUM_LABEL_29": {
        return 29;
      }
      case "ENUM_LABEL_30": {
        return 30;
      }
      case "ENUM_LABEL_31": {
        return 31;
      }
      case "ENUM_LABEL_32": {
        return 32;
      }
      case "ENUM_LABEL_33": {
        return 33;
      }
      case "ENUM_LABEL_34": {
        return 34;
      }
      case "ENUM_LABEL_35": {
        return 35;
      }
      case "ENUM_LABEL_36": {
        return 36;
      }
      case "ENUM_LABEL_37": {
        return 37;
      }
      case "ENUM_LABEL_38": {
        return 38;
      }
      case "ENUM_LABEL_39": {
        return 39;
      }
      case "ENUM_LABEL_40": {
        return 40;
      }
      case "ENUM_LABEL_41": {
        return 41;
      }
      case "ENUM_LABEL_42": {
        return 42;
      }
      case "ENUM_LABEL_43": {
        return 43;
      }
      case "ENUM_LABEL_44": {
        return 44;
      }
      case "ENUM_LABEL_45": {
        return 45;
      }
      case "ENUM_LABEL_46": {
        return 46;
      }
      case "ENUM_LABEL_47": {
        return 47;
      }
      case "ENUM_LABEL_48": {
        return 48;
      }
      case "ENUM_LABEL_49": {
        return 49;
      }
      case "ENUM_LABEL_50": {
        return 50;
      }
      case "ENUM_LABEL_51": {
        return 51;
      }
      case "ENUM_LABEL_52": {
        return 52;
      }
      case "ENUM_LABEL_53": {
        return 53;
      }
      case "ENUM_LABEL_54": {
        return 54;
      }
      case "ENUM_LABEL_55": {
        return 55;
      }
      case "ENUM_LABEL_56": {
        return 56;
      }
      case "ENUM_LABEL_57": {
        return 57;
      }
      case "ENUM_LABEL_58": {
        return 58;
      }
      case "ENUM_LABEL_59": {
        return 59;
      }
      case "ENUM_LABEL_60": {
        return 60;
      }
      case "ENUM_LABEL_61": {
        return 61;
      }
      case "ENUM_LABEL_62": {
        return 62;
      }
      case "ENUM_LABEL_63": {
        return 63;
      }
      case "ENUM_LABEL_64": {
        return 64;
      }
      case "ENUM_LABEL_65": {
        return 65;
      }
      case "ENUM_LABEL_66": {
        return 66;
      }
      case "ENUM_LABEL_67": {
        return 67;
      }
      case "ENUM_LABEL_68": {
        return 68;
      }
      case "ENUM_LABEL_69": {
        return 69;
      }
      case "ENUM_LABEL_70": {
        return 70;
      }
      case "ENUM_LABEL_71": {
        return 71;
      }
      case "ENUM_LABEL_72": {
        return 72;
      }
      case "ENUM_LABEL_73": {
        return 73;
      }
      case "ENUM_LABEL_74": {
        return 74;
      }
      case "ENUM_LABEL_75": {
        return 75;
      }
      case "ENUM_LABEL_76": {
        return 76;
      }
      case "ENUM_LABEL_77": {
        return 77;
      }
      case "ENUM_LABEL_78": {
        return 78;
      }
      case "ENUM_LABEL_79": {
        return 79;
      }
      case "ENUM_LABEL_80": {
        return 80;
      }
      case "ENUM_LABEL_81": {
        return 81;
      }
      case "ENUM_LABEL_82": {
        return 82;
      }
      case "ENUM_LABEL_83": {
        return 83;
      }
      case "ENUM_LABEL_84": {
        return 84;
      }
      case "ENUM_LABEL_85": {
        return 85;
      }
      case "ENUM_LABEL_86": {
        return 86;
      }
      case "ENUM_LABEL_87": {
        return 87;
      }
      case "ENUM_LABEL_88": {
        return 88;
      }
      case "ENUM_LABEL_89": {
        return 89;
      }
      case "ENUM_LABEL_90": {
        return 90;
      }
      case "ENUM_LABEL_91": {
        return 91;
      }
      case "ENUM_LABEL_92": {
        return 92;
      }
      case "ENUM_LABEL_93": {
        return 93;
      }
      case "ENUM_LABEL_94": {
        return 94;
      }
      case "ENUM_LABEL_95": {
        return 95;
      }
      case "ENUM_LABEL_96": {
        return 96;
      }
      case "ENUM_LABEL_97": {
        return 97;
      }
      case "ENUM_LABEL_98": {
        return 98;
      }
      case "ENUM_LABEL_99": {
        return 99;
      }
      case "ENUM_LABEL_100": {
        return 100;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypes = {
  /**
   * Serializes TestAllTypes to protobuf.
   */
  encode: function (msg: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      defaultForeignEnum: ForeignEnum._fromInt(0),
      defaultImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      defaultStringPiece: "",
      defaultCord: "",
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString() as any);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString() as any);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString() as any);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString() as any);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64String(10, msg.optionalSfixed64.toString() as any);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
      );
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    if (
      msg.optionalImportEnum &&
      googleProtobufUnittest_import.ImportEnum._toInt(msg.optionalImportEnum)
    ) {
      writer.writeEnum(
        23,
        googleProtobufUnittest_import.ImportEnum._toInt(msg.optionalImportEnum)
      );
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        googleProtobufUnittest_import_public.PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        40,
        msg.repeatedSfixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writePackedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnum._toInt)
      );
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writePackedEnum(
        53,
        msg.repeatedImportEnum.map(
          googleProtobufUnittest_import.ImportEnum._toInt
        )
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString() as any);
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString() as any);
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString() as any);
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString() as any);
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64String(70, msg.defaultSfixed64.toString() as any);
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes?.length) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.defaultNestedEnum)
    ) {
      writer.writeEnum(
        81,
        TestAllTypes.NestedEnum._toInt(msg.defaultNestedEnum)
      );
    }
    if (msg.defaultForeignEnum && ForeignEnum._toInt(msg.defaultForeignEnum)) {
      writer.writeEnum(82, ForeignEnum._toInt(msg.defaultForeignEnum));
    }
    if (
      msg.defaultImportEnum &&
      googleProtobufUnittest_import.ImportEnum._toInt(msg.defaultImportEnum)
    ) {
      writer.writeEnum(
        83,
        googleProtobufUnittest_import.ImportEnum._toInt(msg.defaultImportEnum)
      );
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 23: {
          msg.optionalImportEnum =
            googleProtobufUnittest_import.ImportEnum._fromInt(
              reader.readEnum()
            );
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            googleProtobufUnittest_import_public.PublicImportMessage
              ._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 32: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 33: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 34: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 35: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 36: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 37: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 38: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 39: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 40: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 41: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 42: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 43: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = googleProtobufUnittest_import.ImportMessage.initialize();
          reader.readMessage(
            m,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt)
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 52: {
          if (reader.isDelimited()) {
            msg.repeatedForeignEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.repeatedForeignEnum.push(
              ForeignEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 53: {
          if (reader.isDelimited()) {
            msg.repeatedImportEnum.push(
              ...reader
                .readPackedEnum()
                .map(googleProtobufUnittest_import.ImportEnum._fromInt)
            );
          } else {
            msg.repeatedImportEnum.push(
              googleProtobufUnittest_import.ImportEnum._fromInt(
                reader.readEnum()
              )
            );
          }
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum()
          );
          break;
        }
        case 82: {
          msg.defaultForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 83: {
          msg.defaultImportEnum =
            googleProtobufUnittest_import.ImportEnum._fromInt(
              reader.readEnum()
            );
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          msg.oneofNestedMessage = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypes.NestedEnum {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypes.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypes.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.NestedMessage>): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.OptionalGroup>): Uint8Array {
      return TestAllTypes.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      reader: BinaryReader
    ): TestAllTypes.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.RepeatedGroup>): Uint8Array {
      return TestAllTypes.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      reader: BinaryReader
    ): TestAllTypes.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes NestedTestAllTypes to protobuf.
   */
  encode: function (msg: Partial<NestedTestAllTypes>): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild as any,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes TestDeprecatedFields to protobuf.
   */
  encode: function (msg: Partial<TestDeprecatedFields>): Uint8Array {
    return TestDeprecatedFields._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDeprecatedFields from protobuf.
   */
  decode: function (bytes: ByteSource): TestDeprecatedFields {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecatedInt32: 0,
      deprecatedInt32InOneof: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    reader: BinaryReader
  ): TestDeprecatedFields {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes TestDeprecatedMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestDeprecatedMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestDeprecatedMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestDeprecatedMessage {
    return {};
  },

  /**
   * Initializes TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestDeprecatedMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestDeprecatedMessage,
    _reader: BinaryReader
  ): TestDeprecatedMessage {
    return _msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes ForeignMessage to protobuf.
   */
  encode: function (msg: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes TestReservedFields to protobuf.
   */
  encode: function (_msg?: Partial<TestReservedFields>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestReservedFields from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestReservedFields {
    return {};
  },

  /**
   * Initializes TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestReservedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestReservedFields,
    _reader: BinaryReader
  ): TestReservedFields {
    return _msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes TestAllExtensions to protobuf.
   */
  encode: function (_msg?: Partial<TestAllExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestAllExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestAllExtensions {
    return {};
  },

  /**
   * Initializes TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestAllExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestAllExtensions,
    _reader: BinaryReader
  ): TestAllExtensions {
    return _msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes OptionalGroup_extension to protobuf.
   */
  encode: function (msg: Partial<OptionalGroup_extension>): Uint8Array {
    return OptionalGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes OptionalGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): OptionalGroup_extension {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OptionalGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    reader: BinaryReader
  ): OptionalGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes RepeatedGroup_extension to protobuf.
   */
  encode: function (msg: Partial<RepeatedGroup_extension>): Uint8Array {
    return RepeatedGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    reader: BinaryReader
  ): RepeatedGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes TestGroup to protobuf.
   */
  encode: function (msg: Partial<TestGroup>): Uint8Array {
    return TestGroup._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestGroup from protobuf.
   */
  decode: function (bytes: ByteSource): TestGroup {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optionalForeignEnum: ForeignEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestGroup>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, reader: BinaryReader): TestGroup {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestGroup.OptionalGroup to protobuf.
     */
    encode: function (msg: Partial<TestGroup.OptionalGroup>): Uint8Array {
      return TestGroup.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      reader: BinaryReader
    ): TestGroup.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes TestGroupExtension to protobuf.
   */
  encode: function (_msg?: Partial<TestGroupExtension>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestGroupExtension from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestGroupExtension {
    return {};
  },

  /**
   * Initializes TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestGroupExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestGroupExtension,
    _reader: BinaryReader
  ): TestGroupExtension {
    return _msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes TestNestedExtension to protobuf.
   */
  encode: function (_msg?: Partial<TestNestedExtension>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestNestedExtension from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestNestedExtension {
    return {};
  },

  /**
   * Initializes TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestNestedExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestNestedExtension,
    _reader: BinaryReader
  ): TestNestedExtension {
    return _msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Uint8Array {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      reader: BinaryReader
    ): TestNestedExtension.OptionalGroup_extension {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes TestChildExtension to protobuf.
   */
  encode: function (msg: Partial<TestChildExtension>): Uint8Array {
    return TestChildExtension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestChildExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestChildExtension {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: "",
      b: "",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestChildExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    reader: BinaryReader
  ): TestChildExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes TestRequired to protobuf.
   */
  encode: function (msg: Partial<TestRequired>): Uint8Array {
    return TestRequired._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequired from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequired {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequired>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequired,
    reader: BinaryReader
  ): TestRequired {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes TestRequiredForeign to protobuf.
   */
  encode: function (msg: Partial<TestRequiredForeign>): Uint8Array {
    return TestRequiredForeign._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredForeign from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredForeign {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredForeign>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    reader: BinaryReader
  ): TestRequiredForeign {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes TestRequiredMessage to protobuf.
   */
  encode: function (msg: Partial<TestRequiredMessage>): Uint8Array {
    return TestRequiredMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessage {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    reader: BinaryReader
  ): TestRequiredMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes TestForeignNested to protobuf.
   */
  encode: function (msg: Partial<TestForeignNested>): Uint8Array {
    return TestForeignNested._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestForeignNested from protobuf.
   */
  decode: function (bytes: ByteSource): TestForeignNested {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestForeignNested>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    reader: BinaryReader
  ): TestForeignNested {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes TestEmptyMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestEmptyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestEmptyMessage,
    _reader: BinaryReader
  ): TestEmptyMessage {
    return _msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (
    _msg?: Partial<TestEmptyMessageWithExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Initializes TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestEmptyMessageWithExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestEmptyMessageWithExtensions,
    _reader: BinaryReader
  ): TestEmptyMessageWithExtensions {
    return _msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes TestPickleNestedMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestPickleNestedMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestPickleNestedMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestPickleNestedMessage {
    return {};
  },

  /**
   * Initializes TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestPickleNestedMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestPickleNestedMessage,
    _reader: BinaryReader
  ): TestPickleNestedMessage {
    return _msg;
  },

  NestedMessage: {
    /**
     * Serializes TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): Uint8Array {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      reader: BinaryReader
    ): TestPickleNestedMessage.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Uint8Array {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        reader: BinaryReader
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes TestMultipleExtensionRanges to protobuf.
   */
  encode: function (_msg?: Partial<TestMultipleExtensionRanges>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestMultipleExtensionRanges from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Initializes TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestMultipleExtensionRanges>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestMultipleExtensionRanges,
    _reader: BinaryReader
  ): TestMultipleExtensionRanges {
    return _msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes TestReallyLargeTagNumber to protobuf.
   */
  encode: function (msg: Partial<TestReallyLargeTagNumber>): Uint8Array {
    return TestReallyLargeTagNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    reader: BinaryReader
  ): TestReallyLargeTagNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes TestRecursiveMessage to protobuf.
   */
  encode: function (msg: Partial<TestRecursiveMessage>): Uint8Array {
    return TestRecursiveMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRecursiveMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMessage {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    reader: BinaryReader
  ): TestRecursiveMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes TestMutualRecursionA to protobuf.
   */
  encode: function (msg: Partial<TestMutualRecursionA>): Uint8Array {
    return TestMutualRecursionA._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMutualRecursionA from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionA {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionA>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    reader: BinaryReader
  ): TestMutualRecursionA {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestMutualRecursionA.SubMessage>
    ): Uint8Array {
      return TestMutualRecursionA.SubMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      reader: BinaryReader
    ): TestMutualRecursionA.SubMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (msg: Partial<TestMutualRecursionA.SubGroup>): Uint8Array {
      return TestMutualRecursionA.SubGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      reader: BinaryReader
    ): TestMutualRecursionA.SubGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes TestMutualRecursionB to protobuf.
   */
  encode: function (msg: Partial<TestMutualRecursionB>): Uint8Array {
    return TestMutualRecursionB._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMutualRecursionB from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionB {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionB>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    reader: BinaryReader
  ): TestMutualRecursionB {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes TestIsInitialized to protobuf.
   */
  encode: function (msg: Partial<TestIsInitialized>): Uint8Array {
    return TestIsInitialized._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestIsInitialized from protobuf.
   */
  decode: function (bytes: ByteSource): TestIsInitialized {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestIsInitialized>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    reader: BinaryReader
  ): TestIsInitialized {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (
      _msg?: Partial<TestIsInitialized.SubMessage>
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (_bytes?: ByteSource): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Initializes TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: Partial<TestIsInitialized.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: TestIsInitialized.SubMessage,
      _reader: BinaryReader
    ): TestIsInitialized.SubMessage {
      return _msg;
    },

    SubGroup: {
      /**
       * Serializes TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Uint8Array {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        reader: BinaryReader
      ): TestIsInitialized.SubMessage.SubGroup {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes TestDupFieldNumber to protobuf.
   */
  encode: function (msg: Partial<TestDupFieldNumber>): Uint8Array {
    return TestDupFieldNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDupFieldNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestDupFieldNumber {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDupFieldNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    reader: BinaryReader
  ): TestDupFieldNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (msg: Partial<TestDupFieldNumber.Foo>): Uint8Array {
      return TestDupFieldNumber.Foo._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      reader: BinaryReader
    ): TestDupFieldNumber.Foo {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (msg: Partial<TestDupFieldNumber.Bar>): Uint8Array {
      return TestDupFieldNumber.Bar._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      reader: BinaryReader
    ): TestDupFieldNumber.Bar {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes TestEagerMessage to protobuf.
   */
  encode: function (msg: Partial<TestEagerMessage>): Uint8Array {
    return TestEagerMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestEagerMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEagerMessage {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEagerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEagerMessage,
    reader: BinaryReader
  ): TestEagerMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes TestLazyMessage to protobuf.
   */
  encode: function (msg: Partial<TestLazyMessage>): Uint8Array {
    return TestLazyMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestLazyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestLazyMessage {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestLazyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestLazyMessage,
    reader: BinaryReader
  ): TestLazyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes TestNestedMessageHasBits to protobuf.
   */
  encode: function (msg: Partial<TestNestedMessageHasBits>): Uint8Array {
    return TestNestedMessageHasBits._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes: ByteSource): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    reader: BinaryReader
  ): TestNestedMessageHasBits {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Uint8Array {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writePackedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage as any,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      reader: BinaryReader
    ): TestNestedMessageHasBits.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            if (reader.isDelimited()) {
              msg.nestedmessageRepeatedInt32.push(...reader.readPackedInt32());
            } else {
              msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            }
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes TestCamelCaseFieldNames to protobuf.
   */
  encode: function (msg: Partial<TestCamelCaseFieldNames>): Uint8Array {
    return TestCamelCaseFieldNames._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes: ByteSource): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: "",
      EnumField: ForeignEnum._fromInt(0),
      MessageField: ForeignMessage.initialize(),
      StringPieceField: "",
      CordField: "",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField && ForeignEnum._toInt(msg.EnumField)) {
      writer.writeEnum(3, ForeignEnum._toInt(msg.EnumField));
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writePackedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writePackedEnum(9, msg.RepeatedEnumField.map(ForeignEnum._toInt));
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    reader: BinaryReader
  ): TestCamelCaseFieldNames {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          if (reader.isDelimited()) {
            msg.RepeatedPrimitiveField.push(...reader.readPackedInt32());
          } else {
            msg.RepeatedPrimitiveField.push(reader.readInt32());
          }
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          if (reader.isDelimited()) {
            msg.RepeatedEnumField.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.RepeatedEnumField.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes TestFieldOrderings to protobuf.
   */
  encode: function (msg: Partial<TestFieldOrderings>): Uint8Array {
    return TestFieldOrderings._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestFieldOrderings from protobuf.
   */
  decode: function (bytes: ByteSource): TestFieldOrderings {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      myString: "",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestFieldOrderings>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString() as any);
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    reader: BinaryReader
  ): TestFieldOrderings {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestFieldOrderings.NestedMessage>
    ): Uint8Array {
      return TestFieldOrderings.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString() as any);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      reader: BinaryReader
    ): TestFieldOrderings.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes TestExtensionOrderings1 to protobuf.
   */
  encode: function (msg: Partial<TestExtensionOrderings1>): Uint8Array {
    return TestExtensionOrderings1._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    reader: BinaryReader
  ): TestExtensionOrderings1 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes TestExtensionOrderings2 to protobuf.
   */
  encode: function (msg: Partial<TestExtensionOrderings2>): Uint8Array {
    return TestExtensionOrderings2._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    reader: BinaryReader
  ): TestExtensionOrderings2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Uint8Array {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        myString: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      reader: BinaryReader
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes TestExtremeDefaultValues to protobuf.
   */
  encode: function (msg: Partial<TestExtremeDefaultValues>): Uint8Array {
    return TestExtremeDefaultValues._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: "",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: "",
      stringWithZero: "",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: "",
      cordWithZero: "",
      replacementString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.escapedBytes?.length) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString() as any);
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString() as any);
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString() as any);
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero?.length) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    reader: BinaryReader
  ): TestExtremeDefaultValues {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes SparseEnumMessage to protobuf.
   */
  encode: function (msg: Partial<SparseEnumMessage>): Uint8Array {
    return SparseEnumMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes SparseEnumMessage from protobuf.
   */
  decode: function (bytes: ByteSource): SparseEnumMessage {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparseEnum: TestSparseEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SparseEnumMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sparseEnum && TestSparseEnum._toInt(msg.sparseEnum)) {
      writer.writeEnum(1, TestSparseEnum._toInt(msg.sparseEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    reader: BinaryReader
  ): SparseEnumMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = TestSparseEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes OneString to protobuf.
   */
  encode: function (msg: Partial<OneString>): Uint8Array {
    return OneString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes OneString from protobuf.
   */
  decode: function (bytes: ByteSource): OneString {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, reader: BinaryReader): OneString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes MoreString to protobuf.
   */
  encode: function (msg: Partial<MoreString>): Uint8Array {
    return MoreString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes MoreString from protobuf.
   */
  decode: function (bytes: ByteSource): MoreString {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, reader: BinaryReader): MoreString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes OneBytes to protobuf.
   */
  encode: function (msg: Partial<OneBytes>): Uint8Array {
    return OneBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes OneBytes from protobuf.
   */
  decode: function (bytes: ByteSource): OneBytes {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, reader: BinaryReader): OneBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes MoreBytes to protobuf.
   */
  encode: function (msg: Partial<MoreBytes>): Uint8Array {
    return MoreBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes MoreBytes from protobuf.
   */
  decode: function (bytes: ByteSource): MoreBytes {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, reader: BinaryReader): MoreBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes Int32Message to protobuf.
   */
  encode: function (msg: Partial<Int32Message>): Uint8Array {
    return Int32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Int32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int32Message {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int32Message,
    reader: BinaryReader
  ): Int32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes Uint32Message to protobuf.
   */
  encode: function (msg: Partial<Uint32Message>): Uint8Array {
    return Uint32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Uint32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint32Message {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint32Message,
    reader: BinaryReader
  ): Uint32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes Int64Message to protobuf.
   */
  encode: function (msg: Partial<Int64Message>): Uint8Array {
    return Int64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Int64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int64Message {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int64Message,
    reader: BinaryReader
  ): Int64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes Uint64Message to protobuf.
   */
  encode: function (msg: Partial<Uint64Message>): Uint8Array {
    return Uint64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes Uint64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint64Message {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint64Message,
    reader: BinaryReader
  ): Uint64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes BoolMessage to protobuf.
   */
  encode: function (msg: Partial<BoolMessage>): Uint8Array {
    return BoolMessage._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes BoolMessage from protobuf.
   */
  decode: function (bytes: ByteSource): BoolMessage {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BoolMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, reader: BinaryReader): BoolMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes TestOneof to protobuf.
   */
  encode: function (msg: Partial<TestOneof>): Uint8Array {
    return TestOneof._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, reader: BinaryReader): TestOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooMessage = TestAllTypes.initialize();
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneof.FooGroup to protobuf.
     */
    encode: function (msg: Partial<TestOneof.FooGroup>): Uint8Array {
      return TestOneof.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      reader: BinaryReader
    ): TestOneof.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (msg: Partial<TestOneofBackwardsCompatible>): Uint8Array {
    return TestOneofBackwardsCompatible._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      fooInt: 0,
      fooString: "",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    reader: BinaryReader
  ): TestOneofBackwardsCompatible {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Uint8Array {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      reader: BinaryReader
    ): TestOneofBackwardsCompatible.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes TestOneof2 to protobuf.
   */
  encode: function (msg: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooCord: undefined,
      fooStringPiece: undefined,
      fooBytes: undefined,
      fooEnum: undefined,
      fooMessage: undefined,
      fooLazyMessage: undefined,
      barInt: undefined,
      barString: undefined,
      barCord: undefined,
      barStringPiece: undefined,
      barBytes: undefined,
      barEnum: undefined,
      barStringWithEmptyDefault: undefined,
      barCordWithEmptyDefault: undefined,
      barStringPieceWithEmptyDefault: undefined,
      barBytesWithEmptyDefault: undefined,
      bazInt: 0,
      bazString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes?.length) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnum._toInt(msg.fooEnum));
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes?.length) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, TestOneof2.NestedEnum._toInt(msg.barEnum));
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.fooMessage = TestOneof2.NestedMessage.initialize();
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          msg.fooLazyMessage = TestOneof2.NestedMessage.initialize();
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestOneof2.NestedEnum {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestOneof2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestOneof2.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  FooGroup: {
    /**
     * Serializes TestOneof2.FooGroup to protobuf.
     */
    encode: function (msg: Partial<TestOneof2.FooGroup>): Uint8Array {
      return TestOneof2.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      reader: BinaryReader
    ): TestOneof2.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes TestOneof2.NestedMessage to protobuf.
     */
    encode: function (msg: Partial<TestOneof2.NestedMessage>): Uint8Array {
      return TestOneof2.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString() as any);
      }
      if (msg.corgeInt?.length) {
        writer.writePackedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      reader: BinaryReader
    ): TestOneof2.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            if (reader.isDelimited()) {
              msg.corgeInt.push(...reader.readPackedInt32());
            } else {
              msg.corgeInt.push(reader.readInt32());
            }
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes TestRequiredOneof to protobuf.
   */
  encode: function (msg: Partial<TestRequiredOneof>): Uint8Array {
    return TestRequiredOneof._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredOneof {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    reader: BinaryReader
  ): TestRequiredOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooMessage = TestRequiredOneof.NestedMessage.initialize();
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestRequiredOneof.NestedMessage>
    ): Uint8Array {
      return TestRequiredOneof.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      reader: BinaryReader
    ): TestRequiredOneof.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes TestPackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedUint32?.length) {
      writer.writePackedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedSint32?.length) {
      writer.writePackedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writePackedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.packedSfixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedFloat?.length) {
      writer.writePackedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writePackedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writePackedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writePackedEnum(103, msg.packedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.packedInt64.push(...reader.readPackedInt64String().map(BigInt));
          } else {
            msg.packedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.packedUint32.push(...reader.readPackedUint32());
          } else {
            msg.packedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.packedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.packedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.packedSint32.push(...reader.readPackedSint32());
          } else {
            msg.packedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.packedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.packedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.packedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.packedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.packedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.packedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.packedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.packedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.packedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.packedFloat.push(...reader.readPackedFloat());
          } else {
            msg.packedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.packedDouble.push(...reader.readPackedDouble());
          } else {
            msg.packedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.packedBool.push(...reader.readPackedBool());
          } else {
            msg.packedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.packedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.packedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes TestUnpackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.unpackedInt32?.length) {
      writer.writePackedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.unpackedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.unpackedUint32?.length) {
      writer.writePackedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.unpackedUint64.map((x) => x.toString() as any)
      );
    }
    if (msg.unpackedSint32?.length) {
      writer.writePackedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.unpackedSint64.map((x) => x.toString() as any)
      );
    }
    if (msg.unpackedFixed32?.length) {
      writer.writePackedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.unpackedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.unpackedSfixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.unpackedFloat?.length) {
      writer.writePackedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writePackedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writePackedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writePackedEnum(103, msg.unpackedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.unpackedInt32.push(...reader.readPackedInt32());
          } else {
            msg.unpackedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.unpackedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.unpackedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.unpackedUint32.push(...reader.readPackedUint32());
          } else {
            msg.unpackedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.unpackedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.unpackedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.unpackedSint32.push(...reader.readPackedSint32());
          } else {
            msg.unpackedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.unpackedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.unpackedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.unpackedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.unpackedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.unpackedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.unpackedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.unpackedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.unpackedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.unpackedFloat.push(...reader.readPackedFloat());
          } else {
            msg.unpackedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.unpackedDouble.push(...reader.readPackedDouble());
          } else {
            msg.unpackedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.unpackedBool.push(...reader.readPackedBool());
          } else {
            msg.unpackedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.unpackedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.unpackedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes TestPackedExtensions to protobuf.
   */
  encode: function (_msg?: Partial<TestPackedExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestPackedExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestPackedExtensions {
    return {};
  },

  /**
   * Initializes TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestPackedExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestPackedExtensions,
    _reader: BinaryReader
  ): TestPackedExtensions {
    return _msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes TestUnpackedExtensions to protobuf.
   */
  encode: function (_msg?: Partial<TestUnpackedExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestUnpackedExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestUnpackedExtensions {
    return {};
  },

  /**
   * Initializes TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestUnpackedExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestUnpackedExtensions,
    _reader: BinaryReader
  ): TestUnpackedExtensions {
    return _msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes TestDynamicExtensions to protobuf.
   */
  encode: function (msg: Partial<TestDynamicExtensions>): Uint8Array {
    return TestDynamicExtensions._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDynamicExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestDynamicExtensions {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnum._fromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType._fromInt(0),
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDynamicExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension && ForeignEnum._toInt(msg.enumExtension)) {
      writer.writeEnum(2001, ForeignEnum._toInt(msg.enumExtension));
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumType._toInt(msg.dynamicEnumExtension)
    ) {
      writer.writeEnum(
        2002,
        TestDynamicExtensions.DynamicEnumType._toInt(msg.dynamicEnumExtension)
      );
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writePackedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    reader: BinaryReader
  ): TestDynamicExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            TestDynamicExtensions.DynamicEnumType._fromInt(reader.readEnum());
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          if (reader.isDelimited()) {
            msg.packedExtension.push(...reader.readPackedSint32());
          } else {
            msg.packedExtension.push(reader.readSint32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: "DYNAMIC_FOO",
    DYNAMIC_BAR: "DYNAMIC_BAR",
    DYNAMIC_BAZ: "DYNAMIC_BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestDynamicExtensions.DynamicEnumType {
      switch (i) {
        case 2200: {
          return "DYNAMIC_FOO";
        }
        case 2201: {
          return "DYNAMIC_BAR";
        }
        case 2202: {
          return "DYNAMIC_BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestDynamicExtensions.DynamicEnumType;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestDynamicExtensions.DynamicEnumType): number {
      switch (i) {
        case "DYNAMIC_FOO": {
          return 2200;
        }
        case "DYNAMIC_BAR": {
          return 2201;
        }
        case "DYNAMIC_BAZ": {
          return 2202;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  DynamicMessageType: {
    /**
     * Serializes TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Uint8Array {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      reader: BinaryReader
    ): TestDynamicExtensions.DynamicMessageType {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Uint8Array {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes: ByteSource): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        2046,
        msg.repeatedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        2047,
        msg.repeatedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        262143,
        msg.repeatedUint64.map((x) => x.toString() as any)
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    reader: BinaryReader
  ): TestRepeatedScalarDifferentTagSizes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 13: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 2046: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 2047: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 262142: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 262143: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes TestParsingMerge to protobuf.
   */
  encode: function (msg: Partial<TestParsingMerge>): Uint8Array {
    return TestParsingMerge._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestParsingMerge from protobuf.
   */
  decode: function (bytes: ByteSource): TestParsingMerge {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestParsingMerge>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes as any,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestParsingMerge,
    reader: BinaryReader
  ): TestParsingMerge {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Uint8Array {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.field1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.field2 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(
          3,
          msg.field3 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(
          1000,
          msg.ext1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(
          1001,
          msg.ext2 as any,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedFieldsGenerator {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestParsingMerge.OptionalGroup>
    ): Uint8Array {
      return TestParsingMerge.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      reader: BinaryReader
    ): TestParsingMerge.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>
    ): Uint8Array {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes TestCommentInjectionMessage to protobuf.
   */
  encode: function (msg: Partial<TestCommentInjectionMessage>): Uint8Array {
    return TestCommentInjectionMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    reader: BinaryReader
  ): TestCommentInjectionMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes FooRequest to protobuf.
   */
  encode: function (_msg?: Partial<FooRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes FooRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooRequest {
    return {};
  },

  /**
   * Initializes FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg: FooRequest, _reader: BinaryReader): FooRequest {
    return _msg;
  },
};

export const FooResponse = {
  /**
   * Serializes FooResponse to protobuf.
   */
  encode: function (_msg?: Partial<FooResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes FooResponse from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooResponse {
    return {};
  },

  /**
   * Initializes FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: FooResponse,
    _reader: BinaryReader
  ): FooResponse {
    return _msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes FooClientMessage to protobuf.
   */
  encode: function (_msg?: Partial<FooClientMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes FooClientMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooClientMessage {
    return {};
  },

  /**
   * Initializes FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooClientMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: FooClientMessage,
    _reader: BinaryReader
  ): FooClientMessage {
    return _msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes FooServerMessage to protobuf.
   */
  encode: function (_msg?: Partial<FooServerMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes FooServerMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooServerMessage {
    return {};
  },

  /**
   * Initializes FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooServerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: FooServerMessage,
    _reader: BinaryReader
  ): FooServerMessage {
    return _msg;
  },
};

export const BarRequest = {
  /**
   * Serializes BarRequest to protobuf.
   */
  encode: function (_msg?: Partial<BarRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes BarRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): BarRequest {
    return {};
  },

  /**
   * Initializes BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<BarRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg: BarRequest, _reader: BinaryReader): BarRequest {
    return _msg;
  },
};

export const BarResponse = {
  /**
   * Serializes BarResponse to protobuf.
   */
  encode: function (_msg?: Partial<BarResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes BarResponse from protobuf.
   */
  decode: function (_bytes?: ByteSource): BarResponse {
    return {};
  },

  /**
   * Initializes BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<BarResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: BarResponse,
    _reader: BinaryReader
  ): BarResponse {
    return _msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes TestJsonName to protobuf.
   */
  encode: function (msg: Partial<TestJsonName>): Uint8Array {
    return TestJsonName._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestJsonName from protobuf.
   */
  decode: function (bytes: ByteSource): TestJsonName {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestJsonName>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestJsonName,
    reader: BinaryReader
  ): TestJsonName {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes TestHugeFieldNumbers to protobuf.
   */
  encode: function (msg: Partial<TestHugeFieldNumbers>): Uint8Array {
    return TestHugeFieldNumbers._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes: ByteSource): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnum._fromInt(0),
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofUint32: undefined,
      oneofTestAllTypes: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum && ForeignEnum._toInt(msg.optionalEnum)) {
      writer.writeEnum(536870004, ForeignEnum._toInt(msg.optionalEnum));
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      writer.writeRepeatedMessage(
        536870010,
        Object.entries(msg.stringStringMap).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestHugeFieldNumbers.StringStringMap._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    reader: BinaryReader
  ): TestHugeFieldNumbers {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 536870003: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 536870004: {
          msg.optionalEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          const map = {} as TestHugeFieldNumbers.StringStringMap;
          reader.readMessage(
            map,
            TestHugeFieldNumbers.StringStringMap._readMessage
          );
          msg.stringStringMap[map.key.toString()] = map.value;
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          msg.oneofTestAllTypes = TestAllTypes.initialize();
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Uint8Array {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      reader: BinaryReader
    ): TestHugeFieldNumbers.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.StringStringMap>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.StringStringMap,
      reader: BinaryReader
    ): TestHugeFieldNumbers.StringStringMap {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes TestExtensionInsideTable to protobuf.
   */
  encode: function (msg: Partial<TestExtensionInsideTable>): Uint8Array {
    return TestExtensionInsideTable._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    reader: BinaryReader
  ): TestExtensionInsideTable {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes TestExtensionRangeSerialize to protobuf.
   */
  encode: function (msg: Partial<TestExtensionRangeSerialize>): Uint8Array {
    return TestExtensionRangeSerialize._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    reader: BinaryReader
  ): TestExtensionRangeSerialize {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ForeignEnumJSON = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnum {
    switch (i) {
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnum): number {
    switch (i) {
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestEnumWithDupValueJSON = {
  FOO1: "FOO1",
  BAR1: "BAR1",
  BAZ: "BAZ",
  FOO2: "FOO2",
  BAR2: "BAR2",
  /**
   * @private
   */
  _fromInt: function (i: number): TestEnumWithDupValue {
    switch (i) {
      case 1: {
        return "FOO1";
      }
      case 2: {
        return "BAR1";
      }
      case 3: {
        return "BAZ";
      }
      case 1: {
        return "FOO2";
      }
      case 2: {
        return "BAR2";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestEnumWithDupValue;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TestEnumWithDupValue): number {
    switch (i) {
      case "FOO1": {
        return 1;
      }
      case "BAR1": {
        return 2;
      }
      case "BAZ": {
        return 3;
      }
      case "FOO2": {
        return 1;
      }
      case "BAR2": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestSparseEnumJSON = {
  SPARSE_A: "SPARSE_A",
  SPARSE_B: "SPARSE_B",
  SPARSE_C: "SPARSE_C",
  SPARSE_D: "SPARSE_D",
  SPARSE_E: "SPARSE_E",
  SPARSE_F: "SPARSE_F",
  SPARSE_G: "SPARSE_G",
  /**
   * @private
   */
  _fromInt: function (i: number): TestSparseEnum {
    switch (i) {
      case 123: {
        return "SPARSE_A";
      }
      case 62374: {
        return "SPARSE_B";
      }
      case 12589234: {
        return "SPARSE_C";
      }
      case -15: {
        return "SPARSE_D";
      }
      case -53452: {
        return "SPARSE_E";
      }
      case 0: {
        return "SPARSE_F";
      }
      case 2: {
        return "SPARSE_G";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestSparseEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TestSparseEnum): number {
    switch (i) {
      case "SPARSE_A": {
        return 123;
      }
      case "SPARSE_B": {
        return 62374;
      }
      case "SPARSE_C": {
        return 12589234;
      }
      case "SPARSE_D": {
        return -15;
      }
      case "SPARSE_E": {
        return -53452;
      }
      case "SPARSE_F": {
        return 0;
      }
      case "SPARSE_G": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const VeryLargeEnumJSON = {
  ENUM_LABEL_DEFAULT: "ENUM_LABEL_DEFAULT",
  ENUM_LABEL_1: "ENUM_LABEL_1",
  ENUM_LABEL_2: "ENUM_LABEL_2",
  ENUM_LABEL_3: "ENUM_LABEL_3",
  ENUM_LABEL_4: "ENUM_LABEL_4",
  ENUM_LABEL_5: "ENUM_LABEL_5",
  ENUM_LABEL_6: "ENUM_LABEL_6",
  ENUM_LABEL_7: "ENUM_LABEL_7",
  ENUM_LABEL_8: "ENUM_LABEL_8",
  ENUM_LABEL_9: "ENUM_LABEL_9",
  ENUM_LABEL_10: "ENUM_LABEL_10",
  ENUM_LABEL_11: "ENUM_LABEL_11",
  ENUM_LABEL_12: "ENUM_LABEL_12",
  ENUM_LABEL_13: "ENUM_LABEL_13",
  ENUM_LABEL_14: "ENUM_LABEL_14",
  ENUM_LABEL_15: "ENUM_LABEL_15",
  ENUM_LABEL_16: "ENUM_LABEL_16",
  ENUM_LABEL_17: "ENUM_LABEL_17",
  ENUM_LABEL_18: "ENUM_LABEL_18",
  ENUM_LABEL_19: "ENUM_LABEL_19",
  ENUM_LABEL_20: "ENUM_LABEL_20",
  ENUM_LABEL_21: "ENUM_LABEL_21",
  ENUM_LABEL_22: "ENUM_LABEL_22",
  ENUM_LABEL_23: "ENUM_LABEL_23",
  ENUM_LABEL_24: "ENUM_LABEL_24",
  ENUM_LABEL_25: "ENUM_LABEL_25",
  ENUM_LABEL_26: "ENUM_LABEL_26",
  ENUM_LABEL_27: "ENUM_LABEL_27",
  ENUM_LABEL_28: "ENUM_LABEL_28",
  ENUM_LABEL_29: "ENUM_LABEL_29",
  ENUM_LABEL_30: "ENUM_LABEL_30",
  ENUM_LABEL_31: "ENUM_LABEL_31",
  ENUM_LABEL_32: "ENUM_LABEL_32",
  ENUM_LABEL_33: "ENUM_LABEL_33",
  ENUM_LABEL_34: "ENUM_LABEL_34",
  ENUM_LABEL_35: "ENUM_LABEL_35",
  ENUM_LABEL_36: "ENUM_LABEL_36",
  ENUM_LABEL_37: "ENUM_LABEL_37",
  ENUM_LABEL_38: "ENUM_LABEL_38",
  ENUM_LABEL_39: "ENUM_LABEL_39",
  ENUM_LABEL_40: "ENUM_LABEL_40",
  ENUM_LABEL_41: "ENUM_LABEL_41",
  ENUM_LABEL_42: "ENUM_LABEL_42",
  ENUM_LABEL_43: "ENUM_LABEL_43",
  ENUM_LABEL_44: "ENUM_LABEL_44",
  ENUM_LABEL_45: "ENUM_LABEL_45",
  ENUM_LABEL_46: "ENUM_LABEL_46",
  ENUM_LABEL_47: "ENUM_LABEL_47",
  ENUM_LABEL_48: "ENUM_LABEL_48",
  ENUM_LABEL_49: "ENUM_LABEL_49",
  ENUM_LABEL_50: "ENUM_LABEL_50",
  ENUM_LABEL_51: "ENUM_LABEL_51",
  ENUM_LABEL_52: "ENUM_LABEL_52",
  ENUM_LABEL_53: "ENUM_LABEL_53",
  ENUM_LABEL_54: "ENUM_LABEL_54",
  ENUM_LABEL_55: "ENUM_LABEL_55",
  ENUM_LABEL_56: "ENUM_LABEL_56",
  ENUM_LABEL_57: "ENUM_LABEL_57",
  ENUM_LABEL_58: "ENUM_LABEL_58",
  ENUM_LABEL_59: "ENUM_LABEL_59",
  ENUM_LABEL_60: "ENUM_LABEL_60",
  ENUM_LABEL_61: "ENUM_LABEL_61",
  ENUM_LABEL_62: "ENUM_LABEL_62",
  ENUM_LABEL_63: "ENUM_LABEL_63",
  ENUM_LABEL_64: "ENUM_LABEL_64",
  ENUM_LABEL_65: "ENUM_LABEL_65",
  ENUM_LABEL_66: "ENUM_LABEL_66",
  ENUM_LABEL_67: "ENUM_LABEL_67",
  ENUM_LABEL_68: "ENUM_LABEL_68",
  ENUM_LABEL_69: "ENUM_LABEL_69",
  ENUM_LABEL_70: "ENUM_LABEL_70",
  ENUM_LABEL_71: "ENUM_LABEL_71",
  ENUM_LABEL_72: "ENUM_LABEL_72",
  ENUM_LABEL_73: "ENUM_LABEL_73",
  ENUM_LABEL_74: "ENUM_LABEL_74",
  ENUM_LABEL_75: "ENUM_LABEL_75",
  ENUM_LABEL_76: "ENUM_LABEL_76",
  ENUM_LABEL_77: "ENUM_LABEL_77",
  ENUM_LABEL_78: "ENUM_LABEL_78",
  ENUM_LABEL_79: "ENUM_LABEL_79",
  ENUM_LABEL_80: "ENUM_LABEL_80",
  ENUM_LABEL_81: "ENUM_LABEL_81",
  ENUM_LABEL_82: "ENUM_LABEL_82",
  ENUM_LABEL_83: "ENUM_LABEL_83",
  ENUM_LABEL_84: "ENUM_LABEL_84",
  ENUM_LABEL_85: "ENUM_LABEL_85",
  ENUM_LABEL_86: "ENUM_LABEL_86",
  ENUM_LABEL_87: "ENUM_LABEL_87",
  ENUM_LABEL_88: "ENUM_LABEL_88",
  ENUM_LABEL_89: "ENUM_LABEL_89",
  ENUM_LABEL_90: "ENUM_LABEL_90",
  ENUM_LABEL_91: "ENUM_LABEL_91",
  ENUM_LABEL_92: "ENUM_LABEL_92",
  ENUM_LABEL_93: "ENUM_LABEL_93",
  ENUM_LABEL_94: "ENUM_LABEL_94",
  ENUM_LABEL_95: "ENUM_LABEL_95",
  ENUM_LABEL_96: "ENUM_LABEL_96",
  ENUM_LABEL_97: "ENUM_LABEL_97",
  ENUM_LABEL_98: "ENUM_LABEL_98",
  ENUM_LABEL_99: "ENUM_LABEL_99",
  ENUM_LABEL_100: "ENUM_LABEL_100",
  /**
   * @private
   */
  _fromInt: function (i: number): VeryLargeEnum {
    switch (i) {
      case 0: {
        return "ENUM_LABEL_DEFAULT";
      }
      case 1: {
        return "ENUM_LABEL_1";
      }
      case 2: {
        return "ENUM_LABEL_2";
      }
      case 3: {
        return "ENUM_LABEL_3";
      }
      case 4: {
        return "ENUM_LABEL_4";
      }
      case 5: {
        return "ENUM_LABEL_5";
      }
      case 6: {
        return "ENUM_LABEL_6";
      }
      case 7: {
        return "ENUM_LABEL_7";
      }
      case 8: {
        return "ENUM_LABEL_8";
      }
      case 9: {
        return "ENUM_LABEL_9";
      }
      case 10: {
        return "ENUM_LABEL_10";
      }
      case 11: {
        return "ENUM_LABEL_11";
      }
      case 12: {
        return "ENUM_LABEL_12";
      }
      case 13: {
        return "ENUM_LABEL_13";
      }
      case 14: {
        return "ENUM_LABEL_14";
      }
      case 15: {
        return "ENUM_LABEL_15";
      }
      case 16: {
        return "ENUM_LABEL_16";
      }
      case 17: {
        return "ENUM_LABEL_17";
      }
      case 18: {
        return "ENUM_LABEL_18";
      }
      case 19: {
        return "ENUM_LABEL_19";
      }
      case 20: {
        return "ENUM_LABEL_20";
      }
      case 21: {
        return "ENUM_LABEL_21";
      }
      case 22: {
        return "ENUM_LABEL_22";
      }
      case 23: {
        return "ENUM_LABEL_23";
      }
      case 24: {
        return "ENUM_LABEL_24";
      }
      case 25: {
        return "ENUM_LABEL_25";
      }
      case 26: {
        return "ENUM_LABEL_26";
      }
      case 27: {
        return "ENUM_LABEL_27";
      }
      case 28: {
        return "ENUM_LABEL_28";
      }
      case 29: {
        return "ENUM_LABEL_29";
      }
      case 30: {
        return "ENUM_LABEL_30";
      }
      case 31: {
        return "ENUM_LABEL_31";
      }
      case 32: {
        return "ENUM_LABEL_32";
      }
      case 33: {
        return "ENUM_LABEL_33";
      }
      case 34: {
        return "ENUM_LABEL_34";
      }
      case 35: {
        return "ENUM_LABEL_35";
      }
      case 36: {
        return "ENUM_LABEL_36";
      }
      case 37: {
        return "ENUM_LABEL_37";
      }
      case 38: {
        return "ENUM_LABEL_38";
      }
      case 39: {
        return "ENUM_LABEL_39";
      }
      case 40: {
        return "ENUM_LABEL_40";
      }
      case 41: {
        return "ENUM_LABEL_41";
      }
      case 42: {
        return "ENUM_LABEL_42";
      }
      case 43: {
        return "ENUM_LABEL_43";
      }
      case 44: {
        return "ENUM_LABEL_44";
      }
      case 45: {
        return "ENUM_LABEL_45";
      }
      case 46: {
        return "ENUM_LABEL_46";
      }
      case 47: {
        return "ENUM_LABEL_47";
      }
      case 48: {
        return "ENUM_LABEL_48";
      }
      case 49: {
        return "ENUM_LABEL_49";
      }
      case 50: {
        return "ENUM_LABEL_50";
      }
      case 51: {
        return "ENUM_LABEL_51";
      }
      case 52: {
        return "ENUM_LABEL_52";
      }
      case 53: {
        return "ENUM_LABEL_53";
      }
      case 54: {
        return "ENUM_LABEL_54";
      }
      case 55: {
        return "ENUM_LABEL_55";
      }
      case 56: {
        return "ENUM_LABEL_56";
      }
      case 57: {
        return "ENUM_LABEL_57";
      }
      case 58: {
        return "ENUM_LABEL_58";
      }
      case 59: {
        return "ENUM_LABEL_59";
      }
      case 60: {
        return "ENUM_LABEL_60";
      }
      case 61: {
        return "ENUM_LABEL_61";
      }
      case 62: {
        return "ENUM_LABEL_62";
      }
      case 63: {
        return "ENUM_LABEL_63";
      }
      case 64: {
        return "ENUM_LABEL_64";
      }
      case 65: {
        return "ENUM_LABEL_65";
      }
      case 66: {
        return "ENUM_LABEL_66";
      }
      case 67: {
        return "ENUM_LABEL_67";
      }
      case 68: {
        return "ENUM_LABEL_68";
      }
      case 69: {
        return "ENUM_LABEL_69";
      }
      case 70: {
        return "ENUM_LABEL_70";
      }
      case 71: {
        return "ENUM_LABEL_71";
      }
      case 72: {
        return "ENUM_LABEL_72";
      }
      case 73: {
        return "ENUM_LABEL_73";
      }
      case 74: {
        return "ENUM_LABEL_74";
      }
      case 75: {
        return "ENUM_LABEL_75";
      }
      case 76: {
        return "ENUM_LABEL_76";
      }
      case 77: {
        return "ENUM_LABEL_77";
      }
      case 78: {
        return "ENUM_LABEL_78";
      }
      case 79: {
        return "ENUM_LABEL_79";
      }
      case 80: {
        return "ENUM_LABEL_80";
      }
      case 81: {
        return "ENUM_LABEL_81";
      }
      case 82: {
        return "ENUM_LABEL_82";
      }
      case 83: {
        return "ENUM_LABEL_83";
      }
      case 84: {
        return "ENUM_LABEL_84";
      }
      case 85: {
        return "ENUM_LABEL_85";
      }
      case 86: {
        return "ENUM_LABEL_86";
      }
      case 87: {
        return "ENUM_LABEL_87";
      }
      case 88: {
        return "ENUM_LABEL_88";
      }
      case 89: {
        return "ENUM_LABEL_89";
      }
      case 90: {
        return "ENUM_LABEL_90";
      }
      case 91: {
        return "ENUM_LABEL_91";
      }
      case 92: {
        return "ENUM_LABEL_92";
      }
      case 93: {
        return "ENUM_LABEL_93";
      }
      case 94: {
        return "ENUM_LABEL_94";
      }
      case 95: {
        return "ENUM_LABEL_95";
      }
      case 96: {
        return "ENUM_LABEL_96";
      }
      case 97: {
        return "ENUM_LABEL_97";
      }
      case 98: {
        return "ENUM_LABEL_98";
      }
      case 99: {
        return "ENUM_LABEL_99";
      }
      case 100: {
        return "ENUM_LABEL_100";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as VeryLargeEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: VeryLargeEnum): number {
    switch (i) {
      case "ENUM_LABEL_DEFAULT": {
        return 0;
      }
      case "ENUM_LABEL_1": {
        return 1;
      }
      case "ENUM_LABEL_2": {
        return 2;
      }
      case "ENUM_LABEL_3": {
        return 3;
      }
      case "ENUM_LABEL_4": {
        return 4;
      }
      case "ENUM_LABEL_5": {
        return 5;
      }
      case "ENUM_LABEL_6": {
        return 6;
      }
      case "ENUM_LABEL_7": {
        return 7;
      }
      case "ENUM_LABEL_8": {
        return 8;
      }
      case "ENUM_LABEL_9": {
        return 9;
      }
      case "ENUM_LABEL_10": {
        return 10;
      }
      case "ENUM_LABEL_11": {
        return 11;
      }
      case "ENUM_LABEL_12": {
        return 12;
      }
      case "ENUM_LABEL_13": {
        return 13;
      }
      case "ENUM_LABEL_14": {
        return 14;
      }
      case "ENUM_LABEL_15": {
        return 15;
      }
      case "ENUM_LABEL_16": {
        return 16;
      }
      case "ENUM_LABEL_17": {
        return 17;
      }
      case "ENUM_LABEL_18": {
        return 18;
      }
      case "ENUM_LABEL_19": {
        return 19;
      }
      case "ENUM_LABEL_20": {
        return 20;
      }
      case "ENUM_LABEL_21": {
        return 21;
      }
      case "ENUM_LABEL_22": {
        return 22;
      }
      case "ENUM_LABEL_23": {
        return 23;
      }
      case "ENUM_LABEL_24": {
        return 24;
      }
      case "ENUM_LABEL_25": {
        return 25;
      }
      case "ENUM_LABEL_26": {
        return 26;
      }
      case "ENUM_LABEL_27": {
        return 27;
      }
      case "ENUM_LABEL_28": {
        return 28;
      }
      case "ENUM_LABEL_29": {
        return 29;
      }
      case "ENUM_LABEL_30": {
        return 30;
      }
      case "ENUM_LABEL_31": {
        return 31;
      }
      case "ENUM_LABEL_32": {
        return 32;
      }
      case "ENUM_LABEL_33": {
        return 33;
      }
      case "ENUM_LABEL_34": {
        return 34;
      }
      case "ENUM_LABEL_35": {
        return 35;
      }
      case "ENUM_LABEL_36": {
        return 36;
      }
      case "ENUM_LABEL_37": {
        return 37;
      }
      case "ENUM_LABEL_38": {
        return 38;
      }
      case "ENUM_LABEL_39": {
        return 39;
      }
      case "ENUM_LABEL_40": {
        return 40;
      }
      case "ENUM_LABEL_41": {
        return 41;
      }
      case "ENUM_LABEL_42": {
        return 42;
      }
      case "ENUM_LABEL_43": {
        return 43;
      }
      case "ENUM_LABEL_44": {
        return 44;
      }
      case "ENUM_LABEL_45": {
        return 45;
      }
      case "ENUM_LABEL_46": {
        return 46;
      }
      case "ENUM_LABEL_47": {
        return 47;
      }
      case "ENUM_LABEL_48": {
        return 48;
      }
      case "ENUM_LABEL_49": {
        return 49;
      }
      case "ENUM_LABEL_50": {
        return 50;
      }
      case "ENUM_LABEL_51": {
        return 51;
      }
      case "ENUM_LABEL_52": {
        return 52;
      }
      case "ENUM_LABEL_53": {
        return 53;
      }
      case "ENUM_LABEL_54": {
        return 54;
      }
      case "ENUM_LABEL_55": {
        return 55;
      }
      case "ENUM_LABEL_56": {
        return 56;
      }
      case "ENUM_LABEL_57": {
        return 57;
      }
      case "ENUM_LABEL_58": {
        return 58;
      }
      case "ENUM_LABEL_59": {
        return 59;
      }
      case "ENUM_LABEL_60": {
        return 60;
      }
      case "ENUM_LABEL_61": {
        return 61;
      }
      case "ENUM_LABEL_62": {
        return 62;
      }
      case "ENUM_LABEL_63": {
        return 63;
      }
      case "ENUM_LABEL_64": {
        return 64;
      }
      case "ENUM_LABEL_65": {
        return 65;
      }
      case "ENUM_LABEL_66": {
        return 66;
      }
      case "ENUM_LABEL_67": {
        return 67;
      }
      case "ENUM_LABEL_68": {
        return 68;
      }
      case "ENUM_LABEL_69": {
        return 69;
      }
      case "ENUM_LABEL_70": {
        return 70;
      }
      case "ENUM_LABEL_71": {
        return 71;
      }
      case "ENUM_LABEL_72": {
        return 72;
      }
      case "ENUM_LABEL_73": {
        return 73;
      }
      case "ENUM_LABEL_74": {
        return 74;
      }
      case "ENUM_LABEL_75": {
        return 75;
      }
      case "ENUM_LABEL_76": {
        return 76;
      }
      case "ENUM_LABEL_77": {
        return 77;
      }
      case "ENUM_LABEL_78": {
        return 78;
      }
      case "ENUM_LABEL_79": {
        return 79;
      }
      case "ENUM_LABEL_80": {
        return 80;
      }
      case "ENUM_LABEL_81": {
        return 81;
      }
      case "ENUM_LABEL_82": {
        return 82;
      }
      case "ENUM_LABEL_83": {
        return 83;
      }
      case "ENUM_LABEL_84": {
        return 84;
      }
      case "ENUM_LABEL_85": {
        return 85;
      }
      case "ENUM_LABEL_86": {
        return 86;
      }
      case "ENUM_LABEL_87": {
        return 87;
      }
      case "ENUM_LABEL_88": {
        return 88;
      }
      case "ENUM_LABEL_89": {
        return 89;
      }
      case "ENUM_LABEL_90": {
        return 90;
      }
      case "ENUM_LABEL_91": {
        return 91;
      }
      case "ENUM_LABEL_92": {
        return 92;
      }
      case "ENUM_LABEL_93": {
        return 93;
      }
      case "ENUM_LABEL_94": {
        return 94;
      }
      case "ENUM_LABEL_95": {
        return 95;
      }
      case "ENUM_LABEL_96": {
        return 96;
      }
      case "ENUM_LABEL_97": {
        return 97;
      }
      case "ENUM_LABEL_98": {
        return 98;
      }
      case "ENUM_LABEL_99": {
        return 99;
      }
      case "ENUM_LABEL_100": {
        return 100;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypesJSON = {
  /**
   * Serializes TestAllTypes to JSON.
   */
  encode: function (msg: Partial<TestAllTypes>): string {
    return JSON.stringify(TestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestAllTypes from JSON.
   */
  decode: function (json: string): TestAllTypes {
    return TestAllTypesJSON._readMessage(
      TestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessageJSON.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessageJSON.initialize(),
      optionalLazyMessage: TestAllTypesJSON.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      defaultForeignEnum: ForeignEnum._fromInt(0),
      defaultImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      defaultStringPiece: "",
      defaultCord: "",
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json["optionalInt64"] = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json["optionalUint32"] = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json["optionalUint64"] = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json["optionalSint32"] = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json["optionalSint64"] = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json["optionalFixed32"] = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json["optionalFixed64"] = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json["optionalSfixed32"] = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json["optionalSfixed64"] = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json["optionalFloat"] = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json["optionalDouble"] = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json["optionalBool"] = msg.optionalBool;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalNestedMessage);
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    if (msg.optionalForeignMessage) {
      const _optionalForeignMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalForeignMessage
      );
      if (Object.keys(_optionalForeignMessage_).length > 0) {
        json["optionalForeignMessage"] = _optionalForeignMessage_;
      }
    }
    if (msg.optionalImportMessage) {
      const _optionalImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalImportMessage
        );
      if (Object.keys(_optionalImportMessage_).length > 0) {
        json["optionalImportMessage"] = _optionalImportMessage_;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      json["optionalNestedEnum"] = msg.optionalNestedEnum;
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    if (
      msg.optionalImportEnum &&
      googleProtobufUnittest_import.ImportEnumJSON._toInt(
        msg.optionalImportEnum
      )
    ) {
      json["optionalImportEnum"] = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json["optionalStringPiece"] = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json["optionalCord"] = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const _optionalPublicImportMessage_ =
        googleProtobufUnittest_import_public.PublicImportMessageJSON._writeMessage(
          msg.optionalPublicImportMessage
        );
      if (Object.keys(_optionalPublicImportMessage_).length > 0) {
        json["optionalPublicImportMessage"] = _optionalPublicImportMessage_;
      }
    }
    if (msg.optionalLazyMessage) {
      const _optionalLazyMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalLazyMessage);
      if (Object.keys(_optionalLazyMessage_).length > 0) {
        json["optionalLazyMessage"] = _optionalLazyMessage_;
      }
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json["repeatedString"] = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json["repeatedBytes"] = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json["repeatedNestedMessage"] = msg.repeatedNestedMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json["repeatedForeignMessage"] = msg.repeatedForeignMessage.map(
        ForeignMessageJSON._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json["repeatedImportMessage"] = msg.repeatedImportMessage.map(
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json["repeatedForeignEnum"] = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json["repeatedImportEnum"] = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json["repeatedStringPiece"] = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json["repeatedCord"] = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json["repeatedLazyMessage"] = msg.repeatedLazyMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      json["defaultInt32"] = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json["defaultInt64"] = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json["defaultUint32"] = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json["defaultUint64"] = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json["defaultSint32"] = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json["defaultSint64"] = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json["defaultFixed32"] = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json["defaultFixed64"] = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json["defaultSfixed32"] = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json["defaultSfixed64"] = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json["defaultFloat"] = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json["defaultDouble"] = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json["defaultBool"] = msg.defaultBool;
    }
    if (msg.defaultString) {
      json["defaultString"] = msg.defaultString;
    }
    if (msg.defaultBytes?.length) {
      json["defaultBytes"] = encodeBase64Bytes(msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.defaultNestedEnum)
    ) {
      json["defaultNestedEnum"] = msg.defaultNestedEnum;
    }
    if (
      msg.defaultForeignEnum &&
      ForeignEnumJSON._toInt(msg.defaultForeignEnum)
    ) {
      json["defaultForeignEnum"] = msg.defaultForeignEnum;
    }
    if (
      msg.defaultImportEnum &&
      googleProtobufUnittest_import.ImportEnumJSON._toInt(msg.defaultImportEnum)
    ) {
      json["defaultImportEnum"] = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json["defaultStringPiece"] = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json["defaultCord"] = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const _oneofNestedMessage_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.oneofNestedMessage
      );
      json["oneofNestedMessage"] = _oneofNestedMessage_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestAllTypes, json: any): TestAllTypes {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _optionalInt64_ = json["optionalInt64"] ?? json["optional_int64"];
    if (_optionalInt64_) {
      msg.optionalInt64 = BigInt(_optionalInt64_);
    }
    const _optionalUint32_ = json["optionalUint32"] ?? json["optional_uint32"];
    if (_optionalUint32_) {
      msg.optionalUint32 = _optionalUint32_;
    }
    const _optionalUint64_ = json["optionalUint64"] ?? json["optional_uint64"];
    if (_optionalUint64_) {
      msg.optionalUint64 = BigInt(_optionalUint64_);
    }
    const _optionalSint32_ = json["optionalSint32"] ?? json["optional_sint32"];
    if (_optionalSint32_) {
      msg.optionalSint32 = _optionalSint32_;
    }
    const _optionalSint64_ = json["optionalSint64"] ?? json["optional_sint64"];
    if (_optionalSint64_) {
      msg.optionalSint64 = BigInt(_optionalSint64_);
    }
    const _optionalFixed32_ =
      json["optionalFixed32"] ?? json["optional_fixed32"];
    if (_optionalFixed32_) {
      msg.optionalFixed32 = _optionalFixed32_;
    }
    const _optionalFixed64_ =
      json["optionalFixed64"] ?? json["optional_fixed64"];
    if (_optionalFixed64_) {
      msg.optionalFixed64 = BigInt(_optionalFixed64_);
    }
    const _optionalSfixed32_ =
      json["optionalSfixed32"] ?? json["optional_sfixed32"];
    if (_optionalSfixed32_) {
      msg.optionalSfixed32 = _optionalSfixed32_;
    }
    const _optionalSfixed64_ =
      json["optionalSfixed64"] ?? json["optional_sfixed64"];
    if (_optionalSfixed64_) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64_);
    }
    const _optionalFloat_ = json["optionalFloat"] ?? json["optional_float"];
    if (_optionalFloat_) {
      msg.optionalFloat = _optionalFloat_;
    }
    const _optionalDouble_ = json["optionalDouble"] ?? json["optional_double"];
    if (_optionalDouble_) {
      msg.optionalDouble = _optionalDouble_;
    }
    const _optionalBool_ = json["optionalBool"] ?? json["optional_bool"];
    if (_optionalBool_) {
      msg.optionalBool = _optionalBool_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalNestedMessage_);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage_ =
      json["optionalForeignMessage"] ?? json["optional_foreign_message"];
    if (_optionalForeignMessage_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _optionalForeignMessage_);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage_ =
      json["optionalImportMessage"] ?? json["optional_import_message"];
    if (_optionalImportMessage_) {
      const m = googleProtobufUnittest_import.ImportMessage.initialize();
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        m,
        _optionalImportMessage_
      );
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum_ =
      json["optionalNestedEnum"] ?? json["optional_nested_enum"];
    if (_optionalNestedEnum_) {
      msg.optionalNestedEnum = _optionalNestedEnum_;
    }
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    const _optionalImportEnum_ =
      json["optionalImportEnum"] ?? json["optional_import_enum"];
    if (_optionalImportEnum_) {
      msg.optionalImportEnum = _optionalImportEnum_;
    }
    const _optionalStringPiece_ =
      json["optionalStringPiece"] ?? json["optional_string_piece"];
    if (_optionalStringPiece_) {
      msg.optionalStringPiece = _optionalStringPiece_;
    }
    const _optionalCord_ = json["optionalCord"] ?? json["optional_cord"];
    if (_optionalCord_) {
      msg.optionalCord = _optionalCord_;
    }
    const _optionalPublicImportMessage_ =
      json["optionalPublicImportMessage"] ??
      json["optional_public_import_message"];
    if (_optionalPublicImportMessage_) {
      const m =
        googleProtobufUnittest_import_public.PublicImportMessage.initialize();
      googleProtobufUnittest_import_public.PublicImportMessageJSON._readMessage(
        m,
        _optionalPublicImportMessage_
      );
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage_ =
      json["optionalLazyMessage"] ?? json["optional_lazy_message"];
    if (_optionalLazyMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalLazyMessage_);
      msg.optionalLazyMessage = m;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedString_ = json["repeatedString"] ?? json["repeated_string"];
    if (_repeatedString_) {
      msg.repeatedString = _repeatedString_;
    }
    const _repeatedBytes_ = json["repeatedBytes"] ?? json["repeated_bytes"];
    if (_repeatedBytes_) {
      msg.repeatedBytes = _repeatedBytes_.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage_ =
      json["repeatedNestedMessage"] ?? json["repeated_nested_message"];
    if (_repeatedNestedMessage_) {
      for (const item of _repeatedNestedMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage_ =
      json["repeatedForeignMessage"] ?? json["repeated_foreign_message"];
    if (_repeatedForeignMessage_) {
      for (const item of _repeatedForeignMessage_) {
        const m = ForeignMessage.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage_ =
      json["repeatedImportMessage"] ?? json["repeated_import_message"];
    if (_repeatedImportMessage_) {
      for (const item of _repeatedImportMessage_) {
        const m = googleProtobufUnittest_import.ImportMessage.initialize();
        googleProtobufUnittest_import.ImportMessageJSON._readMessage(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    const _repeatedForeignEnum_ =
      json["repeatedForeignEnum"] ?? json["repeated_foreign_enum"];
    if (_repeatedForeignEnum_) {
      msg.repeatedForeignEnum = _repeatedForeignEnum_;
    }
    const _repeatedImportEnum_ =
      json["repeatedImportEnum"] ?? json["repeated_import_enum"];
    if (_repeatedImportEnum_) {
      msg.repeatedImportEnum = _repeatedImportEnum_;
    }
    const _repeatedStringPiece_ =
      json["repeatedStringPiece"] ?? json["repeated_string_piece"];
    if (_repeatedStringPiece_) {
      msg.repeatedStringPiece = _repeatedStringPiece_;
    }
    const _repeatedCord_ = json["repeatedCord"] ?? json["repeated_cord"];
    if (_repeatedCord_) {
      msg.repeatedCord = _repeatedCord_;
    }
    const _repeatedLazyMessage_ =
      json["repeatedLazyMessage"] ?? json["repeated_lazy_message"];
    if (_repeatedLazyMessage_) {
      for (const item of _repeatedLazyMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _defaultInt32_ = json["defaultInt32"] ?? json["default_int32"];
    if (_defaultInt32_) {
      msg.defaultInt32 = _defaultInt32_;
    }
    const _defaultInt64_ = json["defaultInt64"] ?? json["default_int64"];
    if (_defaultInt64_) {
      msg.defaultInt64 = BigInt(_defaultInt64_);
    }
    const _defaultUint32_ = json["defaultUint32"] ?? json["default_uint32"];
    if (_defaultUint32_) {
      msg.defaultUint32 = _defaultUint32_;
    }
    const _defaultUint64_ = json["defaultUint64"] ?? json["default_uint64"];
    if (_defaultUint64_) {
      msg.defaultUint64 = BigInt(_defaultUint64_);
    }
    const _defaultSint32_ = json["defaultSint32"] ?? json["default_sint32"];
    if (_defaultSint32_) {
      msg.defaultSint32 = _defaultSint32_;
    }
    const _defaultSint64_ = json["defaultSint64"] ?? json["default_sint64"];
    if (_defaultSint64_) {
      msg.defaultSint64 = BigInt(_defaultSint64_);
    }
    const _defaultFixed32_ = json["defaultFixed32"] ?? json["default_fixed32"];
    if (_defaultFixed32_) {
      msg.defaultFixed32 = _defaultFixed32_;
    }
    const _defaultFixed64_ = json["defaultFixed64"] ?? json["default_fixed64"];
    if (_defaultFixed64_) {
      msg.defaultFixed64 = BigInt(_defaultFixed64_);
    }
    const _defaultSfixed32_ =
      json["defaultSfixed32"] ?? json["default_sfixed32"];
    if (_defaultSfixed32_) {
      msg.defaultSfixed32 = _defaultSfixed32_;
    }
    const _defaultSfixed64_ =
      json["defaultSfixed64"] ?? json["default_sfixed64"];
    if (_defaultSfixed64_) {
      msg.defaultSfixed64 = BigInt(_defaultSfixed64_);
    }
    const _defaultFloat_ = json["defaultFloat"] ?? json["default_float"];
    if (_defaultFloat_) {
      msg.defaultFloat = _defaultFloat_;
    }
    const _defaultDouble_ = json["defaultDouble"] ?? json["default_double"];
    if (_defaultDouble_) {
      msg.defaultDouble = _defaultDouble_;
    }
    const _defaultBool_ = json["defaultBool"] ?? json["default_bool"];
    if (_defaultBool_) {
      msg.defaultBool = _defaultBool_;
    }
    const _defaultString_ = json["defaultString"] ?? json["default_string"];
    if (_defaultString_) {
      msg.defaultString = _defaultString_;
    }
    const _defaultBytes_ = json["defaultBytes"] ?? json["default_bytes"];
    if (_defaultBytes_) {
      msg.defaultBytes = decodeBase64Bytes(_defaultBytes_);
    }
    const _defaultNestedEnum_ =
      json["defaultNestedEnum"] ?? json["default_nested_enum"];
    if (_defaultNestedEnum_) {
      msg.defaultNestedEnum = _defaultNestedEnum_;
    }
    const _defaultForeignEnum_ =
      json["defaultForeignEnum"] ?? json["default_foreign_enum"];
    if (_defaultForeignEnum_) {
      msg.defaultForeignEnum = _defaultForeignEnum_;
    }
    const _defaultImportEnum_ =
      json["defaultImportEnum"] ?? json["default_import_enum"];
    if (_defaultImportEnum_) {
      msg.defaultImportEnum = _defaultImportEnum_;
    }
    const _defaultStringPiece_ =
      json["defaultStringPiece"] ?? json["default_string_piece"];
    if (_defaultStringPiece_) {
      msg.defaultStringPiece = _defaultStringPiece_;
    }
    const _defaultCord_ = json["defaultCord"] ?? json["default_cord"];
    if (_defaultCord_) {
      msg.defaultCord = _defaultCord_;
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofNestedMessage_ =
      json["oneofNestedMessage"] ?? json["oneof_nested_message"];
    if (_oneofNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _oneofNestedMessage_);
      msg.oneofNestedMessage = m;
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypes.NestedEnum {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypes.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypes.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to JSON.
     */
    encode: function (msg: Partial<TestAllTypes.NestedMessage>): string {
      return JSON.stringify(TestAllTypesJSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from JSON.
     */
    decode: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypesJSON.NestedMessage._readMessage(
        TestAllTypesJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      json: any
    ): TestAllTypes.NestedMessage {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestAllTypes.OptionalGroup to JSON.
     */
    encode: function (msg: Partial<TestAllTypes.OptionalGroup>): string {
      return JSON.stringify(TestAllTypesJSON.OptionalGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.OptionalGroup from JSON.
     */
    decode: function (json: string): TestAllTypes.OptionalGroup {
      return TestAllTypesJSON.OptionalGroup._readMessage(
        TestAllTypesJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      json: any
    ): TestAllTypes.OptionalGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestAllTypes.RepeatedGroup to JSON.
     */
    encode: function (msg: Partial<TestAllTypes.RepeatedGroup>): string {
      return JSON.stringify(TestAllTypesJSON.RepeatedGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.RepeatedGroup from JSON.
     */
    decode: function (json: string): TestAllTypes.RepeatedGroup {
      return TestAllTypesJSON.RepeatedGroup._readMessage(
        TestAllTypesJSON.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      json: any
    ): TestAllTypes.RepeatedGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypesJSON = {
  /**
   * Serializes NestedTestAllTypes to JSON.
   */
  encode: function (msg: Partial<NestedTestAllTypes>): string {
    return JSON.stringify(NestedTestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes NestedTestAllTypes from JSON.
   */
  decode: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypesJSON._readMessage(
      NestedTestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypesJSON.initialize(),
      payload: TestAllTypesJSON.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const _child_ = NestedTestAllTypesJSON._writeMessage(msg.child);
      if (Object.keys(_child_).length > 0) {
        json["child"] = _child_;
      }
    }
    if (msg.payload) {
      const _payload_ = TestAllTypesJSON._writeMessage(msg.payload);
      if (Object.keys(_payload_).length > 0) {
        json["payload"] = _payload_;
      }
    }
    if (msg.repeatedChild?.length) {
      json["repeatedChild"] = msg.repeatedChild.map(
        NestedTestAllTypesJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    json: any
  ): NestedTestAllTypes {
    const _child_ = json["child"];
    if (_child_) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypesJSON._readMessage(m, _child_);
      msg.child = m;
    }
    const _payload_ = json["payload"];
    if (_payload_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _payload_);
      msg.payload = m;
    }
    const _repeatedChild_ = json["repeatedChild"] ?? json["repeated_child"];
    if (_repeatedChild_) {
      for (const item of _repeatedChild_) {
        const m = NestedTestAllTypes.initialize();
        NestedTestAllTypesJSON._readMessage(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFieldsJSON = {
  /**
   * Serializes TestDeprecatedFields to JSON.
   */
  encode: function (msg: Partial<TestDeprecatedFields>): string {
    return JSON.stringify(TestDeprecatedFieldsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDeprecatedFields from JSON.
   */
  decode: function (json: string): TestDeprecatedFields {
    return TestDeprecatedFieldsJSON._readMessage(
      TestDeprecatedFieldsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecatedInt32: 0,
      deprecatedInt32InOneof: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedFields>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.deprecatedInt32) {
      json["deprecatedInt32"] = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json["deprecatedInt32InOneof"] = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    json: any
  ): TestDeprecatedFields {
    const _deprecatedInt32_ =
      json["deprecatedInt32"] ?? json["deprecated_int32"];
    if (_deprecatedInt32_) {
      msg.deprecatedInt32 = _deprecatedInt32_;
    }
    const _deprecatedInt32InOneof_ =
      json["deprecatedInt32InOneof"] ?? json["deprecated_int32_in_oneof"];
    if (_deprecatedInt32InOneof_) {
      msg.deprecatedInt32InOneof = _deprecatedInt32InOneof_;
    }
    return msg;
  },
};

export const TestDeprecatedMessageJSON = {
  /**
   * Serializes TestDeprecatedMessage to JSON.
   */
  encode: function (_msg?: Partial<TestDeprecatedMessage>): string {
    return "{}";
  },

  /**
   * Deserializes TestDeprecatedMessage from JSON.
   */
  decode: function (_json?: string): TestDeprecatedMessage {
    return {};
  },

  /**
   * Initializes TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestDeprecatedMessage>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedMessage,
    _json: any
  ): TestDeprecatedMessage {
    return msg;
  },
};

export const ForeignMessageJSON = {
  /**
   * Serializes ForeignMessage to JSON.
   */
  encode: function (msg: Partial<ForeignMessage>): string {
    return JSON.stringify(ForeignMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ForeignMessage from JSON.
   */
  decode: function (json: string): ForeignMessage {
    return ForeignMessageJSON._readMessage(
      ForeignMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json["c"] = msg.c;
    }
    if (msg.d) {
      json["d"] = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ForeignMessage, json: any): ForeignMessage {
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    const _d_ = json["d"];
    if (_d_) {
      msg.d = _d_;
    }
    return msg;
  },
};

export const TestReservedFieldsJSON = {
  /**
   * Serializes TestReservedFields to JSON.
   */
  encode: function (_msg?: Partial<TestReservedFields>): string {
    return "{}";
  },

  /**
   * Deserializes TestReservedFields from JSON.
   */
  decode: function (_json?: string): TestReservedFields {
    return {};
  },

  /**
   * Initializes TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestReservedFields>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReservedFields,
    _json: any
  ): TestReservedFields {
    return msg;
  },
};

export const TestAllExtensionsJSON = {
  /**
   * Serializes TestAllExtensions to JSON.
   */
  encode: function (_msg?: Partial<TestAllExtensions>): string {
    return "{}";
  },

  /**
   * Deserializes TestAllExtensions from JSON.
   */
  decode: function (_json?: string): TestAllExtensions {
    return {};
  },

  /**
   * Initializes TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestAllExtensions>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllExtensions,
    _json: any
  ): TestAllExtensions {
    return msg;
  },
};

export const OptionalGroup_extensionJSON = {
  /**
   * Serializes OptionalGroup_extension to JSON.
   */
  encode: function (msg: Partial<OptionalGroup_extension>): string {
    return JSON.stringify(OptionalGroup_extensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes OptionalGroup_extension from JSON.
   */
  decode: function (json: string): OptionalGroup_extension {
    return OptionalGroup_extensionJSON._readMessage(
      OptionalGroup_extensionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OptionalGroup_extension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    json: any
  ): OptionalGroup_extension {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const RepeatedGroup_extensionJSON = {
  /**
   * Serializes RepeatedGroup_extension to JSON.
   */
  encode: function (msg: Partial<RepeatedGroup_extension>): string {
    return JSON.stringify(RepeatedGroup_extensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes RepeatedGroup_extension from JSON.
   */
  decode: function (json: string): RepeatedGroup_extension {
    return RepeatedGroup_extensionJSON._readMessage(
      RepeatedGroup_extensionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedGroup_extension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    json: any
  ): RepeatedGroup_extension {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const TestGroupJSON = {
  /**
   * Serializes TestGroup to JSON.
   */
  encode: function (msg: Partial<TestGroup>): string {
    return JSON.stringify(TestGroupJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestGroup from JSON.
   */
  decode: function (json: string): TestGroup {
    return TestGroupJSON._readMessage(
      TestGroupJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optionalForeignEnum: ForeignEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<TestGroup>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, json: any): TestGroup {
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestGroup.OptionalGroup to JSON.
     */
    encode: function (msg: Partial<TestGroup.OptionalGroup>): string {
      return JSON.stringify(TestGroupJSON.OptionalGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestGroup.OptionalGroup from JSON.
     */
    decode: function (json: string): TestGroup.OptionalGroup {
      return TestGroupJSON.OptionalGroup._readMessage(
        TestGroupJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      json: any
    ): TestGroup.OptionalGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestGroupExtensionJSON = {
  /**
   * Serializes TestGroupExtension to JSON.
   */
  encode: function (_msg?: Partial<TestGroupExtension>): string {
    return "{}";
  },

  /**
   * Deserializes TestGroupExtension from JSON.
   */
  decode: function (_json?: string): TestGroupExtension {
    return {};
  },

  /**
   * Initializes TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestGroupExtension>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestGroupExtension,
    _json: any
  ): TestGroupExtension {
    return msg;
  },
};

export const TestNestedExtensionJSON = {
  /**
   * Serializes TestNestedExtension to JSON.
   */
  encode: function (_msg?: Partial<TestNestedExtension>): string {
    return "{}";
  },

  /**
   * Deserializes TestNestedExtension from JSON.
   */
  decode: function (_json?: string): TestNestedExtension {
    return {};
  },

  /**
   * Initializes TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestNestedExtension>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedExtension,
    _json: any
  ): TestNestedExtension {
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encode: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): string {
      return JSON.stringify(
        TestNestedExtensionJSON.OptionalGroup_extension._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decode: function (
      json: string
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtensionJSON.OptionalGroup_extension._readMessage(
        TestNestedExtensionJSON.OptionalGroup_extension.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      json: any
    ): TestNestedExtension.OptionalGroup_extension {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestChildExtensionJSON = {
  /**
   * Serializes TestChildExtension to JSON.
   */
  encode: function (msg: Partial<TestChildExtension>): string {
    return JSON.stringify(TestChildExtensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestChildExtension from JSON.
   */
  decode: function (json: string): TestChildExtension {
    return TestChildExtensionJSON._readMessage(
      TestChildExtensionJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: "",
      b: "",
      optionalExtension: TestAllExtensionsJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestChildExtension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.b) {
      json["b"] = msg.b;
    }
    if (msg.optionalExtension) {
      const _optionalExtension_ = TestAllExtensionsJSON._writeMessage(
        msg.optionalExtension
      );
      if (Object.keys(_optionalExtension_).length > 0) {
        json["optionalExtension"] = _optionalExtension_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    json: any
  ): TestChildExtension {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _b_ = json["b"];
    if (_b_) {
      msg.b = _b_;
    }
    const _optionalExtension_ =
      json["optionalExtension"] ?? json["optional_extension"];
    if (_optionalExtension_) {
      const m = TestAllExtensions.initialize();
      TestAllExtensionsJSON._readMessage(m, _optionalExtension_);
      msg.optionalExtension = m;
    }
    return msg;
  },
};

export const TestRequiredJSON = {
  /**
   * Serializes TestRequired to JSON.
   */
  encode: function (msg: Partial<TestRequired>): string {
    return JSON.stringify(TestRequiredJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequired from JSON.
   */
  decode: function (json: string): TestRequired {
    return TestRequiredJSON._readMessage(
      TestRequiredJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequired>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.dummy2) {
      json["dummy2"] = msg.dummy2;
    }
    if (msg.b) {
      json["b"] = msg.b;
    }
    if (msg.dummy4) {
      json["dummy4"] = msg.dummy4;
    }
    if (msg.dummy5) {
      json["dummy5"] = msg.dummy5;
    }
    if (msg.dummy6) {
      json["dummy6"] = msg.dummy6;
    }
    if (msg.dummy7) {
      json["dummy7"] = msg.dummy7;
    }
    if (msg.dummy8) {
      json["dummy8"] = msg.dummy8;
    }
    if (msg.dummy9) {
      json["dummy9"] = msg.dummy9;
    }
    if (msg.dummy10) {
      json["dummy10"] = msg.dummy10;
    }
    if (msg.dummy11) {
      json["dummy11"] = msg.dummy11;
    }
    if (msg.dummy12) {
      json["dummy12"] = msg.dummy12;
    }
    if (msg.dummy13) {
      json["dummy13"] = msg.dummy13;
    }
    if (msg.dummy14) {
      json["dummy14"] = msg.dummy14;
    }
    if (msg.dummy15) {
      json["dummy15"] = msg.dummy15;
    }
    if (msg.dummy16) {
      json["dummy16"] = msg.dummy16;
    }
    if (msg.dummy17) {
      json["dummy17"] = msg.dummy17;
    }
    if (msg.dummy18) {
      json["dummy18"] = msg.dummy18;
    }
    if (msg.dummy19) {
      json["dummy19"] = msg.dummy19;
    }
    if (msg.dummy20) {
      json["dummy20"] = msg.dummy20;
    }
    if (msg.dummy21) {
      json["dummy21"] = msg.dummy21;
    }
    if (msg.dummy22) {
      json["dummy22"] = msg.dummy22;
    }
    if (msg.dummy23) {
      json["dummy23"] = msg.dummy23;
    }
    if (msg.dummy24) {
      json["dummy24"] = msg.dummy24;
    }
    if (msg.dummy25) {
      json["dummy25"] = msg.dummy25;
    }
    if (msg.dummy26) {
      json["dummy26"] = msg.dummy26;
    }
    if (msg.dummy27) {
      json["dummy27"] = msg.dummy27;
    }
    if (msg.dummy28) {
      json["dummy28"] = msg.dummy28;
    }
    if (msg.dummy29) {
      json["dummy29"] = msg.dummy29;
    }
    if (msg.dummy30) {
      json["dummy30"] = msg.dummy30;
    }
    if (msg.dummy31) {
      json["dummy31"] = msg.dummy31;
    }
    if (msg.dummy32) {
      json["dummy32"] = msg.dummy32;
    }
    if (msg.c) {
      json["c"] = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestRequired, json: any): TestRequired {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _dummy2_ = json["dummy2"];
    if (_dummy2_) {
      msg.dummy2 = _dummy2_;
    }
    const _b_ = json["b"];
    if (_b_) {
      msg.b = _b_;
    }
    const _dummy4_ = json["dummy4"];
    if (_dummy4_) {
      msg.dummy4 = _dummy4_;
    }
    const _dummy5_ = json["dummy5"];
    if (_dummy5_) {
      msg.dummy5 = _dummy5_;
    }
    const _dummy6_ = json["dummy6"];
    if (_dummy6_) {
      msg.dummy6 = _dummy6_;
    }
    const _dummy7_ = json["dummy7"];
    if (_dummy7_) {
      msg.dummy7 = _dummy7_;
    }
    const _dummy8_ = json["dummy8"];
    if (_dummy8_) {
      msg.dummy8 = _dummy8_;
    }
    const _dummy9_ = json["dummy9"];
    if (_dummy9_) {
      msg.dummy9 = _dummy9_;
    }
    const _dummy10_ = json["dummy10"];
    if (_dummy10_) {
      msg.dummy10 = _dummy10_;
    }
    const _dummy11_ = json["dummy11"];
    if (_dummy11_) {
      msg.dummy11 = _dummy11_;
    }
    const _dummy12_ = json["dummy12"];
    if (_dummy12_) {
      msg.dummy12 = _dummy12_;
    }
    const _dummy13_ = json["dummy13"];
    if (_dummy13_) {
      msg.dummy13 = _dummy13_;
    }
    const _dummy14_ = json["dummy14"];
    if (_dummy14_) {
      msg.dummy14 = _dummy14_;
    }
    const _dummy15_ = json["dummy15"];
    if (_dummy15_) {
      msg.dummy15 = _dummy15_;
    }
    const _dummy16_ = json["dummy16"];
    if (_dummy16_) {
      msg.dummy16 = _dummy16_;
    }
    const _dummy17_ = json["dummy17"];
    if (_dummy17_) {
      msg.dummy17 = _dummy17_;
    }
    const _dummy18_ = json["dummy18"];
    if (_dummy18_) {
      msg.dummy18 = _dummy18_;
    }
    const _dummy19_ = json["dummy19"];
    if (_dummy19_) {
      msg.dummy19 = _dummy19_;
    }
    const _dummy20_ = json["dummy20"];
    if (_dummy20_) {
      msg.dummy20 = _dummy20_;
    }
    const _dummy21_ = json["dummy21"];
    if (_dummy21_) {
      msg.dummy21 = _dummy21_;
    }
    const _dummy22_ = json["dummy22"];
    if (_dummy22_) {
      msg.dummy22 = _dummy22_;
    }
    const _dummy23_ = json["dummy23"];
    if (_dummy23_) {
      msg.dummy23 = _dummy23_;
    }
    const _dummy24_ = json["dummy24"];
    if (_dummy24_) {
      msg.dummy24 = _dummy24_;
    }
    const _dummy25_ = json["dummy25"];
    if (_dummy25_) {
      msg.dummy25 = _dummy25_;
    }
    const _dummy26_ = json["dummy26"];
    if (_dummy26_) {
      msg.dummy26 = _dummy26_;
    }
    const _dummy27_ = json["dummy27"];
    if (_dummy27_) {
      msg.dummy27 = _dummy27_;
    }
    const _dummy28_ = json["dummy28"];
    if (_dummy28_) {
      msg.dummy28 = _dummy28_;
    }
    const _dummy29_ = json["dummy29"];
    if (_dummy29_) {
      msg.dummy29 = _dummy29_;
    }
    const _dummy30_ = json["dummy30"];
    if (_dummy30_) {
      msg.dummy30 = _dummy30_;
    }
    const _dummy31_ = json["dummy31"];
    if (_dummy31_) {
      msg.dummy31 = _dummy31_;
    }
    const _dummy32_ = json["dummy32"];
    if (_dummy32_) {
      msg.dummy32 = _dummy32_;
    }
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    return msg;
  },
};

export const TestRequiredForeignJSON = {
  /**
   * Serializes TestRequiredForeign to JSON.
   */
  encode: function (msg: Partial<TestRequiredForeign>): string {
    return JSON.stringify(TestRequiredForeignJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredForeign from JSON.
   */
  decode: function (json: string): TestRequiredForeign {
    return TestRequiredForeignJSON._readMessage(
      TestRequiredForeignJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optionalMessage: TestRequiredJSON.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredForeign>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const _optionalMessage_ = TestRequiredJSON._writeMessage(
        msg.optionalMessage
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.repeatedMessage?.length) {
      json["repeatedMessage"] = msg.repeatedMessage.map(
        TestRequiredJSON._writeMessage
      );
    }
    if (msg.dummy) {
      json["dummy"] = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    json: any
  ): TestRequiredForeign {
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      const m = TestRequired.initialize();
      TestRequiredJSON._readMessage(m, _optionalMessage_);
      msg.optionalMessage = m;
    }
    const _repeatedMessage_ =
      json["repeatedMessage"] ?? json["repeated_message"];
    if (_repeatedMessage_) {
      for (const item of _repeatedMessage_) {
        const m = TestRequired.initialize();
        TestRequiredJSON._readMessage(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _dummy_ = json["dummy"];
    if (_dummy_) {
      msg.dummy = _dummy_;
    }
    return msg;
  },
};

export const TestRequiredMessageJSON = {
  /**
   * Serializes TestRequiredMessage to JSON.
   */
  encode: function (msg: Partial<TestRequiredMessage>): string {
    return JSON.stringify(TestRequiredMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredMessage from JSON.
   */
  decode: function (json: string): TestRequiredMessage {
    return TestRequiredMessageJSON._readMessage(
      TestRequiredMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optionalMessage: TestRequiredJSON.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequiredJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const _optionalMessage_ = TestRequiredJSON._writeMessage(
        msg.optionalMessage
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.repeatedMessage?.length) {
      json["repeatedMessage"] = msg.repeatedMessage.map(
        TestRequiredJSON._writeMessage
      );
    }
    if (msg.requiredMessage) {
      const _requiredMessage_ = TestRequiredJSON._writeMessage(
        msg.requiredMessage
      );
      if (Object.keys(_requiredMessage_).length > 0) {
        json["requiredMessage"] = _requiredMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    json: any
  ): TestRequiredMessage {
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      const m = TestRequired.initialize();
      TestRequiredJSON._readMessage(m, _optionalMessage_);
      msg.optionalMessage = m;
    }
    const _repeatedMessage_ =
      json["repeatedMessage"] ?? json["repeated_message"];
    if (_repeatedMessage_) {
      for (const item of _repeatedMessage_) {
        const m = TestRequired.initialize();
        TestRequiredJSON._readMessage(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _requiredMessage_ =
      json["requiredMessage"] ?? json["required_message"];
    if (_requiredMessage_) {
      const m = TestRequired.initialize();
      TestRequiredJSON._readMessage(m, _requiredMessage_);
      msg.requiredMessage = m;
    }
    return msg;
  },
};

export const TestForeignNestedJSON = {
  /**
   * Serializes TestForeignNested to JSON.
   */
  encode: function (msg: Partial<TestForeignNested>): string {
    return JSON.stringify(TestForeignNestedJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestForeignNested from JSON.
   */
  decode: function (json: string): TestForeignNested {
    return TestForeignNestedJSON._readMessage(
      TestForeignNestedJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreignNested: TestAllTypesJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestForeignNested>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.foreignNested) {
      const _foreignNested_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.foreignNested
      );
      if (Object.keys(_foreignNested_).length > 0) {
        json["foreignNested"] = _foreignNested_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    json: any
  ): TestForeignNested {
    const _foreignNested_ = json["foreignNested"] ?? json["foreign_nested"];
    if (_foreignNested_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _foreignNested_);
      msg.foreignNested = m;
    }
    return msg;
  },
};

export const TestEmptyMessageJSON = {
  /**
   * Serializes TestEmptyMessage to JSON.
   */
  encode: function (_msg?: Partial<TestEmptyMessage>): string {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessage from JSON.
   */
  decode: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestEmptyMessage>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestEmptyMessage, _json: any): TestEmptyMessage {
    return msg;
  },
};

export const TestEmptyMessageWithExtensionsJSON = {
  /**
   * Serializes TestEmptyMessageWithExtensions to JSON.
   */
  encode: function (_msg?: Partial<TestEmptyMessageWithExtensions>): string {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessageWithExtensions from JSON.
   */
  decode: function (_json?: string): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Initializes TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestEmptyMessageWithExtensions>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEmptyMessageWithExtensions,
    _json: any
  ): TestEmptyMessageWithExtensions {
    return msg;
  },
};

export const TestPickleNestedMessageJSON = {
  /**
   * Serializes TestPickleNestedMessage to JSON.
   */
  encode: function (_msg?: Partial<TestPickleNestedMessage>): string {
    return "{}";
  },

  /**
   * Deserializes TestPickleNestedMessage from JSON.
   */
  decode: function (_json?: string): TestPickleNestedMessage {
    return {};
  },

  /**
   * Initializes TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestPickleNestedMessage>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPickleNestedMessage,
    _json: any
  ): TestPickleNestedMessage {
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestPickleNestedMessage.NestedMessage to JSON.
     */
    encode: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): string {
      return JSON.stringify(
        TestPickleNestedMessageJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestPickleNestedMessage.NestedMessage from JSON.
     */
    decode: function (json: string): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessageJSON.NestedMessage._readMessage(
        TestPickleNestedMessageJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      json: any
    ): TestPickleNestedMessage.NestedMessage {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encode: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): string {
        return JSON.stringify(
          TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage._writeMessage(
            msg
          )
        );
      },

      /**
       * Deserializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decode: function (
        json: string
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.cc) {
          json["cc"] = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        json: any
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        const _cc_ = json["cc"];
        if (_cc_) {
          msg.cc = _cc_;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRangesJSON = {
  /**
   * Serializes TestMultipleExtensionRanges to JSON.
   */
  encode: function (_msg?: Partial<TestMultipleExtensionRanges>): string {
    return "{}";
  },

  /**
   * Deserializes TestMultipleExtensionRanges from JSON.
   */
  decode: function (_json?: string): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Initializes TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestMultipleExtensionRanges>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMultipleExtensionRanges,
    _json: any
  ): TestMultipleExtensionRanges {
    return msg;
  },
};

export const TestReallyLargeTagNumberJSON = {
  /**
   * Serializes TestReallyLargeTagNumber to JSON.
   */
  encode: function (msg: Partial<TestReallyLargeTagNumber>): string {
    return JSON.stringify(TestReallyLargeTagNumberJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestReallyLargeTagNumber from JSON.
   */
  decode: function (json: string): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumberJSON._readMessage(
      TestReallyLargeTagNumberJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.bb) {
      json["bb"] = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    json: any
  ): TestReallyLargeTagNumber {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _bb_ = json["bb"];
    if (_bb_) {
      msg.bb = _bb_;
    }
    return msg;
  },
};

export const TestRecursiveMessageJSON = {
  /**
   * Serializes TestRecursiveMessage to JSON.
   */
  encode: function (msg: Partial<TestRecursiveMessage>): string {
    return JSON.stringify(TestRecursiveMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRecursiveMessage from JSON.
   */
  decode: function (json: string): TestRecursiveMessage {
    return TestRecursiveMessageJSON._readMessage(
      TestRecursiveMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessageJSON.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const _a_ = TestRecursiveMessageJSON._writeMessage(msg.a);
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    if (msg.i) {
      json["i"] = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    json: any
  ): TestRecursiveMessage {
    const _a_ = json["a"];
    if (_a_) {
      const m = TestRecursiveMessage.initialize();
      TestRecursiveMessageJSON._readMessage(m, _a_);
      msg.a = m;
    }
    const _i_ = json["i"];
    if (_i_) {
      msg.i = _i_;
    }
    return msg;
  },
};

export const TestMutualRecursionAJSON = {
  /**
   * Serializes TestMutualRecursionA to JSON.
   */
  encode: function (msg: Partial<TestMutualRecursionA>): string {
    return JSON.stringify(TestMutualRecursionAJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMutualRecursionA from JSON.
   */
  decode: function (json: string): TestMutualRecursionA {
    return TestMutualRecursionAJSON._readMessage(
      TestMutualRecursionAJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionBJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionA>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.bb) {
      const _bb_ = TestMutualRecursionBJSON._writeMessage(msg.bb);
      if (Object.keys(_bb_).length > 0) {
        json["bb"] = _bb_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    json: any
  ): TestMutualRecursionA {
    const _bb_ = json["bb"];
    if (_bb_) {
      const m = TestMutualRecursionB.initialize();
      TestMutualRecursionBJSON._readMessage(m, _bb_);
      msg.bb = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestMutualRecursionA.SubMessage to JSON.
     */
    encode: function (msg: Partial<TestMutualRecursionA.SubMessage>): string {
      return JSON.stringify(
        TestMutualRecursionAJSON.SubMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestMutualRecursionA.SubMessage from JSON.
     */
    decode: function (json: string): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionAJSON.SubMessage._readMessage(
        TestMutualRecursionAJSON.SubMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionBJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.b) {
        const _b_ = TestMutualRecursionBJSON._writeMessage(msg.b);
        if (Object.keys(_b_).length > 0) {
          json["b"] = _b_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      json: any
    ): TestMutualRecursionA.SubMessage {
      const _b_ = json["b"];
      if (_b_) {
        const m = TestMutualRecursionB.initialize();
        TestMutualRecursionBJSON._readMessage(m, _b_);
        msg.b = m;
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes TestMutualRecursionA.SubGroup to JSON.
     */
    encode: function (msg: Partial<TestMutualRecursionA.SubGroup>): string {
      return JSON.stringify(
        TestMutualRecursionAJSON.SubGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestMutualRecursionA.SubGroup from JSON.
     */
    decode: function (json: string): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionAJSON.SubGroup._readMessage(
        TestMutualRecursionAJSON.SubGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        subMessage: TestMutualRecursionAJSON.SubMessage.initialize(),
        notInThisScc: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.subMessage) {
        const _subMessage_ = TestMutualRecursionAJSON.SubMessage._writeMessage(
          msg.subMessage
        );
        if (Object.keys(_subMessage_).length > 0) {
          json["subMessage"] = _subMessage_;
        }
      }
      if (msg.notInThisScc) {
        const _notInThisScc_ = TestAllTypesJSON._writeMessage(msg.notInThisScc);
        if (Object.keys(_notInThisScc_).length > 0) {
          json["notInThisScc"] = _notInThisScc_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      json: any
    ): TestMutualRecursionA.SubGroup {
      const _subMessage_ = json["subMessage"] ?? json["sub_message"];
      if (_subMessage_) {
        const m = TestMutualRecursionA.SubMessage.initialize();
        TestMutualRecursionAJSON.SubMessage._readMessage(m, _subMessage_);
        msg.subMessage = m;
      }
      const _notInThisScc_ = json["notInThisScc"] ?? json["not_in_this_scc"];
      if (_notInThisScc_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, _notInThisScc_);
        msg.notInThisScc = m;
      }
      return msg;
    },
  },
};

export const TestMutualRecursionBJSON = {
  /**
   * Serializes TestMutualRecursionB to JSON.
   */
  encode: function (msg: Partial<TestMutualRecursionB>): string {
    return JSON.stringify(TestMutualRecursionBJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMutualRecursionB from JSON.
   */
  decode: function (json: string): TestMutualRecursionB {
    return TestMutualRecursionBJSON._readMessage(
      TestMutualRecursionBJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionAJSON.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionB>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const _a_ = TestMutualRecursionAJSON._writeMessage(msg.a);
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    json: any
  ): TestMutualRecursionB {
    const _a_ = json["a"];
    if (_a_) {
      const m = TestMutualRecursionA.initialize();
      TestMutualRecursionAJSON._readMessage(m, _a_);
      msg.a = m;
    }
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    return msg;
  },
};

export const TestIsInitializedJSON = {
  /**
   * Serializes TestIsInitialized to JSON.
   */
  encode: function (msg: Partial<TestIsInitialized>): string {
    return JSON.stringify(TestIsInitializedJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestIsInitialized from JSON.
   */
  decode: function (json: string): TestIsInitialized {
    return TestIsInitializedJSON._readMessage(
      TestIsInitializedJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      subMessage: TestIsInitializedJSON.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestIsInitialized>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const _subMessage_ = TestIsInitializedJSON.SubMessage._writeMessage(
        msg.subMessage
      );
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    json: any
  ): TestIsInitialized {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      const m = TestIsInitialized.SubMessage.initialize();
      TestIsInitializedJSON.SubMessage._readMessage(m, _subMessage_);
      msg.subMessage = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestIsInitialized.SubMessage to JSON.
     */
    encode: function (_msg?: Partial<TestIsInitialized.SubMessage>): string {
      return "{}";
    },

    /**
     * Deserializes TestIsInitialized.SubMessage from JSON.
     */
    decode: function (_json?: string): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Initializes TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: Partial<TestIsInitialized.SubMessage>
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestIsInitialized.SubMessage,
      _json: any
    ): TestIsInitialized.SubMessage {
      return msg;
    },

    SubGroup: {
      /**
       * Serializes TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encode: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): string {
        return JSON.stringify(
          TestIsInitializedJSON.SubMessage.SubGroup._writeMessage(msg)
        );
      },

      /**
       * Deserializes TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decode: function (json: string): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitializedJSON.SubMessage.SubGroup._readMessage(
          TestIsInitializedJSON.SubMessage.SubGroup.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.i) {
          json["i"] = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        json: any
      ): TestIsInitialized.SubMessage.SubGroup {
        const _i_ = json["i"];
        if (_i_) {
          msg.i = _i_;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumberJSON = {
  /**
   * Serializes TestDupFieldNumber to JSON.
   */
  encode: function (msg: Partial<TestDupFieldNumber>): string {
    return JSON.stringify(TestDupFieldNumberJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDupFieldNumber from JSON.
   */
  decode: function (json: string): TestDupFieldNumber {
    return TestDupFieldNumberJSON._readMessage(
      TestDupFieldNumberJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDupFieldNumber>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    json: any
  ): TestDupFieldNumber {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes TestDupFieldNumber.Foo to JSON.
     */
    encode: function (msg: Partial<TestDupFieldNumber.Foo>): string {
      return JSON.stringify(TestDupFieldNumberJSON.Foo._writeMessage(msg));
    },

    /**
     * Deserializes TestDupFieldNumber.Foo from JSON.
     */
    decode: function (json: string): TestDupFieldNumber.Foo {
      return TestDupFieldNumberJSON.Foo._readMessage(
        TestDupFieldNumberJSON.Foo.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      json: any
    ): TestDupFieldNumber.Foo {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes TestDupFieldNumber.Bar to JSON.
     */
    encode: function (msg: Partial<TestDupFieldNumber.Bar>): string {
      return JSON.stringify(TestDupFieldNumberJSON.Bar._writeMessage(msg));
    },

    /**
     * Deserializes TestDupFieldNumber.Bar from JSON.
     */
    decode: function (json: string): TestDupFieldNumber.Bar {
      return TestDupFieldNumberJSON.Bar._readMessage(
        TestDupFieldNumberJSON.Bar.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      json: any
    ): TestDupFieldNumber.Bar {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestEagerMessageJSON = {
  /**
   * Serializes TestEagerMessage to JSON.
   */
  encode: function (msg: Partial<TestEagerMessage>): string {
    return JSON.stringify(TestEagerMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestEagerMessage from JSON.
   */
  decode: function (json: string): TestEagerMessage {
    return TestEagerMessageJSON._readMessage(
      TestEagerMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      subMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEagerMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const _subMessage_ = TestAllTypesJSON._writeMessage(msg.subMessage);
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestEagerMessage, json: any): TestEagerMessage {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _subMessage_);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestLazyMessageJSON = {
  /**
   * Serializes TestLazyMessage to JSON.
   */
  encode: function (msg: Partial<TestLazyMessage>): string {
    return JSON.stringify(TestLazyMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestLazyMessage from JSON.
   */
  decode: function (json: string): TestLazyMessage {
    return TestLazyMessageJSON._readMessage(
      TestLazyMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      subMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestLazyMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const _subMessage_ = TestAllTypesJSON._writeMessage(msg.subMessage);
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestLazyMessage, json: any): TestLazyMessage {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _subMessage_);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestNestedMessageHasBitsJSON = {
  /**
   * Serializes TestNestedMessageHasBits to JSON.
   */
  encode: function (msg: Partial<TestNestedMessageHasBits>): string {
    return JSON.stringify(TestNestedMessageHasBitsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestNestedMessageHasBits from JSON.
   */
  decode: function (json: string): TestNestedMessageHasBits {
    return TestNestedMessageHasBitsJSON._readMessage(
      TestNestedMessageHasBitsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBitsJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestNestedMessageHasBitsJSON.NestedMessage._writeMessage(
          msg.optionalNestedMessage
        );
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    json: any
  ): TestNestedMessageHasBits {
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestNestedMessageHasBits.NestedMessage.initialize();
      TestNestedMessageHasBitsJSON.NestedMessage._readMessage(
        m,
        _optionalNestedMessage_
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encode: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): string {
      return JSON.stringify(
        TestNestedMessageHasBitsJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decode: function (json: string): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBitsJSON.NestedMessage._readMessage(
        TestNestedMessageHasBitsJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json["nestedmessageRepeatedInt32"] = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json["nestedmessageRepeatedForeignmessage"] =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessageJSON._writeMessage
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      json: any
    ): TestNestedMessageHasBits.NestedMessage {
      const _nestedmessageRepeatedInt32_ =
        json["nestedmessageRepeatedInt32"] ??
        json["nestedmessage_repeated_int32"];
      if (_nestedmessageRepeatedInt32_) {
        msg.nestedmessageRepeatedInt32 = _nestedmessageRepeatedInt32_;
      }
      const _nestedmessageRepeatedForeignmessage_ =
        json["nestedmessageRepeatedForeignmessage"] ??
        json["nestedmessage_repeated_foreignmessage"];
      if (_nestedmessageRepeatedForeignmessage_) {
        for (const item of _nestedmessageRepeatedForeignmessage_) {
          const m = ForeignMessage.initialize();
          ForeignMessageJSON._readMessage(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNamesJSON = {
  /**
   * Serializes TestCamelCaseFieldNames to JSON.
   */
  encode: function (msg: Partial<TestCamelCaseFieldNames>): string {
    return JSON.stringify(TestCamelCaseFieldNamesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestCamelCaseFieldNames from JSON.
   */
  decode: function (json: string): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNamesJSON._readMessage(
      TestCamelCaseFieldNamesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: "",
      EnumField: ForeignEnum._fromInt(0),
      MessageField: ForeignMessageJSON.initialize(),
      StringPieceField: "",
      CordField: "",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.PrimitiveField) {
      json["PrimitiveField"] = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json["StringField"] = msg.StringField;
    }
    if (msg.EnumField && ForeignEnumJSON._toInt(msg.EnumField)) {
      json["EnumField"] = msg.EnumField;
    }
    if (msg.MessageField) {
      const _MessageField_ = ForeignMessageJSON._writeMessage(msg.MessageField);
      if (Object.keys(_MessageField_).length > 0) {
        json["MessageField"] = _MessageField_;
      }
    }
    if (msg.StringPieceField) {
      json["StringPieceField"] = msg.StringPieceField;
    }
    if (msg.CordField) {
      json["CordField"] = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json["RepeatedPrimitiveField"] = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json["RepeatedStringField"] = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json["RepeatedEnumField"] = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json["RepeatedMessageField"] = msg.RepeatedMessageField.map(
        ForeignMessageJSON._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json["RepeatedStringPieceField"] = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json["RepeatedCordField"] = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    json: any
  ): TestCamelCaseFieldNames {
    const _PrimitiveField_ = json["PrimitiveField"];
    if (_PrimitiveField_) {
      msg.PrimitiveField = _PrimitiveField_;
    }
    const _StringField_ = json["StringField"];
    if (_StringField_) {
      msg.StringField = _StringField_;
    }
    const _EnumField_ = json["EnumField"];
    if (_EnumField_) {
      msg.EnumField = _EnumField_;
    }
    const _MessageField_ = json["MessageField"];
    if (_MessageField_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _MessageField_);
      msg.MessageField = m;
    }
    const _StringPieceField_ = json["StringPieceField"];
    if (_StringPieceField_) {
      msg.StringPieceField = _StringPieceField_;
    }
    const _CordField_ = json["CordField"];
    if (_CordField_) {
      msg.CordField = _CordField_;
    }
    const _RepeatedPrimitiveField_ = json["RepeatedPrimitiveField"];
    if (_RepeatedPrimitiveField_) {
      msg.RepeatedPrimitiveField = _RepeatedPrimitiveField_;
    }
    const _RepeatedStringField_ = json["RepeatedStringField"];
    if (_RepeatedStringField_) {
      msg.RepeatedStringField = _RepeatedStringField_;
    }
    const _RepeatedEnumField_ = json["RepeatedEnumField"];
    if (_RepeatedEnumField_) {
      msg.RepeatedEnumField = _RepeatedEnumField_;
    }
    const _RepeatedMessageField_ = json["RepeatedMessageField"];
    if (_RepeatedMessageField_) {
      for (const item of _RepeatedMessageField_) {
        const m = ForeignMessage.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const _RepeatedStringPieceField_ = json["RepeatedStringPieceField"];
    if (_RepeatedStringPieceField_) {
      msg.RepeatedStringPieceField = _RepeatedStringPieceField_;
    }
    const _RepeatedCordField_ = json["RepeatedCordField"];
    if (_RepeatedCordField_) {
      msg.RepeatedCordField = _RepeatedCordField_;
    }
    return msg;
  },
};

export const TestFieldOrderingsJSON = {
  /**
   * Serializes TestFieldOrderings to JSON.
   */
  encode: function (msg: Partial<TestFieldOrderings>): string {
    return JSON.stringify(TestFieldOrderingsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestFieldOrderings from JSON.
   */
  decode: function (json: string): TestFieldOrderings {
    return TestFieldOrderingsJSON._readMessage(
      TestFieldOrderingsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      myString: "",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderingsJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestFieldOrderings>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    if (msg.myInt) {
      json["myInt"] = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json["myFloat"] = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestFieldOrderingsJSON.NestedMessage._writeMessage(
          msg.optionalNestedMessage
        );
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    json: any
  ): TestFieldOrderings {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    const _myInt_ = json["myInt"] ?? json["my_int"];
    if (_myInt_) {
      msg.myInt = BigInt(_myInt_);
    }
    const _myFloat_ = json["myFloat"] ?? json["my_float"];
    if (_myFloat_) {
      msg.myFloat = _myFloat_;
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestFieldOrderings.NestedMessage.initialize();
      TestFieldOrderingsJSON.NestedMessage._readMessage(
        m,
        _optionalNestedMessage_
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestFieldOrderings.NestedMessage to JSON.
     */
    encode: function (msg: Partial<TestFieldOrderings.NestedMessage>): string {
      return JSON.stringify(
        TestFieldOrderingsJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestFieldOrderings.NestedMessage from JSON.
     */
    decode: function (json: string): TestFieldOrderings.NestedMessage {
      return TestFieldOrderingsJSON.NestedMessage._readMessage(
        TestFieldOrderingsJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.oo) {
        json["oo"] = msg.oo.toString();
      }
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      json: any
    ): TestFieldOrderings.NestedMessage {
      const _oo_ = json["oo"];
      if (_oo_) {
        msg.oo = BigInt(_oo_);
      }
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1JSON = {
  /**
   * Serializes TestExtensionOrderings1 to JSON.
   */
  encode: function (msg: Partial<TestExtensionOrderings1>): string {
    return JSON.stringify(TestExtensionOrderings1JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionOrderings1 from JSON.
   */
  decode: function (json: string): TestExtensionOrderings1 {
    return TestExtensionOrderings1JSON._readMessage(
      TestExtensionOrderings1JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings1>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    json: any
  ): TestExtensionOrderings1 {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    return msg;
  },
};

export const TestExtensionOrderings2JSON = {
  /**
   * Serializes TestExtensionOrderings2 to JSON.
   */
  encode: function (msg: Partial<TestExtensionOrderings2>): string {
    return JSON.stringify(TestExtensionOrderings2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionOrderings2 from JSON.
   */
  decode: function (json: string): TestExtensionOrderings2 {
    return TestExtensionOrderings2JSON._readMessage(
      TestExtensionOrderings2JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    json: any
  ): TestExtensionOrderings2 {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encode: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): string {
      return JSON.stringify(
        TestExtensionOrderings2JSON.TestExtensionOrderings3._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decode: function (
      json: string
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2JSON.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2JSON.TestExtensionOrderings3.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        myString: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.myString) {
        json["myString"] = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      json: any
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      const _myString_ = json["myString"] ?? json["my_string"];
      if (_myString_) {
        msg.myString = _myString_;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValuesJSON = {
  /**
   * Serializes TestExtremeDefaultValues to JSON.
   */
  encode: function (msg: Partial<TestExtremeDefaultValues>): string {
    return JSON.stringify(TestExtremeDefaultValuesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtremeDefaultValues from JSON.
   */
  decode: function (json: string): TestExtremeDefaultValues {
    return TestExtremeDefaultValuesJSON._readMessage(
      TestExtremeDefaultValuesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: "",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: "",
      stringWithZero: "",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: "",
      cordWithZero: "",
      replacementString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.escapedBytes?.length) {
      json["escapedBytes"] = encodeBase64Bytes(msg.escapedBytes);
    }
    if (msg.largeUint32) {
      json["largeUint32"] = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json["largeUint64"] = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json["smallInt32"] = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json["smallInt64"] = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json["reallySmallInt32"] = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json["reallySmallInt64"] = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json["utf8String"] = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json["zeroFloat"] = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json["oneFloat"] = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json["smallFloat"] = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json["negativeOneFloat"] = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json["negativeFloat"] = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json["largeFloat"] = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json["smallNegativeFloat"] = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json["infDouble"] = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json["negInfDouble"] = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json["nanDouble"] = msg.nanDouble;
    }
    if (msg.infFloat) {
      json["infFloat"] = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json["negInfFloat"] = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json["nanFloat"] = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json["cppTrigraph"] = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json["stringWithZero"] = msg.stringWithZero;
    }
    if (msg.bytesWithZero?.length) {
      json["bytesWithZero"] = encodeBase64Bytes(msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      json["stringPieceWithZero"] = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json["cordWithZero"] = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json["replacementString"] = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    json: any
  ): TestExtremeDefaultValues {
    const _escapedBytes_ = json["escapedBytes"] ?? json["escaped_bytes"];
    if (_escapedBytes_) {
      msg.escapedBytes = decodeBase64Bytes(_escapedBytes_);
    }
    const _largeUint32_ = json["largeUint32"] ?? json["large_uint32"];
    if (_largeUint32_) {
      msg.largeUint32 = _largeUint32_;
    }
    const _largeUint64_ = json["largeUint64"] ?? json["large_uint64"];
    if (_largeUint64_) {
      msg.largeUint64 = BigInt(_largeUint64_);
    }
    const _smallInt32_ = json["smallInt32"] ?? json["small_int32"];
    if (_smallInt32_) {
      msg.smallInt32 = _smallInt32_;
    }
    const _smallInt64_ = json["smallInt64"] ?? json["small_int64"];
    if (_smallInt64_) {
      msg.smallInt64 = BigInt(_smallInt64_);
    }
    const _reallySmallInt32_ =
      json["reallySmallInt32"] ?? json["really_small_int32"];
    if (_reallySmallInt32_) {
      msg.reallySmallInt32 = _reallySmallInt32_;
    }
    const _reallySmallInt64_ =
      json["reallySmallInt64"] ?? json["really_small_int64"];
    if (_reallySmallInt64_) {
      msg.reallySmallInt64 = BigInt(_reallySmallInt64_);
    }
    const _utf8String_ = json["utf8String"] ?? json["utf8_string"];
    if (_utf8String_) {
      msg.utf8String = _utf8String_;
    }
    const _zeroFloat_ = json["zeroFloat"] ?? json["zero_float"];
    if (_zeroFloat_) {
      msg.zeroFloat = _zeroFloat_;
    }
    const _oneFloat_ = json["oneFloat"] ?? json["one_float"];
    if (_oneFloat_) {
      msg.oneFloat = _oneFloat_;
    }
    const _smallFloat_ = json["smallFloat"] ?? json["small_float"];
    if (_smallFloat_) {
      msg.smallFloat = _smallFloat_;
    }
    const _negativeOneFloat_ =
      json["negativeOneFloat"] ?? json["negative_one_float"];
    if (_negativeOneFloat_) {
      msg.negativeOneFloat = _negativeOneFloat_;
    }
    const _negativeFloat_ = json["negativeFloat"] ?? json["negative_float"];
    if (_negativeFloat_) {
      msg.negativeFloat = _negativeFloat_;
    }
    const _largeFloat_ = json["largeFloat"] ?? json["large_float"];
    if (_largeFloat_) {
      msg.largeFloat = _largeFloat_;
    }
    const _smallNegativeFloat_ =
      json["smallNegativeFloat"] ?? json["small_negative_float"];
    if (_smallNegativeFloat_) {
      msg.smallNegativeFloat = _smallNegativeFloat_;
    }
    const _infDouble_ = json["infDouble"] ?? json["inf_double"];
    if (_infDouble_) {
      msg.infDouble = _infDouble_;
    }
    const _negInfDouble_ = json["negInfDouble"] ?? json["neg_inf_double"];
    if (_negInfDouble_) {
      msg.negInfDouble = _negInfDouble_;
    }
    const _nanDouble_ = json["nanDouble"] ?? json["nan_double"];
    if (_nanDouble_) {
      msg.nanDouble = _nanDouble_;
    }
    const _infFloat_ = json["infFloat"] ?? json["inf_float"];
    if (_infFloat_) {
      msg.infFloat = _infFloat_;
    }
    const _negInfFloat_ = json["negInfFloat"] ?? json["neg_inf_float"];
    if (_negInfFloat_) {
      msg.negInfFloat = _negInfFloat_;
    }
    const _nanFloat_ = json["nanFloat"] ?? json["nan_float"];
    if (_nanFloat_) {
      msg.nanFloat = _nanFloat_;
    }
    const _cppTrigraph_ = json["cppTrigraph"] ?? json["cpp_trigraph"];
    if (_cppTrigraph_) {
      msg.cppTrigraph = _cppTrigraph_;
    }
    const _stringWithZero_ = json["stringWithZero"] ?? json["string_with_zero"];
    if (_stringWithZero_) {
      msg.stringWithZero = _stringWithZero_;
    }
    const _bytesWithZero_ = json["bytesWithZero"] ?? json["bytes_with_zero"];
    if (_bytesWithZero_) {
      msg.bytesWithZero = decodeBase64Bytes(_bytesWithZero_);
    }
    const _stringPieceWithZero_ =
      json["stringPieceWithZero"] ?? json["string_piece_with_zero"];
    if (_stringPieceWithZero_) {
      msg.stringPieceWithZero = _stringPieceWithZero_;
    }
    const _cordWithZero_ = json["cordWithZero"] ?? json["cord_with_zero"];
    if (_cordWithZero_) {
      msg.cordWithZero = _cordWithZero_;
    }
    const _replacementString_ =
      json["replacementString"] ?? json["replacement_string"];
    if (_replacementString_) {
      msg.replacementString = _replacementString_;
    }
    return msg;
  },
};

export const SparseEnumMessageJSON = {
  /**
   * Serializes SparseEnumMessage to JSON.
   */
  encode: function (msg: Partial<SparseEnumMessage>): string {
    return JSON.stringify(SparseEnumMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes SparseEnumMessage from JSON.
   */
  decode: function (json: string): SparseEnumMessage {
    return SparseEnumMessageJSON._readMessage(
      SparseEnumMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparseEnum: TestSparseEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SparseEnumMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sparseEnum && TestSparseEnumJSON._toInt(msg.sparseEnum)) {
      json["sparseEnum"] = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    json: any
  ): SparseEnumMessage {
    const _sparseEnum_ = json["sparseEnum"] ?? json["sparse_enum"];
    if (_sparseEnum_) {
      msg.sparseEnum = _sparseEnum_;
    }
    return msg;
  },
};

export const OneStringJSON = {
  /**
   * Serializes OneString to JSON.
   */
  encode: function (msg: Partial<OneString>): string {
    return JSON.stringify(OneStringJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneString from JSON.
   */
  decode: function (json: string): OneString {
    return OneStringJSON._readMessage(
      OneStringJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<OneString>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, json: any): OneString {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const MoreStringJSON = {
  /**
   * Serializes MoreString to JSON.
   */
  encode: function (msg: Partial<MoreString>): string {
    return JSON.stringify(MoreStringJSON._writeMessage(msg));
  },

  /**
   * Deserializes MoreString from JSON.
   */
  decode: function (json: string): MoreString {
    return MoreStringJSON._readMessage(
      MoreStringJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<MoreString>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, json: any): MoreString {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const OneBytesJSON = {
  /**
   * Serializes OneBytes to JSON.
   */
  encode: function (msg: Partial<OneBytes>): string {
    return JSON.stringify(OneBytesJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneBytes from JSON.
   */
  decode: function (json: string): OneBytes {
    return OneBytesJSON._readMessage(
      OneBytesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<OneBytes>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json["data"] = encodeBase64Bytes(msg.data);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, json: any): OneBytes {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = decodeBase64Bytes(_data_);
    }
    return msg;
  },
};

export const MoreBytesJSON = {
  /**
   * Serializes MoreBytes to JSON.
   */
  encode: function (msg: Partial<MoreBytes>): string {
    return JSON.stringify(MoreBytesJSON._writeMessage(msg));
  },

  /**
   * Deserializes MoreBytes from JSON.
   */
  decode: function (json: string): MoreBytes {
    return MoreBytesJSON._readMessage(
      MoreBytesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<MoreBytes>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json["data"] = msg.data.map(encodeBase64Bytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, json: any): MoreBytes {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_.map(decodeBase64Bytes);
    }
    return msg;
  },
};

export const Int32MessageJSON = {
  /**
   * Serializes Int32Message to JSON.
   */
  encode: function (msg: Partial<Int32Message>): string {
    return JSON.stringify(Int32MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Int32Message from JSON.
   */
  decode: function (json: string): Int32Message {
    return Int32MessageJSON._readMessage(
      Int32MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Int32Message, json: any): Int32Message {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const Uint32MessageJSON = {
  /**
   * Serializes Uint32Message to JSON.
   */
  encode: function (msg: Partial<Uint32Message>): string {
    return JSON.stringify(Uint32MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Uint32Message from JSON.
   */
  decode: function (json: string): Uint32Message {
    return Uint32MessageJSON._readMessage(
      Uint32MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint32Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Uint32Message, json: any): Uint32Message {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const Int64MessageJSON = {
  /**
   * Serializes Int64Message to JSON.
   */
  encode: function (msg: Partial<Int64Message>): string {
    return JSON.stringify(Int64MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Int64Message from JSON.
   */
  decode: function (json: string): Int64Message {
    return Int64MessageJSON._readMessage(
      Int64MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Int64Message, json: any): Int64Message {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = BigInt(_data_);
    }
    return msg;
  },
};

export const Uint64MessageJSON = {
  /**
   * Serializes Uint64Message to JSON.
   */
  encode: function (msg: Partial<Uint64Message>): string {
    return JSON.stringify(Uint64MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Uint64Message from JSON.
   */
  decode: function (json: string): Uint64Message {
    return Uint64MessageJSON._readMessage(
      Uint64MessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint64Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Uint64Message, json: any): Uint64Message {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = BigInt(_data_);
    }
    return msg;
  },
};

export const BoolMessageJSON = {
  /**
   * Serializes BoolMessage to JSON.
   */
  encode: function (msg: Partial<BoolMessage>): string {
    return JSON.stringify(BoolMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes BoolMessage from JSON.
   */
  decode: function (json: string): BoolMessage {
    return BoolMessageJSON._readMessage(
      BoolMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<BoolMessage>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, json: any): BoolMessage {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const TestOneofJSON = {
  /**
   * Serializes TestOneof to JSON.
   */
  encode: function (msg: Partial<TestOneof>): string {
    return JSON.stringify(TestOneofJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof from JSON.
   */
  decode: function (json: string): TestOneof {
    return TestOneofJSON._readMessage(
      TestOneofJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<TestOneof>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestAllTypesJSON._writeMessage(msg.fooMessage);
      json["fooMessage"] = _fooMessage_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, json: any): TestOneof {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneof.FooGroup to JSON.
     */
    encode: function (msg: Partial<TestOneof.FooGroup>): string {
      return JSON.stringify(TestOneofJSON.FooGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof.FooGroup from JSON.
     */
    decode: function (json: string): TestOneof.FooGroup {
      return TestOneofJSON.FooGroup._readMessage(
        TestOneofJSON.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      json: any
    ): TestOneof.FooGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatibleJSON = {
  /**
   * Serializes TestOneofBackwardsCompatible to JSON.
   */
  encode: function (msg: Partial<TestOneofBackwardsCompatible>): string {
    return JSON.stringify(TestOneofBackwardsCompatibleJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneofBackwardsCompatible from JSON.
   */
  decode: function (json: string): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatibleJSON._readMessage(
      TestOneofBackwardsCompatibleJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      fooInt: 0,
      fooString: "",
      fooMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage) {
      const _fooMessage_ = TestAllTypesJSON._writeMessage(msg.fooMessage);
      if (Object.keys(_fooMessage_).length > 0) {
        json["fooMessage"] = _fooMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    json: any
  ): TestOneofBackwardsCompatible {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encode: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): string {
      return JSON.stringify(
        TestOneofBackwardsCompatibleJSON.FooGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decode: function (json: string): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatibleJSON.FooGroup._readMessage(
        TestOneofBackwardsCompatibleJSON.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      json: any
    ): TestOneofBackwardsCompatible.FooGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },
};

export const TestOneof2JSON = {
  /**
   * Serializes TestOneof2 to JSON.
   */
  encode: function (msg: Partial<TestOneof2>): string {
    return JSON.stringify(TestOneof2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof2 from JSON.
   */
  decode: function (json: string): TestOneof2 {
    return TestOneof2JSON._readMessage(
      TestOneof2JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooCord: undefined,
      fooStringPiece: undefined,
      fooBytes: undefined,
      fooEnum: undefined,
      fooMessage: undefined,
      fooLazyMessage: undefined,
      barInt: undefined,
      barString: undefined,
      barCord: undefined,
      barStringPiece: undefined,
      barBytes: undefined,
      barEnum: undefined,
      barStringWithEmptyDefault: undefined,
      barCordWithEmptyDefault: undefined,
      barStringPieceWithEmptyDefault: undefined,
      barBytesWithEmptyDefault: undefined,
      bazInt: 0,
      bazString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<TestOneof2>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json["fooCord"] = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json["fooStringPiece"] = msg.fooStringPiece;
    }
    if (msg.fooBytes?.length) {
      json["fooBytes"] = encodeBase64Bytes(msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      json["fooEnum"] = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestOneof2JSON.NestedMessage._writeMessage(
        msg.fooMessage
      );
      json["fooMessage"] = _fooMessage_;
    }
    if (msg.fooLazyMessage != undefined) {
      const _fooLazyMessage_ = TestOneof2JSON.NestedMessage._writeMessage(
        msg.fooLazyMessage
      );
      json["fooLazyMessage"] = _fooLazyMessage_;
    }
    if (msg.barInt != undefined) {
      json["barInt"] = msg.barInt;
    }
    if (msg.barString != undefined) {
      json["barString"] = msg.barString;
    }
    if (msg.barCord != undefined) {
      json["barCord"] = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json["barStringPiece"] = msg.barStringPiece;
    }
    if (msg.barBytes?.length) {
      json["barBytes"] = encodeBase64Bytes(msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      json["barEnum"] = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json["barStringWithEmptyDefault"] = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json["barCordWithEmptyDefault"] = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json["barStringPieceWithEmptyDefault"] =
        msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      json["barBytesWithEmptyDefault"] = encodeBase64Bytes(
        msg.barBytesWithEmptyDefault
      );
    }
    if (msg.bazInt) {
      json["bazInt"] = msg.bazInt;
    }
    if (msg.bazString) {
      json["bazString"] = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, json: any): TestOneof2 {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooCord_ = json["fooCord"] ?? json["foo_cord"];
    if (_fooCord_) {
      msg.fooCord = _fooCord_;
    }
    const _fooStringPiece_ = json["fooStringPiece"] ?? json["foo_string_piece"];
    if (_fooStringPiece_) {
      msg.fooStringPiece = _fooStringPiece_;
    }
    const _fooBytes_ = json["fooBytes"] ?? json["foo_bytes"];
    if (_fooBytes_) {
      msg.fooBytes = decodeBase64Bytes(_fooBytes_);
    }
    const _fooEnum_ = json["fooEnum"] ?? json["foo_enum"];
    if (_fooEnum_) {
      msg.fooEnum = _fooEnum_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2JSON.NestedMessage._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    const _fooLazyMessage_ = json["fooLazyMessage"] ?? json["foo_lazy_message"];
    if (_fooLazyMessage_) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2JSON.NestedMessage._readMessage(m, _fooLazyMessage_);
      msg.fooLazyMessage = m;
    }
    const _barInt_ = json["barInt"] ?? json["bar_int"];
    if (_barInt_) {
      msg.barInt = _barInt_;
    }
    const _barString_ = json["barString"] ?? json["bar_string"];
    if (_barString_) {
      msg.barString = _barString_;
    }
    const _barCord_ = json["barCord"] ?? json["bar_cord"];
    if (_barCord_) {
      msg.barCord = _barCord_;
    }
    const _barStringPiece_ = json["barStringPiece"] ?? json["bar_string_piece"];
    if (_barStringPiece_) {
      msg.barStringPiece = _barStringPiece_;
    }
    const _barBytes_ = json["barBytes"] ?? json["bar_bytes"];
    if (_barBytes_) {
      msg.barBytes = decodeBase64Bytes(_barBytes_);
    }
    const _barEnum_ = json["barEnum"] ?? json["bar_enum"];
    if (_barEnum_) {
      msg.barEnum = _barEnum_;
    }
    const _barStringWithEmptyDefault_ =
      json["barStringWithEmptyDefault"] ??
      json["bar_string_with_empty_default"];
    if (_barStringWithEmptyDefault_) {
      msg.barStringWithEmptyDefault = _barStringWithEmptyDefault_;
    }
    const _barCordWithEmptyDefault_ =
      json["barCordWithEmptyDefault"] ?? json["bar_cord_with_empty_default"];
    if (_barCordWithEmptyDefault_) {
      msg.barCordWithEmptyDefault = _barCordWithEmptyDefault_;
    }
    const _barStringPieceWithEmptyDefault_ =
      json["barStringPieceWithEmptyDefault"] ??
      json["bar_string_piece_with_empty_default"];
    if (_barStringPieceWithEmptyDefault_) {
      msg.barStringPieceWithEmptyDefault = _barStringPieceWithEmptyDefault_;
    }
    const _barBytesWithEmptyDefault_ =
      json["barBytesWithEmptyDefault"] ?? json["bar_bytes_with_empty_default"];
    if (_barBytesWithEmptyDefault_) {
      msg.barBytesWithEmptyDefault = decodeBase64Bytes(
        _barBytesWithEmptyDefault_
      );
    }
    const _bazInt_ = json["bazInt"] ?? json["baz_int"];
    if (_bazInt_) {
      msg.bazInt = _bazInt_;
    }
    const _bazString_ = json["bazString"] ?? json["baz_string"];
    if (_bazString_) {
      msg.bazString = _bazString_;
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestOneof2.NestedEnum {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestOneof2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestOneof2.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  FooGroup: {
    /**
     * Serializes TestOneof2.FooGroup to JSON.
     */
    encode: function (msg: Partial<TestOneof2.FooGroup>): string {
      return JSON.stringify(TestOneof2JSON.FooGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof2.FooGroup from JSON.
     */
    decode: function (json: string): TestOneof2.FooGroup {
      return TestOneof2JSON.FooGroup._readMessage(
        TestOneof2JSON.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      json: any
    ): TestOneof2.FooGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes TestOneof2.NestedMessage to JSON.
     */
    encode: function (msg: Partial<TestOneof2.NestedMessage>): string {
      return JSON.stringify(TestOneof2JSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof2.NestedMessage from JSON.
     */
    decode: function (json: string): TestOneof2.NestedMessage {
      return TestOneof2JSON.NestedMessage._readMessage(
        TestOneof2JSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.quxInt) {
        json["quxInt"] = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json["corgeInt"] = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      json: any
    ): TestOneof2.NestedMessage {
      const _quxInt_ = json["quxInt"] ?? json["qux_int"];
      if (_quxInt_) {
        msg.quxInt = BigInt(_quxInt_);
      }
      const _corgeInt_ = json["corgeInt"] ?? json["corge_int"];
      if (_corgeInt_) {
        msg.corgeInt = _corgeInt_;
      }
      return msg;
    },
  },
};

export const TestRequiredOneofJSON = {
  /**
   * Serializes TestRequiredOneof to JSON.
   */
  encode: function (msg: Partial<TestRequiredOneof>): string {
    return JSON.stringify(TestRequiredOneofJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredOneof from JSON.
   */
  decode: function (json: string): TestRequiredOneof {
    return TestRequiredOneofJSON._readMessage(
      TestRequiredOneofJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredOneof>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestRequiredOneofJSON.NestedMessage._writeMessage(
        msg.fooMessage
      );
      json["fooMessage"] = _fooMessage_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    json: any
  ): TestRequiredOneof {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      const m = TestRequiredOneof.NestedMessage.initialize();
      TestRequiredOneofJSON.NestedMessage._readMessage(m, _fooMessage_);
      msg.fooMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestRequiredOneof.NestedMessage to JSON.
     */
    encode: function (msg: Partial<TestRequiredOneof.NestedMessage>): string {
      return JSON.stringify(
        TestRequiredOneofJSON.NestedMessage._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestRequiredOneof.NestedMessage from JSON.
     */
    decode: function (json: string): TestRequiredOneof.NestedMessage {
      return TestRequiredOneofJSON.NestedMessage._readMessage(
        TestRequiredOneofJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.requiredDouble) {
        json["requiredDouble"] = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      json: any
    ): TestRequiredOneof.NestedMessage {
      const _requiredDouble_ =
        json["requiredDouble"] ?? json["required_double"];
      if (_requiredDouble_) {
        msg.requiredDouble = _requiredDouble_;
      }
      return msg;
    },
  },
};

export const TestPackedTypesJSON = {
  /**
   * Serializes TestPackedTypes to JSON.
   */
  encode: function (msg: Partial<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestPackedTypes from JSON.
   */
  decode: function (json: string): TestPackedTypes {
    return TestPackedTypesJSON._readMessage(
      TestPackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json["packedInt64"] = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json["packedUint32"] = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json["packedUint64"] = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json["packedSint32"] = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json["packedSint64"] = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json["packedFixed32"] = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json["packedFixed64"] = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json["packedSfixed32"] = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json["packedSfixed64"] = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json["packedFloat"] = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json["packedDouble"] = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json["packedBool"] = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json["packedEnum"] = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestPackedTypes, json: any): TestPackedTypes {
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _packedInt64_ = json["packedInt64"] ?? json["packed_int64"];
    if (_packedInt64_) {
      msg.packedInt64 = _packedInt64_.map(BigInt);
    }
    const _packedUint32_ = json["packedUint32"] ?? json["packed_uint32"];
    if (_packedUint32_) {
      msg.packedUint32 = _packedUint32_;
    }
    const _packedUint64_ = json["packedUint64"] ?? json["packed_uint64"];
    if (_packedUint64_) {
      msg.packedUint64 = _packedUint64_.map(BigInt);
    }
    const _packedSint32_ = json["packedSint32"] ?? json["packed_sint32"];
    if (_packedSint32_) {
      msg.packedSint32 = _packedSint32_;
    }
    const _packedSint64_ = json["packedSint64"] ?? json["packed_sint64"];
    if (_packedSint64_) {
      msg.packedSint64 = _packedSint64_.map(BigInt);
    }
    const _packedFixed32_ = json["packedFixed32"] ?? json["packed_fixed32"];
    if (_packedFixed32_) {
      msg.packedFixed32 = _packedFixed32_;
    }
    const _packedFixed64_ = json["packedFixed64"] ?? json["packed_fixed64"];
    if (_packedFixed64_) {
      msg.packedFixed64 = _packedFixed64_.map(BigInt);
    }
    const _packedSfixed32_ = json["packedSfixed32"] ?? json["packed_sfixed32"];
    if (_packedSfixed32_) {
      msg.packedSfixed32 = _packedSfixed32_;
    }
    const _packedSfixed64_ = json["packedSfixed64"] ?? json["packed_sfixed64"];
    if (_packedSfixed64_) {
      msg.packedSfixed64 = _packedSfixed64_.map(BigInt);
    }
    const _packedFloat_ = json["packedFloat"] ?? json["packed_float"];
    if (_packedFloat_) {
      msg.packedFloat = _packedFloat_;
    }
    const _packedDouble_ = json["packedDouble"] ?? json["packed_double"];
    if (_packedDouble_) {
      msg.packedDouble = _packedDouble_;
    }
    const _packedBool_ = json["packedBool"] ?? json["packed_bool"];
    if (_packedBool_) {
      msg.packedBool = _packedBool_;
    }
    const _packedEnum_ = json["packedEnum"] ?? json["packed_enum"];
    if (_packedEnum_) {
      msg.packedEnum = _packedEnum_;
    }
    return msg;
  },
};

export const TestUnpackedTypesJSON = {
  /**
   * Serializes TestUnpackedTypes to JSON.
   */
  encode: function (msg: Partial<TestUnpackedTypes>): string {
    return JSON.stringify(TestUnpackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestUnpackedTypes from JSON.
   */
  decode: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypesJSON._readMessage(
      TestUnpackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.unpackedInt32?.length) {
      json["unpackedInt32"] = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json["unpackedInt64"] = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json["unpackedUint32"] = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json["unpackedUint64"] = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json["unpackedSint32"] = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json["unpackedSint64"] = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json["unpackedFixed32"] = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json["unpackedFixed64"] = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json["unpackedSfixed32"] = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json["unpackedSfixed64"] = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json["unpackedFloat"] = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json["unpackedDouble"] = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json["unpackedBool"] = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json["unpackedEnum"] = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    json: any
  ): TestUnpackedTypes {
    const _unpackedInt32_ = json["unpackedInt32"] ?? json["unpacked_int32"];
    if (_unpackedInt32_) {
      msg.unpackedInt32 = _unpackedInt32_;
    }
    const _unpackedInt64_ = json["unpackedInt64"] ?? json["unpacked_int64"];
    if (_unpackedInt64_) {
      msg.unpackedInt64 = _unpackedInt64_.map(BigInt);
    }
    const _unpackedUint32_ = json["unpackedUint32"] ?? json["unpacked_uint32"];
    if (_unpackedUint32_) {
      msg.unpackedUint32 = _unpackedUint32_;
    }
    const _unpackedUint64_ = json["unpackedUint64"] ?? json["unpacked_uint64"];
    if (_unpackedUint64_) {
      msg.unpackedUint64 = _unpackedUint64_.map(BigInt);
    }
    const _unpackedSint32_ = json["unpackedSint32"] ?? json["unpacked_sint32"];
    if (_unpackedSint32_) {
      msg.unpackedSint32 = _unpackedSint32_;
    }
    const _unpackedSint64_ = json["unpackedSint64"] ?? json["unpacked_sint64"];
    if (_unpackedSint64_) {
      msg.unpackedSint64 = _unpackedSint64_.map(BigInt);
    }
    const _unpackedFixed32_ =
      json["unpackedFixed32"] ?? json["unpacked_fixed32"];
    if (_unpackedFixed32_) {
      msg.unpackedFixed32 = _unpackedFixed32_;
    }
    const _unpackedFixed64_ =
      json["unpackedFixed64"] ?? json["unpacked_fixed64"];
    if (_unpackedFixed64_) {
      msg.unpackedFixed64 = _unpackedFixed64_.map(BigInt);
    }
    const _unpackedSfixed32_ =
      json["unpackedSfixed32"] ?? json["unpacked_sfixed32"];
    if (_unpackedSfixed32_) {
      msg.unpackedSfixed32 = _unpackedSfixed32_;
    }
    const _unpackedSfixed64_ =
      json["unpackedSfixed64"] ?? json["unpacked_sfixed64"];
    if (_unpackedSfixed64_) {
      msg.unpackedSfixed64 = _unpackedSfixed64_.map(BigInt);
    }
    const _unpackedFloat_ = json["unpackedFloat"] ?? json["unpacked_float"];
    if (_unpackedFloat_) {
      msg.unpackedFloat = _unpackedFloat_;
    }
    const _unpackedDouble_ = json["unpackedDouble"] ?? json["unpacked_double"];
    if (_unpackedDouble_) {
      msg.unpackedDouble = _unpackedDouble_;
    }
    const _unpackedBool_ = json["unpackedBool"] ?? json["unpacked_bool"];
    if (_unpackedBool_) {
      msg.unpackedBool = _unpackedBool_;
    }
    const _unpackedEnum_ = json["unpackedEnum"] ?? json["unpacked_enum"];
    if (_unpackedEnum_) {
      msg.unpackedEnum = _unpackedEnum_;
    }
    return msg;
  },
};

export const TestPackedExtensionsJSON = {
  /**
   * Serializes TestPackedExtensions to JSON.
   */
  encode: function (_msg?: Partial<TestPackedExtensions>): string {
    return "{}";
  },

  /**
   * Deserializes TestPackedExtensions from JSON.
   */
  decode: function (_json?: string): TestPackedExtensions {
    return {};
  },

  /**
   * Initializes TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestPackedExtensions>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedExtensions,
    _json: any
  ): TestPackedExtensions {
    return msg;
  },
};

export const TestUnpackedExtensionsJSON = {
  /**
   * Serializes TestUnpackedExtensions to JSON.
   */
  encode: function (_msg?: Partial<TestUnpackedExtensions>): string {
    return "{}";
  },

  /**
   * Deserializes TestUnpackedExtensions from JSON.
   */
  decode: function (_json?: string): TestUnpackedExtensions {
    return {};
  },

  /**
   * Initializes TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestUnpackedExtensions>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedExtensions,
    _json: any
  ): TestUnpackedExtensions {
    return msg;
  },
};

export const TestDynamicExtensionsJSON = {
  /**
   * Serializes TestDynamicExtensions to JSON.
   */
  encode: function (msg: Partial<TestDynamicExtensions>): string {
    return JSON.stringify(TestDynamicExtensionsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDynamicExtensions from JSON.
   */
  decode: function (json: string): TestDynamicExtensions {
    return TestDynamicExtensionsJSON._readMessage(
      TestDynamicExtensionsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnum._fromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType._fromInt(0),
      messageExtension: ForeignMessageJSON.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensionsJSON.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDynamicExtensions>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.scalarExtension) {
      json["scalarExtension"] = msg.scalarExtension;
    }
    if (msg.enumExtension && ForeignEnumJSON._toInt(msg.enumExtension)) {
      json["enumExtension"] = msg.enumExtension;
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensionsJSON.DynamicEnumType._toInt(msg.dynamicEnumExtension)
    ) {
      json["dynamicEnumExtension"] = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const _messageExtension_ = ForeignMessageJSON._writeMessage(
        msg.messageExtension
      );
      if (Object.keys(_messageExtension_).length > 0) {
        json["messageExtension"] = _messageExtension_;
      }
    }
    if (msg.dynamicMessageExtension) {
      const _dynamicMessageExtension_ =
        TestDynamicExtensionsJSON.DynamicMessageType._writeMessage(
          msg.dynamicMessageExtension
        );
      if (Object.keys(_dynamicMessageExtension_).length > 0) {
        json["dynamicMessageExtension"] = _dynamicMessageExtension_;
      }
    }
    if (msg.repeatedExtension?.length) {
      json["repeatedExtension"] = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json["packedExtension"] = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    json: any
  ): TestDynamicExtensions {
    const _scalarExtension_ =
      json["scalarExtension"] ?? json["scalar_extension"];
    if (_scalarExtension_) {
      msg.scalarExtension = _scalarExtension_;
    }
    const _enumExtension_ = json["enumExtension"] ?? json["enum_extension"];
    if (_enumExtension_) {
      msg.enumExtension = _enumExtension_;
    }
    const _dynamicEnumExtension_ =
      json["dynamicEnumExtension"] ?? json["dynamic_enum_extension"];
    if (_dynamicEnumExtension_) {
      msg.dynamicEnumExtension = _dynamicEnumExtension_;
    }
    const _messageExtension_ =
      json["messageExtension"] ?? json["message_extension"];
    if (_messageExtension_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _messageExtension_);
      msg.messageExtension = m;
    }
    const _dynamicMessageExtension_ =
      json["dynamicMessageExtension"] ?? json["dynamic_message_extension"];
    if (_dynamicMessageExtension_) {
      const m = TestDynamicExtensions.DynamicMessageType.initialize();
      TestDynamicExtensionsJSON.DynamicMessageType._readMessage(
        m,
        _dynamicMessageExtension_
      );
      msg.dynamicMessageExtension = m;
    }
    const _repeatedExtension_ =
      json["repeatedExtension"] ?? json["repeated_extension"];
    if (_repeatedExtension_) {
      msg.repeatedExtension = _repeatedExtension_;
    }
    const _packedExtension_ =
      json["packedExtension"] ?? json["packed_extension"];
    if (_packedExtension_) {
      msg.packedExtension = _packedExtension_;
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: "DYNAMIC_FOO",
    DYNAMIC_BAR: "DYNAMIC_BAR",
    DYNAMIC_BAZ: "DYNAMIC_BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestDynamicExtensions.DynamicEnumType {
      switch (i) {
        case 2200: {
          return "DYNAMIC_FOO";
        }
        case 2201: {
          return "DYNAMIC_BAR";
        }
        case 2202: {
          return "DYNAMIC_BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestDynamicExtensions.DynamicEnumType;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestDynamicExtensions.DynamicEnumType): number {
      switch (i) {
        case "DYNAMIC_FOO": {
          return 2200;
        }
        case "DYNAMIC_BAR": {
          return 2201;
        }
        case "DYNAMIC_BAZ": {
          return 2202;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  DynamicMessageType: {
    /**
     * Serializes TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encode: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): string {
      return JSON.stringify(
        TestDynamicExtensionsJSON.DynamicMessageType._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decode: function (json: string): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensionsJSON.DynamicMessageType._readMessage(
        TestDynamicExtensionsJSON.DynamicMessageType.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.dynamicField) {
        json["dynamicField"] = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      json: any
    ): TestDynamicExtensions.DynamicMessageType {
      const _dynamicField_ = json["dynamicField"] ?? json["dynamic_field"];
      if (_dynamicField_) {
        msg.dynamicField = _dynamicField_;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizesJSON = {
  /**
   * Serializes TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encode: function (msg: Partial<TestRepeatedScalarDifferentTagSizes>): string {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizesJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decode: function (json: string): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizesJSON._readMessage(
      TestRepeatedScalarDifferentTagSizesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    json: any
  ): TestRepeatedScalarDifferentTagSizes {
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMergeJSON = {
  /**
   * Serializes TestParsingMerge to JSON.
   */
  encode: function (msg: Partial<TestParsingMerge>): string {
    return JSON.stringify(TestParsingMergeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestParsingMerge from JSON.
   */
  decode: function (json: string): TestParsingMerge {
    return TestParsingMergeJSON._readMessage(
      TestParsingMergeJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      requiredAllTypes: TestAllTypesJSON.initialize(),
      optionalAllTypes: TestAllTypesJSON.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestParsingMerge>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.requiredAllTypes) {
      const _requiredAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.requiredAllTypes
      );
      if (Object.keys(_requiredAllTypes_).length > 0) {
        json["requiredAllTypes"] = _requiredAllTypes_;
      }
    }
    if (msg.optionalAllTypes) {
      const _optionalAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.optionalAllTypes
      );
      if (Object.keys(_optionalAllTypes_).length > 0) {
        json["optionalAllTypes"] = _optionalAllTypes_;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json["repeatedAllTypes"] = msg.repeatedAllTypes.map(
        TestAllTypesJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestParsingMerge, json: any): TestParsingMerge {
    const _requiredAllTypes_ =
      json["requiredAllTypes"] ?? json["required_all_types"];
    if (_requiredAllTypes_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _requiredAllTypes_);
      msg.requiredAllTypes = m;
    }
    const _optionalAllTypes_ =
      json["optionalAllTypes"] ?? json["optional_all_types"];
    if (_optionalAllTypes_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _optionalAllTypes_);
      msg.optionalAllTypes = m;
    }
    const _repeatedAllTypes_ =
      json["repeatedAllTypes"] ?? json["repeated_all_types"];
    if (_repeatedAllTypes_) {
      for (const item of _repeatedAllTypes_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encode: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): string {
      return JSON.stringify(
        TestParsingMergeJSON.RepeatedFieldsGenerator._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decode: function (json: string): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMergeJSON.RepeatedFieldsGenerator._readMessage(
        TestParsingMergeJSON.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.field1?.length) {
        json["field1"] = msg.field1.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.field2?.length) {
        json["field2"] = msg.field2.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.field3?.length) {
        json["field3"] = msg.field3.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.ext1?.length) {
        json["ext1"] = msg.ext1.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.ext2?.length) {
        json["ext2"] = msg.ext2.map(TestAllTypesJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      json: any
    ): TestParsingMerge.RepeatedFieldsGenerator {
      const _field1_ = json["field1"];
      if (_field1_) {
        for (const item of _field1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field1.push(m);
        }
      }
      const _field2_ = json["field2"];
      if (_field2_) {
        for (const item of _field2_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field2.push(m);
        }
      }
      const _field3_ = json["field3"];
      if (_field3_) {
        for (const item of _field3_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field3.push(m);
        }
      }
      const _ext1_ = json["ext1"];
      if (_ext1_) {
        for (const item of _ext1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.ext1.push(m);
        }
      }
      const _ext2_ = json["ext2"];
      if (_ext2_) {
        for (const item of _ext2_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encode: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): string {
        return JSON.stringify(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group1._writeMessage(msg)
        );
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decode: function (
        json: string
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMergeJSON.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypesJSON.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const _field1_ = TestAllTypesJSON._writeMessage(msg.field1);
          if (Object.keys(_field1_).length > 0) {
            json["field1"] = _field1_;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        json: any
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        const _field1_ = json["field1"];
        if (_field1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, _field1_);
          msg.field1 = m;
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encode: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): string {
        return JSON.stringify(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group2._writeMessage(msg)
        );
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decode: function (
        json: string
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMergeJSON.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypesJSON.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const _field1_ = TestAllTypesJSON._writeMessage(msg.field1);
          if (Object.keys(_field1_).length > 0) {
            json["field1"] = _field1_;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        json: any
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        const _field1_ = json["field1"];
        if (_field1_) {
          const m = TestAllTypes.initialize();
          TestAllTypesJSON._readMessage(m, _field1_);
          msg.field1 = m;
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestParsingMerge.OptionalGroup to JSON.
     */
    encode: function (msg: Partial<TestParsingMerge.OptionalGroup>): string {
      return JSON.stringify(
        TestParsingMergeJSON.OptionalGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestParsingMerge.OptionalGroup from JSON.
     */
    decode: function (json: string): TestParsingMerge.OptionalGroup {
      return TestParsingMergeJSON.OptionalGroup._readMessage(
        TestParsingMergeJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optionalGroupAllTypes: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.optionalGroupAllTypes) {
        const _optionalGroupAllTypes_ = TestAllTypesJSON._writeMessage(
          msg.optionalGroupAllTypes
        );
        if (Object.keys(_optionalGroupAllTypes_).length > 0) {
          json["optionalGroupAllTypes"] = _optionalGroupAllTypes_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      json: any
    ): TestParsingMerge.OptionalGroup {
      const _optionalGroupAllTypes_ =
        json["optionalGroupAllTypes"] ?? json["optional_group_all_types"];
      if (_optionalGroupAllTypes_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, _optionalGroupAllTypes_);
        msg.optionalGroupAllTypes = m;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestParsingMerge.RepeatedGroup to JSON.
     */
    encode: function (msg: Partial<TestParsingMerge.RepeatedGroup>): string {
      return JSON.stringify(
        TestParsingMergeJSON.RepeatedGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestParsingMerge.RepeatedGroup from JSON.
     */
    decode: function (json: string): TestParsingMerge.RepeatedGroup {
      return TestParsingMergeJSON.RepeatedGroup._readMessage(
        TestParsingMergeJSON.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeatedGroupAllTypes: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.repeatedGroupAllTypes) {
        const _repeatedGroupAllTypes_ = TestAllTypesJSON._writeMessage(
          msg.repeatedGroupAllTypes
        );
        if (Object.keys(_repeatedGroupAllTypes_).length > 0) {
          json["repeatedGroupAllTypes"] = _repeatedGroupAllTypes_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      json: any
    ): TestParsingMerge.RepeatedGroup {
      const _repeatedGroupAllTypes_ =
        json["repeatedGroupAllTypes"] ?? json["repeated_group_all_types"];
      if (_repeatedGroupAllTypes_) {
        const m = TestAllTypes.initialize();
        TestAllTypesJSON._readMessage(m, _repeatedGroupAllTypes_);
        msg.repeatedGroupAllTypes = m;
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessageJSON = {
  /**
   * Serializes TestCommentInjectionMessage to JSON.
   */
  encode: function (msg: Partial<TestCommentInjectionMessage>): string {
    return JSON.stringify(TestCommentInjectionMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestCommentInjectionMessage from JSON.
   */
  decode: function (json: string): TestCommentInjectionMessage {
    return TestCommentInjectionMessageJSON._readMessage(
      TestCommentInjectionMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    json: any
  ): TestCommentInjectionMessage {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const FooRequestJSON = {
  /**
   * Serializes FooRequest to JSON.
   */
  encode: function (_msg?: Partial<FooRequest>): string {
    return "{}";
  },

  /**
   * Deserializes FooRequest from JSON.
   */
  decode: function (_json?: string): FooRequest {
    return {};
  },

  /**
   * Initializes FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg: Partial<FooRequest>): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooRequest, _json: any): FooRequest {
    return msg;
  },
};

export const FooResponseJSON = {
  /**
   * Serializes FooResponse to JSON.
   */
  encode: function (_msg?: Partial<FooResponse>): string {
    return "{}";
  },

  /**
   * Deserializes FooResponse from JSON.
   */
  decode: function (_json?: string): FooResponse {
    return {};
  },

  /**
   * Initializes FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooResponse>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooResponse, _json: any): FooResponse {
    return msg;
  },
};

export const FooClientMessageJSON = {
  /**
   * Serializes FooClientMessage to JSON.
   */
  encode: function (_msg?: Partial<FooClientMessage>): string {
    return "{}";
  },

  /**
   * Deserializes FooClientMessage from JSON.
   */
  decode: function (_json?: string): FooClientMessage {
    return {};
  },

  /**
   * Initializes FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooClientMessage>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooClientMessage, _json: any): FooClientMessage {
    return msg;
  },
};

export const FooServerMessageJSON = {
  /**
   * Serializes FooServerMessage to JSON.
   */
  encode: function (_msg?: Partial<FooServerMessage>): string {
    return "{}";
  },

  /**
   * Deserializes FooServerMessage from JSON.
   */
  decode: function (_json?: string): FooServerMessage {
    return {};
  },

  /**
   * Initializes FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<FooServerMessage>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooServerMessage, _json: any): FooServerMessage {
    return msg;
  },
};

export const BarRequestJSON = {
  /**
   * Serializes BarRequest to JSON.
   */
  encode: function (_msg?: Partial<BarRequest>): string {
    return "{}";
  },

  /**
   * Deserializes BarRequest from JSON.
   */
  decode: function (_json?: string): BarRequest {
    return {};
  },

  /**
   * Initializes BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg: Partial<BarRequest>): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: BarRequest, _json: any): BarRequest {
    return msg;
  },
};

export const BarResponseJSON = {
  /**
   * Serializes BarResponse to JSON.
   */
  encode: function (_msg?: Partial<BarResponse>): string {
    return "{}";
  },

  /**
   * Deserializes BarResponse from JSON.
   */
  decode: function (_json?: string): BarResponse {
    return {};
  },

  /**
   * Initializes BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<BarResponse>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: BarResponse, _json: any): BarResponse {
    return msg;
  },
};

export const TestJsonNameJSON = {
  /**
   * Serializes TestJsonName to JSON.
   */
  encode: function (msg: Partial<TestJsonName>): string {
    return JSON.stringify(TestJsonNameJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestJsonName from JSON.
   */
  decode: function (json: string): TestJsonName {
    return TestJsonNameJSON._readMessage(
      TestJsonNameJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestJsonName>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fieldName1) {
      json["fieldName1"] = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json["fieldName2"] = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json["FieldName3"] = msg.FieldName3;
    }
    if (msg.FieldName4) {
      json["FieldName4"] = msg.FieldName4;
    }
    if (msg.FIELDNAME5) {
      json["FIELDNAME5"] = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json["@type"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json["fieldname7"] = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestJsonName, json: any): TestJsonName {
    const _fieldName1_ = json["fieldName1"] ?? json["field_name1"];
    if (_fieldName1_) {
      msg.fieldName1 = _fieldName1_;
    }
    const _fieldName2_ = json["fieldName2"];
    if (_fieldName2_) {
      msg.fieldName2 = _fieldName2_;
    }
    const _FieldName3_ = json["FieldName3"];
    if (_FieldName3_) {
      msg.FieldName3 = _FieldName3_;
    }
    const _FieldName4_ = json["FieldName4"] ?? json["_field_name4"];
    if (_FieldName4_) {
      msg.FieldName4 = _FieldName4_;
    }
    const _FIELDNAME5_ = json["FIELDNAME5"] ?? json["FIELD_NAME5"];
    if (_FIELDNAME5_) {
      msg.FIELDNAME5 = _FIELDNAME5_;
    }
    const _fieldName6_ =
      json["@type"] ?? json["fieldName6"] ?? json["field_name6"];
    if (_fieldName6_) {
      msg.fieldName6 = _fieldName6_;
    }
    const _fieldname7_ = json["fieldname7"];
    if (_fieldname7_) {
      msg.fieldname7 = _fieldname7_;
    }
    return msg;
  },
};

export const TestHugeFieldNumbersJSON = {
  /**
   * Serializes TestHugeFieldNumbers to JSON.
   */
  encode: function (msg: Partial<TestHugeFieldNumbers>): string {
    return JSON.stringify(TestHugeFieldNumbersJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestHugeFieldNumbers from JSON.
   */
  decode: function (json: string): TestHugeFieldNumbers {
    return TestHugeFieldNumbersJSON._readMessage(
      TestHugeFieldNumbersJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnum._fromInt(0),
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessageJSON.initialize(),
      stringStringMap: {},
      oneofUint32: undefined,
      oneofTestAllTypes: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json["fixed32"] = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.optionalEnum && ForeignEnumJSON._toInt(msg.optionalEnum)) {
      json["optionalEnum"] = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      const _optionalMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalMessage
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.stringStringMap) {
      const _stringStringMap_ = Object.fromEntries(
        Object.entries(msg.stringStringMap)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestHugeFieldNumbersJSON.StringStringMap._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_stringStringMap_).length > 0) {
        json["stringStringMap"] = _stringStringMap_;
      }
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const _oneofTestAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.oneofTestAllTypes
      );
      json["oneofTestAllTypes"] = _oneofTestAllTypes_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    json: any
  ): TestHugeFieldNumbers {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _fixed32_ = json["fixed32"] ?? json["fixed_32"];
    if (_fixed32_) {
      msg.fixed32 = _fixed32_;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _optionalEnum_ = json["optionalEnum"] ?? json["optional_enum"];
    if (_optionalEnum_) {
      msg.optionalEnum = _optionalEnum_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _optionalMessage_);
      msg.optionalMessage = m;
    }
    const _stringStringMap_ =
      json["stringStringMap"] ?? json["string_string_map"];
    if (_stringStringMap_) {
      msg.stringStringMap = Object.fromEntries(
        Object.entries(_stringStringMap_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestHugeFieldNumbersJSON.StringStringMap._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofTestAllTypes_ =
      json["oneofTestAllTypes"] ?? json["oneof_test_all_types"];
    if (_oneofTestAllTypes_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _oneofTestAllTypes_);
      msg.oneofTestAllTypes = m;
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encode: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestHugeFieldNumbersJSON.OptionalGroup._writeMessage(msg)
      );
    },

    /**
     * Deserializes TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decode: function (json: string): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbersJSON.OptionalGroup._readMessage(
        TestHugeFieldNumbersJSON.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.groupA) {
        json["groupA"] = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      json: any
    ): TestHugeFieldNumbers.OptionalGroup {
      const _groupA_ = json["groupA"] ?? json["group_a"];
      if (_groupA_) {
        msg.groupA = _groupA_;
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.StringStringMap>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.StringStringMap,
      json: any
    ): TestHugeFieldNumbers.StringStringMap {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTableJSON = {
  /**
   * Serializes TestExtensionInsideTable to JSON.
   */
  encode: function (msg: Partial<TestExtensionInsideTable>): string {
    return JSON.stringify(TestExtensionInsideTableJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionInsideTable from JSON.
   */
  decode: function (json: string): TestExtensionInsideTable {
    return TestExtensionInsideTableJSON._readMessage(
      TestExtensionInsideTableJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionInsideTable>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.field1) {
      json["field1"] = msg.field1;
    }
    if (msg.field2) {
      json["field2"] = msg.field2;
    }
    if (msg.field3) {
      json["field3"] = msg.field3;
    }
    if (msg.field4) {
      json["field4"] = msg.field4;
    }
    if (msg.field6) {
      json["field6"] = msg.field6;
    }
    if (msg.field7) {
      json["field7"] = msg.field7;
    }
    if (msg.field8) {
      json["field8"] = msg.field8;
    }
    if (msg.field9) {
      json["field9"] = msg.field9;
    }
    if (msg.field10) {
      json["field10"] = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    json: any
  ): TestExtensionInsideTable {
    const _field1_ = json["field1"];
    if (_field1_) {
      msg.field1 = _field1_;
    }
    const _field2_ = json["field2"];
    if (_field2_) {
      msg.field2 = _field2_;
    }
    const _field3_ = json["field3"];
    if (_field3_) {
      msg.field3 = _field3_;
    }
    const _field4_ = json["field4"];
    if (_field4_) {
      msg.field4 = _field4_;
    }
    const _field6_ = json["field6"];
    if (_field6_) {
      msg.field6 = _field6_;
    }
    const _field7_ = json["field7"];
    if (_field7_) {
      msg.field7 = _field7_;
    }
    const _field8_ = json["field8"];
    if (_field8_) {
      msg.field8 = _field8_;
    }
    const _field9_ = json["field9"];
    if (_field9_) {
      msg.field9 = _field9_;
    }
    const _field10_ = json["field10"];
    if (_field10_) {
      msg.field10 = _field10_;
    }
    return msg;
  },
};

export const TestExtensionRangeSerializeJSON = {
  /**
   * Serializes TestExtensionRangeSerialize to JSON.
   */
  encode: function (msg: Partial<TestExtensionRangeSerialize>): string {
    return JSON.stringify(TestExtensionRangeSerializeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionRangeSerialize from JSON.
   */
  decode: function (json: string): TestExtensionRangeSerialize {
    return TestExtensionRangeSerializeJSON._readMessage(
      TestExtensionRangeSerializeJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooOne) {
      json["fooOne"] = msg.fooOne;
    }
    if (msg.fooTwo) {
      json["fooTwo"] = msg.fooTwo;
    }
    if (msg.fooThree) {
      json["fooThree"] = msg.fooThree;
    }
    if (msg.fooFour) {
      json["fooFour"] = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    json: any
  ): TestExtensionRangeSerialize {
    const _fooOne_ = json["fooOne"] ?? json["foo_one"];
    if (_fooOne_) {
      msg.fooOne = _fooOne_;
    }
    const _fooTwo_ = json["fooTwo"] ?? json["foo_two"];
    if (_fooTwo_) {
      msg.fooTwo = _fooTwo_;
    }
    const _fooThree_ = json["fooThree"] ?? json["foo_three"];
    if (_fooThree_) {
      msg.fooThree = _fooThree_;
    }
    const _fooFour_ = json["fooFour"] ?? json["foo_four"];
    if (_fooFour_) {
      msg.fooFour = _fooFour_;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "google/protobuf/map_unittest.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";

import * as googleProtobufUnittest from "./unittest.pb";

//========================================//
//                 Types                  //
//========================================//

export type MapEnum = "MAP_ENUM_FOO" | "MAP_ENUM_BAR" | "MAP_ENUM_BAZ";

/**
 * Tests maps.
 */
export interface TestMap {
  mapInt32Int32: Record<string, TestMap.MapInt32Int32["value"] | undefined>;
  mapInt64Int64: Record<string, TestMap.MapInt64Int64["value"] | undefined>;
  mapUint32Uint32: Record<string, TestMap.MapUint32Uint32["value"] | undefined>;
  mapUint64Uint64: Record<string, TestMap.MapUint64Uint64["value"] | undefined>;
  mapSint32Sint32: Record<string, TestMap.MapSint32Sint32["value"] | undefined>;
  mapSint64Sint64: Record<string, TestMap.MapSint64Sint64["value"] | undefined>;
  mapFixed32Fixed32: Record<
    string,
    TestMap.MapFixed32Fixed32["value"] | undefined
  >;
  mapFixed64Fixed64: Record<
    string,
    TestMap.MapFixed64Fixed64["value"] | undefined
  >;
  mapSfixed32Sfixed32: Record<
    string,
    TestMap.MapSfixed32Sfixed32["value"] | undefined
  >;
  mapSfixed64Sfixed64: Record<
    string,
    TestMap.MapSfixed64Sfixed64["value"] | undefined
  >;
  mapInt32Float: Record<string, TestMap.MapInt32Float["value"] | undefined>;
  mapInt32Double: Record<string, TestMap.MapInt32Double["value"] | undefined>;
  mapBoolBool: Record<string, TestMap.MapBoolBool["value"] | undefined>;
  mapStringString: Record<string, TestMap.MapStringString["value"] | undefined>;
  mapInt32Bytes: Record<string, TestMap.MapInt32Bytes["value"] | undefined>;
  mapInt32Enum: Record<string, TestMap.MapInt32Enum["value"] | undefined>;
  mapInt32ForeignMessage: Record<
    string,
    TestMap.MapInt32ForeignMessage["value"] | undefined
  >;
  mapStringForeignMessage: Record<
    string,
    TestMap.MapStringForeignMessage["value"] | undefined
  >;
  mapInt32AllTypes: Record<
    string,
    TestMap.MapInt32AllTypes["value"] | undefined
  >;
}

export declare namespace TestMap {
  interface MapInt32Int32 {
    key: number;
    value: number;
  }

  interface MapInt64Int64 {
    key: bigint;
    value: bigint;
  }

  interface MapUint32Uint32 {
    key: number;
    value: number;
  }

  interface MapUint64Uint64 {
    key: bigint;
    value: bigint;
  }

  interface MapSint32Sint32 {
    key: number;
    value: number;
  }

  interface MapSint64Sint64 {
    key: bigint;
    value: bigint;
  }

  interface MapFixed32Fixed32 {
    key: number;
    value: number;
  }

  interface MapFixed64Fixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapSfixed32Sfixed32 {
    key: number;
    value: number;
  }

  interface MapSfixed64Sfixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapInt32Float {
    key: number;
    value: number;
  }

  interface MapInt32Double {
    key: number;
    value: number;
  }

  interface MapBoolBool {
    key: boolean;
    value: boolean;
  }

  interface MapStringString {
    key: string;
    value: string;
  }

  interface MapInt32Bytes {
    key: number;
    value: Uint8Array;
  }

  interface MapInt32Enum {
    key: number;
    value: MapEnum;
  }

  interface MapInt32ForeignMessage {
    key: number;
    value: googleProtobufUnittest.ForeignMessage;
  }

  interface MapStringForeignMessage {
    key: string;
    value: googleProtobufUnittest.ForeignMessage;
  }

  interface MapInt32AllTypes {
    key: number;
    value: googleProtobufUnittest.TestAllTypes;
  }
}

export interface TestMapSubmessage {
  testMap: TestMap;
}

export interface TestMessageMap {
  mapInt32Message: Record<
    string,
    TestMessageMap.MapInt32Message["value"] | undefined
  >;
}

export declare namespace TestMessageMap {
  interface MapInt32Message {
    key: number;
    value: googleProtobufUnittest.TestAllTypes;
  }
}

/**
 * Two map fields share the same entry default instance.
 */
export interface TestSameTypeMap {
  map1: Record<string, TestSameTypeMap.Map1["value"] | undefined>;
  map2: Record<string, TestSameTypeMap.Map2["value"] | undefined>;
}

export declare namespace TestSameTypeMap {
  interface Map1 {
    key: number;
    value: number;
  }

  interface Map2 {
    key: number;
    value: number;
  }
}

/**
 * Test embedded message with required fields
 */
export interface TestRequiredMessageMap {
  mapField: Record<
    string,
    TestRequiredMessageMap.MapField["value"] | undefined
  >;
}

export declare namespace TestRequiredMessageMap {
  interface MapField {
    key: number;
    value: googleProtobufUnittest.TestRequired;
  }
}

export interface TestArenaMap {
  mapInt32Int32: Record<
    string,
    TestArenaMap.MapInt32Int32["value"] | undefined
  >;
  mapInt64Int64: Record<
    string,
    TestArenaMap.MapInt64Int64["value"] | undefined
  >;
  mapUint32Uint32: Record<
    string,
    TestArenaMap.MapUint32Uint32["value"] | undefined
  >;
  mapUint64Uint64: Record<
    string,
    TestArenaMap.MapUint64Uint64["value"] | undefined
  >;
  mapSint32Sint32: Record<
    string,
    TestArenaMap.MapSint32Sint32["value"] | undefined
  >;
  mapSint64Sint64: Record<
    string,
    TestArenaMap.MapSint64Sint64["value"] | undefined
  >;
  mapFixed32Fixed32: Record<
    string,
    TestArenaMap.MapFixed32Fixed32["value"] | undefined
  >;
  mapFixed64Fixed64: Record<
    string,
    TestArenaMap.MapFixed64Fixed64["value"] | undefined
  >;
  mapSfixed32Sfixed32: Record<
    string,
    TestArenaMap.MapSfixed32Sfixed32["value"] | undefined
  >;
  mapSfixed64Sfixed64: Record<
    string,
    TestArenaMap.MapSfixed64Sfixed64["value"] | undefined
  >;
  mapInt32Float: Record<
    string,
    TestArenaMap.MapInt32Float["value"] | undefined
  >;
  mapInt32Double: Record<
    string,
    TestArenaMap.MapInt32Double["value"] | undefined
  >;
  mapBoolBool: Record<string, TestArenaMap.MapBoolBool["value"] | undefined>;
  mapStringString: Record<
    string,
    TestArenaMap.MapStringString["value"] | undefined
  >;
  mapInt32Bytes: Record<
    string,
    TestArenaMap.MapInt32Bytes["value"] | undefined
  >;
  mapInt32Enum: Record<string, TestArenaMap.MapInt32Enum["value"] | undefined>;
  mapInt32ForeignMessage: Record<
    string,
    TestArenaMap.MapInt32ForeignMessage["value"] | undefined
  >;
}

export declare namespace TestArenaMap {
  interface MapInt32Int32 {
    key: number;
    value: number;
  }

  interface MapInt64Int64 {
    key: bigint;
    value: bigint;
  }

  interface MapUint32Uint32 {
    key: number;
    value: number;
  }

  interface MapUint64Uint64 {
    key: bigint;
    value: bigint;
  }

  interface MapSint32Sint32 {
    key: number;
    value: number;
  }

  interface MapSint64Sint64 {
    key: bigint;
    value: bigint;
  }

  interface MapFixed32Fixed32 {
    key: number;
    value: number;
  }

  interface MapFixed64Fixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapSfixed32Sfixed32 {
    key: number;
    value: number;
  }

  interface MapSfixed64Sfixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapInt32Float {
    key: number;
    value: number;
  }

  interface MapInt32Double {
    key: number;
    value: number;
  }

  interface MapBoolBool {
    key: boolean;
    value: boolean;
  }

  interface MapStringString {
    key: string;
    value: string;
  }

  interface MapInt32Bytes {
    key: number;
    value: Uint8Array;
  }

  interface MapInt32Enum {
    key: number;
    value: MapEnum;
  }

  interface MapInt32ForeignMessage {
    key: number;
    value: googleProtobufUnittest.ForeignMessage;
  }
}

/**
 * Previously, message cannot contain map field called "entry".
 */
export interface MessageContainingMapCalledEntry {
  entry: Record<
    string,
    MessageContainingMapCalledEntry.Entry["value"] | undefined
  >;
}

export declare namespace MessageContainingMapCalledEntry {
  interface Entry {
    key: number;
    value: number;
  }
}

export interface TestRecursiveMapMessage {
  a: Record<string, TestRecursiveMapMessage.A["value"] | undefined>;
}

export declare namespace TestRecursiveMapMessage {
  interface A {
    key: string;
    value: TestRecursiveMapMessage;
  }
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: "MAP_ENUM_FOO",
  MAP_ENUM_BAR: "MAP_ENUM_BAR",
  MAP_ENUM_BAZ: "MAP_ENUM_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): MapEnum {
    switch (i) {
      case 0: {
        return "MAP_ENUM_FOO";
      }
      case 1: {
        return "MAP_ENUM_BAR";
      }
      case 2: {
        return "MAP_ENUM_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as MapEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: MapEnum): number {
    switch (i) {
      case "MAP_ENUM_FOO": {
        return 0;
      }
      case "MAP_ENUM_BAR": {
        return 1;
      }
      case "MAP_ENUM_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestMap = {
  /**
   * Serializes TestMap to protobuf.
   */
  encode: function (msg: Partial<TestMap>): Uint8Array {
    return TestMap._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMap {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32ForeignMessage._writeMessage
      );
    }
    if (msg.mapStringForeignMessage) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.mapStringForeignMessage).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapStringForeignMessage._writeMessage
      );
    }
    if (msg.mapInt32AllTypes) {
      writer.writeRepeatedMessage(
        19,
        Object.entries(msg.mapInt32AllTypes).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32AllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, reader: BinaryReader): TestMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestMap.MapInt32Int32;
          reader.readMessage(map, TestMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {} as TestMap.MapInt64Int64;
          reader.readMessage(map, TestMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {} as TestMap.MapUint32Uint32;
          reader.readMessage(map, TestMap.MapUint32Uint32._readMessage);
          msg.mapUint32Uint32[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {} as TestMap.MapUint64Uint64;
          reader.readMessage(map, TestMap.MapUint64Uint64._readMessage);
          msg.mapUint64Uint64[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {} as TestMap.MapSint32Sint32;
          reader.readMessage(map, TestMap.MapSint32Sint32._readMessage);
          msg.mapSint32Sint32[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {} as TestMap.MapSint64Sint64;
          reader.readMessage(map, TestMap.MapSint64Sint64._readMessage);
          msg.mapSint64Sint64[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {} as TestMap.MapFixed32Fixed32;
          reader.readMessage(map, TestMap.MapFixed32Fixed32._readMessage);
          msg.mapFixed32Fixed32[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {} as TestMap.MapFixed64Fixed64;
          reader.readMessage(map, TestMap.MapFixed64Fixed64._readMessage);
          msg.mapFixed64Fixed64[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {} as TestMap.MapSfixed32Sfixed32;
          reader.readMessage(map, TestMap.MapSfixed32Sfixed32._readMessage);
          msg.mapSfixed32Sfixed32[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {} as TestMap.MapSfixed64Sfixed64;
          reader.readMessage(map, TestMap.MapSfixed64Sfixed64._readMessage);
          msg.mapSfixed64Sfixed64[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {} as TestMap.MapInt32Float;
          reader.readMessage(map, TestMap.MapInt32Float._readMessage);
          msg.mapInt32Float[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {} as TestMap.MapInt32Double;
          reader.readMessage(map, TestMap.MapInt32Double._readMessage);
          msg.mapInt32Double[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {} as TestMap.MapBoolBool;
          reader.readMessage(map, TestMap.MapBoolBool._readMessage);
          msg.mapBoolBool[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {} as TestMap.MapStringString;
          reader.readMessage(map, TestMap.MapStringString._readMessage);
          msg.mapStringString[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {} as TestMap.MapInt32Bytes;
          reader.readMessage(map, TestMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {} as TestMap.MapInt32Enum;
          reader.readMessage(map, TestMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {} as TestMap.MapInt32ForeignMessage;
          reader.readMessage(map, TestMap.MapInt32ForeignMessage._readMessage);
          msg.mapInt32ForeignMessage[map.key.toString()] = map.value;
          break;
        }
        case 18: {
          const map = {} as TestMap.MapStringForeignMessage;
          reader.readMessage(map, TestMap.MapStringForeignMessage._readMessage);
          msg.mapStringForeignMessage[map.key.toString()] = map.value;
          break;
        }
        case 19: {
          const map = {} as TestMap.MapInt32AllTypes;
          reader.readMessage(map, TestMap.MapInt32AllTypes._readMessage);
          msg.mapInt32AllTypes[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Int32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Int32,
      reader: BinaryReader
    ): TestMap.MapInt32Int32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt64Int64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt64Int64,
      reader: BinaryReader
    ): TestMap.MapInt64Int64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapUint32Uint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapUint32Uint32,
      reader: BinaryReader
    ): TestMap.MapUint32Uint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapUint64Uint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapUint64Uint64,
      reader: BinaryReader
    ): TestMap.MapUint64Uint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSint32Sint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSint32Sint32,
      reader: BinaryReader
    ): TestMap.MapSint32Sint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSint64Sint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSint64Sint64,
      reader: BinaryReader
    ): TestMap.MapSint64Sint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapFixed32Fixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapFixed32Fixed32,
      reader: BinaryReader
    ): TestMap.MapFixed32Fixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapFixed64Fixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapFixed64Fixed64,
      reader: BinaryReader
    ): TestMap.MapFixed64Fixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSfixed32Sfixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSfixed32Sfixed32,
      reader: BinaryReader
    ): TestMap.MapSfixed32Sfixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSfixed64Sfixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSfixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSfixed64Sfixed64,
      reader: BinaryReader
    ): TestMap.MapSfixed64Sfixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Float>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Float,
      reader: BinaryReader
    ): TestMap.MapInt32Float {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Double>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Double,
      reader: BinaryReader
    ): TestMap.MapInt32Double {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapBoolBool>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapBoolBool,
      reader: BinaryReader
    ): TestMap.MapBoolBool {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapStringString>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapStringString,
      reader: BinaryReader
    ): TestMap.MapStringString {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Bytes>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Bytes,
      reader: BinaryReader
    ): TestMap.MapInt32Bytes {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Enum>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnum._toInt(msg.value)) {
        writer.writeEnum(2, MapEnum._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Enum,
      reader: BinaryReader
    ): TestMap.MapInt32Enum {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnum._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32ForeignMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32ForeignMessage,
      reader: BinaryReader
    ): TestMap.MapInt32ForeignMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapStringForeignMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapStringForeignMessage,
      reader: BinaryReader
    ): TestMap.MapStringForeignMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32AllTypes>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32AllTypes,
      reader: BinaryReader
    ): TestMap.MapInt32AllTypes {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestAllTypes.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes TestMapSubmessage to protobuf.
   */
  encode: function (msg: Partial<TestMapSubmessage>): Uint8Array {
    return TestMapSubmessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMapSubmessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestMapSubmessage {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMapSubmessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    reader: BinaryReader
  ): TestMapSubmessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes TestMessageMap to protobuf.
   */
  encode: function (msg: Partial<TestMessageMap>): Uint8Array {
    return TestMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageMap {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Message) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Message).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMessageMap.MapInt32Message._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageMap,
    reader: BinaryReader
  ): TestMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestMessageMap.MapInt32Message;
          reader.readMessage(map, TestMessageMap.MapInt32Message._readMessage);
          msg.mapInt32Message[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMessageMap.MapInt32Message>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMessageMap.MapInt32Message,
      reader: BinaryReader
    ): TestMessageMap.MapInt32Message {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestAllTypes.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes TestSameTypeMap to protobuf.
   */
  encode: function (msg: Partial<TestSameTypeMap>): Uint8Array {
    return TestSameTypeMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestSameTypeMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestSameTypeMap {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestSameTypeMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map1) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.map1).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestSameTypeMap.Map1._writeMessage
      );
    }
    if (msg.map2) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.map2).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestSameTypeMap.Map2._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestSameTypeMap,
    reader: BinaryReader
  ): TestSameTypeMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestSameTypeMap.Map1;
          reader.readMessage(map, TestSameTypeMap.Map1._readMessage);
          msg.map1[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {} as TestSameTypeMap.Map2;
          reader.readMessage(map, TestSameTypeMap.Map2._readMessage);
          msg.map2[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestSameTypeMap.Map1>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestSameTypeMap.Map1,
      reader: BinaryReader
    ): TestSameTypeMap.Map1 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestSameTypeMap.Map2>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestSameTypeMap.Map2,
      reader: BinaryReader
    ): TestSameTypeMap.Map2 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes TestRequiredMessageMap to protobuf.
   */
  encode: function (msg: Partial<TestRequiredMessageMap>): Uint8Array {
    return TestRequiredMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestRequiredMessageMap.MapField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    reader: BinaryReader
  ): TestRequiredMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestRequiredMessageMap.MapField;
          reader.readMessage(map, TestRequiredMessageMap.MapField._readMessage);
          msg.mapField[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredMessageMap.MapField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestRequired._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredMessageMap.MapField,
      reader: BinaryReader
    ): TestRequiredMessageMap.MapField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestRequired.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestRequired._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestArenaMap = {
  /**
   * Serializes TestArenaMap to protobuf.
   */
  encode: function (msg: Partial<TestArenaMap>): Uint8Array {
    return TestArenaMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestArenaMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestArenaMap {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestArenaMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32ForeignMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestArenaMap,
    reader: BinaryReader
  ): TestArenaMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestArenaMap.MapInt32Int32;
          reader.readMessage(map, TestArenaMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {} as TestArenaMap.MapInt64Int64;
          reader.readMessage(map, TestArenaMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {} as TestArenaMap.MapUint32Uint32;
          reader.readMessage(map, TestArenaMap.MapUint32Uint32._readMessage);
          msg.mapUint32Uint32[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {} as TestArenaMap.MapUint64Uint64;
          reader.readMessage(map, TestArenaMap.MapUint64Uint64._readMessage);
          msg.mapUint64Uint64[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {} as TestArenaMap.MapSint32Sint32;
          reader.readMessage(map, TestArenaMap.MapSint32Sint32._readMessage);
          msg.mapSint32Sint32[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {} as TestArenaMap.MapSint64Sint64;
          reader.readMessage(map, TestArenaMap.MapSint64Sint64._readMessage);
          msg.mapSint64Sint64[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {} as TestArenaMap.MapFixed32Fixed32;
          reader.readMessage(map, TestArenaMap.MapFixed32Fixed32._readMessage);
          msg.mapFixed32Fixed32[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {} as TestArenaMap.MapFixed64Fixed64;
          reader.readMessage(map, TestArenaMap.MapFixed64Fixed64._readMessage);
          msg.mapFixed64Fixed64[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {} as TestArenaMap.MapSfixed32Sfixed32;
          reader.readMessage(
            map,
            TestArenaMap.MapSfixed32Sfixed32._readMessage
          );
          msg.mapSfixed32Sfixed32[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {} as TestArenaMap.MapSfixed64Sfixed64;
          reader.readMessage(
            map,
            TestArenaMap.MapSfixed64Sfixed64._readMessage
          );
          msg.mapSfixed64Sfixed64[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {} as TestArenaMap.MapInt32Float;
          reader.readMessage(map, TestArenaMap.MapInt32Float._readMessage);
          msg.mapInt32Float[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {} as TestArenaMap.MapInt32Double;
          reader.readMessage(map, TestArenaMap.MapInt32Double._readMessage);
          msg.mapInt32Double[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {} as TestArenaMap.MapBoolBool;
          reader.readMessage(map, TestArenaMap.MapBoolBool._readMessage);
          msg.mapBoolBool[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {} as TestArenaMap.MapStringString;
          reader.readMessage(map, TestArenaMap.MapStringString._readMessage);
          msg.mapStringString[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {} as TestArenaMap.MapInt32Bytes;
          reader.readMessage(map, TestArenaMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {} as TestArenaMap.MapInt32Enum;
          reader.readMessage(map, TestArenaMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {} as TestArenaMap.MapInt32ForeignMessage;
          reader.readMessage(
            map,
            TestArenaMap.MapInt32ForeignMessage._readMessage
          );
          msg.mapInt32ForeignMessage[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Int32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Int32,
      reader: BinaryReader
    ): TestArenaMap.MapInt32Int32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt64Int64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt64Int64,
      reader: BinaryReader
    ): TestArenaMap.MapInt64Int64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapUint32Uint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapUint32Uint32,
      reader: BinaryReader
    ): TestArenaMap.MapUint32Uint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapUint64Uint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapUint64Uint64,
      reader: BinaryReader
    ): TestArenaMap.MapUint64Uint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSint32Sint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSint32Sint32,
      reader: BinaryReader
    ): TestArenaMap.MapSint32Sint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSint64Sint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSint64Sint64,
      reader: BinaryReader
    ): TestArenaMap.MapSint64Sint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapFixed32Fixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapFixed32Fixed32,
      reader: BinaryReader
    ): TestArenaMap.MapFixed32Fixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapFixed64Fixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapFixed64Fixed64,
      reader: BinaryReader
    ): TestArenaMap.MapFixed64Fixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSfixed32Sfixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSfixed32Sfixed32,
      reader: BinaryReader
    ): TestArenaMap.MapSfixed32Sfixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSfixed64Sfixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSfixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSfixed64Sfixed64,
      reader: BinaryReader
    ): TestArenaMap.MapSfixed64Sfixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Float>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Float,
      reader: BinaryReader
    ): TestArenaMap.MapInt32Float {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Double>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Double,
      reader: BinaryReader
    ): TestArenaMap.MapInt32Double {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapBoolBool>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapBoolBool,
      reader: BinaryReader
    ): TestArenaMap.MapBoolBool {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapStringString>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapStringString,
      reader: BinaryReader
    ): TestArenaMap.MapStringString {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Bytes>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Bytes,
      reader: BinaryReader
    ): TestArenaMap.MapInt32Bytes {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Enum>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnum._toInt(msg.value)) {
        writer.writeEnum(2, MapEnum._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Enum,
      reader: BinaryReader
    ): TestArenaMap.MapInt32Enum {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnum._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32ForeignMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32ForeignMessage,
      reader: BinaryReader
    ): TestArenaMap.MapInt32ForeignMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (msg: Partial<MessageContainingMapCalledEntry>): Uint8Array {
    return MessageContainingMapCalledEntry._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes: ByteSource): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.entry) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.entry).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MessageContainingMapCalledEntry.Entry._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    reader: BinaryReader
  ): MessageContainingMapCalledEntry {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as MessageContainingMapCalledEntry.Entry;
          reader.readMessage(
            map,
            MessageContainingMapCalledEntry.Entry._readMessage
          );
          msg.entry[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MessageContainingMapCalledEntry.Entry>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MessageContainingMapCalledEntry.Entry,
      reader: BinaryReader
    ): MessageContainingMapCalledEntry.Entry {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes TestRecursiveMapMessage to protobuf.
   */
  encode: function (msg: Partial<TestRecursiveMapMessage>): Uint8Array {
    return TestRecursiveMapMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.a).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestRecursiveMapMessage.A._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    reader: BinaryReader
  ): TestRecursiveMapMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestRecursiveMapMessage.A;
          reader.readMessage(map, TestRecursiveMapMessage.A._readMessage);
          msg.a[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRecursiveMapMessage.A>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          TestRecursiveMapMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRecursiveMapMessage.A,
      reader: BinaryReader
    ): TestRecursiveMapMessage.A {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = TestRecursiveMapMessage.initialize();
            reader.readMessage(msg.value, TestRecursiveMapMessage._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const MapEnumJSON = {
  MAP_ENUM_FOO: "MAP_ENUM_FOO",
  MAP_ENUM_BAR: "MAP_ENUM_BAR",
  MAP_ENUM_BAZ: "MAP_ENUM_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): MapEnum {
    switch (i) {
      case 0: {
        return "MAP_ENUM_FOO";
      }
      case 1: {
        return "MAP_ENUM_BAR";
      }
      case 2: {
        return "MAP_ENUM_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as MapEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: MapEnum): number {
    switch (i) {
      case "MAP_ENUM_FOO": {
        return 0;
      }
      case "MAP_ENUM_BAR": {
        return 1;
      }
      case "MAP_ENUM_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestMapJSON = {
  /**
   * Serializes TestMap to JSON.
   */
  encode: function (msg: Partial<TestMap>): string {
    return JSON.stringify(TestMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMap from JSON.
   */
  decode: function (json: string): TestMap {
    return TestMapJSON._readMessage(TestMapJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<TestMap>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      const _mapInt32Int32_ = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Int32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Int32_).length > 0) {
        json["mapInt32Int32"] = _mapInt32Int32_;
      }
    }
    if (msg.mapInt64Int64) {
      const _mapInt64Int64_ = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt64Int64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt64Int64_).length > 0) {
        json["mapInt64Int64"] = _mapInt64Int64_;
      }
    }
    if (msg.mapUint32Uint32) {
      const _mapUint32Uint32_ = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapUint32Uint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint32Uint32_).length > 0) {
        json["mapUint32Uint32"] = _mapUint32Uint32_;
      }
    }
    if (msg.mapUint64Uint64) {
      const _mapUint64Uint64_ = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapUint64Uint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint64Uint64_).length > 0) {
        json["mapUint64Uint64"] = _mapUint64Uint64_;
      }
    }
    if (msg.mapSint32Sint32) {
      const _mapSint32Sint32_ = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSint32Sint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint32Sint32_).length > 0) {
        json["mapSint32Sint32"] = _mapSint32Sint32_;
      }
    }
    if (msg.mapSint64Sint64) {
      const _mapSint64Sint64_ = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSint64Sint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint64Sint64_).length > 0) {
        json["mapSint64Sint64"] = _mapSint64Sint64_;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const _mapFixed32Fixed32_ = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapFixed32Fixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed32Fixed32_).length > 0) {
        json["mapFixed32Fixed32"] = _mapFixed32Fixed32_;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const _mapFixed64Fixed64_ = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapFixed64Fixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed64Fixed64_).length > 0) {
        json["mapFixed64Fixed64"] = _mapFixed64Fixed64_;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const _mapSfixed32Sfixed32_ = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSfixed32Sfixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed32Sfixed32_).length > 0) {
        json["mapSfixed32Sfixed32"] = _mapSfixed32Sfixed32_;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const _mapSfixed64Sfixed64_ = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSfixed64Sfixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed64Sfixed64_).length > 0) {
        json["mapSfixed64Sfixed64"] = _mapSfixed64Sfixed64_;
      }
    }
    if (msg.mapInt32Float) {
      const _mapInt32Float_ = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Float._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Float_).length > 0) {
        json["mapInt32Float"] = _mapInt32Float_;
      }
    }
    if (msg.mapInt32Double) {
      const _mapInt32Double_ = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Double._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Double_).length > 0) {
        json["mapInt32Double"] = _mapInt32Double_;
      }
    }
    if (msg.mapBoolBool) {
      const _mapBoolBool_ = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapBoolBool._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapBoolBool_).length > 0) {
        json["mapBoolBool"] = _mapBoolBool_;
      }
    }
    if (msg.mapStringString) {
      const _mapStringString_ = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapStringString._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapStringString_).length > 0) {
        json["mapStringString"] = _mapStringString_;
      }
    }
    if (msg.mapInt32Bytes) {
      const _mapInt32Bytes_ = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Bytes._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Bytes_).length > 0) {
        json["mapInt32Bytes"] = _mapInt32Bytes_;
      }
    }
    if (msg.mapInt32Enum) {
      const _mapInt32Enum_ = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Enum._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Enum_).length > 0) {
        json["mapInt32Enum"] = _mapInt32Enum_;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const _mapInt32ForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32ForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32ForeignMessage_).length > 0) {
        json["mapInt32ForeignMessage"] = _mapInt32ForeignMessage_;
      }
    }
    if (msg.mapStringForeignMessage) {
      const _mapStringForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapStringForeignMessage)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapStringForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapStringForeignMessage_).length > 0) {
        json["mapStringForeignMessage"] = _mapStringForeignMessage_;
      }
    }
    if (msg.mapInt32AllTypes) {
      const _mapInt32AllTypes_ = Object.fromEntries(
        Object.entries(msg.mapInt32AllTypes)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32AllTypes._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32AllTypes_).length > 0) {
        json["mapInt32AllTypes"] = _mapInt32AllTypes_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, json: any): TestMap {
    const _mapInt32Int32_ = json["mapInt32Int32"] ?? json["map_int32_int32"];
    if (_mapInt32Int32_) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Int32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64_ = json["mapInt64Int64"] ?? json["map_int64_int64"];
    if (_mapInt64Int64_) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt64Int64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32_ =
      json["mapUint32Uint32"] ?? json["map_uint32_uint32"];
    if (_mapUint32Uint32_) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapUint32Uint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64_ =
      json["mapUint64Uint64"] ?? json["map_uint64_uint64"];
    if (_mapUint64Uint64_) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapUint64Uint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32_ =
      json["mapSint32Sint32"] ?? json["map_sint32_sint32"];
    if (_mapSint32Sint32_) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSint32Sint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64_ =
      json["mapSint64Sint64"] ?? json["map_sint64_sint64"];
    if (_mapSint64Sint64_) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSint64Sint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32_ =
      json["mapFixed32Fixed32"] ?? json["map_fixed32_fixed32"];
    if (_mapFixed32Fixed32_) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapFixed32Fixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64_ =
      json["mapFixed64Fixed64"] ?? json["map_fixed64_fixed64"];
    if (_mapFixed64Fixed64_) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapFixed64Fixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32_ =
      json["mapSfixed32Sfixed32"] ?? json["map_sfixed32_sfixed32"];
    if (_mapSfixed32Sfixed32_) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSfixed32Sfixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64_ =
      json["mapSfixed64Sfixed64"] ?? json["map_sfixed64_sfixed64"];
    if (_mapSfixed64Sfixed64_) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSfixed64Sfixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float_ = json["mapInt32Float"] ?? json["map_int32_float"];
    if (_mapInt32Float_) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Float._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double_ = json["mapInt32Double"] ?? json["map_int32_double"];
    if (_mapInt32Double_) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Double._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool_ = json["mapBoolBool"] ?? json["map_bool_bool"];
    if (_mapBoolBool_) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapBoolBool._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString_ =
      json["mapStringString"] ?? json["map_string_string"];
    if (_mapStringString_) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapStringString._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes_ = json["mapInt32Bytes"] ?? json["map_int32_bytes"];
    if (_mapInt32Bytes_) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Bytes._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum_ = json["mapInt32Enum"] ?? json["map_int32_enum"];
    if (_mapInt32Enum_) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Enum._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage_ =
      json["mapInt32ForeignMessage"] ?? json["map_int32_foreign_message"];
    if (_mapInt32ForeignMessage_) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32ForeignMessage._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringForeignMessage_ =
      json["mapStringForeignMessage"] ?? json["map_string_foreign_message"];
    if (_mapStringForeignMessage_) {
      msg.mapStringForeignMessage = Object.fromEntries(
        Object.entries(_mapStringForeignMessage_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapStringForeignMessage._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32AllTypes_ =
      json["mapInt32AllTypes"] ?? json["map_int32_all_types"];
    if (_mapInt32AllTypes_) {
      msg.mapInt32AllTypes = Object.fromEntries(
        Object.entries(_mapInt32AllTypes_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32AllTypes._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Int32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Int32,
      json: any
    ): TestMap.MapInt32Int32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt64Int64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt64Int64,
      json: any
    ): TestMap.MapInt64Int64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapUint32Uint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapUint32Uint32,
      json: any
    ): TestMap.MapUint32Uint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapUint64Uint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapUint64Uint64,
      json: any
    ): TestMap.MapUint64Uint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSint32Sint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSint32Sint32,
      json: any
    ): TestMap.MapSint32Sint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSint64Sint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSint64Sint64,
      json: any
    ): TestMap.MapSint64Sint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapFixed32Fixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapFixed32Fixed32,
      json: any
    ): TestMap.MapFixed32Fixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapFixed64Fixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapFixed64Fixed64,
      json: any
    ): TestMap.MapFixed64Fixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSfixed32Sfixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSfixed32Sfixed32,
      json: any
    ): TestMap.MapSfixed32Sfixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapSfixed64Sfixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSfixed64Sfixed64,
      json: any
    ): TestMap.MapSfixed64Sfixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Float>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Float,
      json: any
    ): TestMap.MapInt32Float {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Double>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Double,
      json: any
    ): TestMap.MapInt32Double {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapBoolBool>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapBoolBool,
      json: any
    ): TestMap.MapBoolBool {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapStringString>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapStringString,
      json: any
    ): TestMap.MapStringString {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Bytes>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value?.length) {
        json["value"] = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Bytes,
      json: any
    ): TestMap.MapInt32Bytes {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = decodeBase64Bytes(_value_);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32Enum>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && MapEnumJSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Enum,
      json: any
    ): TestMap.MapInt32Enum {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32ForeignMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32ForeignMessage,
      json: any
    ): TestMap.MapInt32ForeignMessage {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.ForeignMessage.initialize();
        googleProtobufUnittest.ForeignMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapStringForeignMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapStringForeignMessage,
      json: any
    ): TestMap.MapStringForeignMessage {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.ForeignMessage.initialize();
        googleProtobufUnittest.ForeignMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMap.MapInt32AllTypes>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestAllTypesJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32AllTypes,
      json: any
    ): TestMap.MapInt32AllTypes {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.TestAllTypes.initialize();
        googleProtobufUnittest.TestAllTypesJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestMapSubmessageJSON = {
  /**
   * Serializes TestMapSubmessage to JSON.
   */
  encode: function (msg: Partial<TestMapSubmessage>): string {
    return JSON.stringify(TestMapSubmessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMapSubmessage from JSON.
   */
  decode: function (json: string): TestMapSubmessage {
    return TestMapSubmessageJSON._readMessage(
      TestMapSubmessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      testMap: TestMapJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMapSubmessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.testMap) {
      const _testMap_ = TestMapJSON._writeMessage(msg.testMap);
      if (Object.keys(_testMap_).length > 0) {
        json["testMap"] = _testMap_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    json: any
  ): TestMapSubmessage {
    const _testMap_ = json["testMap"] ?? json["test_map"];
    if (_testMap_) {
      const m = TestMap.initialize();
      TestMapJSON._readMessage(m, _testMap_);
      msg.testMap = m;
    }
    return msg;
  },
};

export const TestMessageMapJSON = {
  /**
   * Serializes TestMessageMap to JSON.
   */
  encode: function (msg: Partial<TestMessageMap>): string {
    return JSON.stringify(TestMessageMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMessageMap from JSON.
   */
  decode: function (json: string): TestMessageMap {
    return TestMessageMapJSON._readMessage(
      TestMessageMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Message) {
      const _mapInt32Message_ = Object.fromEntries(
        Object.entries(msg.mapInt32Message)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMessageMapJSON.MapInt32Message._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Message_).length > 0) {
        json["mapInt32Message"] = _mapInt32Message_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMessageMap, json: any): TestMessageMap {
    const _mapInt32Message_ =
      json["mapInt32Message"] ?? json["map_int32_message"];
    if (_mapInt32Message_) {
      msg.mapInt32Message = Object.fromEntries(
        Object.entries(_mapInt32Message_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMessageMapJSON.MapInt32Message._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMessageMap.MapInt32Message>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestAllTypesJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMessageMap.MapInt32Message,
      json: any
    ): TestMessageMap.MapInt32Message {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.TestAllTypes.initialize();
        googleProtobufUnittest.TestAllTypesJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestSameTypeMapJSON = {
  /**
   * Serializes TestSameTypeMap to JSON.
   */
  encode: function (msg: Partial<TestSameTypeMap>): string {
    return JSON.stringify(TestSameTypeMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestSameTypeMap from JSON.
   */
  decode: function (json: string): TestSameTypeMap {
    return TestSameTypeMapJSON._readMessage(
      TestSameTypeMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestSameTypeMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.map1) {
      const _map1_ = Object.fromEntries(
        Object.entries(msg.map1)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestSameTypeMapJSON.Map1._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_map1_).length > 0) {
        json["map1"] = _map1_;
      }
    }
    if (msg.map2) {
      const _map2_ = Object.fromEntries(
        Object.entries(msg.map2)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestSameTypeMapJSON.Map2._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_map2_).length > 0) {
        json["map2"] = _map2_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestSameTypeMap, json: any): TestSameTypeMap {
    const _map1_ = json["map1"];
    if (_map1_) {
      msg.map1 = Object.fromEntries(
        Object.entries(_map1_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestSameTypeMapJSON.Map1._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _map2_ = json["map2"];
    if (_map2_) {
      msg.map2 = Object.fromEntries(
        Object.entries(_map2_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestSameTypeMapJSON.Map2._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestSameTypeMap.Map1>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestSameTypeMap.Map1,
      json: any
    ): TestSameTypeMap.Map1 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestSameTypeMap.Map2>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestSameTypeMap.Map2,
      json: any
    ): TestSameTypeMap.Map2 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMapJSON = {
  /**
   * Serializes TestRequiredMessageMap to JSON.
   */
  encode: function (msg: Partial<TestRequiredMessageMap>): string {
    return JSON.stringify(TestRequiredMessageMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredMessageMap from JSON.
   */
  decode: function (json: string): TestRequiredMessageMap {
    return TestRequiredMessageMapJSON._readMessage(
      TestRequiredMessageMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessageMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapField) {
      const _mapField_ = Object.fromEntries(
        Object.entries(msg.mapField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestRequiredMessageMapJSON.MapField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapField_).length > 0) {
        json["mapField"] = _mapField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    json: any
  ): TestRequiredMessageMap {
    const _mapField_ = json["mapField"] ?? json["map_field"];
    if (_mapField_) {
      msg.mapField = Object.fromEntries(
        Object.entries(_mapField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestRequiredMessageMapJSON.MapField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredMessageMap.MapField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestRequiredJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredMessageMap.MapField,
      json: any
    ): TestRequiredMessageMap.MapField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.TestRequired.initialize();
        googleProtobufUnittest.TestRequiredJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestArenaMapJSON = {
  /**
   * Serializes TestArenaMap to JSON.
   */
  encode: function (msg: Partial<TestArenaMap>): string {
    return JSON.stringify(TestArenaMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestArenaMap from JSON.
   */
  decode: function (json: string): TestArenaMap {
    return TestArenaMapJSON._readMessage(
      TestArenaMapJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestArenaMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      const _mapInt32Int32_ = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Int32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Int32_).length > 0) {
        json["mapInt32Int32"] = _mapInt32Int32_;
      }
    }
    if (msg.mapInt64Int64) {
      const _mapInt64Int64_ = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt64Int64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt64Int64_).length > 0) {
        json["mapInt64Int64"] = _mapInt64Int64_;
      }
    }
    if (msg.mapUint32Uint32) {
      const _mapUint32Uint32_ = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapUint32Uint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint32Uint32_).length > 0) {
        json["mapUint32Uint32"] = _mapUint32Uint32_;
      }
    }
    if (msg.mapUint64Uint64) {
      const _mapUint64Uint64_ = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapUint64Uint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapUint64Uint64_).length > 0) {
        json["mapUint64Uint64"] = _mapUint64Uint64_;
      }
    }
    if (msg.mapSint32Sint32) {
      const _mapSint32Sint32_ = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSint32Sint32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint32Sint32_).length > 0) {
        json["mapSint32Sint32"] = _mapSint32Sint32_;
      }
    }
    if (msg.mapSint64Sint64) {
      const _mapSint64Sint64_ = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSint64Sint64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSint64Sint64_).length > 0) {
        json["mapSint64Sint64"] = _mapSint64Sint64_;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const _mapFixed32Fixed32_ = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapFixed32Fixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed32Fixed32_).length > 0) {
        json["mapFixed32Fixed32"] = _mapFixed32Fixed32_;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const _mapFixed64Fixed64_ = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapFixed64Fixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapFixed64Fixed64_).length > 0) {
        json["mapFixed64Fixed64"] = _mapFixed64Fixed64_;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const _mapSfixed32Sfixed32_ = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSfixed32Sfixed32._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed32Sfixed32_).length > 0) {
        json["mapSfixed32Sfixed32"] = _mapSfixed32Sfixed32_;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const _mapSfixed64Sfixed64_ = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSfixed64Sfixed64._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapSfixed64Sfixed64_).length > 0) {
        json["mapSfixed64Sfixed64"] = _mapSfixed64Sfixed64_;
      }
    }
    if (msg.mapInt32Float) {
      const _mapInt32Float_ = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Float._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Float_).length > 0) {
        json["mapInt32Float"] = _mapInt32Float_;
      }
    }
    if (msg.mapInt32Double) {
      const _mapInt32Double_ = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Double._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Double_).length > 0) {
        json["mapInt32Double"] = _mapInt32Double_;
      }
    }
    if (msg.mapBoolBool) {
      const _mapBoolBool_ = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapBoolBool._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapBoolBool_).length > 0) {
        json["mapBoolBool"] = _mapBoolBool_;
      }
    }
    if (msg.mapStringString) {
      const _mapStringString_ = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapStringString._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapStringString_).length > 0) {
        json["mapStringString"] = _mapStringString_;
      }
    }
    if (msg.mapInt32Bytes) {
      const _mapInt32Bytes_ = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Bytes._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Bytes_).length > 0) {
        json["mapInt32Bytes"] = _mapInt32Bytes_;
      }
    }
    if (msg.mapInt32Enum) {
      const _mapInt32Enum_ = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Enum._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32Enum_).length > 0) {
        json["mapInt32Enum"] = _mapInt32Enum_;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const _mapInt32ForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32ForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_mapInt32ForeignMessage_).length > 0) {
        json["mapInt32ForeignMessage"] = _mapInt32ForeignMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestArenaMap, json: any): TestArenaMap {
    const _mapInt32Int32_ = json["mapInt32Int32"] ?? json["map_int32_int32"];
    if (_mapInt32Int32_) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Int32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64_ = json["mapInt64Int64"] ?? json["map_int64_int64"];
    if (_mapInt64Int64_) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt64Int64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32_ =
      json["mapUint32Uint32"] ?? json["map_uint32_uint32"];
    if (_mapUint32Uint32_) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapUint32Uint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64_ =
      json["mapUint64Uint64"] ?? json["map_uint64_uint64"];
    if (_mapUint64Uint64_) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapUint64Uint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32_ =
      json["mapSint32Sint32"] ?? json["map_sint32_sint32"];
    if (_mapSint32Sint32_) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSint32Sint32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64_ =
      json["mapSint64Sint64"] ?? json["map_sint64_sint64"];
    if (_mapSint64Sint64_) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSint64Sint64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32_ =
      json["mapFixed32Fixed32"] ?? json["map_fixed32_fixed32"];
    if (_mapFixed32Fixed32_) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapFixed32Fixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64_ =
      json["mapFixed64Fixed64"] ?? json["map_fixed64_fixed64"];
    if (_mapFixed64Fixed64_) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapFixed64Fixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32_ =
      json["mapSfixed32Sfixed32"] ?? json["map_sfixed32_sfixed32"];
    if (_mapSfixed32Sfixed32_) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSfixed32Sfixed32._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64_ =
      json["mapSfixed64Sfixed64"] ?? json["map_sfixed64_sfixed64"];
    if (_mapSfixed64Sfixed64_) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSfixed64Sfixed64._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float_ = json["mapInt32Float"] ?? json["map_int32_float"];
    if (_mapInt32Float_) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Float._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double_ = json["mapInt32Double"] ?? json["map_int32_double"];
    if (_mapInt32Double_) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Double._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool_ = json["mapBoolBool"] ?? json["map_bool_bool"];
    if (_mapBoolBool_) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapBoolBool._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString_ =
      json["mapStringString"] ?? json["map_string_string"];
    if (_mapStringString_) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapStringString._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes_ = json["mapInt32Bytes"] ?? json["map_int32_bytes"];
    if (_mapInt32Bytes_) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Bytes._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum_ = json["mapInt32Enum"] ?? json["map_int32_enum"];
    if (_mapInt32Enum_) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Enum._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage_ =
      json["mapInt32ForeignMessage"] ?? json["map_int32_foreign_message"];
    if (_mapInt32ForeignMessage_) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32ForeignMessage._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Int32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Int32,
      json: any
    ): TestArenaMap.MapInt32Int32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt64Int64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt64Int64,
      json: any
    ): TestArenaMap.MapInt64Int64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapUint32Uint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapUint32Uint32,
      json: any
    ): TestArenaMap.MapUint32Uint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapUint64Uint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapUint64Uint64,
      json: any
    ): TestArenaMap.MapUint64Uint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSint32Sint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSint32Sint32,
      json: any
    ): TestArenaMap.MapSint32Sint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSint64Sint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSint64Sint64,
      json: any
    ): TestArenaMap.MapSint64Sint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapFixed32Fixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapFixed32Fixed32,
      json: any
    ): TestArenaMap.MapFixed32Fixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapFixed64Fixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapFixed64Fixed64,
      json: any
    ): TestArenaMap.MapFixed64Fixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSfixed32Sfixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSfixed32Sfixed32,
      json: any
    ): TestArenaMap.MapSfixed32Sfixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapSfixed64Sfixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSfixed64Sfixed64,
      json: any
    ): TestArenaMap.MapSfixed64Sfixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Float>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Float,
      json: any
    ): TestArenaMap.MapInt32Float {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Double>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Double,
      json: any
    ): TestArenaMap.MapInt32Double {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapBoolBool>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapBoolBool,
      json: any
    ): TestArenaMap.MapBoolBool {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapStringString>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapStringString,
      json: any
    ): TestArenaMap.MapStringString {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Bytes>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value?.length) {
        json["value"] = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Bytes,
      json: any
    ): TestArenaMap.MapInt32Bytes {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = decodeBase64Bytes(_value_);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32Enum>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && MapEnumJSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Enum,
      json: any
    ): TestArenaMap.MapInt32Enum {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestArenaMap.MapInt32ForeignMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32ForeignMessage,
      json: any
    ): TestArenaMap.MapInt32ForeignMessage {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = googleProtobufUnittest.ForeignMessage.initialize();
        googleProtobufUnittest.ForeignMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntryJSON = {
  /**
   * Serializes MessageContainingMapCalledEntry to JSON.
   */
  encode: function (msg: Partial<MessageContainingMapCalledEntry>): string {
    return JSON.stringify(
      MessageContainingMapCalledEntryJSON._writeMessage(msg)
    );
  },

  /**
   * Deserializes MessageContainingMapCalledEntry from JSON.
   */
  decode: function (json: string): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntryJSON._readMessage(
      MessageContainingMapCalledEntryJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.entry) {
      const _entry_ = Object.fromEntries(
        Object.entries(msg.entry)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MessageContainingMapCalledEntryJSON.Entry._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_entry_).length > 0) {
        json["entry"] = _entry_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    json: any
  ): MessageContainingMapCalledEntry {
    const _entry_ = json["entry"];
    if (_entry_) {
      msg.entry = Object.fromEntries(
        Object.entries(_entry_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MessageContainingMapCalledEntryJSON.Entry._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MessageContainingMapCalledEntry.Entry>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MessageContainingMapCalledEntry.Entry,
      json: any
    ): MessageContainingMapCalledEntry.Entry {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessageJSON = {
  /**
   * Serializes TestRecursiveMapMessage to JSON.
   */
  encode: function (msg: Partial<TestRecursiveMapMessage>): string {
    return JSON.stringify(TestRecursiveMapMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRecursiveMapMessage from JSON.
   */
  decode: function (json: string): TestRecursiveMapMessage {
    return TestRecursiveMapMessageJSON._readMessage(
      TestRecursiveMapMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const _a_ = Object.fromEntries(
        Object.entries(msg.a)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestRecursiveMapMessageJSON.A._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    json: any
  ): TestRecursiveMapMessage {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = Object.fromEntries(
        Object.entries(_a_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestRecursiveMapMessageJSON.A._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRecursiveMapMessage.A>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = TestRecursiveMapMessageJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRecursiveMapMessage.A,
      json: any
    ): TestRecursiveMapMessage.A {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = TestRecursiveMapMessage.initialize();
        TestRecursiveMapMessageJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "google/protobuf/unittest_well_known_types.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_well_known_types.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";

import * as protoscript from "protoscript";

//========================================//
//                 Types                  //
//========================================//

/**
 * Test that we can include all well-known types.
 * Each wrapper type is included separately, as languages
 * map handle different wrappers in different ways.
 */
export interface TestWellKnownTypes {
  anyField: protoscript.Any;
  apiField: protoscript.Api;
  durationField: protoscript.Duration;
  emptyField: protoscript.Empty;
  fieldMaskField: protoscript.FieldMask;
  sourceContextField: protoscript.SourceContext;
  structField: protoscript.Struct;
  timestampField: protoscript.Timestamp;
  typeField: protoscript.Type;
  doubleField: protoscript.DoubleValue;
  floatField: protoscript.FloatValue;
  int64Field: protoscript.Int64Value;
  uint64Field: protoscript.UInt64Value;
  int32Field: protoscript.Int32Value;
  uint32Field: protoscript.UInt32Value;
  boolField: protoscript.BoolValue;
  stringField: protoscript.StringValue;
  bytesField: protoscript.BytesValue;
  /**
   * Part of struct, but useful to be able to test separately
   */
  valueField: protoscript.Value;
}

/**
 * A repeated field for each well-known type.
 */
export interface RepeatedWellKnownTypes {
  anyField: protoscript.Any[];
  apiField: protoscript.Api[];
  durationField: protoscript.Duration[];
  emptyField: protoscript.Empty[];
  fieldMaskField: protoscript.FieldMask[];
  sourceContextField: protoscript.SourceContext[];
  structField: protoscript.Struct[];
  timestampField: protoscript.Timestamp[];
  typeField: protoscript.Type[];
  /**
   * These don't actually make a lot of sense, but they're not prohibited...
   */
  doubleField: protoscript.DoubleValue[];
  floatField: protoscript.FloatValue[];
  int64Field: protoscript.Int64Value[];
  uint64Field: protoscript.UInt64Value[];
  int32Field: protoscript.Int32Value[];
  uint32Field: protoscript.UInt32Value[];
  boolField: protoscript.BoolValue[];
  stringField: protoscript.StringValue[];
  bytesField: protoscript.BytesValue[];
}

export interface OneofWellKnownTypes {
  anyField?: protoscript.Any | null | undefined;
  apiField?: protoscript.Api | null | undefined;
  durationField?: protoscript.Duration | null | undefined;
  emptyField?: protoscript.Empty | null | undefined;
  fieldMaskField?: protoscript.FieldMask | null | undefined;
  sourceContextField?: protoscript.SourceContext | null | undefined;
  structField?: protoscript.Struct | null | undefined;
  timestampField?: protoscript.Timestamp | null | undefined;
  typeField?: protoscript.Type | null | undefined;
  doubleField?: protoscript.DoubleValue | null | undefined;
  floatField?: protoscript.FloatValue | null | undefined;
  int64Field?: protoscript.Int64Value | null | undefined;
  uint64Field?: protoscript.UInt64Value | null | undefined;
  int32Field?: protoscript.Int32Value | null | undefined;
  uint32Field?: protoscript.UInt32Value | null | undefined;
  boolField?: protoscript.BoolValue | null | undefined;
  stringField?: protoscript.StringValue | null | undefined;
  bytesField?: protoscript.BytesValue | null | undefined;
}

/**
 * A map field for each well-known type. We only
 * need to worry about the value part of the map being the
 * well-known types, as messages can't be map keys.
 */
export interface MapWellKnownTypes {
  anyField: Record<string, MapWellKnownTypes.AnyField["value"] | undefined>;
  apiField: Record<string, MapWellKnownTypes.ApiField["value"] | undefined>;
  durationField: Record<
    string,
    MapWellKnownTypes.DurationField["value"] | undefined
  >;
  emptyField: Record<string, MapWellKnownTypes.EmptyField["value"] | undefined>;
  fieldMaskField: Record<
    string,
    MapWellKnownTypes.FieldMaskField["value"] | undefined
  >;
  sourceContextField: Record<
    string,
    MapWellKnownTypes.SourceContextField["value"] | undefined
  >;
  structField: Record<
    string,
    MapWellKnownTypes.StructField["value"] | undefined
  >;
  timestampField: Record<
    string,
    MapWellKnownTypes.TimestampField["value"] | undefined
  >;
  typeField: Record<string, MapWellKnownTypes.TypeField["value"] | undefined>;
  doubleField: Record<
    string,
    MapWellKnownTypes.DoubleField["value"] | undefined
  >;
  floatField: Record<string, MapWellKnownTypes.FloatField["value"] | undefined>;
  int64Field: Record<string, MapWellKnownTypes.Int64Field["value"] | undefined>;
  uint64Field: Record<
    string,
    MapWellKnownTypes.Uint64Field["value"] | undefined
  >;
  int32Field: Record<string, MapWellKnownTypes.Int32Field["value"] | undefined>;
  uint32Field: Record<
    string,
    MapWellKnownTypes.Uint32Field["value"] | undefined
  >;
  boolField: Record<string, MapWellKnownTypes.BoolField["value"] | undefined>;
  stringField: Record<
    string,
    MapWellKnownTypes.StringField["value"] | undefined
  >;
  bytesField: Record<string, MapWellKnownTypes.BytesField["value"] | undefined>;
}

export declare namespace MapWellKnownTypes {
  interface AnyField {
    key: number;
    value: protoscript.Any;
  }

  interface ApiField {
    key: number;
    value: protoscript.Api;
  }

  interface DurationField {
    key: number;
    value: protoscript.Duration;
  }

  interface EmptyField {
    key: number;
    value: protoscript.Empty;
  }

  interface FieldMaskField {
    key: number;
    value: protoscript.FieldMask;
  }

  interface SourceContextField {
    key: number;
    value: protoscript.SourceContext;
  }

  interface StructField {
    key: number;
    value: protoscript.Struct;
  }

  interface TimestampField {
    key: number;
    value: protoscript.Timestamp;
  }

  interface TypeField {
    key: number;
    value: protoscript.Type;
  }

  interface DoubleField {
    key: number;
    value: protoscript.DoubleValue;
  }

  interface FloatField {
    key: number;
    value: protoscript.FloatValue;
  }

  interface Int64Field {
    key: number;
    value: protoscript.Int64Value;
  }

  interface Uint64Field {
    key: number;
    value: protoscript.UInt64Value;
  }

  interface Int32Field {
    key: number;
    value: protoscript.Int32Value;
  }

  interface Uint32Field {
    key: number;
    value: protoscript.UInt32Value;
  }

  interface BoolField {
    key: number;
    value: protoscript.BoolValue;
  }

  interface StringField {
    key: number;
    value: protoscript.StringValue;
  }

  interface BytesField {
    key: number;
    value: protoscript.BytesValue;
  }
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const TestWellKnownTypes = {
  /**
   * Serializes TestWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<TestWellKnownTypes>): Uint8Array {
    return TestWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestWellKnownTypes {
    return TestWellKnownTypes._readMessage(
      TestWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): TestWellKnownTypes {
    return {
      anyField: protoscript.Any.initialize(),
      apiField: protoscript.Api.initialize(),
      durationField: protoscript.Duration.initialize(),
      emptyField: protoscript.Empty.initialize(),
      fieldMaskField: protoscript.FieldMask.initialize(),
      sourceContextField: protoscript.SourceContext.initialize(),
      structField: protoscript.Struct.initialize(),
      timestampField: protoscript.Timestamp.initialize(),
      typeField: protoscript.Type.initialize(),
      doubleField: protoscript.DoubleValue.initialize(),
      floatField: protoscript.FloatValue.initialize(),
      int64Field: protoscript.Int64Value.initialize(),
      uint64Field: protoscript.UInt64Value.initialize(),
      int32Field: protoscript.Int32Value.initialize(),
      uint32Field: protoscript.UInt32Value.initialize(),
      boolField: protoscript.BoolValue.initialize(),
      stringField: protoscript.StringValue.initialize(),
      bytesField: protoscript.BytesValue.initialize(),
      valueField: protoscript.Value.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField) {
      writer.writeMessage(1, msg.anyField, protoscript.Any._writeMessage);
    }
    if (msg.apiField) {
      writer.writeMessage(2, msg.apiField, protoscript.Api._writeMessage);
    }
    if (msg.durationField) {
      writer.writeMessage(
        3,
        msg.durationField,
        protoscript.Duration._writeMessage
      );
    }
    if (msg.emptyField) {
      writer.writeMessage(4, msg.emptyField, protoscript.Empty._writeMessage);
    }
    if (msg.fieldMaskField) {
      writer.writeMessage(
        5,
        msg.fieldMaskField,
        protoscript.FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        protoscript.SourceContext._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeMessage(7, msg.structField, protoscript.Struct._writeMessage);
    }
    if (msg.timestampField) {
      writer.writeMessage(
        8,
        msg.timestampField,
        protoscript.Timestamp._writeMessage
      );
    }
    if (msg.typeField) {
      writer.writeMessage(9, msg.typeField, protoscript.Type._writeMessage);
    }
    if (msg.doubleField) {
      writer.writeMessage(
        10,
        msg.doubleField,
        protoscript.DoubleValue._writeMessage
      );
    }
    if (msg.floatField) {
      writer.writeMessage(
        11,
        msg.floatField,
        protoscript.FloatValue._writeMessage
      );
    }
    if (msg.int64Field) {
      writer.writeMessage(
        12,
        msg.int64Field,
        protoscript.Int64Value._writeMessage
      );
    }
    if (msg.uint64Field) {
      writer.writeMessage(
        13,
        msg.uint64Field,
        protoscript.UInt64Value._writeMessage
      );
    }
    if (msg.int32Field) {
      writer.writeMessage(
        14,
        msg.int32Field,
        protoscript.Int32Value._writeMessage
      );
    }
    if (msg.uint32Field) {
      writer.writeMessage(
        15,
        msg.uint32Field,
        protoscript.UInt32Value._writeMessage
      );
    }
    if (msg.boolField) {
      writer.writeMessage(
        16,
        msg.boolField,
        protoscript.BoolValue._writeMessage
      );
    }
    if (msg.stringField) {
      writer.writeMessage(
        17,
        msg.stringField,
        protoscript.StringValue._writeMessage
      );
    }
    if (msg.bytesField) {
      writer.writeMessage(
        18,
        msg.bytesField,
        protoscript.BytesValue._writeMessage
      );
    }
    if (msg.valueField) {
      writer.writeMessage(19, msg.valueField, protoscript.Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestWellKnownTypes,
    reader: BinaryReader
  ): TestWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.anyField, protoscript.Any._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.apiField, protoscript.Api._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(
            msg.durationField,
            protoscript.Duration._readMessage
          );
          break;
        }
        case 4: {
          reader.readMessage(msg.emptyField, protoscript.Empty._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(
            msg.fieldMaskField,
            protoscript.FieldMask._readMessage
          );
          break;
        }
        case 6: {
          reader.readMessage(
            msg.sourceContextField,
            protoscript.SourceContext._readMessage
          );
          break;
        }
        case 7: {
          reader.readMessage(msg.structField, protoscript.Struct._readMessage);
          break;
        }
        case 8: {
          reader.readMessage(
            msg.timestampField,
            protoscript.Timestamp._readMessage
          );
          break;
        }
        case 9: {
          reader.readMessage(msg.typeField, protoscript.Type._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(
            msg.doubleField,
            protoscript.DoubleValue._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.floatField,
            protoscript.FloatValue._readMessage
          );
          break;
        }
        case 12: {
          reader.readMessage(
            msg.int64Field,
            protoscript.Int64Value._readMessage
          );
          break;
        }
        case 13: {
          reader.readMessage(
            msg.uint64Field,
            protoscript.UInt64Value._readMessage
          );
          break;
        }
        case 14: {
          reader.readMessage(
            msg.int32Field,
            protoscript.Int32Value._readMessage
          );
          break;
        }
        case 15: {
          reader.readMessage(
            msg.uint32Field,
            protoscript.UInt32Value._readMessage
          );
          break;
        }
        case 16: {
          reader.readMessage(msg.boolField, protoscript.BoolValue._readMessage);
          break;
        }
        case 17: {
          reader.readMessage(
            msg.stringField,
            protoscript.StringValue._readMessage
          );
          break;
        }
        case 18: {
          reader.readMessage(
            msg.bytesField,
            protoscript.BytesValue._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(msg.valueField, protoscript.Value._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedWellKnownTypes = {
  /**
   * Serializes RepeatedWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<RepeatedWellKnownTypes>): Uint8Array {
    return RepeatedWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes RepeatedWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedWellKnownTypes {
    return RepeatedWellKnownTypes._readMessage(
      RepeatedWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes RepeatedWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): RepeatedWellKnownTypes {
    return {
      anyField: [],
      apiField: [],
      durationField: [],
      emptyField: [],
      fieldMaskField: [],
      sourceContextField: [],
      structField: [],
      timestampField: [],
      typeField: [],
      doubleField: [],
      floatField: [],
      int64Field: [],
      uint64Field: [],
      int32Field: [],
      uint32Field: [],
      boolField: [],
      stringField: [],
      bytesField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.anyField as any,
        protoscript.Any._writeMessage
      );
    }
    if (msg.apiField?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.apiField as any,
        protoscript.Api._writeMessage
      );
    }
    if (msg.durationField?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.durationField as any,
        protoscript.Duration._writeMessage
      );
    }
    if (msg.emptyField?.length) {
      writer.writeRepeatedMessage(
        4,
        msg.emptyField as any,
        protoscript.Empty._writeMessage
      );
    }
    if (msg.fieldMaskField?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.fieldMaskField as any,
        protoscript.FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField?.length) {
      writer.writeRepeatedMessage(
        6,
        msg.sourceContextField as any,
        protoscript.SourceContext._writeMessage
      );
    }
    if (msg.structField?.length) {
      writer.writeRepeatedMessage(
        7,
        msg.structField as any,
        protoscript.Struct._writeMessage
      );
    }
    if (msg.timestampField?.length) {
      writer.writeRepeatedMessage(
        8,
        msg.timestampField as any,
        protoscript.Timestamp._writeMessage
      );
    }
    if (msg.typeField?.length) {
      writer.writeRepeatedMessage(
        9,
        msg.typeField as any,
        protoscript.Type._writeMessage
      );
    }
    if (msg.doubleField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.doubleField as any,
        protoscript.DoubleValue._writeMessage
      );
    }
    if (msg.floatField?.length) {
      writer.writeRepeatedMessage(
        11,
        msg.floatField as any,
        protoscript.FloatValue._writeMessage
      );
    }
    if (msg.int64Field?.length) {
      writer.writeRepeatedMessage(
        12,
        msg.int64Field as any,
        protoscript.Int64Value._writeMessage
      );
    }
    if (msg.uint64Field?.length) {
      writer.writeRepeatedMessage(
        13,
        msg.uint64Field as any,
        protoscript.UInt64Value._writeMessage
      );
    }
    if (msg.int32Field?.length) {
      writer.writeRepeatedMessage(
        14,
        msg.int32Field as any,
        protoscript.Int32Value._writeMessage
      );
    }
    if (msg.uint32Field?.length) {
      writer.writeRepeatedMessage(
        15,
        msg.uint32Field as any,
        protoscript.UInt32Value._writeMessage
      );
    }
    if (msg.boolField?.length) {
      writer.writeRepeatedMessage(
        16,
        msg.boolField as any,
        protoscript.BoolValue._writeMessage
      );
    }
    if (msg.stringField?.length) {
      writer.writeRepeatedMessage(
        17,
        msg.stringField as any,
        protoscript.StringValue._writeMessage
      );
    }
    if (msg.bytesField?.length) {
      writer.writeRepeatedMessage(
        18,
        msg.bytesField as any,
        protoscript.BytesValue._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedWellKnownTypes,
    reader: BinaryReader
  ): RepeatedWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = protoscript.Any.initialize();
          reader.readMessage(m, protoscript.Any._readMessage);
          msg.anyField.push(m);
          break;
        }
        case 2: {
          const m = protoscript.Api.initialize();
          reader.readMessage(m, protoscript.Api._readMessage);
          msg.apiField.push(m);
          break;
        }
        case 3: {
          const m = protoscript.Duration.initialize();
          reader.readMessage(m, protoscript.Duration._readMessage);
          msg.durationField.push(m);
          break;
        }
        case 4: {
          const m = protoscript.Empty.initialize();
          reader.readMessage(m, protoscript.Empty._readMessage);
          msg.emptyField.push(m);
          break;
        }
        case 5: {
          const m = protoscript.FieldMask.initialize();
          reader.readMessage(m, protoscript.FieldMask._readMessage);
          msg.fieldMaskField.push(m);
          break;
        }
        case 6: {
          const m = protoscript.SourceContext.initialize();
          reader.readMessage(m, protoscript.SourceContext._readMessage);
          msg.sourceContextField.push(m);
          break;
        }
        case 7: {
          const m = protoscript.Struct.initialize();
          reader.readMessage(m, protoscript.Struct._readMessage);
          msg.structField.push(m);
          break;
        }
        case 8: {
          const m = protoscript.Timestamp.initialize();
          reader.readMessage(m, protoscript.Timestamp._readMessage);
          msg.timestampField.push(m);
          break;
        }
        case 9: {
          const m = protoscript.Type.initialize();
          reader.readMessage(m, protoscript.Type._readMessage);
          msg.typeField.push(m);
          break;
        }
        case 10: {
          const m = protoscript.DoubleValue.initialize();
          reader.readMessage(m, protoscript.DoubleValue._readMessage);
          msg.doubleField.push(m);
          break;
        }
        case 11: {
          const m = protoscript.FloatValue.initialize();
          reader.readMessage(m, protoscript.FloatValue._readMessage);
          msg.floatField.push(m);
          break;
        }
        case 12: {
          const m = protoscript.Int64Value.initialize();
          reader.readMessage(m, protoscript.Int64Value._readMessage);
          msg.int64Field.push(m);
          break;
        }
        case 13: {
          const m = protoscript.UInt64Value.initialize();
          reader.readMessage(m, protoscript.UInt64Value._readMessage);
          msg.uint64Field.push(m);
          break;
        }
        case 14: {
          const m = protoscript.Int32Value.initialize();
          reader.readMessage(m, protoscript.Int32Value._readMessage);
          msg.int32Field.push(m);
          break;
        }
        case 15: {
          const m = protoscript.UInt32Value.initialize();
          reader.readMessage(m, protoscript.UInt32Value._readMessage);
          msg.uint32Field.push(m);
          break;
        }
        case 16: {
          const m = protoscript.BoolValue.initialize();
          reader.readMessage(m, protoscript.BoolValue._readMessage);
          msg.boolField.push(m);
          break;
        }
        case 17: {
          const m = protoscript.StringValue.initialize();
          reader.readMessage(m, protoscript.StringValue._readMessage);
          msg.stringField.push(m);
          break;
        }
        case 18: {
          const m = protoscript.BytesValue.initialize();
          reader.readMessage(m, protoscript.BytesValue._readMessage);
          msg.bytesField.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneofWellKnownTypes = {
  /**
   * Serializes OneofWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<OneofWellKnownTypes>): Uint8Array {
    return OneofWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes OneofWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): OneofWellKnownTypes {
    return OneofWellKnownTypes._readMessage(
      OneofWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes OneofWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): OneofWellKnownTypes {
    return {
      anyField: undefined,
      apiField: undefined,
      durationField: undefined,
      emptyField: undefined,
      fieldMaskField: undefined,
      sourceContextField: undefined,
      structField: undefined,
      timestampField: undefined,
      typeField: undefined,
      doubleField: undefined,
      floatField: undefined,
      int64Field: undefined,
      uint64Field: undefined,
      int32Field: undefined,
      uint32Field: undefined,
      boolField: undefined,
      stringField: undefined,
      bytesField: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneofWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField != undefined) {
      writer.writeMessage(1, msg.anyField, protoscript.Any._writeMessage);
    }
    if (msg.apiField != undefined) {
      writer.writeMessage(2, msg.apiField, protoscript.Api._writeMessage);
    }
    if (msg.durationField != undefined) {
      writer.writeMessage(
        3,
        msg.durationField,
        protoscript.Duration._writeMessage
      );
    }
    if (msg.emptyField != undefined) {
      writer.writeMessage(4, msg.emptyField, protoscript.Empty._writeMessage);
    }
    if (msg.fieldMaskField != undefined) {
      writer.writeMessage(
        5,
        msg.fieldMaskField,
        protoscript.FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField != undefined) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        protoscript.SourceContext._writeMessage
      );
    }
    if (msg.structField != undefined) {
      writer.writeMessage(7, msg.structField, protoscript.Struct._writeMessage);
    }
    if (msg.timestampField != undefined) {
      writer.writeMessage(
        8,
        msg.timestampField,
        protoscript.Timestamp._writeMessage
      );
    }
    if (msg.typeField != undefined) {
      writer.writeMessage(9, msg.typeField, protoscript.Type._writeMessage);
    }
    if (msg.doubleField != undefined) {
      writer.writeMessage(
        10,
        msg.doubleField,
        protoscript.DoubleValue._writeMessage
      );
    }
    if (msg.floatField != undefined) {
      writer.writeMessage(
        11,
        msg.floatField,
        protoscript.FloatValue._writeMessage
      );
    }
    if (msg.int64Field != undefined) {
      writer.writeMessage(
        12,
        msg.int64Field,
        protoscript.Int64Value._writeMessage
      );
    }
    if (msg.uint64Field != undefined) {
      writer.writeMessage(
        13,
        msg.uint64Field,
        protoscript.UInt64Value._writeMessage
      );
    }
    if (msg.int32Field != undefined) {
      writer.writeMessage(
        14,
        msg.int32Field,
        protoscript.Int32Value._writeMessage
      );
    }
    if (msg.uint32Field != undefined) {
      writer.writeMessage(
        15,
        msg.uint32Field,
        protoscript.UInt32Value._writeMessage
      );
    }
    if (msg.boolField != undefined) {
      writer.writeMessage(
        16,
        msg.boolField,
        protoscript.BoolValue._writeMessage
      );
    }
    if (msg.stringField != undefined) {
      writer.writeMessage(
        17,
        msg.stringField,
        protoscript.StringValue._writeMessage
      );
    }
    if (msg.bytesField != undefined) {
      writer.writeMessage(
        18,
        msg.bytesField,
        protoscript.BytesValue._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OneofWellKnownTypes,
    reader: BinaryReader
  ): OneofWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.anyField = protoscript.Any.initialize();
          reader.readMessage(msg.anyField, protoscript.Any._readMessage);
          break;
        }
        case 2: {
          msg.apiField = protoscript.Api.initialize();
          reader.readMessage(msg.apiField, protoscript.Api._readMessage);
          break;
        }
        case 3: {
          msg.durationField = protoscript.Duration.initialize();
          reader.readMessage(
            msg.durationField,
            protoscript.Duration._readMessage
          );
          break;
        }
        case 4: {
          msg.emptyField = protoscript.Empty.initialize();
          reader.readMessage(msg.emptyField, protoscript.Empty._readMessage);
          break;
        }
        case 5: {
          msg.fieldMaskField = protoscript.FieldMask.initialize();
          reader.readMessage(
            msg.fieldMaskField,
            protoscript.FieldMask._readMessage
          );
          break;
        }
        case 6: {
          msg.sourceContextField = protoscript.SourceContext.initialize();
          reader.readMessage(
            msg.sourceContextField,
            protoscript.SourceContext._readMessage
          );
          break;
        }
        case 7: {
          msg.structField = protoscript.Struct.initialize();
          reader.readMessage(msg.structField, protoscript.Struct._readMessage);
          break;
        }
        case 8: {
          msg.timestampField = protoscript.Timestamp.initialize();
          reader.readMessage(
            msg.timestampField,
            protoscript.Timestamp._readMessage
          );
          break;
        }
        case 9: {
          msg.typeField = protoscript.Type.initialize();
          reader.readMessage(msg.typeField, protoscript.Type._readMessage);
          break;
        }
        case 10: {
          msg.doubleField = protoscript.DoubleValue.initialize();
          reader.readMessage(
            msg.doubleField,
            protoscript.DoubleValue._readMessage
          );
          break;
        }
        case 11: {
          msg.floatField = protoscript.FloatValue.initialize();
          reader.readMessage(
            msg.floatField,
            protoscript.FloatValue._readMessage
          );
          break;
        }
        case 12: {
          msg.int64Field = protoscript.Int64Value.initialize();
          reader.readMessage(
            msg.int64Field,
            protoscript.Int64Value._readMessage
          );
          break;
        }
        case 13: {
          msg.uint64Field = protoscript.UInt64Value.initialize();
          reader.readMessage(
            msg.uint64Field,
            protoscript.UInt64Value._readMessage
          );
          break;
        }
        case 14: {
          msg.int32Field = protoscript.Int32Value.initialize();
          reader.readMessage(
            msg.int32Field,
            protoscript.Int32Value._readMessage
          );
          break;
        }
        case 15: {
          msg.uint32Field = protoscript.UInt32Value.initialize();
          reader.readMessage(
            msg.uint32Field,
            protoscript.UInt32Value._readMessage
          );
          break;
        }
        case 16: {
          msg.boolField = protoscript.BoolValue.initialize();
          reader.readMessage(msg.boolField, protoscript.BoolValue._readMessage);
          break;
        }
        case 17: {
          msg.stringField = protoscript.StringValue.initialize();
          reader.readMessage(
            msg.stringField,
            protoscript.StringValue._readMessage
          );
          break;
        }
        case 18: {
          msg.bytesField = protoscript.BytesValue.initialize();
          reader.readMessage(
            msg.bytesField,
            protoscript.BytesValue._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MapWellKnownTypes = {
  /**
   * Serializes MapWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<MapWellKnownTypes>): Uint8Array {
    return MapWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes MapWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): MapWellKnownTypes {
    return MapWellKnownTypes._readMessage(
      MapWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes MapWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): MapWellKnownTypes {
    return {
      anyField: {},
      apiField: {},
      durationField: {},
      emptyField: {},
      fieldMaskField: {},
      sourceContextField: {},
      structField: {},
      timestampField: {},
      typeField: {},
      doubleField: {},
      floatField: {},
      int64Field: {},
      uint64Field: {},
      int32Field: {},
      uint32Field: {},
      boolField: {},
      stringField: {},
      bytesField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MapWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.anyField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.AnyField._writeMessage
      );
    }
    if (msg.apiField) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.apiField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.ApiField._writeMessage
      );
    }
    if (msg.durationField) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.durationField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.DurationField._writeMessage
      );
    }
    if (msg.emptyField) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.emptyField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.EmptyField._writeMessage
      );
    }
    if (msg.fieldMaskField) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.fieldMaskField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.FieldMaskField._writeMessage
      );
    }
    if (msg.sourceContextField) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.sourceContextField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.SourceContextField._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.structField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.StructField._writeMessage
      );
    }
    if (msg.timestampField) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.timestampField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.TimestampField._writeMessage
      );
    }
    if (msg.typeField) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.typeField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.TypeField._writeMessage
      );
    }
    if (msg.doubleField) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.doubleField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.DoubleField._writeMessage
      );
    }
    if (msg.floatField) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.floatField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.FloatField._writeMessage
      );
    }
    if (msg.int64Field) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.int64Field).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.Int64Field._writeMessage
      );
    }
    if (msg.uint64Field) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.uint64Field).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.Uint64Field._writeMessage
      );
    }
    if (msg.int32Field) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.int32Field).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.Int32Field._writeMessage
      );
    }
    if (msg.uint32Field) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.uint32Field).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.Uint32Field._writeMessage
      );
    }
    if (msg.boolField) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.boolField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.BoolField._writeMessage
      );
    }
    if (msg.stringField) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.stringField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.StringField._writeMessage
      );
    }
    if (msg.bytesField) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.bytesField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MapWellKnownTypes.BytesField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MapWellKnownTypes,
    reader: BinaryReader
  ): MapWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as MapWellKnownTypes.AnyField;
          reader.readMessage(map, MapWellKnownTypes.AnyField._readMessage);
          msg.anyField[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {} as MapWellKnownTypes.ApiField;
          reader.readMessage(map, MapWellKnownTypes.ApiField._readMessage);
          msg.apiField[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {} as MapWellKnownTypes.DurationField;
          reader.readMessage(map, MapWellKnownTypes.DurationField._readMessage);
          msg.durationField[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {} as MapWellKnownTypes.EmptyField;
          reader.readMessage(map, MapWellKnownTypes.EmptyField._readMessage);
          msg.emptyField[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {} as MapWellKnownTypes.FieldMaskField;
          reader.readMessage(
            map,
            MapWellKnownTypes.FieldMaskField._readMessage
          );
          msg.fieldMaskField[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {} as MapWellKnownTypes.SourceContextField;
          reader.readMessage(
            map,
            MapWellKnownTypes.SourceContextField._readMessage
          );
          msg.sourceContextField[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {} as MapWellKnownTypes.StructField;
          reader.readMessage(map, MapWellKnownTypes.StructField._readMessage);
          msg.structField[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {} as MapWellKnownTypes.TimestampField;
          reader.readMessage(
            map,
            MapWellKnownTypes.TimestampField._readMessage
          );
          msg.timestampField[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {} as MapWellKnownTypes.TypeField;
          reader.readMessage(map, MapWellKnownTypes.TypeField._readMessage);
          msg.typeField[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {} as MapWellKnownTypes.DoubleField;
          reader.readMessage(map, MapWellKnownTypes.DoubleField._readMessage);
          msg.doubleField[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {} as MapWellKnownTypes.FloatField;
          reader.readMessage(map, MapWellKnownTypes.FloatField._readMessage);
          msg.floatField[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {} as MapWellKnownTypes.Int64Field;
          reader.readMessage(map, MapWellKnownTypes.Int64Field._readMessage);
          msg.int64Field[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {} as MapWellKnownTypes.Uint64Field;
          reader.readMessage(map, MapWellKnownTypes.Uint64Field._readMessage);
          msg.uint64Field[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {} as MapWellKnownTypes.Int32Field;
          reader.readMessage(map, MapWellKnownTypes.Int32Field._readMessage);
          msg.int32Field[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {} as MapWellKnownTypes.Uint32Field;
          reader.readMessage(map, MapWellKnownTypes.Uint32Field._readMessage);
          msg.uint32Field[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {} as MapWellKnownTypes.BoolField;
          reader.readMessage(map, MapWellKnownTypes.BoolField._readMessage);
          msg.boolField[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {} as MapWellKnownTypes.StringField;
          reader.readMessage(map, MapWellKnownTypes.StringField._readMessage);
          msg.stringField[map.key.toString()] = map.value;
          break;
        }
        case 18: {
          const map = {} as MapWellKnownTypes.BytesField;
          reader.readMessage(map, MapWellKnownTypes.BytesField._readMessage);
          msg.bytesField[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  AnyField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.AnyField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Any._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.AnyField,
      reader: BinaryReader
    ): MapWellKnownTypes.AnyField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Any.initialize();
            reader.readMessage(msg.value, protoscript.Any._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  ApiField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.ApiField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Api._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.ApiField,
      reader: BinaryReader
    ): MapWellKnownTypes.ApiField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Api.initialize();
            reader.readMessage(msg.value, protoscript.Api._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  DurationField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.DurationField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Duration._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.DurationField,
      reader: BinaryReader
    ): MapWellKnownTypes.DurationField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Duration.initialize();
            reader.readMessage(msg.value, protoscript.Duration._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  EmptyField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.EmptyField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Empty._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.EmptyField,
      reader: BinaryReader
    ): MapWellKnownTypes.EmptyField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Empty.initialize();
            reader.readMessage(msg.value, protoscript.Empty._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FieldMaskField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.FieldMaskField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.FieldMask._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.FieldMaskField,
      reader: BinaryReader
    ): MapWellKnownTypes.FieldMaskField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.FieldMask.initialize();
            reader.readMessage(msg.value, protoscript.FieldMask._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SourceContextField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.SourceContextField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.SourceContext._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.SourceContextField,
      reader: BinaryReader
    ): MapWellKnownTypes.SourceContextField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.SourceContext.initialize();
            reader.readMessage(
              msg.value,
              protoscript.SourceContext._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StructField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.StructField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Struct._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.StructField,
      reader: BinaryReader
    ): MapWellKnownTypes.StructField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Struct.initialize();
            reader.readMessage(msg.value, protoscript.Struct._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  TimestampField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.TimestampField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Timestamp._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.TimestampField,
      reader: BinaryReader
    ): MapWellKnownTypes.TimestampField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Timestamp.initialize();
            reader.readMessage(msg.value, protoscript.Timestamp._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  TypeField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.TypeField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Type._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.TypeField,
      reader: BinaryReader
    ): MapWellKnownTypes.TypeField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Type.initialize();
            reader.readMessage(msg.value, protoscript.Type._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  DoubleField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.DoubleField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.DoubleValue._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.DoubleField,
      reader: BinaryReader
    ): MapWellKnownTypes.DoubleField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.DoubleValue.initialize();
            reader.readMessage(msg.value, protoscript.DoubleValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  FloatField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.FloatField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.FloatValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.FloatField,
      reader: BinaryReader
    ): MapWellKnownTypes.FloatField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.FloatValue.initialize();
            reader.readMessage(msg.value, protoscript.FloatValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Int64Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Int64Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Int64Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Int64Field,
      reader: BinaryReader
    ): MapWellKnownTypes.Int64Field {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Int64Value.initialize();
            reader.readMessage(msg.value, protoscript.Int64Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Uint64Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Uint64Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.UInt64Value._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Uint64Field,
      reader: BinaryReader
    ): MapWellKnownTypes.Uint64Field {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.UInt64Value.initialize();
            reader.readMessage(msg.value, protoscript.UInt64Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Int32Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Int32Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.Int32Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Int32Field,
      reader: BinaryReader
    ): MapWellKnownTypes.Int32Field {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.Int32Value.initialize();
            reader.readMessage(msg.value, protoscript.Int32Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Uint32Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Uint32Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.UInt32Value._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Uint32Field,
      reader: BinaryReader
    ): MapWellKnownTypes.Uint32Field {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.UInt32Value.initialize();
            reader.readMessage(msg.value, protoscript.UInt32Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  BoolField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.BoolField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.BoolValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.BoolField,
      reader: BinaryReader
    ): MapWellKnownTypes.BoolField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.BoolValue.initialize();
            reader.readMessage(msg.value, protoscript.BoolValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StringField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.StringField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          protoscript.StringValue._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.StringField,
      reader: BinaryReader
    ): MapWellKnownTypes.StringField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.StringValue.initialize();
            reader.readMessage(msg.value, protoscript.StringValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  BytesField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.BytesField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, protoscript.BytesValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.BytesField,
      reader: BinaryReader
    ): MapWellKnownTypes.BytesField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = protoscript.BytesValue.initialize();
            reader.readMessage(msg.value, protoscript.BytesValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const TestWellKnownTypesJSON = {
  /**
   * Serializes TestWellKnownTypes to JSON.
   */
  encode: function (msg: Partial<TestWellKnownTypes>): string {
    return JSON.stringify(TestWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestWellKnownTypes from JSON.
   */
  decode: function (json: string): TestWellKnownTypes {
    return TestWellKnownTypesJSON._readMessage(
      TestWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): TestWellKnownTypes {
    return {
      anyField: protoscript.AnyJSON.initialize(),
      apiField: protoscript.ApiJSON.initialize(),
      durationField: protoscript.DurationJSON.initialize(),
      emptyField: protoscript.EmptyJSON.initialize(),
      fieldMaskField: protoscript.FieldMaskJSON.initialize(),
      sourceContextField: protoscript.SourceContextJSON.initialize(),
      structField: protoscript.StructJSON.initialize(),
      timestampField: protoscript.TimestampJSON.initialize(),
      typeField: protoscript.TypeJSON.initialize(),
      doubleField: protoscript.DoubleValueJSON.initialize(),
      floatField: protoscript.FloatValueJSON.initialize(),
      int64Field: protoscript.Int64ValueJSON.initialize(),
      uint64Field: protoscript.UInt64ValueJSON.initialize(),
      int32Field: protoscript.Int32ValueJSON.initialize(),
      uint32Field: protoscript.UInt32ValueJSON.initialize(),
      boolField: protoscript.BoolValueJSON.initialize(),
      stringField: protoscript.StringValueJSON.initialize(),
      bytesField: protoscript.BytesValueJSON.initialize(),
      valueField: protoscript.ValueJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField) {
      const _anyField_ = protoscript.AnyJSON._writeMessage(msg.anyField);
      if (Object.keys(_anyField_).length > 0) {
        json["anyField"] = _anyField_;
      }
    }
    if (msg.apiField) {
      const _apiField_ = protoscript.ApiJSON._writeMessage(msg.apiField);
      if (Object.keys(_apiField_).length > 0) {
        json["apiField"] = _apiField_;
      }
    }
    if (msg.durationField) {
      const _durationField_ = protoscript.DurationJSON._writeMessage(
        msg.durationField
      );
      if (Object.keys(_durationField_).length > 0) {
        json["durationField"] = _durationField_;
      }
    }
    if (msg.emptyField) {
      const _emptyField_ = protoscript.EmptyJSON._writeMessage(msg.emptyField);
      if (Object.keys(_emptyField_).length > 0) {
        json["emptyField"] = _emptyField_;
      }
    }
    if (msg.fieldMaskField) {
      const _fieldMaskField_ = protoscript.FieldMaskJSON._writeMessage(
        msg.fieldMaskField
      );
      if (Object.keys(_fieldMaskField_).length > 0) {
        json["fieldMaskField"] = _fieldMaskField_;
      }
    }
    if (msg.sourceContextField) {
      const _sourceContextField_ = protoscript.SourceContextJSON._writeMessage(
        msg.sourceContextField
      );
      if (Object.keys(_sourceContextField_).length > 0) {
        json["sourceContextField"] = _sourceContextField_;
      }
    }
    if (msg.structField) {
      const _structField_ = protoscript.StructJSON._writeMessage(
        msg.structField
      );
      if (Object.keys(_structField_).length > 0) {
        json["structField"] = _structField_;
      }
    }
    if (msg.timestampField) {
      const _timestampField_ = protoscript.TimestampJSON._writeMessage(
        msg.timestampField
      );
      if (Object.keys(_timestampField_).length > 0) {
        json["timestampField"] = _timestampField_;
      }
    }
    if (msg.typeField) {
      const _typeField_ = protoscript.TypeJSON._writeMessage(msg.typeField);
      if (Object.keys(_typeField_).length > 0) {
        json["typeField"] = _typeField_;
      }
    }
    if (msg.doubleField) {
      const _doubleField_ = protoscript.DoubleValueJSON._writeMessage(
        msg.doubleField
      );
      if (Object.keys(_doubleField_).length > 0) {
        json["doubleField"] = _doubleField_;
      }
    }
    if (msg.floatField) {
      const _floatField_ = protoscript.FloatValueJSON._writeMessage(
        msg.floatField
      );
      if (Object.keys(_floatField_).length > 0) {
        json["floatField"] = _floatField_;
      }
    }
    if (msg.int64Field) {
      const _int64Field_ = protoscript.Int64ValueJSON._writeMessage(
        msg.int64Field
      );
      if (Object.keys(_int64Field_).length > 0) {
        json["int64Field"] = _int64Field_;
      }
    }
    if (msg.uint64Field) {
      const _uint64Field_ = protoscript.UInt64ValueJSON._writeMessage(
        msg.uint64Field
      );
      if (Object.keys(_uint64Field_).length > 0) {
        json["uint64Field"] = _uint64Field_;
      }
    }
    if (msg.int32Field) {
      const _int32Field_ = protoscript.Int32ValueJSON._writeMessage(
        msg.int32Field
      );
      if (Object.keys(_int32Field_).length > 0) {
        json["int32Field"] = _int32Field_;
      }
    }
    if (msg.uint32Field) {
      const _uint32Field_ = protoscript.UInt32ValueJSON._writeMessage(
        msg.uint32Field
      );
      if (Object.keys(_uint32Field_).length > 0) {
        json["uint32Field"] = _uint32Field_;
      }
    }
    if (msg.boolField) {
      const _boolField_ = protoscript.BoolValueJSON._writeMessage(
        msg.boolField
      );
      if (Object.keys(_boolField_).length > 0) {
        json["boolField"] = _boolField_;
      }
    }
    if (msg.stringField) {
      const _stringField_ = protoscript.StringValueJSON._writeMessage(
        msg.stringField
      );
      if (Object.keys(_stringField_).length > 0) {
        json["stringField"] = _stringField_;
      }
    }
    if (msg.bytesField) {
      const _bytesField_ = protoscript.BytesValueJSON._writeMessage(
        msg.bytesField
      );
      if (Object.keys(_bytesField_).length > 0) {
        json["bytesField"] = _bytesField_;
      }
    }
    if (msg.valueField) {
      const _valueField_ = protoscript.ValueJSON._writeMessage(msg.valueField);
      if (Object.keys(_valueField_).length > 0) {
        json["valueField"] = _valueField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestWellKnownTypes,
    json: any
  ): TestWellKnownTypes {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      const m = protoscript.Any.initialize();
      protoscript.AnyJSON._readMessage(m, _anyField_);
      msg.anyField = m;
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      const m = protoscript.Api.initialize();
      protoscript.ApiJSON._readMessage(m, _apiField_);
      msg.apiField = m;
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      const m = protoscript.Duration.initialize();
      protoscript.DurationJSON._readMessage(m, _durationField_);
      msg.durationField = m;
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      const m = protoscript.Empty.initialize();
      protoscript.EmptyJSON._readMessage(m, _emptyField_);
      msg.emptyField = m;
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      const m = protoscript.FieldMask.initialize();
      protoscript.FieldMaskJSON._readMessage(m, _fieldMaskField_);
      msg.fieldMaskField = m;
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      const m = protoscript.SourceContext.initialize();
      protoscript.SourceContextJSON._readMessage(m, _sourceContextField_);
      msg.sourceContextField = m;
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      const m = protoscript.Struct.initialize();
      protoscript.StructJSON._readMessage(m, _structField_);
      msg.structField = m;
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      const m = protoscript.Timestamp.initialize();
      protoscript.TimestampJSON._readMessage(m, _timestampField_);
      msg.timestampField = m;
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      const m = protoscript.Type.initialize();
      protoscript.TypeJSON._readMessage(m, _typeField_);
      msg.typeField = m;
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      const m = protoscript.DoubleValue.initialize();
      protoscript.DoubleValueJSON._readMessage(m, _doubleField_);
      msg.doubleField = m;
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      const m = protoscript.FloatValue.initialize();
      protoscript.FloatValueJSON._readMessage(m, _floatField_);
      msg.floatField = m;
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      const m = protoscript.Int64Value.initialize();
      protoscript.Int64ValueJSON._readMessage(m, _int64Field_);
      msg.int64Field = m;
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      const m = protoscript.UInt64Value.initialize();
      protoscript.UInt64ValueJSON._readMessage(m, _uint64Field_);
      msg.uint64Field = m;
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      const m = protoscript.Int32Value.initialize();
      protoscript.Int32ValueJSON._readMessage(m, _int32Field_);
      msg.int32Field = m;
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      const m = protoscript.UInt32Value.initialize();
      protoscript.UInt32ValueJSON._readMessage(m, _uint32Field_);
      msg.uint32Field = m;
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      const m = protoscript.BoolValue.initialize();
      protoscript.BoolValueJSON._readMessage(m, _boolField_);
      msg.boolField = m;
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      const m = protoscript.StringValue.initialize();
      protoscript.StringValueJSON._readMessage(m, _stringField_);
      msg.stringField = m;
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      const m = protoscript.BytesValue.initialize();
      protoscript.BytesValueJSON._readMessage(m, _bytesField_);
      msg.bytesField = m;
    }
    const _valueField_ = json["valueField"] ?? json["value_field"];
    if (_valueField_) {
      const m = protoscript.Value.initialize();
      protoscript.ValueJSON._readMessage(m, _valueField_);
      msg.valueField = m;
    }
    return msg;
  },
};

export const RepeatedWellKnownTypesJSON = {
  /**
   * Serializes RepeatedWellKnownTypes to JSON.
   */
  encode: function (msg: Partial<RepeatedWellKnownTypes>): string {
    return JSON.stringify(RepeatedWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes RepeatedWellKnownTypes from JSON.
   */
  decode: function (json: string): RepeatedWellKnownTypes {
    return RepeatedWellKnownTypesJSON._readMessage(
      RepeatedWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes RepeatedWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): RepeatedWellKnownTypes {
    return {
      anyField: [],
      apiField: [],
      durationField: [],
      emptyField: [],
      fieldMaskField: [],
      sourceContextField: [],
      structField: [],
      timestampField: [],
      typeField: [],
      doubleField: [],
      floatField: [],
      int64Field: [],
      uint64Field: [],
      int32Field: [],
      uint32Field: [],
      boolField: [],
      stringField: [],
      bytesField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField?.length) {
      json["anyField"] = msg.anyField.map(protoscript.AnyJSON._writeMessage);
    }
    if (msg.apiField?.length) {
      json["apiField"] = msg.apiField.map(protoscript.ApiJSON._writeMessage);
    }
    if (msg.durationField?.length) {
      json["durationField"] = msg.durationField.map(
        protoscript.DurationJSON._writeMessage
      );
    }
    if (msg.emptyField?.length) {
      json["emptyField"] = msg.emptyField.map(
        protoscript.EmptyJSON._writeMessage
      );
    }
    if (msg.fieldMaskField?.length) {
      json["fieldMaskField"] = msg.fieldMaskField.map(
        protoscript.FieldMaskJSON._writeMessage
      );
    }
    if (msg.sourceContextField?.length) {
      json["sourceContextField"] = msg.sourceContextField.map(
        protoscript.SourceContextJSON._writeMessage
      );
    }
    if (msg.structField?.length) {
      json["structField"] = msg.structField.map(
        protoscript.StructJSON._writeMessage
      );
    }
    if (msg.timestampField?.length) {
      json["timestampField"] = msg.timestampField.map(
        protoscript.TimestampJSON._writeMessage
      );
    }
    if (msg.typeField?.length) {
      json["typeField"] = msg.typeField.map(protoscript.TypeJSON._writeMessage);
    }
    if (msg.doubleField?.length) {
      json["doubleField"] = msg.doubleField.map(
        protoscript.DoubleValueJSON._writeMessage
      );
    }
    if (msg.floatField?.length) {
      json["floatField"] = msg.floatField.map(
        protoscript.FloatValueJSON._writeMessage
      );
    }
    if (msg.int64Field?.length) {
      json["int64Field"] = msg.int64Field.map(
        protoscript.Int64ValueJSON._writeMessage
      );
    }
    if (msg.uint64Field?.length) {
      json["uint64Field"] = msg.uint64Field.map(
        protoscript.UInt64ValueJSON._writeMessage
      );
    }
    if (msg.int32Field?.length) {
      json["int32Field"] = msg.int32Field.map(
        protoscript.Int32ValueJSON._writeMessage
      );
    }
    if (msg.uint32Field?.length) {
      json["uint32Field"] = msg.uint32Field.map(
        protoscript.UInt32ValueJSON._writeMessage
      );
    }
    if (msg.boolField?.length) {
      json["boolField"] = msg.boolField.map(
        protoscript.BoolValueJSON._writeMessage
      );
    }
    if (msg.stringField?.length) {
      json["stringField"] = msg.stringField.map(
        protoscript.StringValueJSON._writeMessage
      );
    }
    if (msg.bytesField?.length) {
      json["bytesField"] = msg.bytesField.map(
        protoscript.BytesValueJSON._writeMessage
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedWellKnownTypes,
    json: any
  ): RepeatedWellKnownTypes {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      for (const item of _anyField_) {
        const m = protoscript.Any.initialize();
        protoscript.AnyJSON._readMessage(m, item);
        msg.anyField.push(m);
      }
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      for (const item of _apiField_) {
        const m = protoscript.Api.initialize();
        protoscript.ApiJSON._readMessage(m, item);
        msg.apiField.push(m);
      }
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      for (const item of _durationField_) {
        const m = protoscript.Duration.initialize();
        protoscript.DurationJSON._readMessage(m, item);
        msg.durationField.push(m);
      }
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      for (const item of _emptyField_) {
        const m = protoscript.Empty.initialize();
        protoscript.EmptyJSON._readMessage(m, item);
        msg.emptyField.push(m);
      }
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      for (const item of _fieldMaskField_) {
        const m = protoscript.FieldMask.initialize();
        protoscript.FieldMaskJSON._readMessage(m, item);
        msg.fieldMaskField.push(m);
      }
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      for (const item of _sourceContextField_) {
        const m = protoscript.SourceContext.initialize();
        protoscript.SourceContextJSON._readMessage(m, item);
        msg.sourceContextField.push(m);
      }
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      for (const item of _structField_) {
        const m = protoscript.Struct.initialize();
        protoscript.StructJSON._readMessage(m, item);
        msg.structField.push(m);
      }
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      for (const item of _timestampField_) {
        const m = protoscript.Timestamp.initialize();
        protoscript.TimestampJSON._readMessage(m, item);
        msg.timestampField.push(m);
      }
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      for (const item of _typeField_) {
        const m = protoscript.Type.initialize();
        protoscript.TypeJSON._readMessage(m, item);
        msg.typeField.push(m);
      }
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      for (const item of _doubleField_) {
        const m = protoscript.DoubleValue.initialize();
        protoscript.DoubleValueJSON._readMessage(m, item);
        msg.doubleField.push(m);
      }
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      for (const item of _floatField_) {
        const m = protoscript.FloatValue.initialize();
        protoscript.FloatValueJSON._readMessage(m, item);
        msg.floatField.push(m);
      }
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      for (const item of _int64Field_) {
        const m = protoscript.Int64Value.initialize();
        protoscript.Int64ValueJSON._readMessage(m, item);
        msg.int64Field.push(m);
      }
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      for (const item of _uint64Field_) {
        const m = protoscript.UInt64Value.initialize();
        protoscript.UInt64ValueJSON._readMessage(m, item);
        msg.uint64Field.push(m);
      }
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      for (const item of _int32Field_) {
        const m = protoscript.Int32Value.initialize();
        protoscript.Int32ValueJSON._readMessage(m, item);
        msg.int32Field.push(m);
      }
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      for (const item of _uint32Field_) {
        const m = protoscript.UInt32Value.initialize();
        protoscript.UInt32ValueJSON._readMessage(m, item);
        msg.uint32Field.push(m);
      }
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      for (const item of _boolField_) {
        const m = protoscript.BoolValue.initialize();
        protoscript.BoolValueJSON._readMessage(m, item);
        msg.boolField.push(m);
      }
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      for (const item of _stringField_) {
        const m = protoscript.StringValue.initialize();
        protoscript.StringValueJSON._readMessage(m, item);
        msg.stringField.push(m);
      }
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      for (const item of _bytesField_) {
        const m = protoscript.BytesValue.initialize();
        protoscript.BytesValueJSON._readMessage(m, item);
        msg.bytesField.push(m);
      }
    }
    return msg;
  },
};

export const OneofWellKnownTypesJSON = {
  /**
   * Serializes OneofWellKnownTypes to JSON.
   */
  encode: function (msg: Partial<OneofWellKnownTypes>): string {
    return JSON.stringify(OneofWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneofWellKnownTypes from JSON.
   */
  decode: function (json: string): OneofWellKnownTypes {
    return OneofWellKnownTypesJSON._readMessage(
      OneofWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes OneofWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): OneofWellKnownTypes {
    return {
      anyField: undefined,
      apiField: undefined,
      durationField: undefined,
      emptyField: undefined,
      fieldMaskField: undefined,
      sourceContextField: undefined,
      structField: undefined,
      timestampField: undefined,
      typeField: undefined,
      doubleField: undefined,
      floatField: undefined,
      int64Field: undefined,
      uint64Field: undefined,
      int32Field: undefined,
      uint32Field: undefined,
      boolField: undefined,
      stringField: undefined,
      bytesField: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneofWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField != undefined) {
      const _anyField_ = protoscript.AnyJSON._writeMessage(msg.anyField);
      json["anyField"] = _anyField_;
    }
    if (msg.apiField != undefined) {
      const _apiField_ = protoscript.ApiJSON._writeMessage(msg.apiField);
      json["apiField"] = _apiField_;
    }
    if (msg.durationField != undefined) {
      const _durationField_ = protoscript.DurationJSON._writeMessage(
        msg.durationField
      );
      json["durationField"] = _durationField_;
    }
    if (msg.emptyField != undefined) {
      const _emptyField_ = protoscript.EmptyJSON._writeMessage(msg.emptyField);
      json["emptyField"] = _emptyField_;
    }
    if (msg.fieldMaskField != undefined) {
      const _fieldMaskField_ = protoscript.FieldMaskJSON._writeMessage(
        msg.fieldMaskField
      );
      json["fieldMaskField"] = _fieldMaskField_;
    }
    if (msg.sourceContextField != undefined) {
      const _sourceContextField_ = protoscript.SourceContextJSON._writeMessage(
        msg.sourceContextField
      );
      json["sourceContextField"] = _sourceContextField_;
    }
    if (msg.structField != undefined) {
      const _structField_ = protoscript.StructJSON._writeMessage(
        msg.structField
      );
      json["structField"] = _structField_;
    }
    if (msg.timestampField != undefined) {
      const _timestampField_ = protoscript.TimestampJSON._writeMessage(
        msg.timestampField
      );
      json["timestampField"] = _timestampField_;
    }
    if (msg.typeField != undefined) {
      const _typeField_ = protoscript.TypeJSON._writeMessage(msg.typeField);
      json["typeField"] = _typeField_;
    }
    if (msg.doubleField != undefined) {
      const _doubleField_ = protoscript.DoubleValueJSON._writeMessage(
        msg.doubleField
      );
      json["doubleField"] = _doubleField_;
    }
    if (msg.floatField != undefined) {
      const _floatField_ = protoscript.FloatValueJSON._writeMessage(
        msg.floatField
      );
      json["floatField"] = _floatField_;
    }
    if (msg.int64Field != undefined) {
      const _int64Field_ = protoscript.Int64ValueJSON._writeMessage(
        msg.int64Field
      );
      json["int64Field"] = _int64Field_;
    }
    if (msg.uint64Field != undefined) {
      const _uint64Field_ = protoscript.UInt64ValueJSON._writeMessage(
        msg.uint64Field
      );
      json["uint64Field"] = _uint64Field_;
    }
    if (msg.int32Field != undefined) {
      const _int32Field_ = protoscript.Int32ValueJSON._writeMessage(
        msg.int32Field
      );
      json["int32Field"] = _int32Field_;
    }
    if (msg.uint32Field != undefined) {
      const _uint32Field_ = protoscript.UInt32ValueJSON._writeMessage(
        msg.uint32Field
      );
      json["uint32Field"] = _uint32Field_;
    }
    if (msg.boolField != undefined) {
      const _boolField_ = protoscript.BoolValueJSON._writeMessage(
        msg.boolField
      );
      json["boolField"] = _boolField_;
    }
    if (msg.stringField != undefined) {
      const _stringField_ = protoscript.StringValueJSON._writeMessage(
        msg.stringField
      );
      json["stringField"] = _stringField_;
    }
    if (msg.bytesField != undefined) {
      const _bytesField_ = protoscript.BytesValueJSON._writeMessage(
        msg.bytesField
      );
      json["bytesField"] = _bytesField_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OneofWellKnownTypes,
    json: any
  ): OneofWellKnownTypes {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      const m = protoscript.Any.initialize();
      protoscript.AnyJSON._readMessage(m, _anyField_);
      msg.anyField = m;
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      const m = protoscript.Api.initialize();
      protoscript.ApiJSON._readMessage(m, _apiField_);
      msg.apiField = m;
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      const m = protoscript.Duration.initialize();
      protoscript.DurationJSON._readMessage(m, _durationField_);
      msg.durationField = m;
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      const m = protoscript.Empty.initialize();
      protoscript.EmptyJSON._readMessage(m, _emptyField_);
      msg.emptyField = m;
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      const m = protoscript.FieldMask.initialize();
      protoscript.FieldMaskJSON._readMessage(m, _fieldMaskField_);
      msg.fieldMaskField = m;
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      const m = protoscript.SourceContext.initialize();
      protoscript.SourceContextJSON._readMessage(m, _sourceContextField_);
      msg.sourceContextField = m;
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      const m = protoscript.Struct.initialize();
      protoscript.StructJSON._readMessage(m, _structField_);
      msg.structField = m;
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      const m = protoscript.Timestamp.initialize();
      protoscript.TimestampJSON._readMessage(m, _timestampField_);
      msg.timestampField = m;
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      const m = protoscript.Type.initialize();
      protoscript.TypeJSON._readMessage(m, _typeField_);
      msg.typeField = m;
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      const m = protoscript.DoubleValue.initialize();
      protoscript.DoubleValueJSON._readMessage(m, _doubleField_);
      msg.doubleField = m;
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      const m = protoscript.FloatValue.initialize();
      protoscript.FloatValueJSON._readMessage(m, _floatField_);
      msg.floatField = m;
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      const m = protoscript.Int64Value.initialize();
      protoscript.Int64ValueJSON._readMessage(m, _int64Field_);
      msg.int64Field = m;
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      const m = protoscript.UInt64Value.initialize();
      protoscript.UInt64ValueJSON._readMessage(m, _uint64Field_);
      msg.uint64Field = m;
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      const m = protoscript.Int32Value.initialize();
      protoscript.Int32ValueJSON._readMessage(m, _int32Field_);
      msg.int32Field = m;
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      const m = protoscript.UInt32Value.initialize();
      protoscript.UInt32ValueJSON._readMessage(m, _uint32Field_);
      msg.uint32Field = m;
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      const m = protoscript.BoolValue.initialize();
      protoscript.BoolValueJSON._readMessage(m, _boolField_);
      msg.boolField = m;
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      const m = protoscript.StringValue.initialize();
      protoscript.StringValueJSON._readMessage(m, _stringField_);
      msg.stringField = m;
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      const m = protoscript.BytesValue.initialize();
      protoscript.BytesValueJSON._readMessage(m, _bytesField_);
      msg.bytesField = m;
    }
    return msg;
  },
};

export const MapWellKnownTypesJSON = {
  /**
   * Serializes MapWellKnownTypes to JSON.
   */
  encode: function (msg: Partial<MapWellKnownTypes>): string {
    return JSON.stringify(MapWellKnownTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes MapWellKnownTypes from JSON.
   */
  decode: function (json: string): MapWellKnownTypes {
    return MapWellKnownTypesJSON._readMessage(
      MapWellKnownTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes MapWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): MapWellKnownTypes {
    return {
      anyField: {},
      apiField: {},
      durationField: {},
      emptyField: {},
      fieldMaskField: {},
      sourceContextField: {},
      structField: {},
      timestampField: {},
      typeField: {},
      doubleField: {},
      floatField: {},
      int64Field: {},
      uint64Field: {},
      int32Field: {},
      uint32Field: {},
      boolField: {},
      stringField: {},
      bytesField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MapWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField) {
      const _anyField_ = Object.fromEntries(
        Object.entries(msg.anyField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.AnyField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_anyField_).length > 0) {
        json["anyField"] = _anyField_;
      }
    }
    if (msg.apiField) {
      const _apiField_ = Object.fromEntries(
        Object.entries(msg.apiField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.ApiField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_apiField_).length > 0) {
        json["apiField"] = _apiField_;
      }
    }
    if (msg.durationField) {
      const _durationField_ = Object.fromEntries(
        Object.entries(msg.durationField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.DurationField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_durationField_).length > 0) {
        json["durationField"] = _durationField_;
      }
    }
    if (msg.emptyField) {
      const _emptyField_ = Object.fromEntries(
        Object.entries(msg.emptyField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.EmptyField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_emptyField_).length > 0) {
        json["emptyField"] = _emptyField_;
      }
    }
    if (msg.fieldMaskField) {
      const _fieldMaskField_ = Object.fromEntries(
        Object.entries(msg.fieldMaskField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.FieldMaskField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_fieldMaskField_).length > 0) {
        json["fieldMaskField"] = _fieldMaskField_;
      }
    }
    if (msg.sourceContextField) {
      const _sourceContextField_ = Object.fromEntries(
        Object.entries(msg.sourceContextField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.SourceContextField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_sourceContextField_).length > 0) {
        json["sourceContextField"] = _sourceContextField_;
      }
    }
    if (msg.structField) {
      const _structField_ = Object.fromEntries(
        Object.entries(msg.structField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.StructField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_structField_).length > 0) {
        json["structField"] = _structField_;
      }
    }
    if (msg.timestampField) {
      const _timestampField_ = Object.fromEntries(
        Object.entries(msg.timestampField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.TimestampField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_timestampField_).length > 0) {
        json["timestampField"] = _timestampField_;
      }
    }
    if (msg.typeField) {
      const _typeField_ = Object.fromEntries(
        Object.entries(msg.typeField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.TypeField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_typeField_).length > 0) {
        json["typeField"] = _typeField_;
      }
    }
    if (msg.doubleField) {
      const _doubleField_ = Object.fromEntries(
        Object.entries(msg.doubleField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.DoubleField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_doubleField_).length > 0) {
        json["doubleField"] = _doubleField_;
      }
    }
    if (msg.floatField) {
      const _floatField_ = Object.fromEntries(
        Object.entries(msg.floatField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.FloatField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_floatField_).length > 0) {
        json["floatField"] = _floatField_;
      }
    }
    if (msg.int64Field) {
      const _int64Field_ = Object.fromEntries(
        Object.entries(msg.int64Field)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Int64Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_int64Field_).length > 0) {
        json["int64Field"] = _int64Field_;
      }
    }
    if (msg.uint64Field) {
      const _uint64Field_ = Object.fromEntries(
        Object.entries(msg.uint64Field)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Uint64Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_uint64Field_).length > 0) {
        json["uint64Field"] = _uint64Field_;
      }
    }
    if (msg.int32Field) {
      const _int32Field_ = Object.fromEntries(
        Object.entries(msg.int32Field)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Int32Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_int32Field_).length > 0) {
        json["int32Field"] = _int32Field_;
      }
    }
    if (msg.uint32Field) {
      const _uint32Field_ = Object.fromEntries(
        Object.entries(msg.uint32Field)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Uint32Field._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_uint32Field_).length > 0) {
        json["uint32Field"] = _uint32Field_;
      }
    }
    if (msg.boolField) {
      const _boolField_ = Object.fromEntries(
        Object.entries(msg.boolField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.BoolField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_boolField_).length > 0) {
        json["boolField"] = _boolField_;
      }
    }
    if (msg.stringField) {
      const _stringField_ = Object.fromEntries(
        Object.entries(msg.stringField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.StringField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_stringField_).length > 0) {
        json["stringField"] = _stringField_;
      }
    }
    if (msg.bytesField) {
      const _bytesField_ = Object.fromEntries(
        Object.entries(msg.bytesField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.BytesField._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_bytesField_).length > 0) {
        json["bytesField"] = _bytesField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MapWellKnownTypes,
    json: any
  ): MapWellKnownTypes {
    const _anyField_ = json["anyField"] ?? json["any_field"];
    if (_anyField_) {
      msg.anyField = Object.fromEntries(
        Object.entries(_anyField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.AnyField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _apiField_ = json["apiField"] ?? json["api_field"];
    if (_apiField_) {
      msg.apiField = Object.fromEntries(
        Object.entries(_apiField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.ApiField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _durationField_ = json["durationField"] ?? json["duration_field"];
    if (_durationField_) {
      msg.durationField = Object.fromEntries(
        Object.entries(_durationField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.DurationField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _emptyField_ = json["emptyField"] ?? json["empty_field"];
    if (_emptyField_) {
      msg.emptyField = Object.fromEntries(
        Object.entries(_emptyField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.EmptyField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _fieldMaskField_ = json["fieldMaskField"] ?? json["field_mask_field"];
    if (_fieldMaskField_) {
      msg.fieldMaskField = Object.fromEntries(
        Object.entries(_fieldMaskField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.FieldMaskField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _sourceContextField_ =
      json["sourceContextField"] ?? json["source_context_field"];
    if (_sourceContextField_) {
      msg.sourceContextField = Object.fromEntries(
        Object.entries(_sourceContextField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.SourceContextField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _structField_ = json["structField"] ?? json["struct_field"];
    if (_structField_) {
      msg.structField = Object.fromEntries(
        Object.entries(_structField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.StructField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _timestampField_ = json["timestampField"] ?? json["timestamp_field"];
    if (_timestampField_) {
      msg.timestampField = Object.fromEntries(
        Object.entries(_timestampField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.TimestampField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _typeField_ = json["typeField"] ?? json["type_field"];
    if (_typeField_) {
      msg.typeField = Object.fromEntries(
        Object.entries(_typeField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.TypeField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _doubleField_ = json["doubleField"] ?? json["double_field"];
    if (_doubleField_) {
      msg.doubleField = Object.fromEntries(
        Object.entries(_doubleField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.DoubleField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _floatField_ = json["floatField"] ?? json["float_field"];
    if (_floatField_) {
      msg.floatField = Object.fromEntries(
        Object.entries(_floatField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.FloatField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int64Field_ = json["int64Field"] ?? json["int64_field"];
    if (_int64Field_) {
      msg.int64Field = Object.fromEntries(
        Object.entries(_int64Field_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Int64Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint64Field_ = json["uint64Field"] ?? json["uint64_field"];
    if (_uint64Field_) {
      msg.uint64Field = Object.fromEntries(
        Object.entries(_uint64Field_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Uint64Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int32Field_ = json["int32Field"] ?? json["int32_field"];
    if (_int32Field_) {
      msg.int32Field = Object.fromEntries(
        Object.entries(_int32Field_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Int32Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint32Field_ = json["uint32Field"] ?? json["uint32_field"];
    if (_uint32Field_) {
      msg.uint32Field = Object.fromEntries(
        Object.entries(_uint32Field_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.Uint32Field._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _boolField_ = json["boolField"] ?? json["bool_field"];
    if (_boolField_) {
      msg.boolField = Object.fromEntries(
        Object.entries(_boolField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.BoolField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _stringField_ = json["stringField"] ?? json["string_field"];
    if (_stringField_) {
      msg.stringField = Object.fromEntries(
        Object.entries(_stringField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.StringField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _bytesField_ = json["bytesField"] ?? json["bytes_field"];
    if (_bytesField_) {
      msg.bytesField = Object.fromEntries(
        Object.entries(_bytesField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MapWellKnownTypesJSON.BytesField._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  AnyField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.AnyField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.AnyJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.AnyField,
      json: any
    ): MapWellKnownTypes.AnyField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Any.initialize();
        protoscript.AnyJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  ApiField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.ApiField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.ApiJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.ApiField,
      json: any
    ): MapWellKnownTypes.ApiField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Api.initialize();
        protoscript.ApiJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  DurationField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.DurationField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.DurationJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.DurationField,
      json: any
    ): MapWellKnownTypes.DurationField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Duration.initialize();
        protoscript.DurationJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  EmptyField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.EmptyField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.EmptyJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.EmptyField,
      json: any
    ): MapWellKnownTypes.EmptyField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Empty.initialize();
        protoscript.EmptyJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  FieldMaskField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.FieldMaskField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.FieldMaskJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.FieldMaskField,
      json: any
    ): MapWellKnownTypes.FieldMaskField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.FieldMask.initialize();
        protoscript.FieldMaskJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  SourceContextField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.SourceContextField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.SourceContextJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.SourceContextField,
      json: any
    ): MapWellKnownTypes.SourceContextField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.SourceContext.initialize();
        protoscript.SourceContextJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  StructField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.StructField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.StructJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.StructField,
      json: any
    ): MapWellKnownTypes.StructField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Struct.initialize();
        protoscript.StructJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  TimestampField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.TimestampField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.TimestampJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.TimestampField,
      json: any
    ): MapWellKnownTypes.TimestampField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Timestamp.initialize();
        protoscript.TimestampJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  TypeField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.TypeField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.TypeJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.TypeField,
      json: any
    ): MapWellKnownTypes.TypeField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Type.initialize();
        protoscript.TypeJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  DoubleField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.DoubleField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.DoubleValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.DoubleField,
      json: any
    ): MapWellKnownTypes.DoubleField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.DoubleValue.initialize();
        protoscript.DoubleValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  FloatField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.FloatField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.FloatValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.FloatField,
      json: any
    ): MapWellKnownTypes.FloatField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.FloatValue.initialize();
        protoscript.FloatValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Int64Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Int64Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.Int64ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Int64Field,
      json: any
    ): MapWellKnownTypes.Int64Field {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Int64Value.initialize();
        protoscript.Int64ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint64Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Uint64Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.UInt64ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Uint64Field,
      json: any
    ): MapWellKnownTypes.Uint64Field {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.UInt64Value.initialize();
        protoscript.UInt64ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Int32Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Int32Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.Int32ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Int32Field,
      json: any
    ): MapWellKnownTypes.Int32Field {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.Int32Value.initialize();
        protoscript.Int32ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint32Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.Uint32Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.UInt32ValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.Uint32Field,
      json: any
    ): MapWellKnownTypes.Uint32Field {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.UInt32Value.initialize();
        protoscript.UInt32ValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  BoolField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.BoolField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.BoolValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.BoolField,
      json: any
    ): MapWellKnownTypes.BoolField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.BoolValue.initialize();
        protoscript.BoolValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  StringField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.StringField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.StringValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.StringField,
      json: any
    ): MapWellKnownTypes.StringField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.StringValue.initialize();
        protoscript.StringValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  BytesField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<MapWellKnownTypes.BytesField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = protoscript.BytesValueJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapWellKnownTypes.BytesField,
      json: any
    ): MapWellKnownTypes.BytesField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = protoscript.BytesValue.initialize();
        protoscript.BytesValueJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      {
        "array": [
          "google/protobuf/unittest_proto3.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";

import * as googleProtobufUnittest_import from "./unittest_import.pb";
import * as googleProtobufUnittest_import_public from "./unittest_import_public.pb";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum =
  | "FOREIGN_ZERO"
  | "FOREIGN_FOO"
  | "FOREIGN_BAR"
  | "FOREIGN_BAZ";

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: googleProtobufUnittest_import.ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalStringPiece: string;
  optionalCord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalPublicImportMessage: googleProtobufUnittest_import_public.PublicImportMessage;
  optionalLazyMessage: TestAllTypes.NestedMessage;
  optionalLazyImportMessage: googleProtobufUnittest_import.ImportMessage;
  /**
   * Repeated
   */
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: googleProtobufUnittest_import.ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  oneofUint32?: number | null | undefined;
  oneofNestedMessage?: TestAllTypes.NestedMessage | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

export declare namespace TestAllTypes {
  export type NestedEnum = "ZERO" | "FOO" | "BAR" | "BAZ" | "NEG";

  export interface NestedMessage {
    /**
     * The field name "b" fails to compile in proto1 because it conflicts with
     * a local variable named "b" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  fooEnum?: TestOneof2.NestedEnum | null | undefined;
}

export declare namespace TestOneof2 {
  export type NestedEnum = "UNKNOWN" | "FOO" | "BAR" | "BAZ";
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: "FOREIGN_ZERO",
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnum {
    switch (i) {
      case 0: {
        return "FOREIGN_ZERO";
      }
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnum): number {
    switch (i) {
      case "FOREIGN_ZERO": {
        return 0;
      }
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypes = {
  /**
   * Serializes TestAllTypes to protobuf.
   */
  encode: function (msg: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString() as any);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString() as any);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString() as any);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString() as any);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64String(10, msg.optionalSfixed64.toString() as any);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
      );
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        googleProtobufUnittest_import_public.PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        40,
        msg.repeatedSfixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        googleProtobufUnittest_import.ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writePackedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnum._toInt)
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            googleProtobufUnittest_import_public.PublicImportMessage
              ._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 32: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 33: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 34: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 35: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 36: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 37: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 38: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 39: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 40: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 41: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 42: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 43: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = googleProtobufUnittest_import.ImportMessage.initialize();
          reader.readMessage(
            m,
            googleProtobufUnittest_import.ImportMessage._readMessage
          );
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt)
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 52: {
          if (reader.isDelimited()) {
            msg.repeatedForeignEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.repeatedForeignEnum.push(
              ForeignEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          msg.oneofNestedMessage = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    ZERO: "ZERO",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypes.NestedEnum {
      switch (i) {
        case 0: {
          return "ZERO";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypes.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypes.NestedEnum): number {
      switch (i) {
        case "ZERO": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.NestedMessage>): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes TestPackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedUint32?.length) {
      writer.writePackedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedSint32?.length) {
      writer.writePackedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writePackedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.packedSfixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.packedFloat?.length) {
      writer.writePackedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writePackedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writePackedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writePackedEnum(103, msg.packedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.packedInt64.push(...reader.readPackedInt64String().map(BigInt));
          } else {
            msg.packedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.packedUint32.push(...reader.readPackedUint32());
          } else {
            msg.packedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.packedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.packedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.packedSint32.push(...reader.readPackedSint32());
          } else {
            msg.packedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.packedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.packedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.packedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.packedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.packedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.packedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.packedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.packedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.packedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.packedFloat.push(...reader.readPackedFloat());
          } else {
            msg.packedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.packedDouble.push(...reader.readPackedDouble());
          } else {
            msg.packedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.packedBool.push(...reader.readPackedBool());
          } else {
            msg.packedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.packedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt)
            );
          } else {
            msg.packedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes TestUnpackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        2,
        msg.repeatedInt64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        4,
        msg.repeatedUint64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        6,
        msg.repeatedSint64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        8,
        msg.repeatedFixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        10,
        msg.repeatedSfixed64.map((x) => x.toString() as any)
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        14,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt)
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 2: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt)
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 3: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 4: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt)
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 5: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 6: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt)
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 7: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 8: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt)
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 9: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 10: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt)
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 11: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 12: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 13: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 14: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt)
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum())
            );
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes NestedTestAllTypes to protobuf.
   */
  encode: function (msg: Partial<NestedTestAllTypes>): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes ForeignMessage to protobuf.
   */
  encode: function (msg: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes TestEmptyMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestEmptyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestEmptyMessage,
    _reader: BinaryReader
  ): TestEmptyMessage {
    return _msg;
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes TestMessageWithDummy to protobuf.
   */
  encode: function (msg: Partial<TestMessageWithDummy>): Uint8Array {
    return TestMessageWithDummy._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMessageWithDummy from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageWithDummy {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageWithDummy>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    reader: BinaryReader
  ): TestMessageWithDummy {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes TestOneof2 to protobuf.
   */
  encode: function (msg: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooEnum: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnum._toInt(msg.fooEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    UNKNOWN: "UNKNOWN",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestOneof2.NestedEnum {
      switch (i) {
        case 0: {
          return "UNKNOWN";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestOneof2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestOneof2.NestedEnum): number {
      switch (i) {
        case "UNKNOWN": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ForeignEnumJSON = {
  FOREIGN_ZERO: "FOREIGN_ZERO",
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnum {
    switch (i) {
      case 0: {
        return "FOREIGN_ZERO";
      }
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnum): number {
    switch (i) {
      case "FOREIGN_ZERO": {
        return 0;
      }
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypesJSON = {
  /**
   * Serializes TestAllTypes to JSON.
   */
  encode: function (msg: Partial<TestAllTypes>): string {
    return JSON.stringify(TestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestAllTypes from JSON.
   */
  decode: function (json: string): TestAllTypes {
    return TestAllTypesJSON._readMessage(
      TestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessageJSON.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessageJSON.initialize(),
      optionalLazyMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalLazyImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json["optionalInt64"] = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json["optionalUint32"] = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json["optionalUint64"] = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json["optionalSint32"] = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json["optionalSint64"] = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json["optionalFixed32"] = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json["optionalFixed64"] = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json["optionalSfixed32"] = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json["optionalSfixed64"] = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json["optionalFloat"] = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json["optionalDouble"] = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json["optionalBool"] = msg.optionalBool;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalNestedMessage);
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    if (msg.optionalForeignMessage) {
      const _optionalForeignMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalForeignMessage
      );
      if (Object.keys(_optionalForeignMessage_).length > 0) {
        json["optionalForeignMessage"] = _optionalForeignMessage_;
      }
    }
    if (msg.optionalImportMessage) {
      const _optionalImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalImportMessage
        );
      if (Object.keys(_optionalImportMessage_).length > 0) {
        json["optionalImportMessage"] = _optionalImportMessage_;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      json["optionalNestedEnum"] = msg.optionalNestedEnum;
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json["optionalStringPiece"] = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json["optionalCord"] = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const _optionalPublicImportMessage_ =
        googleProtobufUnittest_import_public.PublicImportMessageJSON._writeMessage(
          msg.optionalPublicImportMessage
        );
      if (Object.keys(_optionalPublicImportMessage_).length > 0) {
        json["optionalPublicImportMessage"] = _optionalPublicImportMessage_;
      }
    }
    if (msg.optionalLazyMessage) {
      const _optionalLazyMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalLazyMessage);
      if (Object.keys(_optionalLazyMessage_).length > 0) {
        json["optionalLazyMessage"] = _optionalLazyMessage_;
      }
    }
    if (msg.optionalLazyImportMessage) {
      const _optionalLazyImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalLazyImportMessage
        );
      if (Object.keys(_optionalLazyImportMessage_).length > 0) {
        json["optionalLazyImportMessage"] = _optionalLazyImportMessage_;
      }
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json["repeatedString"] = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json["repeatedBytes"] = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json["repeatedNestedMessage"] = msg.repeatedNestedMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json["repeatedForeignMessage"] = msg.repeatedForeignMessage.map(
        ForeignMessageJSON._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json["repeatedImportMessage"] = msg.repeatedImportMessage.map(
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json["repeatedForeignEnum"] = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json["repeatedStringPiece"] = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json["repeatedCord"] = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json["repeatedLazyMessage"] = msg.repeatedLazyMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const _oneofNestedMessage_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.oneofNestedMessage
      );
      json["oneofNestedMessage"] = _oneofNestedMessage_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestAllTypes, json: any): TestAllTypes {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _optionalInt64_ = json["optionalInt64"] ?? json["optional_int64"];
    if (_optionalInt64_) {
      msg.optionalInt64 = BigInt(_optionalInt64_);
    }
    const _optionalUint32_ = json["optionalUint32"] ?? json["optional_uint32"];
    if (_optionalUint32_) {
      msg.optionalUint32 = _optionalUint32_;
    }
    const _optionalUint64_ = json["optionalUint64"] ?? json["optional_uint64"];
    if (_optionalUint64_) {
      msg.optionalUint64 = BigInt(_optionalUint64_);
    }
    const _optionalSint32_ = json["optionalSint32"] ?? json["optional_sint32"];
    if (_optionalSint32_) {
      msg.optionalSint32 = _optionalSint32_;
    }
    const _optionalSint64_ = json["optionalSint64"] ?? json["optional_sint64"];
    if (_optionalSint64_) {
      msg.optionalSint64 = BigInt(_optionalSint64_);
    }
    const _optionalFixed32_ =
      json["optionalFixed32"] ?? json["optional_fixed32"];
    if (_optionalFixed32_) {
      msg.optionalFixed32 = _optionalFixed32_;
    }
    const _optionalFixed64_ =
      json["optionalFixed64"] ?? json["optional_fixed64"];
    if (_optionalFixed64_) {
      msg.optionalFixed64 = BigInt(_optionalFixed64_);
    }
    const _optionalSfixed32_ =
      json["optionalSfixed32"] ?? json["optional_sfixed32"];
    if (_optionalSfixed32_) {
      msg.optionalSfixed32 = _optionalSfixed32_;
    }
    const _optionalSfixed64_ =
      json["optionalSfixed64"] ?? json["optional_sfixed64"];
    if (_optionalSfixed64_) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64_);
    }
    const _optionalFloat_ = json["optionalFloat"] ?? json["optional_float"];
    if (_optionalFloat_) {
      msg.optionalFloat = _optionalFloat_;
    }
    const _optionalDouble_ = json["optionalDouble"] ?? json["optional_double"];
    if (_optionalDouble_) {
      msg.optionalDouble = _optionalDouble_;
    }
    const _optionalBool_ = json["optionalBool"] ?? json["optional_bool"];
    if (_optionalBool_) {
      msg.optionalBool = _optionalBool_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalNestedMessage_);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage_ =
      json["optionalForeignMessage"] ?? json["optional_foreign_message"];
    if (_optionalForeignMessage_) {
      const m = ForeignMessage.initialize();
      ForeignMessageJSON._readMessage(m, _optionalForeignMessage_);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage_ =
      json["optionalImportMessage"] ?? json["optional_import_message"];
    if (_optionalImportMessage_) {
      const m = googleProtobufUnittest_import.ImportMessage.initialize();
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        m,
        _optionalImportMessage_
      );
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum_ =
      json["optionalNestedEnum"] ?? json["optional_nested_enum"];
    if (_optionalNestedEnum_) {
      msg.optionalNestedEnum = _optionalNestedEnum_;
    }
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    const _optionalStringPiece_ =
      json["optionalStringPiece"] ?? json["optional_string_piece"];
    if (_optionalStringPiece_) {
      msg.optionalStringPiece = _optionalStringPiece_;
    }
    const _optionalCord_ = json["optionalCord"] ?? json["optional_cord"];
    if (_optionalCord_) {
      msg.optionalCord = _optionalCord_;
    }
    const _optionalPublicImportMessage_ =
      json["optionalPublicImportMessage"] ??
      json["optional_public_import_message"];
    if (_optionalPublicImportMessage_) {
      const m =
        googleProtobufUnittest_import_public.PublicImportMessage.initialize();
      googleProtobufUnittest_import_public.PublicImportMessageJSON._readMessage(
        m,
        _optionalPublicImportMessage_
      );
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage_ =
      json["optionalLazyMessage"] ?? json["optional_lazy_message"];
    if (_optionalLazyMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _optionalLazyMessage_);
      msg.optionalLazyMessage = m;
    }
    const _optionalLazyImportMessage_ =
      json["optionalLazyImportMessage"] ?? json["optional_lazy_import_message"];
    if (_optionalLazyImportMessage_) {
      const m = googleProtobufUnittest_import.ImportMessage.initialize();
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        m,
        _optionalLazyImportMessage_
      );
      msg.optionalLazyImportMessage = m;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedString_ = json["repeatedString"] ?? json["repeated_string"];
    if (_repeatedString_) {
      msg.repeatedString = _repeatedString_;
    }
    const _repeatedBytes_ = json["repeatedBytes"] ?? json["repeated_bytes"];
    if (_repeatedBytes_) {
      msg.repeatedBytes = _repeatedBytes_.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage_ =
      json["repeatedNestedMessage"] ?? json["repeated_nested_message"];
    if (_repeatedNestedMessage_) {
      for (const item of _repeatedNestedMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage_ =
      json["repeatedForeignMessage"] ?? json["repeated_foreign_message"];
    if (_repeatedForeignMessage_) {
      for (const item of _repeatedForeignMessage_) {
        const m = ForeignMessage.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage_ =
      json["repeatedImportMessage"] ?? json["repeated_import_message"];
    if (_repeatedImportMessage_) {
      for (const item of _repeatedImportMessage_) {
        const m = googleProtobufUnittest_import.ImportMessage.initialize();
        googleProtobufUnittest_import.ImportMessageJSON._readMessage(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    const _repeatedForeignEnum_ =
      json["repeatedForeignEnum"] ?? json["repeated_foreign_enum"];
    if (_repeatedForeignEnum_) {
      msg.repeatedForeignEnum = _repeatedForeignEnum_;
    }
    const _repeatedStringPiece_ =
      json["repeatedStringPiece"] ?? json["repeated_string_piece"];
    if (_repeatedStringPiece_) {
      msg.repeatedStringPiece = _repeatedStringPiece_;
    }
    const _repeatedCord_ = json["repeatedCord"] ?? json["repeated_cord"];
    if (_repeatedCord_) {
      msg.repeatedCord = _repeatedCord_;
    }
    const _repeatedLazyMessage_ =
      json["repeatedLazyMessage"] ?? json["repeated_lazy_message"];
    if (_repeatedLazyMessage_) {
      for (const item of _repeatedLazyMessage_) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofNestedMessage_ =
      json["oneofNestedMessage"] ?? json["oneof_nested_message"];
    if (_oneofNestedMessage_) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(m, _oneofNestedMessage_);
      msg.oneofNestedMessage = m;
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  NestedEnum: {
    ZERO: "ZERO",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypes.NestedEnum {
      switch (i) {
        case 0: {
          return "ZERO";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypes.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypes.NestedEnum): number {
      switch (i) {
        case "ZERO": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to JSON.
     */
    encode: function (msg: Partial<TestAllTypes.NestedMessage>): string {
      return JSON.stringify(TestAllTypesJSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from JSON.
     */
    decode: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypesJSON.NestedMessage._readMessage(
        TestAllTypesJSON.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      json: any
    ): TestAllTypes.NestedMessage {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },
};

export const TestPackedTypesJSON = {
  /**
   * Serializes TestPackedTypes to JSON.
   */
  encode: function (msg: Partial<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestPackedTypes from JSON.
   */
  decode: function (json: string): TestPackedTypes {
    return TestPackedTypesJSON._readMessage(
      TestPackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json["packedInt64"] = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json["packedUint32"] = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json["packedUint64"] = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json["packedSint32"] = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json["packedSint64"] = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json["packedFixed32"] = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json["packedFixed64"] = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json["packedSfixed32"] = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json["packedSfixed64"] = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json["packedFloat"] = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json["packedDouble"] = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json["packedBool"] = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json["packedEnum"] = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestPackedTypes, json: any): TestPackedTypes {
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _packedInt64_ = json["packedInt64"] ?? json["packed_int64"];
    if (_packedInt64_) {
      msg.packedInt64 = _packedInt64_.map(BigInt);
    }
    const _packedUint32_ = json["packedUint32"] ?? json["packed_uint32"];
    if (_packedUint32_) {
      msg.packedUint32 = _packedUint32_;
    }
    const _packedUint64_ = json["packedUint64"] ?? json["packed_uint64"];
    if (_packedUint64_) {
      msg.packedUint64 = _packedUint64_.map(BigInt);
    }
    const _packedSint32_ = json["packedSint32"] ?? json["packed_sint32"];
    if (_packedSint32_) {
      msg.packedSint32 = _packedSint32_;
    }
    const _packedSint64_ = json["packedSint64"] ?? json["packed_sint64"];
    if (_packedSint64_) {
      msg.packedSint64 = _packedSint64_.map(BigInt);
    }
    const _packedFixed32_ = json["packedFixed32"] ?? json["packed_fixed32"];
    if (_packedFixed32_) {
      msg.packedFixed32 = _packedFixed32_;
    }
    const _packedFixed64_ = json["packedFixed64"] ?? json["packed_fixed64"];
    if (_packedFixed64_) {
      msg.packedFixed64 = _packedFixed64_.map(BigInt);
    }
    const _packedSfixed32_ = json["packedSfixed32"] ?? json["packed_sfixed32"];
    if (_packedSfixed32_) {
      msg.packedSfixed32 = _packedSfixed32_;
    }
    const _packedSfixed64_ = json["packedSfixed64"] ?? json["packed_sfixed64"];
    if (_packedSfixed64_) {
      msg.packedSfixed64 = _packedSfixed64_.map(BigInt);
    }
    const _packedFloat_ = json["packedFloat"] ?? json["packed_float"];
    if (_packedFloat_) {
      msg.packedFloat = _packedFloat_;
    }
    const _packedDouble_ = json["packedDouble"] ?? json["packed_double"];
    if (_packedDouble_) {
      msg.packedDouble = _packedDouble_;
    }
    const _packedBool_ = json["packedBool"] ?? json["packed_bool"];
    if (_packedBool_) {
      msg.packedBool = _packedBool_;
    }
    const _packedEnum_ = json["packedEnum"] ?? json["packed_enum"];
    if (_packedEnum_) {
      msg.packedEnum = _packedEnum_;
    }
    return msg;
  },
};

export const TestUnpackedTypesJSON = {
  /**
   * Serializes TestUnpackedTypes to JSON.
   */
  encode: function (msg: Partial<TestUnpackedTypes>): string {
    return JSON.stringify(TestUnpackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestUnpackedTypes from JSON.
   */
  decode: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypesJSON._readMessage(
      TestUnpackedTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    json: any
  ): TestUnpackedTypes {
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    return msg;
  },
};

export const NestedTestAllTypesJSON = {
  /**
   * Serializes NestedTestAllTypes to JSON.
   */
  encode: function (msg: Partial<NestedTestAllTypes>): string {
    return JSON.stringify(NestedTestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes NestedTestAllTypes from JSON.
   */
  decode: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypesJSON._readMessage(
      NestedTestAllTypesJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypesJSON.initialize(),
      payload: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const _child_ = NestedTestAllTypesJSON._writeMessage(msg.child);
      if (Object.keys(_child_).length > 0) {
        json["child"] = _child_;
      }
    }
    if (msg.payload) {
      const _payload_ = TestAllTypesJSON._writeMessage(msg.payload);
      if (Object.keys(_payload_).length > 0) {
        json["payload"] = _payload_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    json: any
  ): NestedTestAllTypes {
    const _child_ = json["child"];
    if (_child_) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypesJSON._readMessage(m, _child_);
      msg.child = m;
    }
    const _payload_ = json["payload"];
    if (_payload_) {
      const m = TestAllTypes.initialize();
      TestAllTypesJSON._readMessage(m, _payload_);
      msg.payload = m;
    }
    return msg;
  },
};

export const ForeignMessageJSON = {
  /**
   * Serializes ForeignMessage to JSON.
   */
  encode: function (msg: Partial<ForeignMessage>): string {
    return JSON.stringify(ForeignMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ForeignMessage from JSON.
   */
  decode: function (json: string): ForeignMessage {
    return ForeignMessageJSON._readMessage(
      ForeignMessageJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json["c"] = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ForeignMessage, json: any): ForeignMessage {
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    return msg;
  },
};

export const TestEmptyMessageJSON = {
  /**
   * Serializes TestEmptyMessage to JSON.
   */
  encode: function (_msg?: Partial<TestEmptyMessage>): string {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessage from JSON.
   */
  decode: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: Partial<TestEmptyMessage>
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestEmptyMessage, _json: any): TestEmptyMessage {
    return msg;
  },
};

export const TestMessageWithDummyJSON = {
  /**
   * Serializes TestMessageWithDummy to JSON.
   */
  encode: function (msg: Partial<TestMessageWithDummy>): string {
    return JSON.stringify(TestMessageWithDummyJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMessageWithDummy from JSON.
   */
  decode: function (json: string): TestMessageWithDummy {
    return TestMessageWithDummyJSON._readMessage(
      TestMessageWithDummyJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageWithDummy>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.dummy) {
      json["dummy"] = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    json: any
  ): TestMessageWithDummy {
    const _dummy_ = json["dummy"];
    if (_dummy_) {
      msg.dummy = _dummy_;
    }
    return msg;
  },
};

export const TestOneof2JSON = {
  /**
   * Serializes TestOneof2 to JSON.
   */
  encode: function (msg: Partial<TestOneof2>): string {
    return JSON.stringify(TestOneof2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof2 from JSON.
   */
  decode: function (json: string): TestOneof2 {
    return TestOneof2JSON._readMessage(
      TestOneof2JSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooEnum: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<TestOneof2>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooEnum != undefined) {
      json["fooEnum"] = msg.fooEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, json: any): TestOneof2 {
    const _fooEnum_ = json["fooEnum"] ?? json["foo_enum"];
    if (_fooEnum_) {
      msg.fooEnum = _fooEnum_;
    }
    return msg;
  },

  NestedEnum: {
    UNKNOWN: "UNKNOWN",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestOneof2.NestedEnum {
      switch (i) {
        case 0: {
          return "UNKNOWN";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestOneof2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestOneof2.NestedEnum): number {
      switch (i) {
        case "UNKNOWN": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
    ],
  },
}
`;
