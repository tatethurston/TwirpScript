// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[` 1`] = `
"$ /Users/tatethurston/twirpscript/e2e-tests/test-protos/node_modules/.bin/twirpscript
[TwirpScript] Using configuration file at '/Users/tatethurston/twirpscript/e2e-tests/test-protos/.twirp.json'.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
"
`;

exports[` 2`] = `
"$ /Users/tatethurston/twirpscript/e2e-tests/test-protos/node_modules/.bin/tsc --noEmit
"
`;

exports[`TwirpScript Compiler generates src/7/a.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 7/a.proto
import type {
  ByteSource,
  ClientConfiguration,
  ServiceHandler,
} from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  createMethodHandler,
} from \\"twirpscript\\";

//========================================//
//       FooService Protobuf Client       //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await PBrequest(
    \\"/A.FooService/Foo1\\",
    Foo1Request.encode(foo1Request),
    config
  );
  return Foo1Response.decode(response);
}

export async function Foo2(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await PBrequest(
    \\"/A.FooService/Foo2\\",
    Foo2Request.encode(foo2Request),
    config
  );
  return Foo2Response.decode(response);
}

export async function Foo3(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await PBrequest(
    \\"/A.FooService/Foo3\\",
    Foo3Request.encode(foo3Request),
    config
  );
  return Foo3Response.decode(response);
}

export async function Foo4(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await PBrequest(
    \\"/A.FooService/Foo4\\",
    Foo4Request.encode(foo4Request),
    config
  );
  return Foo4Response.decode(response);
}

export async function Foo5(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await PBrequest(
    \\"/A.FooService/Foo5\\",
    Foo5Request.encode(foo5Request),
    config
  );
  return Foo5Response.decode(response);
}

//========================================//
//         FooService JSON Client         //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1JSON(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await JSONrequest<Foo1Response>(
    \\"/A.FooService/Foo1\\",
    foo1Request,
    config
  );
  return response;
}

export async function Foo2JSON(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await JSONrequest<Foo2Response>(
    \\"/A.FooService/Foo2\\",
    foo2Request,
    config
  );
  return response;
}

export async function Foo3JSON(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await JSONrequest<Foo3Response>(
    \\"/A.FooService/Foo3\\",
    foo3Request,
    config
  );
  return response;
}

export async function Foo4JSON(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await JSONrequest<Foo4Response>(
    \\"/A.FooService/Foo4\\",
    foo4Request,
    config
  );
  return response;
}

export async function Foo5JSON(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await JSONrequest<Foo5Response>(
    \\"/A.FooService/Foo5\\",
    foo5Request,
    config
  );
  return response;
}

//========================================//
//           FooService Service           //
//========================================//

export interface FooServiceService<Context = unknown> {
  /**
   * Login via credentials
   */
  Foo1: (
    foo1Request: Foo1Request,
    context: Context
  ) => Promise<Foo1Response> | Foo1Response;
  Foo2: (
    foo2Request: Foo2Request,
    context: Context
  ) => Promise<Foo2Response> | Foo2Response;
  Foo3: (
    foo3Request: Foo3Request,
    context: Context
  ) => Promise<Foo3Response> | Foo3Response;
  Foo4: (
    foo4Request: Foo4Request,
    context: Context
  ) => Promise<Foo4Response> | Foo4Response;
  Foo5: (
    foo5Request: Foo5Request,
    context: Context
  ) => Promise<Foo5Response> | Foo5Response;
}

export function createFooServiceHandler<Context>(
  service: FooServiceService<Context>
): ServiceHandler<Context> {
  return {
    path: \\"A.FooService\\",
    methods: {
      Foo1: createMethodHandler({
        handler: service.Foo1,
        encode: Foo1Response.encode,
        decode: Foo1Request.decode,
      }),
      Foo2: createMethodHandler({
        handler: service.Foo2,
        encode: Foo2Response.encode,
        decode: Foo2Request.decode,
      }),
      Foo3: createMethodHandler({
        handler: service.Foo3,
        encode: Foo3Response.encode,
        decode: Foo3Request.decode,
      }),
      Foo4: createMethodHandler({
        handler: service.Foo4,
        encode: Foo4Response.encode,
        decode: Foo4Request.decode,
      }),
      Foo5: createMethodHandler({
        handler: service.Foo5,
        encode: Foo5Response.encode,
        decode: Foo5Request.decode,
      }),
    },
  };
}

//========================================//
//                 Types                  //
//========================================//

export interface Foo1Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo1Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Foo1Request = {
  writeMessage: function (msg: Foo1Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Request: Foo1Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Request.writeMessage(foo1Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Request.readMessage(message, reader);
    return message as Foo1Request;
  },

  defaultValue: function (): Foo1Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo1Response = {
  writeMessage: function (msg: Foo1Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Response: Foo1Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Response.writeMessage(foo1Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Response.readMessage(message, reader);
    return message as Foo1Response;
  },

  defaultValue: function (): Foo1Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Request = {
  writeMessage: function (msg: Foo2Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Request: Foo2Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Request.writeMessage(foo2Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Request.readMessage(message, reader);
    return message as Foo2Request;
  },

  defaultValue: function (): Foo2Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Response = {
  writeMessage: function (msg: Foo2Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Response: Foo2Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Response.writeMessage(foo2Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Response.readMessage(message, reader);
    return message as Foo2Response;
  },

  defaultValue: function (): Foo2Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Request = {
  writeMessage: function (msg: Foo3Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Request: Foo3Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Request.writeMessage(foo3Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Request.readMessage(message, reader);
    return message as Foo3Request;
  },

  defaultValue: function (): Foo3Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Response = {
  writeMessage: function (msg: Foo3Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Response: Foo3Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Response.writeMessage(foo3Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Response.readMessage(message, reader);
    return message as Foo3Response;
  },

  defaultValue: function (): Foo3Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Request = {
  writeMessage: function (msg: Foo4Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Request: Foo4Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Request.writeMessage(foo4Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Request.readMessage(message, reader);
    return message as Foo4Request;
  },

  defaultValue: function (): Foo4Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Response = {
  writeMessage: function (msg: Foo4Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Response: Foo4Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Response.writeMessage(foo4Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Response.readMessage(message, reader);
    return message as Foo4Response;
  },

  defaultValue: function (): Foo4Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Request = {
  writeMessage: function (msg: Foo5Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Request: Foo5Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Request.writeMessage(foo5Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Request.readMessage(message, reader);
    return message as Foo5Request;
  },

  defaultValue: function (): Foo5Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Response = {
  writeMessage: function (msg: Foo5Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Response: Foo5Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Response.writeMessage(foo5Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Response.readMessage(message, reader);
    return message as Foo5Response;
  },

  defaultValue: function (): Foo5Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};
"
`;

exports[`TwirpScript Compiler generates src/7/b.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 7/b.proto
import type {
  ByteSource,
  ClientConfiguration,
  ServiceHandler,
} from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  createMethodHandler,
} from \\"twirpscript\\";

//========================================//
//       FooService Protobuf Client       //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await PBrequest(
    \\"/B.FooService/Foo1\\",
    Foo1Request.encode(foo1Request),
    config
  );
  return Foo1Response.decode(response);
}

export async function Foo2(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await PBrequest(
    \\"/B.FooService/Foo2\\",
    Foo2Request.encode(foo2Request),
    config
  );
  return Foo2Response.decode(response);
}

export async function Foo3(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await PBrequest(
    \\"/B.FooService/Foo3\\",
    Foo3Request.encode(foo3Request),
    config
  );
  return Foo3Response.decode(response);
}

export async function Foo4(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await PBrequest(
    \\"/B.FooService/Foo4\\",
    Foo4Request.encode(foo4Request),
    config
  );
  return Foo4Response.decode(response);
}

export async function Foo5(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await PBrequest(
    \\"/B.FooService/Foo5\\",
    Foo5Request.encode(foo5Request),
    config
  );
  return Foo5Response.decode(response);
}

//========================================//
//         FooService JSON Client         //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1JSON(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await JSONrequest<Foo1Response>(
    \\"/B.FooService/Foo1\\",
    foo1Request,
    config
  );
  return response;
}

export async function Foo2JSON(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await JSONrequest<Foo2Response>(
    \\"/B.FooService/Foo2\\",
    foo2Request,
    config
  );
  return response;
}

export async function Foo3JSON(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await JSONrequest<Foo3Response>(
    \\"/B.FooService/Foo3\\",
    foo3Request,
    config
  );
  return response;
}

export async function Foo4JSON(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await JSONrequest<Foo4Response>(
    \\"/B.FooService/Foo4\\",
    foo4Request,
    config
  );
  return response;
}

export async function Foo5JSON(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await JSONrequest<Foo5Response>(
    \\"/B.FooService/Foo5\\",
    foo5Request,
    config
  );
  return response;
}

//========================================//
//           FooService Service           //
//========================================//

export interface FooServiceService<Context = unknown> {
  /**
   * Login via credentials
   */
  Foo1: (
    foo1Request: Foo1Request,
    context: Context
  ) => Promise<Foo1Response> | Foo1Response;
  Foo2: (
    foo2Request: Foo2Request,
    context: Context
  ) => Promise<Foo2Response> | Foo2Response;
  Foo3: (
    foo3Request: Foo3Request,
    context: Context
  ) => Promise<Foo3Response> | Foo3Response;
  Foo4: (
    foo4Request: Foo4Request,
    context: Context
  ) => Promise<Foo4Response> | Foo4Response;
  Foo5: (
    foo5Request: Foo5Request,
    context: Context
  ) => Promise<Foo5Response> | Foo5Response;
}

export function createFooServiceHandler<Context>(
  service: FooServiceService<Context>
): ServiceHandler<Context> {
  return {
    path: \\"B.FooService\\",
    methods: {
      Foo1: createMethodHandler({
        handler: service.Foo1,
        encode: Foo1Response.encode,
        decode: Foo1Request.decode,
      }),
      Foo2: createMethodHandler({
        handler: service.Foo2,
        encode: Foo2Response.encode,
        decode: Foo2Request.decode,
      }),
      Foo3: createMethodHandler({
        handler: service.Foo3,
        encode: Foo3Response.encode,
        decode: Foo3Request.decode,
      }),
      Foo4: createMethodHandler({
        handler: service.Foo4,
        encode: Foo4Response.encode,
        decode: Foo4Request.decode,
      }),
      Foo5: createMethodHandler({
        handler: service.Foo5,
        encode: Foo5Response.encode,
        decode: Foo5Request.decode,
      }),
    },
  };
}

//========================================//
//                 Types                  //
//========================================//

export interface Foo1Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo1Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Foo1Request = {
  writeMessage: function (msg: Foo1Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Request: Foo1Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Request.writeMessage(foo1Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Request.readMessage(message, reader);
    return message as Foo1Request;
  },

  defaultValue: function (): Foo1Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo1Response = {
  writeMessage: function (msg: Foo1Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Response: Foo1Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Response.writeMessage(foo1Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Response.readMessage(message, reader);
    return message as Foo1Response;
  },

  defaultValue: function (): Foo1Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Request = {
  writeMessage: function (msg: Foo2Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Request: Foo2Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Request.writeMessage(foo2Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Request.readMessage(message, reader);
    return message as Foo2Request;
  },

  defaultValue: function (): Foo2Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Response = {
  writeMessage: function (msg: Foo2Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Response: Foo2Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Response.writeMessage(foo2Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Response.readMessage(message, reader);
    return message as Foo2Response;
  },

  defaultValue: function (): Foo2Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Request = {
  writeMessage: function (msg: Foo3Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Request: Foo3Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Request.writeMessage(foo3Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Request.readMessage(message, reader);
    return message as Foo3Request;
  },

  defaultValue: function (): Foo3Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Response = {
  writeMessage: function (msg: Foo3Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Response: Foo3Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Response.writeMessage(foo3Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Response.readMessage(message, reader);
    return message as Foo3Response;
  },

  defaultValue: function (): Foo3Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Request = {
  writeMessage: function (msg: Foo4Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Request: Foo4Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Request.writeMessage(foo4Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Request.readMessage(message, reader);
    return message as Foo4Request;
  },

  defaultValue: function (): Foo4Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Response = {
  writeMessage: function (msg: Foo4Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Response: Foo4Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Response.writeMessage(foo4Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Response.readMessage(message, reader);
    return message as Foo4Response;
  },

  defaultValue: function (): Foo4Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Request = {
  writeMessage: function (msg: Foo5Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Request: Foo5Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Request.writeMessage(foo5Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Request.readMessage(message, reader);
    return message as Foo5Request;
  },

  defaultValue: function (): Foo5Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Response = {
  writeMessage: function (msg: Foo5Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Response: Foo5Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Response.writeMessage(foo5Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Response.readMessage(message, reader);
    return message as Foo5Response;
  },

  defaultValue: function (): Foo5Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};
"
`;

exports[`TwirpScript Compiler generates src/7/c.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 7/c.proto
import type {
  ByteSource,
  ClientConfiguration,
  ServiceHandler,
} from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  createMethodHandler,
} from \\"twirpscript\\";

//========================================//
//       FooService Protobuf Client       //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await PBrequest(
    \\"/C.FooService/Foo1\\",
    Foo1Request.encode(foo1Request),
    config
  );
  return Foo1Response.decode(response);
}

export async function Foo2(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await PBrequest(
    \\"/C.FooService/Foo2\\",
    Foo2Request.encode(foo2Request),
    config
  );
  return Foo2Response.decode(response);
}

export async function Foo3(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await PBrequest(
    \\"/C.FooService/Foo3\\",
    Foo3Request.encode(foo3Request),
    config
  );
  return Foo3Response.decode(response);
}

export async function Foo4(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await PBrequest(
    \\"/C.FooService/Foo4\\",
    Foo4Request.encode(foo4Request),
    config
  );
  return Foo4Response.decode(response);
}

export async function Foo5(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await PBrequest(
    \\"/C.FooService/Foo5\\",
    Foo5Request.encode(foo5Request),
    config
  );
  return Foo5Response.decode(response);
}

//========================================//
//         FooService JSON Client         //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1JSON(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await JSONrequest<Foo1Response>(
    \\"/C.FooService/Foo1\\",
    foo1Request,
    config
  );
  return response;
}

export async function Foo2JSON(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await JSONrequest<Foo2Response>(
    \\"/C.FooService/Foo2\\",
    foo2Request,
    config
  );
  return response;
}

export async function Foo3JSON(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await JSONrequest<Foo3Response>(
    \\"/C.FooService/Foo3\\",
    foo3Request,
    config
  );
  return response;
}

export async function Foo4JSON(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await JSONrequest<Foo4Response>(
    \\"/C.FooService/Foo4\\",
    foo4Request,
    config
  );
  return response;
}

export async function Foo5JSON(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await JSONrequest<Foo5Response>(
    \\"/C.FooService/Foo5\\",
    foo5Request,
    config
  );
  return response;
}

//========================================//
//           FooService Service           //
//========================================//

export interface FooServiceService<Context = unknown> {
  /**
   * Login via credentials
   */
  Foo1: (
    foo1Request: Foo1Request,
    context: Context
  ) => Promise<Foo1Response> | Foo1Response;
  Foo2: (
    foo2Request: Foo2Request,
    context: Context
  ) => Promise<Foo2Response> | Foo2Response;
  Foo3: (
    foo3Request: Foo3Request,
    context: Context
  ) => Promise<Foo3Response> | Foo3Response;
  Foo4: (
    foo4Request: Foo4Request,
    context: Context
  ) => Promise<Foo4Response> | Foo4Response;
  Foo5: (
    foo5Request: Foo5Request,
    context: Context
  ) => Promise<Foo5Response> | Foo5Response;
}

export function createFooServiceHandler<Context>(
  service: FooServiceService<Context>
): ServiceHandler<Context> {
  return {
    path: \\"C.FooService\\",
    methods: {
      Foo1: createMethodHandler({
        handler: service.Foo1,
        encode: Foo1Response.encode,
        decode: Foo1Request.decode,
      }),
      Foo2: createMethodHandler({
        handler: service.Foo2,
        encode: Foo2Response.encode,
        decode: Foo2Request.decode,
      }),
      Foo3: createMethodHandler({
        handler: service.Foo3,
        encode: Foo3Response.encode,
        decode: Foo3Request.decode,
      }),
      Foo4: createMethodHandler({
        handler: service.Foo4,
        encode: Foo4Response.encode,
        decode: Foo4Request.decode,
      }),
      Foo5: createMethodHandler({
        handler: service.Foo5,
        encode: Foo5Response.encode,
        decode: Foo5Request.decode,
      }),
    },
  };
}

//========================================//
//                 Types                  //
//========================================//

export interface Foo1Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo1Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Foo1Request = {
  writeMessage: function (msg: Foo1Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Request: Foo1Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Request.writeMessage(foo1Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Request.readMessage(message, reader);
    return message as Foo1Request;
  },

  defaultValue: function (): Foo1Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo1Response = {
  writeMessage: function (msg: Foo1Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Response: Foo1Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Response.writeMessage(foo1Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Response.readMessage(message, reader);
    return message as Foo1Response;
  },

  defaultValue: function (): Foo1Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Request = {
  writeMessage: function (msg: Foo2Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Request: Foo2Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Request.writeMessage(foo2Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Request.readMessage(message, reader);
    return message as Foo2Request;
  },

  defaultValue: function (): Foo2Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Response = {
  writeMessage: function (msg: Foo2Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Response: Foo2Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Response.writeMessage(foo2Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Response.readMessage(message, reader);
    return message as Foo2Response;
  },

  defaultValue: function (): Foo2Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Request = {
  writeMessage: function (msg: Foo3Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Request: Foo3Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Request.writeMessage(foo3Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Request.readMessage(message, reader);
    return message as Foo3Request;
  },

  defaultValue: function (): Foo3Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Response = {
  writeMessage: function (msg: Foo3Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Response: Foo3Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Response.writeMessage(foo3Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Response.readMessage(message, reader);
    return message as Foo3Response;
  },

  defaultValue: function (): Foo3Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Request = {
  writeMessage: function (msg: Foo4Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Request: Foo4Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Request.writeMessage(foo4Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Request.readMessage(message, reader);
    return message as Foo4Request;
  },

  defaultValue: function (): Foo4Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Response = {
  writeMessage: function (msg: Foo4Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Response: Foo4Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Response.writeMessage(foo4Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Response.readMessage(message, reader);
    return message as Foo4Response;
  },

  defaultValue: function (): Foo4Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Request = {
  writeMessage: function (msg: Foo5Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Request: Foo5Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Request.writeMessage(foo5Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Request.readMessage(message, reader);
    return message as Foo5Request;
  },

  defaultValue: function (): Foo5Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Response = {
  writeMessage: function (msg: Foo5Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Response: Foo5Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Response.writeMessage(foo5Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Response.readMessage(message, reader);
    return message as Foo5Response;
  },

  defaultValue: function (): Foo5Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};
"
`;

exports[`TwirpScript Compiler generates src/7/d.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 7/d.proto
import type {
  ByteSource,
  ClientConfiguration,
  ServiceHandler,
} from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  createMethodHandler,
} from \\"twirpscript\\";

//========================================//
//       FooService Protobuf Client       //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await PBrequest(
    \\"/D.FooService/Foo1\\",
    Foo1Request.encode(foo1Request),
    config
  );
  return Foo1Response.decode(response);
}

export async function Foo2(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await PBrequest(
    \\"/D.FooService/Foo2\\",
    Foo2Request.encode(foo2Request),
    config
  );
  return Foo2Response.decode(response);
}

export async function Foo3(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await PBrequest(
    \\"/D.FooService/Foo3\\",
    Foo3Request.encode(foo3Request),
    config
  );
  return Foo3Response.decode(response);
}

export async function Foo4(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await PBrequest(
    \\"/D.FooService/Foo4\\",
    Foo4Request.encode(foo4Request),
    config
  );
  return Foo4Response.decode(response);
}

export async function Foo5(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await PBrequest(
    \\"/D.FooService/Foo5\\",
    Foo5Request.encode(foo5Request),
    config
  );
  return Foo5Response.decode(response);
}

//========================================//
//         FooService JSON Client         //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1JSON(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await JSONrequest<Foo1Response>(
    \\"/D.FooService/Foo1\\",
    foo1Request,
    config
  );
  return response;
}

export async function Foo2JSON(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await JSONrequest<Foo2Response>(
    \\"/D.FooService/Foo2\\",
    foo2Request,
    config
  );
  return response;
}

export async function Foo3JSON(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await JSONrequest<Foo3Response>(
    \\"/D.FooService/Foo3\\",
    foo3Request,
    config
  );
  return response;
}

export async function Foo4JSON(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await JSONrequest<Foo4Response>(
    \\"/D.FooService/Foo4\\",
    foo4Request,
    config
  );
  return response;
}

export async function Foo5JSON(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await JSONrequest<Foo5Response>(
    \\"/D.FooService/Foo5\\",
    foo5Request,
    config
  );
  return response;
}

//========================================//
//           FooService Service           //
//========================================//

export interface FooServiceService<Context = unknown> {
  /**
   * Login via credentials
   */
  Foo1: (
    foo1Request: Foo1Request,
    context: Context
  ) => Promise<Foo1Response> | Foo1Response;
  Foo2: (
    foo2Request: Foo2Request,
    context: Context
  ) => Promise<Foo2Response> | Foo2Response;
  Foo3: (
    foo3Request: Foo3Request,
    context: Context
  ) => Promise<Foo3Response> | Foo3Response;
  Foo4: (
    foo4Request: Foo4Request,
    context: Context
  ) => Promise<Foo4Response> | Foo4Response;
  Foo5: (
    foo5Request: Foo5Request,
    context: Context
  ) => Promise<Foo5Response> | Foo5Response;
}

export function createFooServiceHandler<Context>(
  service: FooServiceService<Context>
): ServiceHandler<Context> {
  return {
    path: \\"D.FooService\\",
    methods: {
      Foo1: createMethodHandler({
        handler: service.Foo1,
        encode: Foo1Response.encode,
        decode: Foo1Request.decode,
      }),
      Foo2: createMethodHandler({
        handler: service.Foo2,
        encode: Foo2Response.encode,
        decode: Foo2Request.decode,
      }),
      Foo3: createMethodHandler({
        handler: service.Foo3,
        encode: Foo3Response.encode,
        decode: Foo3Request.decode,
      }),
      Foo4: createMethodHandler({
        handler: service.Foo4,
        encode: Foo4Response.encode,
        decode: Foo4Request.decode,
      }),
      Foo5: createMethodHandler({
        handler: service.Foo5,
        encode: Foo5Response.encode,
        decode: Foo5Request.decode,
      }),
    },
  };
}

//========================================//
//                 Types                  //
//========================================//

export interface Foo1Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo1Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Foo1Request = {
  writeMessage: function (msg: Foo1Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Request: Foo1Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Request.writeMessage(foo1Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Request.readMessage(message, reader);
    return message as Foo1Request;
  },

  defaultValue: function (): Foo1Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo1Response = {
  writeMessage: function (msg: Foo1Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Response: Foo1Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Response.writeMessage(foo1Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Response.readMessage(message, reader);
    return message as Foo1Response;
  },

  defaultValue: function (): Foo1Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Request = {
  writeMessage: function (msg: Foo2Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Request: Foo2Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Request.writeMessage(foo2Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Request.readMessage(message, reader);
    return message as Foo2Request;
  },

  defaultValue: function (): Foo2Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Response = {
  writeMessage: function (msg: Foo2Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Response: Foo2Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Response.writeMessage(foo2Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Response.readMessage(message, reader);
    return message as Foo2Response;
  },

  defaultValue: function (): Foo2Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Request = {
  writeMessage: function (msg: Foo3Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Request: Foo3Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Request.writeMessage(foo3Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Request.readMessage(message, reader);
    return message as Foo3Request;
  },

  defaultValue: function (): Foo3Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Response = {
  writeMessage: function (msg: Foo3Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Response: Foo3Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Response.writeMessage(foo3Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Response.readMessage(message, reader);
    return message as Foo3Response;
  },

  defaultValue: function (): Foo3Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Request = {
  writeMessage: function (msg: Foo4Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Request: Foo4Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Request.writeMessage(foo4Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Request.readMessage(message, reader);
    return message as Foo4Request;
  },

  defaultValue: function (): Foo4Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Response = {
  writeMessage: function (msg: Foo4Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Response: Foo4Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Response.writeMessage(foo4Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Response.readMessage(message, reader);
    return message as Foo4Response;
  },

  defaultValue: function (): Foo4Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Request = {
  writeMessage: function (msg: Foo5Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Request: Foo5Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Request.writeMessage(foo5Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Request.readMessage(message, reader);
    return message as Foo5Request;
  },

  defaultValue: function (): Foo5Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Response = {
  writeMessage: function (msg: Foo5Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Response: Foo5Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Response.writeMessage(foo5Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Response.readMessage(message, reader);
    return message as Foo5Response;
  },

  defaultValue: function (): Foo5Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};
"
`;

exports[`TwirpScript Compiler generates src/10/multi-service.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 10/multi-service.proto
import type {
  ByteSource,
  ClientConfiguration,
  ServiceHandler,
} from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  createMethodHandler,
} from \\"twirpscript\\";

//========================================//
//      CheckService Protobuf Client      //
//========================================//

export async function Info(
  infoRequest: InfoRequest,
  config?: ClientConfiguration
): Promise<InfoResponse> {
  const response = await PBrequest(
    \\"/api.v1.CheckService/Info\\",
    InfoRequest.encode(infoRequest),
    config
  );
  return InfoResponse.decode(response);
}

export async function DoStuff(
  doStuffRequest: DoStuffRequest,
  config?: ClientConfiguration
): Promise<DoStuffResponse> {
  const response = await PBrequest(
    \\"/api.v1.CheckService/DoStuff\\",
    DoStuffRequest.encode(doStuffRequest),
    config
  );
  return DoStuffResponse.decode(response);
}

//========================================//
//  VerificationService Protobuf Client   //
//========================================//

export async function Verify(
  verifyRequest: VerifyRequest,
  config?: ClientConfiguration
): Promise<VerifyResponse> {
  const response = await PBrequest(
    \\"/api.v1.VerificationService/Verify\\",
    VerifyRequest.encode(verifyRequest),
    config
  );
  return VerifyResponse.decode(response);
}

//========================================//
//        CheckService JSON Client        //
//========================================//

export async function InfoJSON(
  infoRequest: InfoRequest,
  config?: ClientConfiguration
): Promise<InfoResponse> {
  const response = await JSONrequest<InfoResponse>(
    \\"/api.v1.CheckService/Info\\",
    infoRequest,
    config
  );
  return response;
}

export async function DoStuffJSON(
  doStuffRequest: DoStuffRequest,
  config?: ClientConfiguration
): Promise<DoStuffResponse> {
  const response = await JSONrequest<DoStuffResponse>(
    \\"/api.v1.CheckService/DoStuff\\",
    doStuffRequest,
    config
  );
  return response;
}

//========================================//
//    VerificationService JSON Client     //
//========================================//

export async function VerifyJSON(
  verifyRequest: VerifyRequest,
  config?: ClientConfiguration
): Promise<VerifyResponse> {
  const response = await JSONrequest<VerifyResponse>(
    \\"/api.v1.VerificationService/Verify\\",
    verifyRequest,
    config
  );
  return response;
}

//========================================//
//          CheckService Service          //
//========================================//

export interface CheckServiceService<Context = unknown> {
  Info: (
    infoRequest: InfoRequest,
    context: Context
  ) => Promise<InfoResponse> | InfoResponse;
  DoStuff: (
    doStuffRequest: DoStuffRequest,
    context: Context
  ) => Promise<DoStuffResponse> | DoStuffResponse;
}

export function createCheckServiceHandler<Context>(
  service: CheckServiceService<Context>
): ServiceHandler<Context> {
  return {
    path: \\"api.v1.CheckService\\",
    methods: {
      Info: createMethodHandler({
        handler: service.Info,
        encode: InfoResponse.encode,
        decode: InfoRequest.decode,
      }),
      DoStuff: createMethodHandler({
        handler: service.DoStuff,
        encode: DoStuffResponse.encode,
        decode: DoStuffRequest.decode,
      }),
    },
  };
}

//========================================//
//      VerificationService Service       //
//========================================//

export interface VerificationServiceService<Context = unknown> {
  Verify: (
    verifyRequest: VerifyRequest,
    context: Context
  ) => Promise<VerifyResponse> | VerifyResponse;
}

export function createVerificationServiceHandler<Context>(
  service: VerificationServiceService<Context>
): ServiceHandler<Context> {
  return {
    path: \\"api.v1.VerificationService\\",
    methods: {
      Verify: createMethodHandler({
        handler: service.Verify,
        encode: VerifyResponse.encode,
        decode: VerifyRequest.decode,
      }),
    },
  };
}

//========================================//
//                 Types                  //
//========================================//

export interface InfoRequest {}

export interface DoStuffRequest {}

export interface InfoResponse {
  hostname: string;
}

export interface DoStuffResponse {
  data: string;
}

export interface VerifyRequest {
  token: string;
  nonce: string;
}

export interface VerifyResponse {
  status: boolean;
  sign: string;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const InfoRequest = {
  writeMessage: function (msg: InfoRequest, writer: BinaryWriter): void {},

  encode: function (infoRequest: InfoRequest): Uint8Array {
    const writer = new BinaryWriter();
    InfoRequest.writeMessage(infoRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<InfoRequest>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): InfoRequest {
    const reader = new BinaryReader(bytes);
    const message = {};
    InfoRequest.readMessage(message, reader);
    return message as InfoRequest;
  },

  defaultValue: function (): InfoRequest {
    return {};
  },
};

export const DoStuffRequest = {
  writeMessage: function (msg: DoStuffRequest, writer: BinaryWriter): void {},

  encode: function (doStuffRequest: DoStuffRequest): Uint8Array {
    const writer = new BinaryWriter();
    DoStuffRequest.writeMessage(doStuffRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<DoStuffRequest>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): DoStuffRequest {
    const reader = new BinaryReader(bytes);
    const message = {};
    DoStuffRequest.readMessage(message, reader);
    return message as DoStuffRequest;
  },

  defaultValue: function (): DoStuffRequest {
    return {};
  },
};

export const InfoResponse = {
  writeMessage: function (msg: InfoResponse, writer: BinaryWriter): void {
    if (msg.hostname) {
      writer.writeString(1, msg.hostname);
    }
  },

  encode: function (infoResponse: InfoResponse): Uint8Array {
    const writer = new BinaryWriter();
    InfoResponse.writeMessage(infoResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<InfoResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.hostname = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.hostname) {
      msg.hostname = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): InfoResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    InfoResponse.readMessage(message, reader);
    return message as InfoResponse;
  },

  defaultValue: function (): InfoResponse {
    return {
      hostname: \\"\\",
    };
  },
};

export const DoStuffResponse = {
  writeMessage: function (msg: DoStuffResponse, writer: BinaryWriter): void {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
  },

  encode: function (doStuffResponse: DoStuffResponse): Uint8Array {
    const writer = new BinaryWriter();
    DoStuffResponse.writeMessage(doStuffResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<DoStuffResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): DoStuffResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    DoStuffResponse.readMessage(message, reader);
    return message as DoStuffResponse;
  },

  defaultValue: function (): DoStuffResponse {
    return {
      data: \\"\\",
    };
  },
};

export const VerifyRequest = {
  writeMessage: function (msg: VerifyRequest, writer: BinaryWriter): void {
    if (msg.token) {
      writer.writeString(1, msg.token);
    }
    if (msg.nonce) {
      writer.writeInt64String(2, msg.nonce);
    }
  },

  encode: function (verifyRequest: VerifyRequest): Uint8Array {
    const writer = new BinaryWriter();
    VerifyRequest.writeMessage(verifyRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<VerifyRequest>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.token = reader.readString();
          break;
        }
        case 2: {
          msg.nonce = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.token) {
      msg.token = \\"\\";
    }
    if (!msg.nonce) {
      msg.nonce = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): VerifyRequest {
    const reader = new BinaryReader(bytes);
    const message = {};
    VerifyRequest.readMessage(message, reader);
    return message as VerifyRequest;
  },

  defaultValue: function (): VerifyRequest {
    return {
      token: \\"\\",
      nonce: \\"\\",
    };
  },
};

export const VerifyResponse = {
  writeMessage: function (msg: VerifyResponse, writer: BinaryWriter): void {
    if (msg.status) {
      writer.writeBool(1, msg.status);
    }
    if (msg.sign) {
      writer.writeString(2, msg.sign);
    }
  },

  encode: function (verifyResponse: VerifyResponse): Uint8Array {
    const writer = new BinaryWriter();
    VerifyResponse.writeMessage(verifyResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<VerifyResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.status = reader.readBool();
          break;
        }
        case 2: {
          msg.sign = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.status) {
      msg.status = false;
    }
    if (!msg.sign) {
      msg.sign = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): VerifyResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    VerifyResponse.readMessage(message, reader);
    return message as VerifyResponse;
  },

  defaultValue: function (): VerifyResponse {
    return {
      status: false,
      sign: \\"\\",
    };
  },
};
"
`;

exports[`TwirpScript Compiler generates src/24/long.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 24/long.proto
import type {
  ByteSource,
  ClientConfiguration,
  ServiceHandler,
} from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  createMethodHandler,
} from \\"twirpscript\\";

//======================================================//
// VeryLongNameThatCausesAnErrorService Protobuf Client //
//======================================================//

export async function GetAll(
  getAllRequest: GetAllRequest,
  config?: ClientConfiguration
): Promise<GetAllResponse> {
  const response = await PBrequest(
    \\"/pkg.VeryLongNameThatCausesAnErrorService/GetAll\\",
    GetAllRequest.encode(getAllRequest),
    config
  );
  return GetAllResponse.decode(response);
}

//==================================================//
// VeryLongNameThatCausesAnErrorService JSON Client //
//==================================================//

export async function GetAllJSON(
  getAllRequest: GetAllRequest,
  config?: ClientConfiguration
): Promise<GetAllResponse> {
  const response = await JSONrequest<GetAllResponse>(
    \\"/pkg.VeryLongNameThatCausesAnErrorService/GetAll\\",
    getAllRequest,
    config
  );
  return response;
}

//==============================================//
// VeryLongNameThatCausesAnErrorService Service //
//==============================================//

export interface VeryLongNameThatCausesAnErrorServiceService<
  Context = unknown
> {
  GetAll: (
    getAllRequest: GetAllRequest,
    context: Context
  ) => Promise<GetAllResponse> | GetAllResponse;
}

export function createVeryLongNameThatCausesAnErrorServiceHandler<Context>(
  service: VeryLongNameThatCausesAnErrorServiceService<Context>
): ServiceHandler<Context> {
  return {
    path: \\"pkg.VeryLongNameThatCausesAnErrorService\\",
    methods: {
      GetAll: createMethodHandler({
        handler: service.GetAll,
        encode: GetAllResponse.encode,
        decode: GetAllRequest.decode,
      }),
    },
  };
}

//========================================//
//                 Types                  //
//========================================//

export interface VeryLongNameThatCausesAnError {
  id: number;
}

export interface GetAllRequest {}

export interface GetAllResponse {}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const VeryLongNameThatCausesAnError = {
  writeMessage: function (
    msg: VeryLongNameThatCausesAnError,
    writer: BinaryWriter
  ): void {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
  },

  encode: function (
    veryLongNameThatCausesAnError: VeryLongNameThatCausesAnError
  ): Uint8Array {
    const writer = new BinaryWriter();
    VeryLongNameThatCausesAnError.writeMessage(
      veryLongNameThatCausesAnError,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<VeryLongNameThatCausesAnError>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.id) {
      msg.id = 0;
    }
  },

  decode: function (bytes: ByteSource): VeryLongNameThatCausesAnError {
    const reader = new BinaryReader(bytes);
    const message = {};
    VeryLongNameThatCausesAnError.readMessage(message, reader);
    return message as VeryLongNameThatCausesAnError;
  },

  defaultValue: function (): VeryLongNameThatCausesAnError {
    return {
      id: 0,
    };
  },
};

export const GetAllRequest = {
  writeMessage: function (msg: GetAllRequest, writer: BinaryWriter): void {},

  encode: function (getAllRequest: GetAllRequest): Uint8Array {
    const writer = new BinaryWriter();
    GetAllRequest.writeMessage(getAllRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<GetAllRequest>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): GetAllRequest {
    const reader = new BinaryReader(bytes);
    const message = {};
    GetAllRequest.readMessage(message, reader);
    return message as GetAllRequest;
  },

  defaultValue: function (): GetAllRequest {
    return {};
  },
};

export const GetAllResponse = {
  writeMessage: function (msg: GetAllResponse, writer: BinaryWriter): void {},

  encode: function (getAllResponse: GetAllResponse): Uint8Array {
    const writer = new BinaryWriter();
    GetAllResponse.writeMessage(getAllResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<GetAllResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): GetAllResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    GetAllResponse.readMessage(message, reader);
    return message as GetAllResponse;
  },

  defaultValue: function (): GetAllResponse {
    return {};
  },
};
"
`;

exports[`TwirpScript Compiler generates src/34/address.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 34/address.proto
import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export interface GetUserResponse {
  user_id: string;
  addresses: GetUserResponse.AddressList;
}

export namespace GetUserResponse {
  export interface Address {
    id: string;
    value: AddressValue;
  }

  export interface AddressList {
    address: GetUserResponse.Address[];
    primary: GetUserResponse.Address;
  }
}

export interface AddressValue {
  address_line1?: string;
  address_line2?: string;
  country_code?: string;
  postcode?: string;
  state?: string;
  suburb?: string;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const GetUserResponse = {
  writeMessage: function (msg: GetUserResponse, writer: BinaryWriter): void {
    if (msg.user_id) {
      writer.writeString(1, msg.user_id);
    }
    if (msg.addresses) {
      writer.writeMessage(
        2,
        msg.addresses,
        GetUserResponse.AddressList.writeMessage
      );
    }
  },

  encode: function (getUserResponse: GetUserResponse): Uint8Array {
    const writer = new BinaryWriter();
    GetUserResponse.writeMessage(getUserResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<GetUserResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.user_id = reader.readString();
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, GetUserResponse.AddressList.readMessage);
          msg.addresses = message as GetUserResponse.AddressList;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.user_id) {
      msg.user_id = \\"\\";
    }
    if (!msg.addresses) {
      msg.addresses = GetUserResponse.AddressList.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): GetUserResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    GetUserResponse.readMessage(message, reader);
    return message as GetUserResponse;
  },

  defaultValue: function (): GetUserResponse {
    return {
      user_id: \\"\\",
      addresses: GetUserResponse.AddressList.defaultValue(),
    };
  },

  Address: {
    writeMessage: function (
      msg: GetUserResponse.Address,
      writer: BinaryWriter
    ): void {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, AddressValue.writeMessage);
      }
    },

    encode: function (address: GetUserResponse.Address): Uint8Array {
      const writer = new BinaryWriter();
      GetUserResponse.Address.writeMessage(address, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<GetUserResponse.Address>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, AddressValue.readMessage);
            msg.value = message as AddressValue;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.id) {
        msg.id = \\"\\";
      }
      if (!msg.value) {
        msg.value = AddressValue.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): GetUserResponse.Address {
      const reader = new BinaryReader(bytes);
      const message = {};
      GetUserResponse.Address.readMessage(message, reader);
      return message as GetUserResponse.Address;
    },

    defaultValue: function (): GetUserResponse.Address {
      return {
        id: \\"\\",
        value: AddressValue.defaultValue(),
      };
    },
  },

  AddressList: {
    writeMessage: function (
      msg: GetUserResponse.AddressList,
      writer: BinaryWriter
    ): void {
      if (msg.address.length > 0) {
        writer.writeRepeatedMessage(
          1,
          msg.address as any,
          GetUserResponse.Address.writeMessage
        );
      }
      if (msg.primary) {
        writer.writeMessage(
          2,
          msg.primary,
          GetUserResponse.Address.writeMessage
        );
      }
    },

    encode: function (addressList: GetUserResponse.AddressList): Uint8Array {
      const writer = new BinaryWriter();
      GetUserResponse.AddressList.writeMessage(addressList, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<GetUserResponse.AddressList>,
      reader: BinaryReader
    ): void {
      msg.address = [];
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const message = {};
            reader.readMessage(message, GetUserResponse.Address.readMessage);
            msg.address.push(message as GetUserResponse.Address);
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, GetUserResponse.Address.readMessage);
            msg.primary = message as GetUserResponse.Address;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.primary) {
        msg.primary = GetUserResponse.Address.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): GetUserResponse.AddressList {
      const reader = new BinaryReader(bytes);
      const message = {};
      GetUserResponse.AddressList.readMessage(message, reader);
      return message as GetUserResponse.AddressList;
    },

    defaultValue: function (): GetUserResponse.AddressList {
      return {
        address: [],
        primary: GetUserResponse.Address.defaultValue(),
      };
    },
  },
};

export const AddressValue = {
  writeMessage: function (msg: AddressValue, writer: BinaryWriter): void {
    if (msg.address_line1 != undefined) {
      writer.writeString(1, msg.address_line1);
    }
    if (msg.address_line2 != undefined) {
      writer.writeString(2, msg.address_line2);
    }
    if (msg.country_code != undefined) {
      writer.writeString(3, msg.country_code);
    }
    if (msg.postcode != undefined) {
      writer.writeString(4, msg.postcode);
    }
    if (msg.state != undefined) {
      writer.writeString(5, msg.state);
    }
    if (msg.suburb != undefined) {
      writer.writeString(6, msg.suburb);
    }
  },

  encode: function (addressValue: AddressValue): Uint8Array {
    const writer = new BinaryWriter();
    AddressValue.writeMessage(addressValue, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<AddressValue>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.address_line1 = reader.readString();
          break;
        }
        case 2: {
          msg.address_line2 = reader.readString();
          break;
        }
        case 3: {
          msg.country_code = reader.readString();
          break;
        }
        case 4: {
          msg.postcode = reader.readString();
          break;
        }
        case 5: {
          msg.state = reader.readString();
          break;
        }
        case 6: {
          msg.suburb = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): AddressValue {
    const reader = new BinaryReader(bytes);
    const message = {};
    AddressValue.readMessage(message, reader);
    return message as AddressValue;
  },

  defaultValue: function (): AddressValue {
    return {};
  },
};
"
`;

exports[`TwirpScript Compiler generates src/google/protobuf/unittest_import.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto
import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = typeof ImportEnum[keyof typeof ImportEnum];

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap =
  typeof ImportEnumForMap[keyof typeof ImportEnumForMap];

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: 7,
  IMPORT_BAR: 8,
  IMPORT_BAZ: 9,
} as const;

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 } as const;

export const ImportMessage = {
  writeMessage: function (msg: ImportMessage, writer: BinaryWriter): void {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
  },

  encode: function (importMessage: ImportMessage): Uint8Array {
    const writer = new BinaryWriter();
    ImportMessage.writeMessage(importMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<ImportMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.d) {
      msg.d = 0;
    }
  },

  decode: function (bytes: ByteSource): ImportMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    ImportMessage.readMessage(message, reader);
    return message as ImportMessage;
  },

  defaultValue: function (): ImportMessage {
    return {
      d: 0,
    };
  },
};
"
`;

exports[`TwirpScript Compiler generates src/google/protobuf/unittest_import_public.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto
import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export interface PublicImportMessage {
  e: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  writeMessage: function (
    msg: PublicImportMessage,
    writer: BinaryWriter
  ): void {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
  },

  encode: function (publicImportMessage: PublicImportMessage): Uint8Array {
    const writer = new BinaryWriter();
    PublicImportMessage.writeMessage(publicImportMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<PublicImportMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.e) {
      msg.e = 0;
    }
  },

  decode: function (bytes: ByteSource): PublicImportMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    PublicImportMessage.readMessage(message, reader);
    return message as PublicImportMessage;
  },

  defaultValue: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },
};
"
`;

exports[`TwirpScript Compiler generates src/google/protobuf/unittest_proto3.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto
import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optional_int32: number;
  optional_int64: string;
  optional_uint32: number;
  optional_uint64: string;
  optional_sint32: number;
  optional_sint64: string;
  optional_fixed32: number;
  optional_fixed64: string;
  optional_sfixed32: number;
  optional_sfixed64: string;
  optional_float: number;
  optional_double: number;
  optional_bool: boolean;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_nested_message: TestAllTypes.NestedMessage;
  optional_foreign_message: ForeignMessage;
  optional_import_message: ImportMessage;
  optional_nested_enum: TestAllTypes.NestedEnum;
  optional_foreign_enum: ForeignEnum;
  optional_string_piece: string;
  optional_cord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optional_public_import_message: PublicImportMessage;
  optional_lazy_message: TestAllTypes.NestedMessage;
  optional_lazy_import_message: ImportMessage;
  /**
   * Repeated
   */
  repeated_int32: number[];
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_string: string[];
  repeated_bytes: Uint8Array[];
  repeated_nested_message: TestAllTypes.NestedMessage[];
  repeated_foreign_message: ForeignMessage[];
  repeated_import_message: ImportMessage[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
  repeated_foreign_enum: ForeignEnum[];
  repeated_string_piece: string[];
  repeated_cord: string[];
  repeated_lazy_message: TestAllTypes.NestedMessage[];
  oneof_uint32?: number;
  oneof_nested_message?: TestAllTypes.NestedMessage;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packed_int32: number[];
  packed_int64: string[];
  packed_uint32: number[];
  packed_uint64: string[];
  packed_sint32: number[];
  packed_sint64: string[];
  packed_fixed32: number[];
  packed_fixed64: string[];
  packed_sfixed32: number[];
  packed_sfixed64: string[];
  packed_float: number[];
  packed_double: number[];
  packed_bool: boolean[];
  packed_enum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeated_int32: number[];
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  foo_enum?: TestOneof2.NestedEnum;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestAllTypes = {
  writeMessage: function (msg: TestAllTypes, writer: BinaryWriter): void {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage.writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_lazy_import_message) {
      writer.writeMessage(
        115,
        msg.optional_lazy_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_int32.length > 0) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64.length > 0) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32.length > 0) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64.length > 0) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32.length > 0) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64.length > 0) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32.length > 0) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64.length > 0) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32.length > 0) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64.length > 0) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float.length > 0) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double.length > 0) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool.length > 0) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string.length > 0) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes.length > 0) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message.length > 0) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message as any,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_foreign_message.length > 0) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message as any,
        ForeignMessage.writeMessage
      );
    }
    if (msg.repeated_import_message.length > 0) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message as any,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_nested_enum.length > 0) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum.length > 0) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_string_piece.length > 0) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord.length > 0) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message.length > 0) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message as any,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
  },

  encode: function (testAllTypes: TestAllTypes): Uint8Array {
    const writer = new BinaryWriter();
    TestAllTypes.writeMessage(testAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestAllTypes>,
    reader: BinaryReader
  ): void {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_string = [];
    msg.repeated_bytes = [];
    msg.repeated_nested_message = [];
    msg.repeated_foreign_message = [];
    msg.repeated_import_message = [];
    msg.repeated_nested_enum = [];
    msg.repeated_foreign_enum = [];
    msg.repeated_string_piece = [];
    msg.repeated_cord = [];
    msg.repeated_lazy_message = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_nested_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 19: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_foreign_message = message as ForeignMessage;
          break;
        }
        case 20: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_import_message = message as ImportMessage;
          break;
        }
        case 21: {
          msg.optional_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          const message = {};
          reader.readMessage(message, PublicImportMessage.readMessage);
          msg.optional_public_import_message = message as PublicImportMessage;
          break;
        }
        case 27: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_lazy_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 115: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_lazy_import_message = message as ImportMessage;
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_nested_message.push(
            message as TestAllTypes.NestedMessage
          );
          break;
        }
        case 49: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.repeated_foreign_message.push(message as ForeignMessage);
          break;
        }
        case 50: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.repeated_import_message.push(message as ImportMessage);
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_lazy_message.push(message as TestAllTypes.NestedMessage);
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.oneof_nested_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.optional_int64) {
      msg.optional_int64 = \\"\\";
    }
    if (!msg.optional_uint32) {
      msg.optional_uint32 = 0;
    }
    if (!msg.optional_uint64) {
      msg.optional_uint64 = \\"\\";
    }
    if (!msg.optional_sint32) {
      msg.optional_sint32 = 0;
    }
    if (!msg.optional_sint64) {
      msg.optional_sint64 = \\"\\";
    }
    if (!msg.optional_fixed32) {
      msg.optional_fixed32 = 0;
    }
    if (!msg.optional_fixed64) {
      msg.optional_fixed64 = \\"\\";
    }
    if (!msg.optional_sfixed32) {
      msg.optional_sfixed32 = 0;
    }
    if (!msg.optional_sfixed64) {
      msg.optional_sfixed64 = \\"\\";
    }
    if (!msg.optional_float) {
      msg.optional_float = 0;
    }
    if (!msg.optional_double) {
      msg.optional_double = 0;
    }
    if (!msg.optional_bool) {
      msg.optional_bool = false;
    }
    if (!msg.optional_string) {
      msg.optional_string = \\"\\";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_foreign_message) {
      msg.optional_foreign_message = ForeignMessage.defaultValue();
    }
    if (!msg.optional_import_message) {
      msg.optional_import_message = ImportMessage.defaultValue();
    }
    if (!msg.optional_nested_enum) {
      msg.optional_nested_enum = 0;
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
    if (!msg.optional_string_piece) {
      msg.optional_string_piece = \\"\\";
    }
    if (!msg.optional_cord) {
      msg.optional_cord = \\"\\";
    }
    if (!msg.optional_public_import_message) {
      msg.optional_public_import_message = PublicImportMessage.defaultValue();
    }
    if (!msg.optional_lazy_message) {
      msg.optional_lazy_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_lazy_import_message) {
      msg.optional_lazy_import_message = ImportMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestAllTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllTypes.readMessage(message, reader);
    return message as TestAllTypes;
  },

  defaultValue: function (): TestAllTypes {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_foreign_message: ForeignMessage.defaultValue(),
      optional_import_message: ImportMessage.defaultValue(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.defaultValue(),
      optional_lazy_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_lazy_import_message: ImportMessage.defaultValue(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      oneof_nested_message: TestAllTypes.NestedMessage.defaultValue(),
    };
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    writeMessage: function (
      msg: TestAllTypes.NestedMessage,
      writer: BinaryWriter
    ): void {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (nestedMessage: TestAllTypes.NestedMessage): Uint8Array {
      const writer = new BinaryWriter();
      TestAllTypes.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.NestedMessage.readMessage(message, reader);
      return message as TestAllTypes.NestedMessage;
    },

    defaultValue: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },
  },
};

export const TestPackedTypes = {
  writeMessage: function (msg: TestPackedTypes, writer: BinaryWriter): void {
    if (msg.packed_int32.length > 0) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64.length > 0) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32.length > 0) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64.length > 0) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32.length > 0) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64.length > 0) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32.length > 0) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64.length > 0) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32.length > 0) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64.length > 0) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float.length > 0) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double.length > 0) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool.length > 0) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum.length > 0) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
  },

  encode: function (testPackedTypes: TestPackedTypes): Uint8Array {
    const writer = new BinaryWriter();
    TestPackedTypes.writeMessage(testPackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestPackedTypes>,
    reader: BinaryReader
  ): void {
    msg.packed_int32 = [];
    msg.packed_int64 = [];
    msg.packed_uint32 = [];
    msg.packed_uint64 = [];
    msg.packed_sint32 = [];
    msg.packed_sint64 = [];
    msg.packed_fixed32 = [];
    msg.packed_fixed64 = [];
    msg.packed_sfixed32 = [];
    msg.packed_sfixed64 = [];
    msg.packed_float = [];
    msg.packed_double = [];
    msg.packed_bool = [];
    msg.packed_enum = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestPackedTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedTypes.readMessage(message, reader);
    return message as TestPackedTypes;
  },

  defaultValue: function (): TestPackedTypes {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },
};

export const TestUnpackedTypes = {
  writeMessage: function (msg: TestUnpackedTypes, writer: BinaryWriter): void {
    if (msg.repeated_int32.length > 0) {
      writer.writeRepeatedInt32(1, msg.repeated_int32);
    }
    if (msg.repeated_int64.length > 0) {
      writer.writeRepeatedInt64String(2, msg.repeated_int64);
    }
    if (msg.repeated_uint32.length > 0) {
      writer.writeRepeatedUint32(3, msg.repeated_uint32);
    }
    if (msg.repeated_uint64.length > 0) {
      writer.writeRepeatedUint64String(4, msg.repeated_uint64);
    }
    if (msg.repeated_sint32.length > 0) {
      writer.writeRepeatedSint32(5, msg.repeated_sint32);
    }
    if (msg.repeated_sint64.length > 0) {
      writer.writeRepeatedSint64String(6, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32.length > 0) {
      writer.writeRepeatedFixed32(7, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64.length > 0) {
      writer.writeRepeatedFixed64String(8, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32.length > 0) {
      writer.writeRepeatedSfixed32(9, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64.length > 0) {
      writer.writeRepeatedSfixed64(10, msg.repeated_sfixed64);
    }
    if (msg.repeated_float.length > 0) {
      writer.writeRepeatedFloat(11, msg.repeated_float);
    }
    if (msg.repeated_double.length > 0) {
      writer.writeRepeatedDouble(12, msg.repeated_double);
    }
    if (msg.repeated_bool.length > 0) {
      writer.writeRepeatedBool(13, msg.repeated_bool);
    }
    if (msg.repeated_nested_enum.length > 0) {
      writer.writeRepeatedEnum(14, msg.repeated_nested_enum);
    }
  },

  encode: function (testUnpackedTypes: TestUnpackedTypes): Uint8Array {
    const writer = new BinaryWriter();
    TestUnpackedTypes.writeMessage(testUnpackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestUnpackedTypes>,
    reader: BinaryReader
  ): void {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_nested_enum = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestUnpackedTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedTypes.readMessage(message, reader);
    return message as TestUnpackedTypes;
  },

  defaultValue: function (): TestUnpackedTypes {
    return {
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_nested_enum: [],
    };
  },
};

export const NestedTestAllTypes = {
  writeMessage: function (msg: NestedTestAllTypes, writer: BinaryWriter): void {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes.writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes.writeMessage);
    }
  },

  encode: function (nestedTestAllTypes: NestedTestAllTypes): Uint8Array {
    const writer = new BinaryWriter();
    NestedTestAllTypes.writeMessage(nestedTestAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<NestedTestAllTypes>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.child = message as NestedTestAllTypes;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.payload = message as TestAllTypes;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.child) {
      msg.child = NestedTestAllTypes.defaultValue();
    }
    if (!msg.payload) {
      msg.payload = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): NestedTestAllTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    NestedTestAllTypes.readMessage(message, reader);
    return message as NestedTestAllTypes;
  },

  defaultValue: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.defaultValue(),
      payload: TestAllTypes.defaultValue(),
    };
  },
};

export const ForeignMessage = {
  writeMessage: function (msg: ForeignMessage, writer: BinaryWriter): void {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
  },

  encode: function (foreignMessage: ForeignMessage): Uint8Array {
    const writer = new BinaryWriter();
    ForeignMessage.writeMessage(foreignMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<ForeignMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.c) {
      msg.c = 0;
    }
  },

  decode: function (bytes: ByteSource): ForeignMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    ForeignMessage.readMessage(message, reader);
    return message as ForeignMessage;
  },

  defaultValue: function (): ForeignMessage {
    return {
      c: 0,
    };
  },
};

export const TestEmptyMessage = {
  writeMessage: function (msg: TestEmptyMessage, writer: BinaryWriter): void {},

  encode: function (testEmptyMessage: TestEmptyMessage): Uint8Array {
    const writer = new BinaryWriter();
    TestEmptyMessage.writeMessage(testEmptyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestEmptyMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestEmptyMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessage.readMessage(message, reader);
    return message as TestEmptyMessage;
  },

  defaultValue: function (): TestEmptyMessage {
    return {};
  },
};

export const TestMessageWithDummy = {
  writeMessage: function (
    msg: TestMessageWithDummy,
    writer: BinaryWriter
  ): void {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
  },

  encode: function (testMessageWithDummy: TestMessageWithDummy): Uint8Array {
    const writer = new BinaryWriter();
    TestMessageWithDummy.writeMessage(testMessageWithDummy, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMessageWithDummy>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.dummy) {
      msg.dummy = false;
    }
  },

  decode: function (bytes: ByteSource): TestMessageWithDummy {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMessageWithDummy.readMessage(message, reader);
    return message as TestMessageWithDummy;
  },

  defaultValue: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },
};

export const TestOneof2 = {
  writeMessage: function (msg: TestOneof2, writer: BinaryWriter): void {
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
  },

  encode: function (testOneof2: TestOneof2): Uint8Array {
    const writer = new BinaryWriter();
    TestOneof2.writeMessage(testOneof2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<TestOneof2>, reader: BinaryReader): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.foo_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestOneof2 {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof2.readMessage(message, reader);
    return message as TestOneof2;
  },

  defaultValue: function (): TestOneof2 {
    return {};
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 } as const,
};
"
`;
