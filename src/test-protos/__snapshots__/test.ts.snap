// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`TwirpScript Compiler generates JavaScript 1`] = `
Object {
  "array": Array [
    ,
    1,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    Array [
      Array [
        "google/protobuf/unittest_import_public.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (publicImportMessage) {
    return PublicImportMessage._writeMessage(
      publicImportMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes) {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_import.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = { IMPORT_FOO: 7, IMPORT_BAR: 8, IMPORT_BAZ: 9 };

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 };

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (importMessage) {
    return ImportMessage._writeMessage(
      importMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes) {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(fooRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(barRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(fooRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(barRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

export function createTestServiceHandler(service) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = { FOREIGN_FOO: 4, FOREIGN_BAR: 5, FOREIGN_BAZ: 6 };

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
};

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes) {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.initialize(),
      optional_foreign_message: ForeignMessage.initialize(),
      optional_import_message: ImportMessage.initialize(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_import_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.initialize(),
      optional_lazy_message: TestAllTypes.NestedMessage.initialize(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_import_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      default_int32: 0,
      default_int64: \\"\\",
      default_uint32: 0,
      default_uint64: \\"\\",
      default_sint32: 0,
      default_sint64: \\"\\",
      default_fixed32: 0,
      default_fixed64: \\"\\",
      default_sfixed32: 0,
      default_sfixed64: \\"\\",
      default_float: 0,
      default_double: 0,
      default_bool: false,
      default_string: \\"\\",
      default_bytes: new Uint8Array(),
      default_nested_enum: 0,
      default_foreign_enum: 0,
      default_import_enum: 0,
      default_string_piece: \\"\\",
      default_cord: \\"\\",
      oneof_nested_message: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_import_enum) {
      writer.writeEnum(23, msg.optional_import_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_import_enum?.length) {
      writer.writeRepeatedEnum(53, msg.repeated_import_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.default_int32) {
      writer.writeInt32(61, msg.default_int32);
    }
    if (msg.default_int64) {
      writer.writeInt64String(62, msg.default_int64);
    }
    if (msg.default_uint32) {
      writer.writeUint32(63, msg.default_uint32);
    }
    if (msg.default_uint64) {
      writer.writeUint64String(64, msg.default_uint64);
    }
    if (msg.default_sint32) {
      writer.writeSint32(65, msg.default_sint32);
    }
    if (msg.default_sint64) {
      writer.writeSint64String(66, msg.default_sint64);
    }
    if (msg.default_fixed32) {
      writer.writeFixed32(67, msg.default_fixed32);
    }
    if (msg.default_fixed64) {
      writer.writeFixed64String(68, msg.default_fixed64);
    }
    if (msg.default_sfixed32) {
      writer.writeSfixed32(69, msg.default_sfixed32);
    }
    if (msg.default_sfixed64) {
      writer.writeSfixed64(70, msg.default_sfixed64);
    }
    if (msg.default_float) {
      writer.writeFloat(71, msg.default_float);
    }
    if (msg.default_double) {
      writer.writeDouble(72, msg.default_double);
    }
    if (msg.default_bool) {
      writer.writeBool(73, msg.default_bool);
    }
    if (msg.default_string) {
      writer.writeString(74, msg.default_string);
    }
    if (msg.default_bytes) {
      writer.writeBytes(75, msg.default_bytes);
    }
    if (msg.default_nested_enum) {
      writer.writeEnum(81, msg.default_nested_enum);
    }
    if (msg.default_foreign_enum) {
      writer.writeEnum(82, msg.default_foreign_enum);
    }
    if (msg.default_import_enum) {
      writer.writeEnum(83, msg.default_import_enum);
    }
    if (msg.default_string_piece) {
      writer.writeString(84, msg.default_string_piece);
    }
    if (msg.default_cord) {
      writer.writeString(85, msg.default_cord);
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optional_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optional_foreign_message,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optional_import_message,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optional_nested_enum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum();
          break;
        }
        case 23: {
          msg.optional_import_enum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optional_public_import_message,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optional_lazy_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          msg.repeated_nested_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 49: {
          msg.repeated_foreign_message.push(
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            )
          );
          break;
        }
        case 50: {
          msg.repeated_import_message.push(
            reader.readMessage(
              ImportMessage.initialize(),
              ImportMessage._readMessage
            )
          );
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum());
          break;
        }
        case 53: {
          msg.repeated_import_enum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          msg.repeated_lazy_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 61: {
          msg.default_int32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.default_int64 = reader.readInt64String();
          break;
        }
        case 63: {
          msg.default_uint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.default_uint64 = reader.readUint64String();
          break;
        }
        case 65: {
          msg.default_sint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.default_sint64 = reader.readSint64();
          break;
        }
        case 67: {
          msg.default_fixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.default_fixed64 = reader.readFixed64String();
          break;
        }
        case 69: {
          msg.default_sfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.default_sfixed64 = reader.readSfixed64();
          break;
        }
        case 71: {
          msg.default_float = reader.readFloat();
          break;
        }
        case 72: {
          msg.default_double = reader.readDouble();
          break;
        }
        case 73: {
          msg.default_bool = reader.readBool();
          break;
        }
        case 74: {
          msg.default_string = reader.readString();
          break;
        }
        case 75: {
          msg.default_bytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.default_nested_enum = reader.readEnum();
          break;
        }
        case 82: {
          msg.default_foreign_enum = reader.readEnum();
          break;
        }
        case 83: {
          msg.default_import_enum = reader.readEnum();
          break;
        }
        case 84: {
          msg.default_string_piece = reader.readString();
          break;
        }
        case 85: {
          msg.default_cord = reader.readString();
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneof_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestAllTypes.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (repeatedGroup) {
      return TestAllTypes.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (nestedTestAllTypes) {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeated_child: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeated_child?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_child,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          msg.repeated_child.push(
            reader.readMessage(
              NestedTestAllTypes.initialize(),
              NestedTestAllTypes._readMessage
            )
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (testDeprecatedFields) {
    return TestDeprecatedFields._writeMessage(
      testDeprecatedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes) {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecated_int32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.deprecated_int32) {
      writer.writeInt32(1, msg.deprecated_int32);
    }
    if (msg.deprecated_int32_in_oneof != undefined) {
      writer.writeInt32(2, msg.deprecated_int32_in_oneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecated_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecated_int32_in_oneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */
  encode: function (testDeprecatedMessage) {
    return TestDeprecatedMessage._writeMessage(
      testDeprecatedMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */
  decode: function (bytes) {
    return TestDeprecatedMessage._readMessage(
      TestDeprecatedMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage) {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */
  encode: function (testReservedFields) {
    return TestReservedFields._writeMessage(
      testReservedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */
  decode: function (bytes) {
    return TestReservedFields._readMessage(
      TestReservedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */
  encode: function (testAllExtensions) {
    return TestAllExtensions._writeMessage(
      testAllExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestAllExtensions._readMessage(
      TestAllExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (optionalGroup_extension) {
    return OptionalGroup_extension._writeMessage(
      optionalGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (repeatedGroup_extension) {
    return RepeatedGroup_extension._writeMessage(
      repeatedGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (testGroup) {
    return TestGroup._writeMessage(
      testGroup,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes) {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_foreign_enum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optional_foreign_enum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestGroup.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */
  encode: function (testGroupExtension) {
    return TestGroupExtension._writeMessage(
      testGroupExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */
  decode: function (bytes) {
    return TestGroupExtension._readMessage(
      TestGroupExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */
  encode: function (testNestedExtension) {
    return TestNestedExtension._writeMessage(
      testNestedExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */
  decode: function (bytes) {
    return TestNestedExtension._readMessage(
      TestNestedExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (optionalGroup_extension) {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        optionalGroup_extension,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (bytes) {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (testChildExtension) {
    return TestChildExtension._writeMessage(
      testChildExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes) {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
      b: \\"\\",
      optional_extension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optional_extension) {
      writer.writeMessage(
        3,
        msg.optional_extension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optional_extension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (testRequired) {
    return TestRequired._writeMessage(
      testRequired,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes) {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (testRequiredForeign) {
    return TestRequiredForeign._writeMessage(
      testRequiredForeign,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_message: TestRequired.initialize(),
      repeated_message: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired._writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optional_message, TestRequired._readMessage);
          break;
        }
        case 2: {
          msg.repeated_message.push(
            reader.readMessage(
              TestRequired.initialize(),
              TestRequired._readMessage
            )
          );
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (testRequiredMessage) {
    return TestRequiredMessage._writeMessage(
      testRequiredMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_message: TestRequired.initialize(),
      repeated_message: [],
      required_message: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired._writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message,
        TestRequired._writeMessage
      );
    }
    if (msg.required_message) {
      writer.writeMessage(3, msg.required_message, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optional_message, TestRequired._readMessage);
          break;
        }
        case 2: {
          msg.repeated_message.push(
            reader.readMessage(
              TestRequired.initialize(),
              TestRequired._readMessage
            )
          );
          break;
        }
        case 3: {
          reader.readMessage(msg.required_message, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (testForeignNested) {
    return TestForeignNested._writeMessage(
      testForeignNested,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes) {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreign_nested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foreign_nested) {
      writer.writeMessage(
        1,
        msg.foreign_nested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreign_nested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (testEmptyMessage) {
    return TestEmptyMessage._writeMessage(
      testEmptyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEmptyMessage._readMessage(
      TestEmptyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (testEmptyMessageWithExtensions) {
    return TestEmptyMessageWithExtensions._writeMessage(
      testEmptyMessageWithExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestEmptyMessageWithExtensions._readMessage(
      TestEmptyMessageWithExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */
  encode: function (testPickleNestedMessage) {
    return TestPickleNestedMessage._writeMessage(
      testPickleNestedMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */
  decode: function (bytes) {
    return TestPickleNestedMessage._readMessage(
      TestPickleNestedMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (nestedNestedMessage) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          nestedNestedMessage,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (bytes) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */
  encode: function (testMultipleExtensionRanges) {
    return TestMultipleExtensionRanges._writeMessage(
      testMultipleExtensionRanges,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */
  decode: function (bytes) {
    return TestMultipleExtensionRanges._readMessage(
      TestMultipleExtensionRanges.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (testReallyLargeTagNumber) {
    return TestReallyLargeTagNumber._writeMessage(
      testReallyLargeTagNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes) {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (testRecursiveMessage) {
    return TestRecursiveMessage._writeMessage(
      testRecursiveMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (testMutualRecursionA) {
    return TestMutualRecursionA._writeMessage(
      testMutualRecursionA,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (subMessage) {
      return TestMutualRecursionA.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (subGroup) {
      return TestMutualRecursionA.SubGroup._writeMessage(
        subGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        sub_message: TestMutualRecursionA.SubMessage.initialize(),
        not_in_this_scc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.sub_message) {
        writer.writeMessage(
          3,
          msg.sub_message,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.not_in_this_scc) {
        writer.writeMessage(4, msg.not_in_this_scc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.sub_message,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.not_in_this_scc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (testMutualRecursionB) {
    return TestMutualRecursionB._writeMessage(
      testMutualRecursionB,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionA.initialize(),
      optional_int32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optional_int32) {
      writer.writeInt32(2, msg.optional_int32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (testIsInitialized) {
    return TestIsInitialized._writeMessage(
      testIsInitialized,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes) {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      sub_message: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sub_message) {
      writer.writeMessage(
        1,
        msg.sub_message,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.sub_message,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (subMessage) {
      return TestIsInitialized.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (bytes) {
      return TestIsInitialized.SubMessage._readMessage(
        TestIsInitialized.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (subGroup) {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          subGroup,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (bytes) {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (testDupFieldNumber) {
    return TestDupFieldNumber._writeMessage(
      testDupFieldNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes) {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (foo) {
      return TestDupFieldNumber.Foo._writeMessage(
        foo,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (bar) {
      return TestDupFieldNumber.Bar._writeMessage(
        bar,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (testEagerMessage) {
    return TestEagerMessage._writeMessage(
      testEagerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sub_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.sub_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (testLazyMessage) {
    return TestLazyMessage._writeMessage(
      testLazyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sub_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.sub_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (testNestedMessageHasBits) {
    return TestNestedMessageHasBits._writeMessage(
      testNestedMessageHasBits,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes) {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_nested_message:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_nested_message) {
      writer.writeMessage(
        1,
        msg.optional_nested_message,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optional_nested_message,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessage_repeated_int32: [],
        nestedmessage_repeated_foreignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.nestedmessage_repeated_int32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessage_repeated_int32);
      }
      if (msg.nestedmessage_repeated_foreignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessage_repeated_foreignmessage,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessage_repeated_int32.push(reader.readInt32());
            break;
          }
          case 2: {
            msg.nestedmessage_repeated_foreignmessage.push(
              reader.readMessage(
                ForeignMessage.initialize(),
                ForeignMessage._readMessage
              )
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (testCamelCaseFieldNames) {
    return TestCamelCaseFieldNames._writeMessage(
      testCamelCaseFieldNames,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes) {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum();
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum());
          break;
        }
        case 10: {
          msg.RepeatedMessageField.push(
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            )
          );
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (testFieldOrderings) {
    return TestFieldOrderings._writeMessage(
      testFieldOrderings,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes) {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      my_string: \\"\\",
      my_int: \\"\\",
      my_float: 0,
      optional_nested_message: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.my_string) {
      writer.writeString(11, msg.my_string);
    }
    if (msg.my_int) {
      writer.writeInt64String(1, msg.my_int);
    }
    if (msg.my_float) {
      writer.writeFloat(101, msg.my_float);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        200,
        msg.optional_nested_message,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.my_string = reader.readString();
          break;
        }
        case 1: {
          msg.my_int = reader.readInt64String();
          break;
        }
        case 101: {
          msg.my_float = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optional_nested_message,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestFieldOrderings.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: \\"\\",
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = reader.readInt64String();
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (testExtensionOrderings1) {
    return TestExtensionOrderings1._writeMessage(
      testExtensionOrderings1,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      my_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (testExtensionOrderings2) {
    return TestExtensionOrderings2._writeMessage(
      testExtensionOrderings2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      my_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (testExtensionOrderings3) {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        testExtensionOrderings3,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (bytes) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        my_string: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.my_string) {
        writer.writeString(1, msg.my_string);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.my_string = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (testExtremeDefaultValues) {
    return TestExtremeDefaultValues._writeMessage(
      testExtremeDefaultValues,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes) {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escaped_bytes: new Uint8Array(),
      large_uint32: 0,
      large_uint64: \\"\\",
      small_int32: 0,
      small_int64: \\"\\",
      really_small_int32: 0,
      really_small_int64: \\"\\",
      utf8_string: \\"\\",
      zero_float: 0,
      one_float: 0,
      small_float: 0,
      negative_one_float: 0,
      negative_float: 0,
      large_float: 0,
      small_negative_float: 0,
      inf_double: 0,
      neg_inf_double: 0,
      nan_double: 0,
      inf_float: 0,
      neg_inf_float: 0,
      nan_float: 0,
      cpp_trigraph: \\"\\",
      string_with_zero: \\"\\",
      bytes_with_zero: new Uint8Array(),
      string_piece_with_zero: \\"\\",
      cord_with_zero: \\"\\",
      replacement_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.escaped_bytes) {
      writer.writeBytes(1, msg.escaped_bytes);
    }
    if (msg.large_uint32) {
      writer.writeUint32(2, msg.large_uint32);
    }
    if (msg.large_uint64) {
      writer.writeUint64String(3, msg.large_uint64);
    }
    if (msg.small_int32) {
      writer.writeInt32(4, msg.small_int32);
    }
    if (msg.small_int64) {
      writer.writeInt64String(5, msg.small_int64);
    }
    if (msg.really_small_int32) {
      writer.writeInt32(21, msg.really_small_int32);
    }
    if (msg.really_small_int64) {
      writer.writeInt64String(22, msg.really_small_int64);
    }
    if (msg.utf8_string) {
      writer.writeString(6, msg.utf8_string);
    }
    if (msg.zero_float) {
      writer.writeFloat(7, msg.zero_float);
    }
    if (msg.one_float) {
      writer.writeFloat(8, msg.one_float);
    }
    if (msg.small_float) {
      writer.writeFloat(9, msg.small_float);
    }
    if (msg.negative_one_float) {
      writer.writeFloat(10, msg.negative_one_float);
    }
    if (msg.negative_float) {
      writer.writeFloat(11, msg.negative_float);
    }
    if (msg.large_float) {
      writer.writeFloat(12, msg.large_float);
    }
    if (msg.small_negative_float) {
      writer.writeFloat(13, msg.small_negative_float);
    }
    if (msg.inf_double) {
      writer.writeDouble(14, msg.inf_double);
    }
    if (msg.neg_inf_double) {
      writer.writeDouble(15, msg.neg_inf_double);
    }
    if (msg.nan_double) {
      writer.writeDouble(16, msg.nan_double);
    }
    if (msg.inf_float) {
      writer.writeFloat(17, msg.inf_float);
    }
    if (msg.neg_inf_float) {
      writer.writeFloat(18, msg.neg_inf_float);
    }
    if (msg.nan_float) {
      writer.writeFloat(19, msg.nan_float);
    }
    if (msg.cpp_trigraph) {
      writer.writeString(20, msg.cpp_trigraph);
    }
    if (msg.string_with_zero) {
      writer.writeString(23, msg.string_with_zero);
    }
    if (msg.bytes_with_zero) {
      writer.writeBytes(24, msg.bytes_with_zero);
    }
    if (msg.string_piece_with_zero) {
      writer.writeString(25, msg.string_piece_with_zero);
    }
    if (msg.cord_with_zero) {
      writer.writeString(26, msg.cord_with_zero);
    }
    if (msg.replacement_string) {
      writer.writeString(27, msg.replacement_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escaped_bytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.large_uint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.large_uint64 = reader.readUint64String();
          break;
        }
        case 4: {
          msg.small_int32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.small_int64 = reader.readInt64String();
          break;
        }
        case 21: {
          msg.really_small_int32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.really_small_int64 = reader.readInt64String();
          break;
        }
        case 6: {
          msg.utf8_string = reader.readString();
          break;
        }
        case 7: {
          msg.zero_float = reader.readFloat();
          break;
        }
        case 8: {
          msg.one_float = reader.readFloat();
          break;
        }
        case 9: {
          msg.small_float = reader.readFloat();
          break;
        }
        case 10: {
          msg.negative_one_float = reader.readFloat();
          break;
        }
        case 11: {
          msg.negative_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.large_float = reader.readFloat();
          break;
        }
        case 13: {
          msg.small_negative_float = reader.readFloat();
          break;
        }
        case 14: {
          msg.inf_double = reader.readDouble();
          break;
        }
        case 15: {
          msg.neg_inf_double = reader.readDouble();
          break;
        }
        case 16: {
          msg.nan_double = reader.readDouble();
          break;
        }
        case 17: {
          msg.inf_float = reader.readFloat();
          break;
        }
        case 18: {
          msg.neg_inf_float = reader.readFloat();
          break;
        }
        case 19: {
          msg.nan_float = reader.readFloat();
          break;
        }
        case 20: {
          msg.cpp_trigraph = reader.readString();
          break;
        }
        case 23: {
          msg.string_with_zero = reader.readString();
          break;
        }
        case 24: {
          msg.bytes_with_zero = reader.readBytes();
          break;
        }
        case 25: {
          msg.string_piece_with_zero = reader.readString();
          break;
        }
        case 26: {
          msg.cord_with_zero = reader.readString();
          break;
        }
        case 27: {
          msg.replacement_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (sparseEnumMessage) {
    return SparseEnumMessage._writeMessage(
      sparseEnumMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes) {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparse_enum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sparse_enum) {
      writer.writeEnum(1, msg.sparse_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparse_enum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (oneString) {
    return OneString._writeMessage(
      oneString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes) {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (moreString) {
    return MoreString._writeMessage(
      moreString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes) {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (oneBytes) {
    return OneBytes._writeMessage(
      oneBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes) {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (moreBytes) {
    return MoreBytes._writeMessage(
      moreBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes) {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (int32Message) {
    return Int32Message._writeMessage(
      int32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes) {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (uint32Message) {
    return Uint32Message._writeMessage(
      uint32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes) {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (int64Message) {
    return Int64Message._writeMessage(
      int64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes) {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (uint64Message) {
    return Uint64Message._writeMessage(
      uint64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes) {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (boolMessage) {
    return BoolMessage._writeMessage(
      boolMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes) {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (testOneof) {
    return TestOneof._writeMessage(
      testOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes) {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      foo_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.foo_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneof.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (testOneofBackwardsCompatible) {
    return TestOneofBackwardsCompatible._writeMessage(
      testOneofBackwardsCompatible,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes) {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      foo_int: 0,
      foo_string: \\"\\",
      foo_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foo_int) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.foo_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2) {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      foo_message: TestOneof2.NestedMessage.initialize(),
      foo_lazy_message: TestOneof2.NestedMessage.initialize(),
      baz_int: 0,
      baz_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_cord != undefined) {
      writer.writeString(3, msg.foo_cord);
    }
    if (msg.foo_string_piece != undefined) {
      writer.writeString(4, msg.foo_string_piece);
    }
    if (msg.foo_bytes != undefined) {
      writer.writeBytes(5, msg.foo_bytes);
    }
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        7,
        msg.foo_message,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.foo_lazy_message != undefined) {
      writer.writeMessage(
        11,
        msg.foo_lazy_message,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.bar_int != undefined) {
      writer.writeInt32(12, msg.bar_int);
    }
    if (msg.bar_string != undefined) {
      writer.writeString(13, msg.bar_string);
    }
    if (msg.bar_cord != undefined) {
      writer.writeString(14, msg.bar_cord);
    }
    if (msg.bar_string_piece != undefined) {
      writer.writeString(15, msg.bar_string_piece);
    }
    if (msg.bar_bytes != undefined) {
      writer.writeBytes(16, msg.bar_bytes);
    }
    if (msg.bar_enum != undefined) {
      writer.writeEnum(17, msg.bar_enum);
    }
    if (msg.bar_string_with_empty_default != undefined) {
      writer.writeString(20, msg.bar_string_with_empty_default);
    }
    if (msg.bar_cord_with_empty_default != undefined) {
      writer.writeString(21, msg.bar_cord_with_empty_default);
    }
    if (msg.bar_string_piece_with_empty_default != undefined) {
      writer.writeString(22, msg.bar_string_piece_with_empty_default);
    }
    if (msg.bar_bytes_with_empty_default != undefined) {
      writer.writeBytes(23, msg.bar_bytes_with_empty_default);
    }
    if (msg.baz_int) {
      writer.writeInt32(18, msg.baz_int);
    }
    if (msg.baz_string) {
      writer.writeString(19, msg.baz_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          msg.foo_cord = reader.readString();
          break;
        }
        case 4: {
          msg.foo_string_piece = reader.readString();
          break;
        }
        case 5: {
          msg.foo_bytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.foo_enum = reader.readEnum();
          break;
        }
        case 7: {
          reader.readMessage(
            msg.foo_message,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.foo_lazy_message,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.bar_int = reader.readInt32();
          break;
        }
        case 13: {
          msg.bar_string = reader.readString();
          break;
        }
        case 14: {
          msg.bar_cord = reader.readString();
          break;
        }
        case 15: {
          msg.bar_string_piece = reader.readString();
          break;
        }
        case 16: {
          msg.bar_bytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.bar_enum = reader.readEnum();
          break;
        }
        case 20: {
          msg.bar_string_with_empty_default = reader.readString();
          break;
        }
        case 21: {
          msg.bar_cord_with_empty_default = reader.readString();
          break;
        }
        case 22: {
          msg.bar_string_piece_with_empty_default = reader.readString();
          break;
        }
        case 23: {
          msg.bar_bytes_with_empty_default = reader.readBytes();
          break;
        }
        case 18: {
          msg.baz_int = reader.readInt32();
          break;
        }
        case 19: {
          msg.baz_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 },

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneof2.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestOneof2.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        qux_int: \\"\\",
        corge_int: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.qux_int) {
        writer.writeInt64String(1, msg.qux_int);
      }
      if (msg.corge_int?.length) {
        writer.writeRepeatedInt32(2, msg.corge_int);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.qux_int = reader.readInt64String();
            break;
          }
          case 2: {
            msg.corge_int.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (testRequiredOneof) {
    return TestRequiredOneof._writeMessage(
      testRequiredOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      foo_message: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        3,
        msg.foo_message,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.foo_message,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestRequiredOneof.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        required_double: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.required_double) {
        writer.writeDouble(1, msg.required_double);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.required_double = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes) {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes) {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpacked_int32: [],
      unpacked_int64: [],
      unpacked_uint32: [],
      unpacked_uint64: [],
      unpacked_sint32: [],
      unpacked_sint64: [],
      unpacked_fixed32: [],
      unpacked_fixed64: [],
      unpacked_sfixed32: [],
      unpacked_sfixed64: [],
      unpacked_float: [],
      unpacked_double: [],
      unpacked_bool: [],
      unpacked_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.unpacked_int32?.length) {
      writer.writeRepeatedInt32(90, msg.unpacked_int32);
    }
    if (msg.unpacked_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpacked_int64);
    }
    if (msg.unpacked_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpacked_uint32);
    }
    if (msg.unpacked_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpacked_uint64);
    }
    if (msg.unpacked_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpacked_sint32);
    }
    if (msg.unpacked_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpacked_sint64);
    }
    if (msg.unpacked_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpacked_fixed32);
    }
    if (msg.unpacked_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpacked_fixed64);
    }
    if (msg.unpacked_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpacked_sfixed32);
    }
    if (msg.unpacked_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpacked_sfixed64);
    }
    if (msg.unpacked_float?.length) {
      writer.writeRepeatedFloat(100, msg.unpacked_float);
    }
    if (msg.unpacked_double?.length) {
      writer.writeRepeatedDouble(101, msg.unpacked_double);
    }
    if (msg.unpacked_bool?.length) {
      writer.writeRepeatedBool(102, msg.unpacked_bool);
    }
    if (msg.unpacked_enum?.length) {
      writer.writeRepeatedEnum(103, msg.unpacked_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpacked_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpacked_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.unpacked_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpacked_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.unpacked_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpacked_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.unpacked_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpacked_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.unpacked_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpacked_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.unpacked_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpacked_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpacked_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpacked_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */
  encode: function (testPackedExtensions) {
    return TestPackedExtensions._writeMessage(
      testPackedExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestPackedExtensions._readMessage(
      TestPackedExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */
  encode: function (testUnpackedExtensions) {
    return TestUnpackedExtensions._writeMessage(
      testUnpackedExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedExtensions._readMessage(
      TestUnpackedExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (testDynamicExtensions) {
    return TestDynamicExtensions._writeMessage(
      testDynamicExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalar_extension: 0,
      enum_extension: 0,
      dynamic_enum_extension: 0,
      message_extension: ForeignMessage.initialize(),
      dynamic_message_extension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeated_extension: [],
      packed_extension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.scalar_extension) {
      writer.writeFixed32(2000, msg.scalar_extension);
    }
    if (msg.enum_extension) {
      writer.writeEnum(2001, msg.enum_extension);
    }
    if (msg.dynamic_enum_extension) {
      writer.writeEnum(2002, msg.dynamic_enum_extension);
    }
    if (msg.message_extension) {
      writer.writeMessage(
        2003,
        msg.message_extension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamic_message_extension) {
      writer.writeMessage(
        2004,
        msg.dynamic_message_extension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeated_extension?.length) {
      writer.writeRepeatedString(2005, msg.repeated_extension);
    }
    if (msg.packed_extension?.length) {
      writer.writeRepeatedSint32(2006, msg.packed_extension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalar_extension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enum_extension = reader.readEnum();
          break;
        }
        case 2002: {
          msg.dynamic_enum_extension = reader.readEnum();
          break;
        }
        case 2003: {
          reader.readMessage(
            msg.message_extension,
            ForeignMessage._readMessage
          );
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamic_message_extension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeated_extension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packed_extension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: { DYNAMIC_FOO: 2200, DYNAMIC_BAR: 2201, DYNAMIC_BAZ: 2202 },

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (dynamicMessageType) {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        dynamicMessageType,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (bytes) {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamic_field: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.dynamic_field) {
        writer.writeInt32(2100, msg.dynamic_field);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamic_field = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (testRepeatedScalarDifferentTagSizes) {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      testRepeatedScalarDifferentTagSizes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes) {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeated_fixed32: [],
      repeated_int32: [],
      repeated_fixed64: [],
      repeated_int64: [],
      repeated_float: [],
      repeated_uint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeated_fixed32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(13, msg.repeated_int32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeated_fixed64);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeated_int64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(262142, msg.repeated_float);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeated_uint64);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 2047: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 262142: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (testParsingMerge) {
    return TestParsingMerge._writeMessage(
      testParsingMerge,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes) {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      required_all_types: TestAllTypes.initialize(),
      optional_all_types: TestAllTypes.initialize(),
      repeated_all_types: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.required_all_types) {
      writer.writeMessage(
        1,
        msg.required_all_types,
        TestAllTypes._writeMessage
      );
    }
    if (msg.optional_all_types) {
      writer.writeMessage(
        2,
        msg.optional_all_types,
        TestAllTypes._writeMessage
      );
    }
    if (msg.repeated_all_types?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_all_types,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.required_all_types, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optional_all_types, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          msg.repeated_all_types.push(
            reader.readMessage(
              TestAllTypes.initialize(),
              TestAllTypes._readMessage
            )
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (repeatedFieldsGenerator) {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        repeatedFieldsGenerator,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(1, msg.field1, TestAllTypes._writeMessage);
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(2, msg.field2, TestAllTypes._writeMessage);
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(3, msg.field3, TestAllTypes._writeMessage);
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(1000, msg.ext1, TestAllTypes._writeMessage);
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(1001, msg.ext2, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.field1.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 2: {
            msg.field2.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 3: {
            msg.field3.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 1000: {
            msg.ext1.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 1001: {
            msg.ext2.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (group1) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          group1,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (group2) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          group2,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestParsingMerge.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optional_group_all_types: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.optional_group_all_types) {
        writer.writeMessage(
          11,
          msg.optional_group_all_types,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optional_group_all_types,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (repeatedGroup) {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeated_group_all_types: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.repeated_group_all_types) {
        writer.writeMessage(
          21,
          msg.repeated_group_all_types,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeated_group_all_types,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (testCommentInjectionMessage) {
    return TestCommentInjectionMessage._writeMessage(
      testCommentInjectionMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes) {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */
  encode: function (fooRequest) {
    return FooRequest._writeMessage(
      fooRequest,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */
  decode: function (bytes) {
    return FooRequest._readMessage(
      FooRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */
  encode: function (fooResponse) {
    return FooResponse._writeMessage(
      fooResponse,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */
  decode: function (bytes) {
    return FooResponse._readMessage(
      FooResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */
  encode: function (fooClientMessage) {
    return FooClientMessage._writeMessage(
      fooClientMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */
  decode: function (bytes) {
    return FooClientMessage._readMessage(
      FooClientMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */
  encode: function (fooServerMessage) {
    return FooServerMessage._writeMessage(
      fooServerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */
  decode: function (bytes) {
    return FooServerMessage._readMessage(
      FooServerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */
  encode: function (barRequest) {
    return BarRequest._writeMessage(
      barRequest,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */
  decode: function (bytes) {
    return BarRequest._readMessage(
      BarRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */
  encode: function (barResponse) {
    return BarResponse._writeMessage(
      barResponse,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */
  decode: function (bytes) {
    return BarResponse._readMessage(
      BarResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (testJsonName) {
    return TestJsonName._writeMessage(
      testJsonName,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes) {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      field_name1: 0,
      fieldName2: 0,
      FieldName3: 0,
      _field_name4: 0,
      FIELD_NAME5: 0,
      field_name6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.field_name1) {
      writer.writeInt32(1, msg.field_name1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg._field_name4) {
      writer.writeInt32(4, msg._field_name4);
    }
    if (msg.FIELD_NAME5) {
      writer.writeInt32(5, msg.FIELD_NAME5);
    }
    if (msg.field_name6) {
      writer.writeInt32(6, msg.field_name6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field_name1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg._field_name4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELD_NAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field_name6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (testHugeFieldNumbers) {
    return TestHugeFieldNumbers._writeMessage(
      testHugeFieldNumbers,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes) {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_int32: 0,
      fixed_32: 0,
      repeated_int32: [],
      packed_int32: [],
      optional_enum: 0,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_message: ForeignMessage.initialize(),
      string_string_map: {},
      oneof_test_all_types: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_int32) {
      writer.writeInt32(536870000, msg.optional_int32);
    }
    if (msg.fixed_32) {
      writer.writeInt32(536870001, msg.fixed_32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeated_int32);
    }
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packed_int32);
    }
    if (msg.optional_enum) {
      writer.writeEnum(536870004, msg.optional_enum);
    }
    if (msg.optional_string) {
      writer.writeString(536870005, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(536870006, msg.optional_bytes);
    }
    if (msg.optional_message) {
      writer.writeMessage(
        536870007,
        msg.optional_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.string_string_map) {
      for (const key in msg.string_string_map) {
        writer.writeMessage(536870010, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.string_string_map[key]);
        });
      }
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(536870011, msg.oneof_uint32);
    }
    if (msg.oneof_test_all_types != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneof_test_all_types,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(536870013, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(536870014, msg.oneof_bytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed_32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optional_enum = reader.readEnum();
          break;
        }
        case 536870005: {
          msg.optional_string = reader.readString();
          break;
        }
        case 536870006: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optional_message, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.string_string_map[key] = value;
            }
          });
          break;
        }
        case 536870011: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(
            msg.oneof_test_all_types,
            TestAllTypes._readMessage
          );
          break;
        }
        case 536870013: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        group_a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.group_a) {
        writer.writeInt32(536870009, msg.group_a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.group_a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (testExtensionInsideTable) {
    return TestExtensionInsideTable._writeMessage(
      testExtensionInsideTable,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (testExtensionRangeSerialize) {
    return TestExtensionRangeSerialize._writeMessage(
      testExtensionRangeSerialize,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      foo_one: 0,
      foo_two: 0,
      foo_three: 0,
      foo_four: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foo_one) {
      writer.writeInt32(1, msg.foo_one);
    }
    if (msg.foo_two) {
      writer.writeInt32(6, msg.foo_two);
    }
    if (msg.foo_three) {
      writer.writeInt32(7, msg.foo_three);
    }
    if (msg.foo_four) {
      writer.writeInt32(13, msg.foo_four);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_one = reader.readInt32();
          break;
        }
        case 6: {
          msg.foo_two = reader.readInt32();
          break;
        }
        case 7: {
          msg.foo_three = reader.readInt32();
          break;
        }
        case 13: {
          msg.foo_four = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/map_unittest.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = { MAP_ENUM_FOO: 0, MAP_ENUM_BAR: 1, MAP_ENUM_BAZ: 2 };

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (testMap) {
    return TestMap._writeMessage(testMap, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes) {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
      map_string_foreign_message: {},
      map_int32_all_types: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map_int32_int32[key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key);
          mapWriter.writeInt64String(2, msg.map_int64_int64[key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key);
          mapWriter.writeUint32(2, msg.map_uint32_uint32[key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64[key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key);
          mapWriter.writeSint32(2, msg.map_sint32_sint32[key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64[key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32[key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64[key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32[key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64[key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeFloat(2, msg.map_int32_float[key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeDouble(2, msg.map_int32_double[key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key);
          mapWriter.writeBool(2, msg.map_bool_bool[key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.map_string_string[key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeBytes(2, msg.map_int32_bytes[key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeEnum(2, msg.map_int32_enum[key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message[key]);
        });
      }
    }
    if (msg.map_string_foreign_message) {
      for (const key in msg.map_string_foreign_message) {
        writer.writeMessage(18, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeMessage(2, msg.map_string_foreign_message[key]);
        });
      }
    }
    if (msg.map_int32_all_types) {
      for (const key in msg.map_int32_all_types) {
        writer.writeMessage(19, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_all_types[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int64_int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint32_uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint64_uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint32_sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint64_sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed32_fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed64_fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed32_sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed64_sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.map_bool_bool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.map_string_string[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_foreign_message[key] = value;
            }
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_string_foreign_message[key] = value;
            }
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_all_types[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (testMapSubmessage) {
    return TestMapSubmessage._writeMessage(
      testMapSubmessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes) {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      test_map: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.test_map) {
      writer.writeMessage(1, msg.test_map, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.test_map, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (testMessageMap) {
    return TestMessageMap._writeMessage(
      testMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map_int32_message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map_int32_message) {
      for (const key in msg.map_int32_message) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_message[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (testSameTypeMap) {
    return TestSameTypeMap._writeMessage(
      testSameTypeMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes) {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map1) {
      for (const key in msg.map1) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map1[key]);
        });
      }
    }
    if (msg.map2) {
      for (const key in msg.map2) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map2[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map1[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map2[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (testRequiredMessageMap) {
    return TestRequiredMessageMap._writeMessage(
      testRequiredMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map_field: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map_field) {
      for (const key in msg.map_field) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_field[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_field[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (testArenaMap) {
    return TestArenaMap._writeMessage(
      testArenaMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes) {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map_int32_int32[key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key);
          mapWriter.writeInt64String(2, msg.map_int64_int64[key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key);
          mapWriter.writeUint32(2, msg.map_uint32_uint32[key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64[key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key);
          mapWriter.writeSint32(2, msg.map_sint32_sint32[key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64[key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32[key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64[key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32[key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64[key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeFloat(2, msg.map_int32_float[key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeDouble(2, msg.map_int32_double[key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key);
          mapWriter.writeBool(2, msg.map_bool_bool[key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.map_string_string[key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeBytes(2, msg.map_int32_bytes[key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeEnum(2, msg.map_int32_enum[key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int64_int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint32_uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint64_uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint32_sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint64_sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed32_fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed64_fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed32_sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed64_sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.map_bool_bool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.map_string_string[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_foreign_message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (messageContainingMapCalledEntry) {
    return MessageContainingMapCalledEntry._writeMessage(
      messageContainingMapCalledEntry,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes) {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.entry) {
      for (const key in msg.entry) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.entry[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.entry[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (testRecursiveMapMessage) {
    return TestRecursiveMapMessage._writeMessage(
      testRecursiveMapMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      for (const key in msg.a) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeMessage(2, msg.a[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.a[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_proto3.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes) {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.initialize(),
      optional_foreign_message: ForeignMessage.initialize(),
      optional_import_message: ImportMessage.initialize(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.initialize(),
      optional_lazy_message: TestAllTypes.NestedMessage.initialize(),
      optional_lazy_import_message: ImportMessage.initialize(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      oneof_nested_message: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optional_lazy_import_message) {
      writer.writeMessage(
        115,
        msg.optional_lazy_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optional_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optional_foreign_message,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optional_import_message,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optional_nested_enum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optional_public_import_message,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optional_lazy_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optional_lazy_import_message,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          msg.repeated_nested_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 49: {
          msg.repeated_foreign_message.push(
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            )
          );
          break;
        }
        case 50: {
          msg.repeated_import_message.push(
            reader.readMessage(
              ImportMessage.initialize(),
              ImportMessage._readMessage
            )
          );
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          msg.repeated_lazy_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneof_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes) {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes) {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_nested_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(1, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(11, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(12, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(13, msg.repeated_bool);
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(14, msg.repeated_nested_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeated_nested_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (nestedTestAllTypes) {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage) {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (testEmptyMessage) {
    return TestEmptyMessage._writeMessage(
      testEmptyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEmptyMessage._readMessage(
      TestEmptyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (testMessageWithDummy) {
    return TestMessageWithDummy._writeMessage(
      testMessageWithDummy,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes) {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function () {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2) {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.foo_enum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 },
};
",
      ],
    ],
  ],
  "arrayIndexOffset_": -1,
  "convertedPrimitiveFields_": Object {},
  "messageId_": undefined,
  "pivot_": 1.7976931348623157e+308,
  "wrappers_": Object {
    "15": Array [
      Object {
        "array": Array [
          "google/protobuf/unittest_import_public.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (publicImportMessage) {
    return PublicImportMessage._writeMessage(
      publicImportMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes) {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_import.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = { IMPORT_FOO: 7, IMPORT_BAR: 8, IMPORT_BAZ: 9 };

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 };

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (importMessage) {
    return ImportMessage._writeMessage(
      importMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes) {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(fooRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(barRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(fooRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(barRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

export function createTestServiceHandler(service) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = { FOREIGN_FOO: 4, FOREIGN_BAR: 5, FOREIGN_BAZ: 6 };

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
};

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes) {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.initialize(),
      optional_foreign_message: ForeignMessage.initialize(),
      optional_import_message: ImportMessage.initialize(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_import_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.initialize(),
      optional_lazy_message: TestAllTypes.NestedMessage.initialize(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_import_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      default_int32: 0,
      default_int64: \\"\\",
      default_uint32: 0,
      default_uint64: \\"\\",
      default_sint32: 0,
      default_sint64: \\"\\",
      default_fixed32: 0,
      default_fixed64: \\"\\",
      default_sfixed32: 0,
      default_sfixed64: \\"\\",
      default_float: 0,
      default_double: 0,
      default_bool: false,
      default_string: \\"\\",
      default_bytes: new Uint8Array(),
      default_nested_enum: 0,
      default_foreign_enum: 0,
      default_import_enum: 0,
      default_string_piece: \\"\\",
      default_cord: \\"\\",
      oneof_nested_message: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_import_enum) {
      writer.writeEnum(23, msg.optional_import_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_import_enum?.length) {
      writer.writeRepeatedEnum(53, msg.repeated_import_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.default_int32) {
      writer.writeInt32(61, msg.default_int32);
    }
    if (msg.default_int64) {
      writer.writeInt64String(62, msg.default_int64);
    }
    if (msg.default_uint32) {
      writer.writeUint32(63, msg.default_uint32);
    }
    if (msg.default_uint64) {
      writer.writeUint64String(64, msg.default_uint64);
    }
    if (msg.default_sint32) {
      writer.writeSint32(65, msg.default_sint32);
    }
    if (msg.default_sint64) {
      writer.writeSint64String(66, msg.default_sint64);
    }
    if (msg.default_fixed32) {
      writer.writeFixed32(67, msg.default_fixed32);
    }
    if (msg.default_fixed64) {
      writer.writeFixed64String(68, msg.default_fixed64);
    }
    if (msg.default_sfixed32) {
      writer.writeSfixed32(69, msg.default_sfixed32);
    }
    if (msg.default_sfixed64) {
      writer.writeSfixed64(70, msg.default_sfixed64);
    }
    if (msg.default_float) {
      writer.writeFloat(71, msg.default_float);
    }
    if (msg.default_double) {
      writer.writeDouble(72, msg.default_double);
    }
    if (msg.default_bool) {
      writer.writeBool(73, msg.default_bool);
    }
    if (msg.default_string) {
      writer.writeString(74, msg.default_string);
    }
    if (msg.default_bytes) {
      writer.writeBytes(75, msg.default_bytes);
    }
    if (msg.default_nested_enum) {
      writer.writeEnum(81, msg.default_nested_enum);
    }
    if (msg.default_foreign_enum) {
      writer.writeEnum(82, msg.default_foreign_enum);
    }
    if (msg.default_import_enum) {
      writer.writeEnum(83, msg.default_import_enum);
    }
    if (msg.default_string_piece) {
      writer.writeString(84, msg.default_string_piece);
    }
    if (msg.default_cord) {
      writer.writeString(85, msg.default_cord);
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optional_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optional_foreign_message,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optional_import_message,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optional_nested_enum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum();
          break;
        }
        case 23: {
          msg.optional_import_enum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optional_public_import_message,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optional_lazy_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          msg.repeated_nested_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 49: {
          msg.repeated_foreign_message.push(
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            )
          );
          break;
        }
        case 50: {
          msg.repeated_import_message.push(
            reader.readMessage(
              ImportMessage.initialize(),
              ImportMessage._readMessage
            )
          );
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum());
          break;
        }
        case 53: {
          msg.repeated_import_enum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          msg.repeated_lazy_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 61: {
          msg.default_int32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.default_int64 = reader.readInt64String();
          break;
        }
        case 63: {
          msg.default_uint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.default_uint64 = reader.readUint64String();
          break;
        }
        case 65: {
          msg.default_sint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.default_sint64 = reader.readSint64();
          break;
        }
        case 67: {
          msg.default_fixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.default_fixed64 = reader.readFixed64String();
          break;
        }
        case 69: {
          msg.default_sfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.default_sfixed64 = reader.readSfixed64();
          break;
        }
        case 71: {
          msg.default_float = reader.readFloat();
          break;
        }
        case 72: {
          msg.default_double = reader.readDouble();
          break;
        }
        case 73: {
          msg.default_bool = reader.readBool();
          break;
        }
        case 74: {
          msg.default_string = reader.readString();
          break;
        }
        case 75: {
          msg.default_bytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.default_nested_enum = reader.readEnum();
          break;
        }
        case 82: {
          msg.default_foreign_enum = reader.readEnum();
          break;
        }
        case 83: {
          msg.default_import_enum = reader.readEnum();
          break;
        }
        case 84: {
          msg.default_string_piece = reader.readString();
          break;
        }
        case 85: {
          msg.default_cord = reader.readString();
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneof_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestAllTypes.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (repeatedGroup) {
      return TestAllTypes.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (nestedTestAllTypes) {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeated_child: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeated_child?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_child,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          msg.repeated_child.push(
            reader.readMessage(
              NestedTestAllTypes.initialize(),
              NestedTestAllTypes._readMessage
            )
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (testDeprecatedFields) {
    return TestDeprecatedFields._writeMessage(
      testDeprecatedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes) {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecated_int32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.deprecated_int32) {
      writer.writeInt32(1, msg.deprecated_int32);
    }
    if (msg.deprecated_int32_in_oneof != undefined) {
      writer.writeInt32(2, msg.deprecated_int32_in_oneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecated_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecated_int32_in_oneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */
  encode: function (testDeprecatedMessage) {
    return TestDeprecatedMessage._writeMessage(
      testDeprecatedMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */
  decode: function (bytes) {
    return TestDeprecatedMessage._readMessage(
      TestDeprecatedMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage) {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */
  encode: function (testReservedFields) {
    return TestReservedFields._writeMessage(
      testReservedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */
  decode: function (bytes) {
    return TestReservedFields._readMessage(
      TestReservedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */
  encode: function (testAllExtensions) {
    return TestAllExtensions._writeMessage(
      testAllExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestAllExtensions._readMessage(
      TestAllExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (optionalGroup_extension) {
    return OptionalGroup_extension._writeMessage(
      optionalGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (repeatedGroup_extension) {
    return RepeatedGroup_extension._writeMessage(
      repeatedGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (testGroup) {
    return TestGroup._writeMessage(
      testGroup,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes) {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_foreign_enum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optional_foreign_enum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestGroup.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */
  encode: function (testGroupExtension) {
    return TestGroupExtension._writeMessage(
      testGroupExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */
  decode: function (bytes) {
    return TestGroupExtension._readMessage(
      TestGroupExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */
  encode: function (testNestedExtension) {
    return TestNestedExtension._writeMessage(
      testNestedExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */
  decode: function (bytes) {
    return TestNestedExtension._readMessage(
      TestNestedExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (optionalGroup_extension) {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        optionalGroup_extension,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (bytes) {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (testChildExtension) {
    return TestChildExtension._writeMessage(
      testChildExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes) {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
      b: \\"\\",
      optional_extension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optional_extension) {
      writer.writeMessage(
        3,
        msg.optional_extension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optional_extension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (testRequired) {
    return TestRequired._writeMessage(
      testRequired,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes) {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (testRequiredForeign) {
    return TestRequiredForeign._writeMessage(
      testRequiredForeign,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_message: TestRequired.initialize(),
      repeated_message: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired._writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optional_message, TestRequired._readMessage);
          break;
        }
        case 2: {
          msg.repeated_message.push(
            reader.readMessage(
              TestRequired.initialize(),
              TestRequired._readMessage
            )
          );
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (testRequiredMessage) {
    return TestRequiredMessage._writeMessage(
      testRequiredMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_message: TestRequired.initialize(),
      repeated_message: [],
      required_message: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired._writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message,
        TestRequired._writeMessage
      );
    }
    if (msg.required_message) {
      writer.writeMessage(3, msg.required_message, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optional_message, TestRequired._readMessage);
          break;
        }
        case 2: {
          msg.repeated_message.push(
            reader.readMessage(
              TestRequired.initialize(),
              TestRequired._readMessage
            )
          );
          break;
        }
        case 3: {
          reader.readMessage(msg.required_message, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (testForeignNested) {
    return TestForeignNested._writeMessage(
      testForeignNested,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes) {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreign_nested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foreign_nested) {
      writer.writeMessage(
        1,
        msg.foreign_nested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreign_nested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (testEmptyMessage) {
    return TestEmptyMessage._writeMessage(
      testEmptyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEmptyMessage._readMessage(
      TestEmptyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (testEmptyMessageWithExtensions) {
    return TestEmptyMessageWithExtensions._writeMessage(
      testEmptyMessageWithExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestEmptyMessageWithExtensions._readMessage(
      TestEmptyMessageWithExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */
  encode: function (testPickleNestedMessage) {
    return TestPickleNestedMessage._writeMessage(
      testPickleNestedMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */
  decode: function (bytes) {
    return TestPickleNestedMessage._readMessage(
      TestPickleNestedMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (nestedNestedMessage) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          nestedNestedMessage,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (bytes) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */
  encode: function (testMultipleExtensionRanges) {
    return TestMultipleExtensionRanges._writeMessage(
      testMultipleExtensionRanges,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */
  decode: function (bytes) {
    return TestMultipleExtensionRanges._readMessage(
      TestMultipleExtensionRanges.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (testReallyLargeTagNumber) {
    return TestReallyLargeTagNumber._writeMessage(
      testReallyLargeTagNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes) {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (testRecursiveMessage) {
    return TestRecursiveMessage._writeMessage(
      testRecursiveMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (testMutualRecursionA) {
    return TestMutualRecursionA._writeMessage(
      testMutualRecursionA,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (subMessage) {
      return TestMutualRecursionA.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (subGroup) {
      return TestMutualRecursionA.SubGroup._writeMessage(
        subGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        sub_message: TestMutualRecursionA.SubMessage.initialize(),
        not_in_this_scc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.sub_message) {
        writer.writeMessage(
          3,
          msg.sub_message,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.not_in_this_scc) {
        writer.writeMessage(4, msg.not_in_this_scc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.sub_message,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.not_in_this_scc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (testMutualRecursionB) {
    return TestMutualRecursionB._writeMessage(
      testMutualRecursionB,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionA.initialize(),
      optional_int32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optional_int32) {
      writer.writeInt32(2, msg.optional_int32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (testIsInitialized) {
    return TestIsInitialized._writeMessage(
      testIsInitialized,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes) {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      sub_message: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sub_message) {
      writer.writeMessage(
        1,
        msg.sub_message,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.sub_message,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (subMessage) {
      return TestIsInitialized.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (bytes) {
      return TestIsInitialized.SubMessage._readMessage(
        TestIsInitialized.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (subGroup) {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          subGroup,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (bytes) {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (testDupFieldNumber) {
    return TestDupFieldNumber._writeMessage(
      testDupFieldNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes) {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (foo) {
      return TestDupFieldNumber.Foo._writeMessage(
        foo,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (bar) {
      return TestDupFieldNumber.Bar._writeMessage(
        bar,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (testEagerMessage) {
    return TestEagerMessage._writeMessage(
      testEagerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sub_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.sub_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (testLazyMessage) {
    return TestLazyMessage._writeMessage(
      testLazyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sub_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.sub_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (testNestedMessageHasBits) {
    return TestNestedMessageHasBits._writeMessage(
      testNestedMessageHasBits,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes) {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_nested_message:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_nested_message) {
      writer.writeMessage(
        1,
        msg.optional_nested_message,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optional_nested_message,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessage_repeated_int32: [],
        nestedmessage_repeated_foreignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.nestedmessage_repeated_int32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessage_repeated_int32);
      }
      if (msg.nestedmessage_repeated_foreignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessage_repeated_foreignmessage,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessage_repeated_int32.push(reader.readInt32());
            break;
          }
          case 2: {
            msg.nestedmessage_repeated_foreignmessage.push(
              reader.readMessage(
                ForeignMessage.initialize(),
                ForeignMessage._readMessage
              )
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (testCamelCaseFieldNames) {
    return TestCamelCaseFieldNames._writeMessage(
      testCamelCaseFieldNames,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes) {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum();
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum());
          break;
        }
        case 10: {
          msg.RepeatedMessageField.push(
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            )
          );
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (testFieldOrderings) {
    return TestFieldOrderings._writeMessage(
      testFieldOrderings,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes) {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      my_string: \\"\\",
      my_int: \\"\\",
      my_float: 0,
      optional_nested_message: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.my_string) {
      writer.writeString(11, msg.my_string);
    }
    if (msg.my_int) {
      writer.writeInt64String(1, msg.my_int);
    }
    if (msg.my_float) {
      writer.writeFloat(101, msg.my_float);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        200,
        msg.optional_nested_message,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.my_string = reader.readString();
          break;
        }
        case 1: {
          msg.my_int = reader.readInt64String();
          break;
        }
        case 101: {
          msg.my_float = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optional_nested_message,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestFieldOrderings.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: \\"\\",
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = reader.readInt64String();
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (testExtensionOrderings1) {
    return TestExtensionOrderings1._writeMessage(
      testExtensionOrderings1,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      my_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (testExtensionOrderings2) {
    return TestExtensionOrderings2._writeMessage(
      testExtensionOrderings2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      my_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (testExtensionOrderings3) {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        testExtensionOrderings3,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (bytes) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        my_string: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.my_string) {
        writer.writeString(1, msg.my_string);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.my_string = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (testExtremeDefaultValues) {
    return TestExtremeDefaultValues._writeMessage(
      testExtremeDefaultValues,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes) {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escaped_bytes: new Uint8Array(),
      large_uint32: 0,
      large_uint64: \\"\\",
      small_int32: 0,
      small_int64: \\"\\",
      really_small_int32: 0,
      really_small_int64: \\"\\",
      utf8_string: \\"\\",
      zero_float: 0,
      one_float: 0,
      small_float: 0,
      negative_one_float: 0,
      negative_float: 0,
      large_float: 0,
      small_negative_float: 0,
      inf_double: 0,
      neg_inf_double: 0,
      nan_double: 0,
      inf_float: 0,
      neg_inf_float: 0,
      nan_float: 0,
      cpp_trigraph: \\"\\",
      string_with_zero: \\"\\",
      bytes_with_zero: new Uint8Array(),
      string_piece_with_zero: \\"\\",
      cord_with_zero: \\"\\",
      replacement_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.escaped_bytes) {
      writer.writeBytes(1, msg.escaped_bytes);
    }
    if (msg.large_uint32) {
      writer.writeUint32(2, msg.large_uint32);
    }
    if (msg.large_uint64) {
      writer.writeUint64String(3, msg.large_uint64);
    }
    if (msg.small_int32) {
      writer.writeInt32(4, msg.small_int32);
    }
    if (msg.small_int64) {
      writer.writeInt64String(5, msg.small_int64);
    }
    if (msg.really_small_int32) {
      writer.writeInt32(21, msg.really_small_int32);
    }
    if (msg.really_small_int64) {
      writer.writeInt64String(22, msg.really_small_int64);
    }
    if (msg.utf8_string) {
      writer.writeString(6, msg.utf8_string);
    }
    if (msg.zero_float) {
      writer.writeFloat(7, msg.zero_float);
    }
    if (msg.one_float) {
      writer.writeFloat(8, msg.one_float);
    }
    if (msg.small_float) {
      writer.writeFloat(9, msg.small_float);
    }
    if (msg.negative_one_float) {
      writer.writeFloat(10, msg.negative_one_float);
    }
    if (msg.negative_float) {
      writer.writeFloat(11, msg.negative_float);
    }
    if (msg.large_float) {
      writer.writeFloat(12, msg.large_float);
    }
    if (msg.small_negative_float) {
      writer.writeFloat(13, msg.small_negative_float);
    }
    if (msg.inf_double) {
      writer.writeDouble(14, msg.inf_double);
    }
    if (msg.neg_inf_double) {
      writer.writeDouble(15, msg.neg_inf_double);
    }
    if (msg.nan_double) {
      writer.writeDouble(16, msg.nan_double);
    }
    if (msg.inf_float) {
      writer.writeFloat(17, msg.inf_float);
    }
    if (msg.neg_inf_float) {
      writer.writeFloat(18, msg.neg_inf_float);
    }
    if (msg.nan_float) {
      writer.writeFloat(19, msg.nan_float);
    }
    if (msg.cpp_trigraph) {
      writer.writeString(20, msg.cpp_trigraph);
    }
    if (msg.string_with_zero) {
      writer.writeString(23, msg.string_with_zero);
    }
    if (msg.bytes_with_zero) {
      writer.writeBytes(24, msg.bytes_with_zero);
    }
    if (msg.string_piece_with_zero) {
      writer.writeString(25, msg.string_piece_with_zero);
    }
    if (msg.cord_with_zero) {
      writer.writeString(26, msg.cord_with_zero);
    }
    if (msg.replacement_string) {
      writer.writeString(27, msg.replacement_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escaped_bytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.large_uint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.large_uint64 = reader.readUint64String();
          break;
        }
        case 4: {
          msg.small_int32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.small_int64 = reader.readInt64String();
          break;
        }
        case 21: {
          msg.really_small_int32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.really_small_int64 = reader.readInt64String();
          break;
        }
        case 6: {
          msg.utf8_string = reader.readString();
          break;
        }
        case 7: {
          msg.zero_float = reader.readFloat();
          break;
        }
        case 8: {
          msg.one_float = reader.readFloat();
          break;
        }
        case 9: {
          msg.small_float = reader.readFloat();
          break;
        }
        case 10: {
          msg.negative_one_float = reader.readFloat();
          break;
        }
        case 11: {
          msg.negative_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.large_float = reader.readFloat();
          break;
        }
        case 13: {
          msg.small_negative_float = reader.readFloat();
          break;
        }
        case 14: {
          msg.inf_double = reader.readDouble();
          break;
        }
        case 15: {
          msg.neg_inf_double = reader.readDouble();
          break;
        }
        case 16: {
          msg.nan_double = reader.readDouble();
          break;
        }
        case 17: {
          msg.inf_float = reader.readFloat();
          break;
        }
        case 18: {
          msg.neg_inf_float = reader.readFloat();
          break;
        }
        case 19: {
          msg.nan_float = reader.readFloat();
          break;
        }
        case 20: {
          msg.cpp_trigraph = reader.readString();
          break;
        }
        case 23: {
          msg.string_with_zero = reader.readString();
          break;
        }
        case 24: {
          msg.bytes_with_zero = reader.readBytes();
          break;
        }
        case 25: {
          msg.string_piece_with_zero = reader.readString();
          break;
        }
        case 26: {
          msg.cord_with_zero = reader.readString();
          break;
        }
        case 27: {
          msg.replacement_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (sparseEnumMessage) {
    return SparseEnumMessage._writeMessage(
      sparseEnumMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes) {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparse_enum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sparse_enum) {
      writer.writeEnum(1, msg.sparse_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparse_enum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (oneString) {
    return OneString._writeMessage(
      oneString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes) {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (moreString) {
    return MoreString._writeMessage(
      moreString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes) {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (oneBytes) {
    return OneBytes._writeMessage(
      oneBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes) {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (moreBytes) {
    return MoreBytes._writeMessage(
      moreBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes) {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (int32Message) {
    return Int32Message._writeMessage(
      int32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes) {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (uint32Message) {
    return Uint32Message._writeMessage(
      uint32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes) {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (int64Message) {
    return Int64Message._writeMessage(
      int64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes) {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (uint64Message) {
    return Uint64Message._writeMessage(
      uint64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes) {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (boolMessage) {
    return BoolMessage._writeMessage(
      boolMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes) {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (testOneof) {
    return TestOneof._writeMessage(
      testOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes) {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      foo_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.foo_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneof.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (testOneofBackwardsCompatible) {
    return TestOneofBackwardsCompatible._writeMessage(
      testOneofBackwardsCompatible,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes) {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      foo_int: 0,
      foo_string: \\"\\",
      foo_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foo_int) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.foo_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2) {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      foo_message: TestOneof2.NestedMessage.initialize(),
      foo_lazy_message: TestOneof2.NestedMessage.initialize(),
      baz_int: 0,
      baz_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_cord != undefined) {
      writer.writeString(3, msg.foo_cord);
    }
    if (msg.foo_string_piece != undefined) {
      writer.writeString(4, msg.foo_string_piece);
    }
    if (msg.foo_bytes != undefined) {
      writer.writeBytes(5, msg.foo_bytes);
    }
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        7,
        msg.foo_message,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.foo_lazy_message != undefined) {
      writer.writeMessage(
        11,
        msg.foo_lazy_message,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.bar_int != undefined) {
      writer.writeInt32(12, msg.bar_int);
    }
    if (msg.bar_string != undefined) {
      writer.writeString(13, msg.bar_string);
    }
    if (msg.bar_cord != undefined) {
      writer.writeString(14, msg.bar_cord);
    }
    if (msg.bar_string_piece != undefined) {
      writer.writeString(15, msg.bar_string_piece);
    }
    if (msg.bar_bytes != undefined) {
      writer.writeBytes(16, msg.bar_bytes);
    }
    if (msg.bar_enum != undefined) {
      writer.writeEnum(17, msg.bar_enum);
    }
    if (msg.bar_string_with_empty_default != undefined) {
      writer.writeString(20, msg.bar_string_with_empty_default);
    }
    if (msg.bar_cord_with_empty_default != undefined) {
      writer.writeString(21, msg.bar_cord_with_empty_default);
    }
    if (msg.bar_string_piece_with_empty_default != undefined) {
      writer.writeString(22, msg.bar_string_piece_with_empty_default);
    }
    if (msg.bar_bytes_with_empty_default != undefined) {
      writer.writeBytes(23, msg.bar_bytes_with_empty_default);
    }
    if (msg.baz_int) {
      writer.writeInt32(18, msg.baz_int);
    }
    if (msg.baz_string) {
      writer.writeString(19, msg.baz_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          msg.foo_cord = reader.readString();
          break;
        }
        case 4: {
          msg.foo_string_piece = reader.readString();
          break;
        }
        case 5: {
          msg.foo_bytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.foo_enum = reader.readEnum();
          break;
        }
        case 7: {
          reader.readMessage(
            msg.foo_message,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.foo_lazy_message,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.bar_int = reader.readInt32();
          break;
        }
        case 13: {
          msg.bar_string = reader.readString();
          break;
        }
        case 14: {
          msg.bar_cord = reader.readString();
          break;
        }
        case 15: {
          msg.bar_string_piece = reader.readString();
          break;
        }
        case 16: {
          msg.bar_bytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.bar_enum = reader.readEnum();
          break;
        }
        case 20: {
          msg.bar_string_with_empty_default = reader.readString();
          break;
        }
        case 21: {
          msg.bar_cord_with_empty_default = reader.readString();
          break;
        }
        case 22: {
          msg.bar_string_piece_with_empty_default = reader.readString();
          break;
        }
        case 23: {
          msg.bar_bytes_with_empty_default = reader.readBytes();
          break;
        }
        case 18: {
          msg.baz_int = reader.readInt32();
          break;
        }
        case 19: {
          msg.baz_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 },

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneof2.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestOneof2.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        qux_int: \\"\\",
        corge_int: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.qux_int) {
        writer.writeInt64String(1, msg.qux_int);
      }
      if (msg.corge_int?.length) {
        writer.writeRepeatedInt32(2, msg.corge_int);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.qux_int = reader.readInt64String();
            break;
          }
          case 2: {
            msg.corge_int.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (testRequiredOneof) {
    return TestRequiredOneof._writeMessage(
      testRequiredOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      foo_message: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        3,
        msg.foo_message,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.foo_message,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestRequiredOneof.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        required_double: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.required_double) {
        writer.writeDouble(1, msg.required_double);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.required_double = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes) {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes) {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpacked_int32: [],
      unpacked_int64: [],
      unpacked_uint32: [],
      unpacked_uint64: [],
      unpacked_sint32: [],
      unpacked_sint64: [],
      unpacked_fixed32: [],
      unpacked_fixed64: [],
      unpacked_sfixed32: [],
      unpacked_sfixed64: [],
      unpacked_float: [],
      unpacked_double: [],
      unpacked_bool: [],
      unpacked_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.unpacked_int32?.length) {
      writer.writeRepeatedInt32(90, msg.unpacked_int32);
    }
    if (msg.unpacked_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpacked_int64);
    }
    if (msg.unpacked_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpacked_uint32);
    }
    if (msg.unpacked_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpacked_uint64);
    }
    if (msg.unpacked_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpacked_sint32);
    }
    if (msg.unpacked_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpacked_sint64);
    }
    if (msg.unpacked_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpacked_fixed32);
    }
    if (msg.unpacked_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpacked_fixed64);
    }
    if (msg.unpacked_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpacked_sfixed32);
    }
    if (msg.unpacked_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpacked_sfixed64);
    }
    if (msg.unpacked_float?.length) {
      writer.writeRepeatedFloat(100, msg.unpacked_float);
    }
    if (msg.unpacked_double?.length) {
      writer.writeRepeatedDouble(101, msg.unpacked_double);
    }
    if (msg.unpacked_bool?.length) {
      writer.writeRepeatedBool(102, msg.unpacked_bool);
    }
    if (msg.unpacked_enum?.length) {
      writer.writeRepeatedEnum(103, msg.unpacked_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpacked_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpacked_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.unpacked_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpacked_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.unpacked_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpacked_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.unpacked_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpacked_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.unpacked_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpacked_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.unpacked_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpacked_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpacked_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpacked_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */
  encode: function (testPackedExtensions) {
    return TestPackedExtensions._writeMessage(
      testPackedExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestPackedExtensions._readMessage(
      TestPackedExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */
  encode: function (testUnpackedExtensions) {
    return TestUnpackedExtensions._writeMessage(
      testUnpackedExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedExtensions._readMessage(
      TestUnpackedExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (testDynamicExtensions) {
    return TestDynamicExtensions._writeMessage(
      testDynamicExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalar_extension: 0,
      enum_extension: 0,
      dynamic_enum_extension: 0,
      message_extension: ForeignMessage.initialize(),
      dynamic_message_extension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeated_extension: [],
      packed_extension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.scalar_extension) {
      writer.writeFixed32(2000, msg.scalar_extension);
    }
    if (msg.enum_extension) {
      writer.writeEnum(2001, msg.enum_extension);
    }
    if (msg.dynamic_enum_extension) {
      writer.writeEnum(2002, msg.dynamic_enum_extension);
    }
    if (msg.message_extension) {
      writer.writeMessage(
        2003,
        msg.message_extension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamic_message_extension) {
      writer.writeMessage(
        2004,
        msg.dynamic_message_extension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeated_extension?.length) {
      writer.writeRepeatedString(2005, msg.repeated_extension);
    }
    if (msg.packed_extension?.length) {
      writer.writeRepeatedSint32(2006, msg.packed_extension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalar_extension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enum_extension = reader.readEnum();
          break;
        }
        case 2002: {
          msg.dynamic_enum_extension = reader.readEnum();
          break;
        }
        case 2003: {
          reader.readMessage(
            msg.message_extension,
            ForeignMessage._readMessage
          );
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamic_message_extension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeated_extension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packed_extension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: { DYNAMIC_FOO: 2200, DYNAMIC_BAR: 2201, DYNAMIC_BAZ: 2202 },

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (dynamicMessageType) {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        dynamicMessageType,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (bytes) {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamic_field: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.dynamic_field) {
        writer.writeInt32(2100, msg.dynamic_field);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamic_field = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (testRepeatedScalarDifferentTagSizes) {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      testRepeatedScalarDifferentTagSizes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes) {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeated_fixed32: [],
      repeated_int32: [],
      repeated_fixed64: [],
      repeated_int64: [],
      repeated_float: [],
      repeated_uint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeated_fixed32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(13, msg.repeated_int32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeated_fixed64);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeated_int64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(262142, msg.repeated_float);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeated_uint64);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 2047: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 262142: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (testParsingMerge) {
    return TestParsingMerge._writeMessage(
      testParsingMerge,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes) {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      required_all_types: TestAllTypes.initialize(),
      optional_all_types: TestAllTypes.initialize(),
      repeated_all_types: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.required_all_types) {
      writer.writeMessage(
        1,
        msg.required_all_types,
        TestAllTypes._writeMessage
      );
    }
    if (msg.optional_all_types) {
      writer.writeMessage(
        2,
        msg.optional_all_types,
        TestAllTypes._writeMessage
      );
    }
    if (msg.repeated_all_types?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_all_types,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.required_all_types, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optional_all_types, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          msg.repeated_all_types.push(
            reader.readMessage(
              TestAllTypes.initialize(),
              TestAllTypes._readMessage
            )
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (repeatedFieldsGenerator) {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        repeatedFieldsGenerator,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(1, msg.field1, TestAllTypes._writeMessage);
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(2, msg.field2, TestAllTypes._writeMessage);
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(3, msg.field3, TestAllTypes._writeMessage);
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(1000, msg.ext1, TestAllTypes._writeMessage);
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(1001, msg.ext2, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.field1.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 2: {
            msg.field2.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 3: {
            msg.field3.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 1000: {
            msg.ext1.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 1001: {
            msg.ext2.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (group1) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          group1,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (group2) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          group2,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestParsingMerge.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optional_group_all_types: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.optional_group_all_types) {
        writer.writeMessage(
          11,
          msg.optional_group_all_types,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optional_group_all_types,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (repeatedGroup) {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeated_group_all_types: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.repeated_group_all_types) {
        writer.writeMessage(
          21,
          msg.repeated_group_all_types,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeated_group_all_types,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (testCommentInjectionMessage) {
    return TestCommentInjectionMessage._writeMessage(
      testCommentInjectionMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes) {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */
  encode: function (fooRequest) {
    return FooRequest._writeMessage(
      fooRequest,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */
  decode: function (bytes) {
    return FooRequest._readMessage(
      FooRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */
  encode: function (fooResponse) {
    return FooResponse._writeMessage(
      fooResponse,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */
  decode: function (bytes) {
    return FooResponse._readMessage(
      FooResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */
  encode: function (fooClientMessage) {
    return FooClientMessage._writeMessage(
      fooClientMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */
  decode: function (bytes) {
    return FooClientMessage._readMessage(
      FooClientMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */
  encode: function (fooServerMessage) {
    return FooServerMessage._writeMessage(
      fooServerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */
  decode: function (bytes) {
    return FooServerMessage._readMessage(
      FooServerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */
  encode: function (barRequest) {
    return BarRequest._writeMessage(
      barRequest,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */
  decode: function (bytes) {
    return BarRequest._readMessage(
      BarRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */
  encode: function (barResponse) {
    return BarResponse._writeMessage(
      barResponse,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */
  decode: function (bytes) {
    return BarResponse._readMessage(
      BarResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (testJsonName) {
    return TestJsonName._writeMessage(
      testJsonName,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes) {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      field_name1: 0,
      fieldName2: 0,
      FieldName3: 0,
      _field_name4: 0,
      FIELD_NAME5: 0,
      field_name6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.field_name1) {
      writer.writeInt32(1, msg.field_name1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg._field_name4) {
      writer.writeInt32(4, msg._field_name4);
    }
    if (msg.FIELD_NAME5) {
      writer.writeInt32(5, msg.FIELD_NAME5);
    }
    if (msg.field_name6) {
      writer.writeInt32(6, msg.field_name6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field_name1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg._field_name4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELD_NAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field_name6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (testHugeFieldNumbers) {
    return TestHugeFieldNumbers._writeMessage(
      testHugeFieldNumbers,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes) {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_int32: 0,
      fixed_32: 0,
      repeated_int32: [],
      packed_int32: [],
      optional_enum: 0,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_message: ForeignMessage.initialize(),
      string_string_map: {},
      oneof_test_all_types: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_int32) {
      writer.writeInt32(536870000, msg.optional_int32);
    }
    if (msg.fixed_32) {
      writer.writeInt32(536870001, msg.fixed_32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeated_int32);
    }
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packed_int32);
    }
    if (msg.optional_enum) {
      writer.writeEnum(536870004, msg.optional_enum);
    }
    if (msg.optional_string) {
      writer.writeString(536870005, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(536870006, msg.optional_bytes);
    }
    if (msg.optional_message) {
      writer.writeMessage(
        536870007,
        msg.optional_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.string_string_map) {
      for (const key in msg.string_string_map) {
        writer.writeMessage(536870010, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.string_string_map[key]);
        });
      }
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(536870011, msg.oneof_uint32);
    }
    if (msg.oneof_test_all_types != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneof_test_all_types,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(536870013, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(536870014, msg.oneof_bytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed_32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optional_enum = reader.readEnum();
          break;
        }
        case 536870005: {
          msg.optional_string = reader.readString();
          break;
        }
        case 536870006: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optional_message, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.string_string_map[key] = value;
            }
          });
          break;
        }
        case 536870011: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(
            msg.oneof_test_all_types,
            TestAllTypes._readMessage
          );
          break;
        }
        case 536870013: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        group_a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.group_a) {
        writer.writeInt32(536870009, msg.group_a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.group_a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (testExtensionInsideTable) {
    return TestExtensionInsideTable._writeMessage(
      testExtensionInsideTable,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (testExtensionRangeSerialize) {
    return TestExtensionRangeSerialize._writeMessage(
      testExtensionRangeSerialize,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      foo_one: 0,
      foo_two: 0,
      foo_three: 0,
      foo_four: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foo_one) {
      writer.writeInt32(1, msg.foo_one);
    }
    if (msg.foo_two) {
      writer.writeInt32(6, msg.foo_two);
    }
    if (msg.foo_three) {
      writer.writeInt32(7, msg.foo_three);
    }
    if (msg.foo_four) {
      writer.writeInt32(13, msg.foo_four);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_one = reader.readInt32();
          break;
        }
        case 6: {
          msg.foo_two = reader.readInt32();
          break;
        }
        case 7: {
          msg.foo_three = reader.readInt32();
          break;
        }
        case 13: {
          msg.foo_four = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/map_unittest.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = { MAP_ENUM_FOO: 0, MAP_ENUM_BAR: 1, MAP_ENUM_BAZ: 2 };

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (testMap) {
    return TestMap._writeMessage(testMap, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes) {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
      map_string_foreign_message: {},
      map_int32_all_types: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map_int32_int32[key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key);
          mapWriter.writeInt64String(2, msg.map_int64_int64[key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key);
          mapWriter.writeUint32(2, msg.map_uint32_uint32[key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64[key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key);
          mapWriter.writeSint32(2, msg.map_sint32_sint32[key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64[key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32[key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64[key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32[key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64[key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeFloat(2, msg.map_int32_float[key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeDouble(2, msg.map_int32_double[key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key);
          mapWriter.writeBool(2, msg.map_bool_bool[key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.map_string_string[key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeBytes(2, msg.map_int32_bytes[key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeEnum(2, msg.map_int32_enum[key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message[key]);
        });
      }
    }
    if (msg.map_string_foreign_message) {
      for (const key in msg.map_string_foreign_message) {
        writer.writeMessage(18, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeMessage(2, msg.map_string_foreign_message[key]);
        });
      }
    }
    if (msg.map_int32_all_types) {
      for (const key in msg.map_int32_all_types) {
        writer.writeMessage(19, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_all_types[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int64_int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint32_uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint64_uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint32_sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint64_sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed32_fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed64_fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed32_sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed64_sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.map_bool_bool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.map_string_string[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_foreign_message[key] = value;
            }
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_string_foreign_message[key] = value;
            }
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_all_types[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (testMapSubmessage) {
    return TestMapSubmessage._writeMessage(
      testMapSubmessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes) {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      test_map: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.test_map) {
      writer.writeMessage(1, msg.test_map, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.test_map, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (testMessageMap) {
    return TestMessageMap._writeMessage(
      testMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map_int32_message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map_int32_message) {
      for (const key in msg.map_int32_message) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_message[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (testSameTypeMap) {
    return TestSameTypeMap._writeMessage(
      testSameTypeMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes) {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map1) {
      for (const key in msg.map1) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map1[key]);
        });
      }
    }
    if (msg.map2) {
      for (const key in msg.map2) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map2[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map1[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map2[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (testRequiredMessageMap) {
    return TestRequiredMessageMap._writeMessage(
      testRequiredMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map_field: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map_field) {
      for (const key in msg.map_field) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_field[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_field[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (testArenaMap) {
    return TestArenaMap._writeMessage(
      testArenaMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes) {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map_int32_int32[key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key);
          mapWriter.writeInt64String(2, msg.map_int64_int64[key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key);
          mapWriter.writeUint32(2, msg.map_uint32_uint32[key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64[key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key);
          mapWriter.writeSint32(2, msg.map_sint32_sint32[key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64[key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32[key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64[key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32[key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64[key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeFloat(2, msg.map_int32_float[key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeDouble(2, msg.map_int32_double[key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key);
          mapWriter.writeBool(2, msg.map_bool_bool[key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.map_string_string[key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeBytes(2, msg.map_int32_bytes[key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeEnum(2, msg.map_int32_enum[key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int64_int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint32_uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint64_uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint32_sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint64_sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed32_fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed64_fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed32_sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed64_sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.map_bool_bool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.map_string_string[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_foreign_message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (messageContainingMapCalledEntry) {
    return MessageContainingMapCalledEntry._writeMessage(
      messageContainingMapCalledEntry,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes) {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.entry) {
      for (const key in msg.entry) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.entry[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.entry[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (testRecursiveMapMessage) {
    return TestRecursiveMapMessage._writeMessage(
      testRecursiveMapMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      for (const key in msg.a) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeMessage(2, msg.a[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.a[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_proto3.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes) {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.initialize(),
      optional_foreign_message: ForeignMessage.initialize(),
      optional_import_message: ImportMessage.initialize(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.initialize(),
      optional_lazy_message: TestAllTypes.NestedMessage.initialize(),
      optional_lazy_import_message: ImportMessage.initialize(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      oneof_nested_message: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optional_lazy_import_message) {
      writer.writeMessage(
        115,
        msg.optional_lazy_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optional_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optional_foreign_message,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optional_import_message,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optional_nested_enum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optional_public_import_message,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optional_lazy_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optional_lazy_import_message,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          msg.repeated_nested_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 49: {
          msg.repeated_foreign_message.push(
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            )
          );
          break;
        }
        case 50: {
          msg.repeated_import_message.push(
            reader.readMessage(
              ImportMessage.initialize(),
              ImportMessage._readMessage
            )
          );
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          msg.repeated_lazy_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneof_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes) {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes) {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_nested_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(1, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(11, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(12, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(13, msg.repeated_bool);
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(14, msg.repeated_nested_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeated_nested_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (nestedTestAllTypes) {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage) {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (testEmptyMessage) {
    return TestEmptyMessage._writeMessage(
      testEmptyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEmptyMessage._readMessage(
      TestEmptyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (testMessageWithDummy) {
    return TestMessageWithDummy._writeMessage(
      testMessageWithDummy,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes) {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function () {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2) {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.foo_enum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
    ],
  },
}
`;

exports[`TwirpScript Compiler generates TypeScript 1`] = `
Object {
  "array": Array [
    ,
    1,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    Array [
      Array [
        "google/protobuf/unittest_import_public.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export interface PublicImportMessage {
  e: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (
    publicImportMessage: Partial<PublicImportMessage>
  ): Uint8Array {
    return PublicImportMessage._writeMessage(
      publicImportMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): PublicImportMessage {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PublicImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PublicImportMessage,
    reader: BinaryReader
  ): PublicImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_import.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = typeof ImportEnum[keyof typeof ImportEnum];

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap =
  typeof ImportEnumForMap[keyof typeof ImportEnumForMap];

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: 7,
  IMPORT_BAR: 8,
  IMPORT_BAZ: 9,
} as const;

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 } as const;

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (importMessage: Partial<ImportMessage>): Uint8Array {
    return ImportMessage._writeMessage(
      importMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ImportMessage {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ImportMessage,
    reader: BinaryReader
  ): ImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await JSONrequest<FooResponse>(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await JSONrequest<BarResponse>(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

//========================================//
//          TestService Service           //
//========================================//

export interface TestServiceService<Context = unknown> {
  Foo: (
    fooRequest: FooRequest,
    context: Context
  ) => Promise<FooResponse> | FooResponse;
  Bar: (
    barRequest: BarRequest,
    context: Context
  ) => Promise<BarResponse> | BarResponse;
}

export function createTestServiceHandler<Context>(
  service: TestServiceService<Context>
) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * Test an enum that has multiple values with the same number.
 */
export type TestEnumWithDupValue =
  typeof TestEnumWithDupValue[keyof typeof TestEnumWithDupValue];

/**
 * Test an enum with large, unordered values.
 */
export type TestSparseEnum = typeof TestSparseEnum[keyof typeof TestSparseEnum];

export type VeryLargeEnum = typeof VeryLargeEnum[keyof typeof VeryLargeEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optional_int32: number;
  optional_int64: string;
  optional_uint32: number;
  optional_uint64: string;
  optional_sint32: number;
  optional_sint64: string;
  optional_fixed32: number;
  optional_fixed64: string;
  optional_sfixed32: number;
  optional_sfixed64: string;
  optional_float: number;
  optional_double: number;
  optional_bool: boolean;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_nested_message: TestAllTypes.NestedMessage;
  optional_foreign_message: ForeignMessage;
  optional_import_message: ImportMessage;
  optional_nested_enum: TestAllTypes.NestedEnum;
  optional_foreign_enum: ForeignEnum;
  optional_import_enum: ImportEnum;
  optional_string_piece: string;
  optional_cord: string;
  optional_public_import_message: PublicImportMessage;
  /**
   * Defined in unittest_import_public.proto
   */
  optional_lazy_message: TestAllTypes.NestedMessage;
  repeated_int32: number[];
  /**
   * Repeated
   */
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_string: string[];
  repeated_bytes: Uint8Array[];
  repeated_nested_message: TestAllTypes.NestedMessage[];
  repeated_foreign_message: ForeignMessage[];
  repeated_import_message: ImportMessage[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
  repeated_foreign_enum: ForeignEnum[];
  repeated_import_enum: ImportEnum[];
  repeated_string_piece: string[];
  repeated_cord: string[];
  repeated_lazy_message: TestAllTypes.NestedMessage[];
  default_int32: number;
  default_int64: string;
  /**
   * Singular with defaults
   */
  default_uint32: number;
  default_uint64: string;
  default_sint32: number;
  default_sint64: string;
  default_fixed32: number;
  default_fixed64: string;
  default_sfixed32: number;
  default_sfixed64: string;
  default_float: number;
  default_double: number;
  default_bool: boolean;
  default_string: string;
  default_bytes: Uint8Array;
  default_nested_enum: TestAllTypes.NestedEnum;
  default_foreign_enum: ForeignEnum;
  default_import_enum: ImportEnum;
  default_string_piece: string;
  default_cord: string;
  oneof_uint32?: number;
  oneof_nested_message?: TestAllTypes.NestedMessage;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }

  export interface OptionalGroup {
    a: number;
  }

  export interface RepeatedGroup {
    a: number;
  }
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
  repeated_child: NestedTestAllTypes[];
}

export interface TestDeprecatedFields {
  deprecated_int32: number;
  deprecated_int32_in_oneof?: number;
}

export interface TestDeprecatedMessage {}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
  d: number;
}

export interface TestReservedFields {}

export interface TestAllExtensions {}

export interface OptionalGroup_extension {
  a: number;
}

export interface RepeatedGroup_extension {
  a: number;
}

export interface TestGroup {
  optional_foreign_enum: ForeignEnum;
}

export namespace TestGroup {
  export interface OptionalGroup {
    a: number;
  }
}

export interface TestGroupExtension {}

export interface TestNestedExtension {}

export namespace TestNestedExtension {
  export interface OptionalGroup_extension {
    a: number;
  }
}

export interface TestChildExtension {
  a: string;
  b: string;
  optional_extension: TestAllExtensions;
}

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 */
export interface TestRequired {
  a: number;
  dummy2: number;
  b: number;
  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   */
  dummy4: number;
  dummy5: number;
  dummy6: number;
  dummy7: number;
  dummy8: number;
  dummy9: number;
  dummy10: number;
  dummy11: number;
  dummy12: number;
  dummy13: number;
  dummy14: number;
  dummy15: number;
  dummy16: number;
  dummy17: number;
  dummy18: number;
  dummy19: number;
  dummy20: number;
  dummy21: number;
  dummy22: number;
  dummy23: number;
  dummy24: number;
  dummy25: number;
  dummy26: number;
  dummy27: number;
  dummy28: number;
  dummy29: number;
  dummy30: number;
  dummy31: number;
  dummy32: number;
  c: number;
}

export interface TestRequiredForeign {
  optional_message: TestRequired;
  repeated_message: TestRequired[];
  dummy: number;
}

export interface TestRequiredMessage {
  optional_message: TestRequired;
  repeated_message: TestRequired[];
  required_message: TestRequired;
}

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 */
export interface TestForeignNested {
  foreign_nested: TestAllTypes.NestedMessage;
}

/**
 * TestEmptyMessage is used to test unknown field support.
 */
export interface TestEmptyMessage {}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 */
export interface TestEmptyMessageWithExtensions {}

/**
 * Needed for a Python test.
 */
export interface TestPickleNestedMessage {}

export namespace TestPickleNestedMessage {
  export interface NestedMessage {
    bb: number;
  }

  export namespace NestedMessage {
    export interface NestedNestedMessage {
      cc: number;
    }
  }
}

export interface TestMultipleExtensionRanges {}

/**
 * Test that really large tag numbers don't break anything.
 */
export interface TestReallyLargeTagNumber {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   */
  a: number;
  bb: number;
}

export interface TestRecursiveMessage {
  a: TestRecursiveMessage;
  i: number;
}

/**
 * Test that mutual recursion works.
 */
export interface TestMutualRecursionA {
  bb: TestMutualRecursionB;
}

export namespace TestMutualRecursionA {
  export interface SubMessage {
    b: TestMutualRecursionB;
  }

  export interface SubGroup {
    sub_message: TestMutualRecursionA.SubMessage;
    not_in_this_scc: TestAllTypes;
  }
}

export interface TestMutualRecursionB {
  a: TestMutualRecursionA;
  optional_int32: number;
}

export interface TestIsInitialized {
  sub_message: TestIsInitialized.SubMessage;
}

export namespace TestIsInitialized {
  export interface SubMessage {}

  export namespace SubMessage {
    export interface SubGroup {
      i: number;
    }
  }
}

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 */
export interface TestDupFieldNumber {
  a: number;
}

export namespace TestDupFieldNumber {
  export interface Foo {
    a: number;
  }

  export interface Bar {
    a: number;
  }
}

/**
 * Additional messages for testing lazy fields.
 */
export interface TestEagerMessage {
  sub_message: TestAllTypes;
}

export interface TestLazyMessage {
  sub_message: TestAllTypes;
}

/**
 * Needed for a Python test.
 */
export interface TestNestedMessageHasBits {
  optional_nested_message: TestNestedMessageHasBits.NestedMessage;
}

export namespace TestNestedMessageHasBits {
  export interface NestedMessage {
    nestedmessage_repeated_int32: number[];
    nestedmessage_repeated_foreignmessage: ForeignMessage[];
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 */
export interface TestCamelCaseFieldNames {
  PrimitiveField: number;
  StringField: string;
  EnumField: ForeignEnum;
  MessageField: ForeignMessage;
  StringPieceField: string;
  CordField: string;
  RepeatedPrimitiveField: number[];
  RepeatedStringField: string[];
  RepeatedEnumField: ForeignEnum[];
  RepeatedMessageField: ForeignMessage[];
  RepeatedStringPieceField: string[];
  RepeatedCordField: string[];
}

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 */
export interface TestFieldOrderings {
  my_string: string;
  my_int: string;
  my_float: number;
  optional_nested_message: TestFieldOrderings.NestedMessage;
}

export namespace TestFieldOrderings {
  export interface NestedMessage {
    oo: string;
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestExtensionOrderings1 {
  my_string: string;
}

export interface TestExtensionOrderings2 {
  my_string: string;
}

export namespace TestExtensionOrderings2 {
  export interface TestExtensionOrderings3 {
    my_string: string;
  }
}

export interface TestExtremeDefaultValues {
  escaped_bytes: Uint8Array;
  large_uint32: number;
  large_uint64: string;
  small_int32: number;
  small_int64: string;
  really_small_int32: number;
  really_small_int64: string;
  /**
   * The default value here is UTF-8 for \\"\\\\u1234\\".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   */
  utf8_string: string;
  /**
   * Tests for single-precision floating-point values.
   */
  zero_float: number;
  one_float: number;
  small_float: number;
  negative_one_float: number;
  negative_float: number;
  /**
   * Using exponents
   */
  large_float: number;
  small_negative_float: number;
  /**
   * Text for nonfinite floating-point values.
   */
  inf_double: number;
  neg_inf_double: number;
  nan_double: number;
  inf_float: number;
  neg_inf_float: number;
  nan_float: number;
  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, \\"\\\\?\\" is a valid way to escape ? in string
   * literals.
   */
  cpp_trigraph: string;
  /**
   * String defaults containing the character '\\\\000'
   */
  string_with_zero: string;
  bytes_with_zero: Uint8Array;
  string_piece_with_zero: string;
  cord_with_zero: string;
  replacement_string: string;
}

export interface SparseEnumMessage {
  sparse_enum: TestSparseEnum;
}

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 */
export interface OneString {
  data: string;
}

export interface MoreString {
  data: string[];
}

export interface OneBytes {
  data: Uint8Array;
}

export interface MoreBytes {
  data: Uint8Array[];
}

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 */
export interface Int32Message {
  data: number;
}

export interface Uint32Message {
  data: number;
}

export interface Int64Message {
  data: string;
}

export interface Uint64Message {
  data: string;
}

export interface BoolMessage {
  data: boolean;
}

/**
 * Test oneofs.
 */
export interface TestOneof {
  foo_int?: number;
  foo_string?: string;
  foo_message?: TestAllTypes;
}

export namespace TestOneof {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneofBackwardsCompatible {
  foo_int: number;
  foo_string: string;
  foo_message: TestAllTypes;
}

export namespace TestOneofBackwardsCompatible {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneof2 {
  foo_int?: number;
  foo_string?: string;
  foo_cord?: string;
  foo_string_piece?: string;
  foo_bytes?: Uint8Array;
  foo_enum?: TestOneof2.NestedEnum;
  foo_message?: TestOneof2.NestedMessage;
  foo_lazy_message?: TestOneof2.NestedMessage;
  bar_int?: number;
  bar_string?: string;
  bar_cord?: string;
  bar_string_piece?: string;
  bar_bytes?: Uint8Array;
  bar_enum?: TestOneof2.NestedEnum;
  bar_string_with_empty_default?: string;
  bar_cord_with_empty_default?: string;
  bar_string_piece_with_empty_default?: string;
  bar_bytes_with_empty_default?: Uint8Array;
  baz_int: number;
  baz_string: string;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];

  export interface FooGroup {
    a: number;
    b: string;
  }

  export interface NestedMessage {
    qux_int: string;
    corge_int: number[];
  }
}

export interface TestRequiredOneof {
  foo_int?: number;
  foo_string?: string;
  foo_message?: TestRequiredOneof.NestedMessage;
}

export namespace TestRequiredOneof {
  export interface NestedMessage {
    required_double: number;
  }
}

export interface TestPackedTypes {
  packed_int32: number[];
  packed_int64: string[];
  packed_uint32: number[];
  packed_uint64: string[];
  packed_sint32: number[];
  packed_sint64: string[];
  packed_fixed32: number[];
  packed_fixed64: string[];
  packed_sfixed32: number[];
  packed_sfixed64: string[];
  packed_float: number[];
  packed_double: number[];
  packed_bool: boolean[];
  packed_enum: ForeignEnum[];
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 */
export interface TestUnpackedTypes {
  unpacked_int32: number[];
  unpacked_int64: string[];
  unpacked_uint32: number[];
  unpacked_uint64: string[];
  unpacked_sint32: number[];
  unpacked_sint64: string[];
  unpacked_fixed32: number[];
  unpacked_fixed64: string[];
  unpacked_sfixed32: number[];
  unpacked_sfixed64: string[];
  unpacked_float: number[];
  unpacked_double: number[];
  unpacked_bool: boolean[];
  unpacked_enum: ForeignEnum[];
}

export interface TestPackedExtensions {}

export interface TestUnpackedExtensions {}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 */
export interface TestDynamicExtensions {
  scalar_extension: number;
  enum_extension: ForeignEnum;
  dynamic_enum_extension: TestDynamicExtensions.DynamicEnumType;
  message_extension: ForeignMessage;
  dynamic_message_extension: TestDynamicExtensions.DynamicMessageType;
  repeated_extension: string[];
  packed_extension: number[];
}

export namespace TestDynamicExtensions {
  export type DynamicEnumType =
    typeof TestDynamicExtensions.DynamicEnumType[keyof typeof TestDynamicExtensions.DynamicEnumType];

  export interface DynamicMessageType {
    dynamic_field: number;
  }
}

export interface TestRepeatedScalarDifferentTagSizes {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   */
  repeated_fixed32: number[];
  /**
   * Check for a varint type, just for good measure.
   */
  repeated_int32: number[];
  /**
   * These have two-byte tags.
   */
  repeated_fixed64: string[];
  repeated_int64: string[];
  /**
   * Three byte tags.
   */
  repeated_float: number[];
  repeated_uint64: string[];
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 */
export interface TestParsingMerge {
  required_all_types: TestAllTypes;
  optional_all_types: TestAllTypes;
  repeated_all_types: TestAllTypes[];
}

export namespace TestParsingMerge {
  /**
   * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
   * except that all fields are repeated. In the tests, we will serialize the
   * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
   * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
   * the corresponding required/optional fields in TestParsingMerge.
   */
  export interface RepeatedFieldsGenerator {
    field1: TestAllTypes[];
    field2: TestAllTypes[];
    field3: TestAllTypes[];
    ext1: TestAllTypes[];
    ext2: TestAllTypes[];
  }

  export namespace RepeatedFieldsGenerator {
    export interface Group1 {
      field1: TestAllTypes;
    }

    export interface Group2 {
      field1: TestAllTypes;
    }
  }

  export interface OptionalGroup {
    optional_group_all_types: TestAllTypes;
  }

  export interface RepeatedGroup {
    repeated_group_all_types: TestAllTypes;
  }
}

export interface TestCommentInjectionMessage {
  /**
   * *\\\\/ <- This should not close the generated doc comment
   */
  a: string;
}

/**
 * Test that RPC services work.
 */
export interface FooRequest {}

export interface FooResponse {}

export interface FooClientMessage {}

export interface FooServerMessage {}

export interface BarRequest {}

export interface BarResponse {}

export interface TestJsonName {
  field_name1: number;
  fieldName2: number;
  FieldName3: number;
  _field_name4: number;
  FIELD_NAME5: number;
  field_name6: number;
  fieldname7: number;
}

export interface TestHugeFieldNumbers {
  optional_int32: number;
  fixed_32: number;
  repeated_int32: number[];
  packed_int32: number[];
  optional_enum: ForeignEnum;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_message: ForeignMessage;
  string_string_map: Record<string, string | undefined>;
  oneof_uint32?: number;
  oneof_test_all_types?: TestAllTypes;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestHugeFieldNumbers {
  export interface OptionalGroup {
    group_a: number;
  }
}

export interface TestExtensionInsideTable {
  field1: number;
  field2: number;
  field3: number;
  field4: number;
  field6: number;
  field7: number;
  field8: number;
  field9: number;
  field10: number;
}

export interface TestExtensionRangeSerialize {
  foo_one: number;
  foo_two: number;
  foo_three: number;
  foo_four: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
} as const;

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
} as const;

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
} as const;

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.initialize(),
      optional_foreign_message: ForeignMessage.initialize(),
      optional_import_message: ImportMessage.initialize(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_import_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.initialize(),
      optional_lazy_message: TestAllTypes.NestedMessage.initialize(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_import_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      default_int32: 0,
      default_int64: \\"\\",
      default_uint32: 0,
      default_uint64: \\"\\",
      default_sint32: 0,
      default_sint64: \\"\\",
      default_fixed32: 0,
      default_fixed64: \\"\\",
      default_sfixed32: 0,
      default_sfixed64: \\"\\",
      default_float: 0,
      default_double: 0,
      default_bool: false,
      default_string: \\"\\",
      default_bytes: new Uint8Array(),
      default_nested_enum: 0,
      default_foreign_enum: 0,
      default_import_enum: 0,
      default_string_piece: \\"\\",
      default_cord: \\"\\",
      oneof_nested_message: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_import_enum) {
      writer.writeEnum(23, msg.optional_import_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_import_enum?.length) {
      writer.writeRepeatedEnum(53, msg.repeated_import_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.default_int32) {
      writer.writeInt32(61, msg.default_int32);
    }
    if (msg.default_int64) {
      writer.writeInt64String(62, msg.default_int64);
    }
    if (msg.default_uint32) {
      writer.writeUint32(63, msg.default_uint32);
    }
    if (msg.default_uint64) {
      writer.writeUint64String(64, msg.default_uint64);
    }
    if (msg.default_sint32) {
      writer.writeSint32(65, msg.default_sint32);
    }
    if (msg.default_sint64) {
      writer.writeSint64String(66, msg.default_sint64);
    }
    if (msg.default_fixed32) {
      writer.writeFixed32(67, msg.default_fixed32);
    }
    if (msg.default_fixed64) {
      writer.writeFixed64String(68, msg.default_fixed64);
    }
    if (msg.default_sfixed32) {
      writer.writeSfixed32(69, msg.default_sfixed32);
    }
    if (msg.default_sfixed64) {
      writer.writeSfixed64(70, msg.default_sfixed64);
    }
    if (msg.default_float) {
      writer.writeFloat(71, msg.default_float);
    }
    if (msg.default_double) {
      writer.writeDouble(72, msg.default_double);
    }
    if (msg.default_bool) {
      writer.writeBool(73, msg.default_bool);
    }
    if (msg.default_string) {
      writer.writeString(74, msg.default_string);
    }
    if (msg.default_bytes) {
      writer.writeBytes(75, msg.default_bytes);
    }
    if (msg.default_nested_enum) {
      writer.writeEnum(81, msg.default_nested_enum);
    }
    if (msg.default_foreign_enum) {
      writer.writeEnum(82, msg.default_foreign_enum);
    }
    if (msg.default_import_enum) {
      writer.writeEnum(83, msg.default_import_enum);
    }
    if (msg.default_string_piece) {
      writer.writeString(84, msg.default_string_piece);
    }
    if (msg.default_cord) {
      writer.writeString(85, msg.default_cord);
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optional_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optional_foreign_message,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optional_import_message,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optional_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 23: {
          msg.optional_import_enum = reader.readEnum() as ImportEnum;
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optional_public_import_message,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optional_lazy_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          msg.repeated_nested_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 49: {
          msg.repeated_foreign_message.push(
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            )
          );
          break;
        }
        case 50: {
          msg.repeated_import_message.push(
            reader.readMessage(
              ImportMessage.initialize(),
              ImportMessage._readMessage
            )
          );
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 53: {
          msg.repeated_import_enum.push(reader.readEnum() as ImportEnum);
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          msg.repeated_lazy_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 61: {
          msg.default_int32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.default_int64 = reader.readInt64String();
          break;
        }
        case 63: {
          msg.default_uint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.default_uint64 = reader.readUint64String();
          break;
        }
        case 65: {
          msg.default_sint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.default_sint64 = reader.readSint64();
          break;
        }
        case 67: {
          msg.default_fixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.default_fixed64 = reader.readFixed64String();
          break;
        }
        case 69: {
          msg.default_sfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.default_sfixed64 = reader.readSfixed64();
          break;
        }
        case 71: {
          msg.default_float = reader.readFloat();
          break;
        }
        case 72: {
          msg.default_double = reader.readDouble();
          break;
        }
        case 73: {
          msg.default_bool = reader.readBool();
          break;
        }
        case 74: {
          msg.default_string = reader.readString();
          break;
        }
        case 75: {
          msg.default_bytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.default_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 82: {
          msg.default_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 83: {
          msg.default_import_enum = reader.readEnum() as ImportEnum;
          break;
        }
        case 84: {
          msg.default_string_piece = reader.readString();
          break;
        }
        case 85: {
          msg.default_cord = reader.readString();
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneof_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestAllTypes.OptionalGroup>
    ): Uint8Array {
      return TestAllTypes.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      reader: BinaryReader
    ): TestAllTypes.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (
      repeatedGroup: Partial<TestAllTypes.RepeatedGroup>
    ): Uint8Array {
      return TestAllTypes.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      reader: BinaryReader
    ): TestAllTypes.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeated_child: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeated_child?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_child as any,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          msg.repeated_child.push(
            reader.readMessage(
              NestedTestAllTypes.initialize(),
              NestedTestAllTypes._readMessage
            )
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (
    testDeprecatedFields: Partial<TestDeprecatedFields>
  ): Uint8Array {
    return TestDeprecatedFields._writeMessage(
      testDeprecatedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes: ByteSource): TestDeprecatedFields {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecated_int32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.deprecated_int32) {
      writer.writeInt32(1, msg.deprecated_int32);
    }
    if (msg.deprecated_int32_in_oneof != undefined) {
      writer.writeInt32(2, msg.deprecated_int32_in_oneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    reader: BinaryReader
  ): TestDeprecatedFields {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecated_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecated_int32_in_oneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */
  encode: function (
    testDeprecatedMessage: Partial<TestDeprecatedMessage>
  ): Uint8Array {
    return TestDeprecatedMessage._writeMessage(
      testDeprecatedMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestDeprecatedMessage {
    return TestDeprecatedMessage._readMessage(
      TestDeprecatedMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedMessage,
    reader: BinaryReader
  ): TestDeprecatedMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */
  encode: function (
    testReservedFields: Partial<TestReservedFields>
  ): Uint8Array {
    return TestReservedFields._writeMessage(
      testReservedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */
  decode: function (bytes: ByteSource): TestReservedFields {
    return TestReservedFields._readMessage(
      TestReservedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReservedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReservedFields,
    reader: BinaryReader
  ): TestReservedFields {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */
  encode: function (testAllExtensions: Partial<TestAllExtensions>): Uint8Array {
    return TestAllExtensions._writeMessage(
      testAllExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllExtensions {
    return TestAllExtensions._readMessage(
      TestAllExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllExtensions,
    reader: BinaryReader
  ): TestAllExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (
    optionalGroup_extension: Partial<OptionalGroup_extension>
  ): Uint8Array {
    return OptionalGroup_extension._writeMessage(
      optionalGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): OptionalGroup_extension {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OptionalGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    reader: BinaryReader
  ): OptionalGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (
    repeatedGroup_extension: Partial<RepeatedGroup_extension>
  ): Uint8Array {
    return RepeatedGroup_extension._writeMessage(
      repeatedGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    reader: BinaryReader
  ): RepeatedGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (testGroup: Partial<TestGroup>): Uint8Array {
    return TestGroup._writeMessage(
      testGroup,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes: ByteSource): TestGroup {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optional_foreign_enum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestGroup>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, reader: BinaryReader): TestGroup {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestGroup.OptionalGroup>
    ): Uint8Array {
      return TestGroup.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      reader: BinaryReader
    ): TestGroup.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */
  encode: function (
    testGroupExtension: Partial<TestGroupExtension>
  ): Uint8Array {
    return TestGroupExtension._writeMessage(
      testGroupExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestGroupExtension {
    return TestGroupExtension._readMessage(
      TestGroupExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestGroupExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestGroupExtension,
    reader: BinaryReader
  ): TestGroupExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */
  encode: function (
    testNestedExtension: Partial<TestNestedExtension>
  ): Uint8Array {
    return TestNestedExtension._writeMessage(
      testNestedExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestNestedExtension {
    return TestNestedExtension._readMessage(
      TestNestedExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedExtension,
    reader: BinaryReader
  ): TestNestedExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (
      optionalGroup_extension: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Uint8Array {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        optionalGroup_extension,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      reader: BinaryReader
    ): TestNestedExtension.OptionalGroup_extension {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (
    testChildExtension: Partial<TestChildExtension>
  ): Uint8Array {
    return TestChildExtension._writeMessage(
      testChildExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestChildExtension {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: \\"\\",
      b: \\"\\",
      optional_extension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestChildExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optional_extension) {
      writer.writeMessage(
        3,
        msg.optional_extension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    reader: BinaryReader
  ): TestChildExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optional_extension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (testRequired: Partial<TestRequired>): Uint8Array {
    return TestRequired._writeMessage(
      testRequired,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequired {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequired>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequired,
    reader: BinaryReader
  ): TestRequired {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (
    testRequiredForeign: Partial<TestRequiredForeign>
  ): Uint8Array {
    return TestRequiredForeign._writeMessage(
      testRequiredForeign,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredForeign {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optional_message: TestRequired.initialize(),
      repeated_message: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredForeign>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired._writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message as any,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    reader: BinaryReader
  ): TestRequiredForeign {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optional_message, TestRequired._readMessage);
          break;
        }
        case 2: {
          msg.repeated_message.push(
            reader.readMessage(
              TestRequired.initialize(),
              TestRequired._readMessage
            )
          );
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (
    testRequiredMessage: Partial<TestRequiredMessage>
  ): Uint8Array {
    return TestRequiredMessage._writeMessage(
      testRequiredMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessage {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optional_message: TestRequired.initialize(),
      repeated_message: [],
      required_message: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired._writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message as any,
        TestRequired._writeMessage
      );
    }
    if (msg.required_message) {
      writer.writeMessage(3, msg.required_message, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    reader: BinaryReader
  ): TestRequiredMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optional_message, TestRequired._readMessage);
          break;
        }
        case 2: {
          msg.repeated_message.push(
            reader.readMessage(
              TestRequired.initialize(),
              TestRequired._readMessage
            )
          );
          break;
        }
        case 3: {
          reader.readMessage(msg.required_message, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (testForeignNested: Partial<TestForeignNested>): Uint8Array {
    return TestForeignNested._writeMessage(
      testForeignNested,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes: ByteSource): TestForeignNested {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreign_nested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestForeignNested>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foreign_nested) {
      writer.writeMessage(
        1,
        msg.foreign_nested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    reader: BinaryReader
  ): TestForeignNested {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreign_nested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (testEmptyMessage: Partial<TestEmptyMessage>): Uint8Array {
    return TestEmptyMessage._writeMessage(
      testEmptyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEmptyMessage {
    return TestEmptyMessage._readMessage(
      TestEmptyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEmptyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEmptyMessage,
    reader: BinaryReader
  ): TestEmptyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (
    testEmptyMessageWithExtensions: Partial<TestEmptyMessageWithExtensions>
  ): Uint8Array {
    return TestEmptyMessageWithExtensions._writeMessage(
      testEmptyMessageWithExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestEmptyMessageWithExtensions {
    return TestEmptyMessageWithExtensions._readMessage(
      TestEmptyMessageWithExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEmptyMessageWithExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEmptyMessageWithExtensions,
    reader: BinaryReader
  ): TestEmptyMessageWithExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */
  encode: function (
    testPickleNestedMessage: Partial<TestPickleNestedMessage>
  ): Uint8Array {
    return TestPickleNestedMessage._writeMessage(
      testPickleNestedMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestPickleNestedMessage {
    return TestPickleNestedMessage._readMessage(
      TestPickleNestedMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPickleNestedMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPickleNestedMessage,
    reader: BinaryReader
  ): TestPickleNestedMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestPickleNestedMessage.NestedMessage>
    ): Uint8Array {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      reader: BinaryReader
    ): TestPickleNestedMessage.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (
        nestedNestedMessage: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Uint8Array {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          nestedNestedMessage,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        reader: BinaryReader
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */
  encode: function (
    testMultipleExtensionRanges: Partial<TestMultipleExtensionRanges>
  ): Uint8Array {
    return TestMultipleExtensionRanges._writeMessage(
      testMultipleExtensionRanges,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */
  decode: function (bytes: ByteSource): TestMultipleExtensionRanges {
    return TestMultipleExtensionRanges._readMessage(
      TestMultipleExtensionRanges.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMultipleExtensionRanges>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMultipleExtensionRanges,
    reader: BinaryReader
  ): TestMultipleExtensionRanges {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (
    testReallyLargeTagNumber: Partial<TestReallyLargeTagNumber>
  ): Uint8Array {
    return TestReallyLargeTagNumber._writeMessage(
      testReallyLargeTagNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    reader: BinaryReader
  ): TestReallyLargeTagNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (
    testRecursiveMessage: Partial<TestRecursiveMessage>
  ): Uint8Array {
    return TestRecursiveMessage._writeMessage(
      testRecursiveMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMessage {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    reader: BinaryReader
  ): TestRecursiveMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (
    testMutualRecursionA: Partial<TestMutualRecursionA>
  ): Uint8Array {
    return TestMutualRecursionA._writeMessage(
      testMutualRecursionA,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionA {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionA>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    reader: BinaryReader
  ): TestMutualRecursionA {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (
      subMessage: Partial<TestMutualRecursionA.SubMessage>
    ): Uint8Array {
      return TestMutualRecursionA.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      reader: BinaryReader
    ): TestMutualRecursionA.SubMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (
      subGroup: Partial<TestMutualRecursionA.SubGroup>
    ): Uint8Array {
      return TestMutualRecursionA.SubGroup._writeMessage(
        subGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        sub_message: TestMutualRecursionA.SubMessage.initialize(),
        not_in_this_scc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.sub_message) {
        writer.writeMessage(
          3,
          msg.sub_message,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.not_in_this_scc) {
        writer.writeMessage(4, msg.not_in_this_scc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      reader: BinaryReader
    ): TestMutualRecursionA.SubGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.sub_message,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.not_in_this_scc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (
    testMutualRecursionB: Partial<TestMutualRecursionB>
  ): Uint8Array {
    return TestMutualRecursionB._writeMessage(
      testMutualRecursionB,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionB {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionA.initialize(),
      optional_int32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionB>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optional_int32) {
      writer.writeInt32(2, msg.optional_int32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    reader: BinaryReader
  ): TestMutualRecursionB {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (testIsInitialized: Partial<TestIsInitialized>): Uint8Array {
    return TestIsInitialized._writeMessage(
      testIsInitialized,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes: ByteSource): TestIsInitialized {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      sub_message: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestIsInitialized>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sub_message) {
      writer.writeMessage(
        1,
        msg.sub_message,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    reader: BinaryReader
  ): TestIsInitialized {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.sub_message,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (
      subMessage: Partial<TestIsInitialized.SubMessage>
    ): Uint8Array {
      return TestIsInitialized.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestIsInitialized.SubMessage {
      return TestIsInitialized.SubMessage._readMessage(
        TestIsInitialized.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestIsInitialized.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestIsInitialized.SubMessage,
      reader: BinaryReader
    ): TestIsInitialized.SubMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (
        subGroup: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Uint8Array {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          subGroup,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        reader: BinaryReader
      ): TestIsInitialized.SubMessage.SubGroup {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (
    testDupFieldNumber: Partial<TestDupFieldNumber>
  ): Uint8Array {
    return TestDupFieldNumber._writeMessage(
      testDupFieldNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestDupFieldNumber {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDupFieldNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    reader: BinaryReader
  ): TestDupFieldNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (foo: Partial<TestDupFieldNumber.Foo>): Uint8Array {
      return TestDupFieldNumber.Foo._writeMessage(
        foo,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      reader: BinaryReader
    ): TestDupFieldNumber.Foo {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (bar: Partial<TestDupFieldNumber.Bar>): Uint8Array {
      return TestDupFieldNumber.Bar._writeMessage(
        bar,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      reader: BinaryReader
    ): TestDupFieldNumber.Bar {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (testEagerMessage: Partial<TestEagerMessage>): Uint8Array {
    return TestEagerMessage._writeMessage(
      testEagerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEagerMessage {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      sub_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEagerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEagerMessage,
    reader: BinaryReader
  ): TestEagerMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.sub_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (testLazyMessage: Partial<TestLazyMessage>): Uint8Array {
    return TestLazyMessage._writeMessage(
      testLazyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestLazyMessage {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      sub_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestLazyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestLazyMessage,
    reader: BinaryReader
  ): TestLazyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.sub_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (
    testNestedMessageHasBits: Partial<TestNestedMessageHasBits>
  ): Uint8Array {
    return TestNestedMessageHasBits._writeMessage(
      testNestedMessageHasBits,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes: ByteSource): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optional_nested_message:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_nested_message) {
      writer.writeMessage(
        1,
        msg.optional_nested_message,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    reader: BinaryReader
  ): TestNestedMessageHasBits {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optional_nested_message,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Uint8Array {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessage_repeated_int32: [],
        nestedmessage_repeated_foreignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.nestedmessage_repeated_int32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessage_repeated_int32);
      }
      if (msg.nestedmessage_repeated_foreignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessage_repeated_foreignmessage as any,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      reader: BinaryReader
    ): TestNestedMessageHasBits.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessage_repeated_int32.push(reader.readInt32());
            break;
          }
          case 2: {
            msg.nestedmessage_repeated_foreignmessage.push(
              reader.readMessage(
                ForeignMessage.initialize(),
                ForeignMessage._readMessage
              )
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (
    testCamelCaseFieldNames: Partial<TestCamelCaseFieldNames>
  ): Uint8Array {
    return TestCamelCaseFieldNames._writeMessage(
      testCamelCaseFieldNames,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes: ByteSource): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    reader: BinaryReader
  ): TestCamelCaseFieldNames {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum() as ForeignEnum;
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 10: {
          msg.RepeatedMessageField.push(
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            )
          );
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (
    testFieldOrderings: Partial<TestFieldOrderings>
  ): Uint8Array {
    return TestFieldOrderings._writeMessage(
      testFieldOrderings,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes: ByteSource): TestFieldOrderings {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      my_string: \\"\\",
      my_int: \\"\\",
      my_float: 0,
      optional_nested_message: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestFieldOrderings>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.my_string) {
      writer.writeString(11, msg.my_string);
    }
    if (msg.my_int) {
      writer.writeInt64String(1, msg.my_int);
    }
    if (msg.my_float) {
      writer.writeFloat(101, msg.my_float);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        200,
        msg.optional_nested_message,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    reader: BinaryReader
  ): TestFieldOrderings {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.my_string = reader.readString();
          break;
        }
        case 1: {
          msg.my_int = reader.readInt64String();
          break;
        }
        case 101: {
          msg.my_float = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optional_nested_message,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestFieldOrderings.NestedMessage>
    ): Uint8Array {
      return TestFieldOrderings.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: \\"\\",
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      reader: BinaryReader
    ): TestFieldOrderings.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = reader.readInt64String();
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (
    testExtensionOrderings1: Partial<TestExtensionOrderings1>
  ): Uint8Array {
    return TestExtensionOrderings1._writeMessage(
      testExtensionOrderings1,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      my_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    reader: BinaryReader
  ): TestExtensionOrderings1 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (
    testExtensionOrderings2: Partial<TestExtensionOrderings2>
  ): Uint8Array {
    return TestExtensionOrderings2._writeMessage(
      testExtensionOrderings2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      my_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    reader: BinaryReader
  ): TestExtensionOrderings2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (
      testExtensionOrderings3: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Uint8Array {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        testExtensionOrderings3,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        my_string: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.my_string) {
        writer.writeString(1, msg.my_string);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      reader: BinaryReader
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.my_string = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (
    testExtremeDefaultValues: Partial<TestExtremeDefaultValues>
  ): Uint8Array {
    return TestExtremeDefaultValues._writeMessage(
      testExtremeDefaultValues,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escaped_bytes: new Uint8Array(),
      large_uint32: 0,
      large_uint64: \\"\\",
      small_int32: 0,
      small_int64: \\"\\",
      really_small_int32: 0,
      really_small_int64: \\"\\",
      utf8_string: \\"\\",
      zero_float: 0,
      one_float: 0,
      small_float: 0,
      negative_one_float: 0,
      negative_float: 0,
      large_float: 0,
      small_negative_float: 0,
      inf_double: 0,
      neg_inf_double: 0,
      nan_double: 0,
      inf_float: 0,
      neg_inf_float: 0,
      nan_float: 0,
      cpp_trigraph: \\"\\",
      string_with_zero: \\"\\",
      bytes_with_zero: new Uint8Array(),
      string_piece_with_zero: \\"\\",
      cord_with_zero: \\"\\",
      replacement_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.escaped_bytes) {
      writer.writeBytes(1, msg.escaped_bytes);
    }
    if (msg.large_uint32) {
      writer.writeUint32(2, msg.large_uint32);
    }
    if (msg.large_uint64) {
      writer.writeUint64String(3, msg.large_uint64);
    }
    if (msg.small_int32) {
      writer.writeInt32(4, msg.small_int32);
    }
    if (msg.small_int64) {
      writer.writeInt64String(5, msg.small_int64);
    }
    if (msg.really_small_int32) {
      writer.writeInt32(21, msg.really_small_int32);
    }
    if (msg.really_small_int64) {
      writer.writeInt64String(22, msg.really_small_int64);
    }
    if (msg.utf8_string) {
      writer.writeString(6, msg.utf8_string);
    }
    if (msg.zero_float) {
      writer.writeFloat(7, msg.zero_float);
    }
    if (msg.one_float) {
      writer.writeFloat(8, msg.one_float);
    }
    if (msg.small_float) {
      writer.writeFloat(9, msg.small_float);
    }
    if (msg.negative_one_float) {
      writer.writeFloat(10, msg.negative_one_float);
    }
    if (msg.negative_float) {
      writer.writeFloat(11, msg.negative_float);
    }
    if (msg.large_float) {
      writer.writeFloat(12, msg.large_float);
    }
    if (msg.small_negative_float) {
      writer.writeFloat(13, msg.small_negative_float);
    }
    if (msg.inf_double) {
      writer.writeDouble(14, msg.inf_double);
    }
    if (msg.neg_inf_double) {
      writer.writeDouble(15, msg.neg_inf_double);
    }
    if (msg.nan_double) {
      writer.writeDouble(16, msg.nan_double);
    }
    if (msg.inf_float) {
      writer.writeFloat(17, msg.inf_float);
    }
    if (msg.neg_inf_float) {
      writer.writeFloat(18, msg.neg_inf_float);
    }
    if (msg.nan_float) {
      writer.writeFloat(19, msg.nan_float);
    }
    if (msg.cpp_trigraph) {
      writer.writeString(20, msg.cpp_trigraph);
    }
    if (msg.string_with_zero) {
      writer.writeString(23, msg.string_with_zero);
    }
    if (msg.bytes_with_zero) {
      writer.writeBytes(24, msg.bytes_with_zero);
    }
    if (msg.string_piece_with_zero) {
      writer.writeString(25, msg.string_piece_with_zero);
    }
    if (msg.cord_with_zero) {
      writer.writeString(26, msg.cord_with_zero);
    }
    if (msg.replacement_string) {
      writer.writeString(27, msg.replacement_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    reader: BinaryReader
  ): TestExtremeDefaultValues {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escaped_bytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.large_uint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.large_uint64 = reader.readUint64String();
          break;
        }
        case 4: {
          msg.small_int32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.small_int64 = reader.readInt64String();
          break;
        }
        case 21: {
          msg.really_small_int32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.really_small_int64 = reader.readInt64String();
          break;
        }
        case 6: {
          msg.utf8_string = reader.readString();
          break;
        }
        case 7: {
          msg.zero_float = reader.readFloat();
          break;
        }
        case 8: {
          msg.one_float = reader.readFloat();
          break;
        }
        case 9: {
          msg.small_float = reader.readFloat();
          break;
        }
        case 10: {
          msg.negative_one_float = reader.readFloat();
          break;
        }
        case 11: {
          msg.negative_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.large_float = reader.readFloat();
          break;
        }
        case 13: {
          msg.small_negative_float = reader.readFloat();
          break;
        }
        case 14: {
          msg.inf_double = reader.readDouble();
          break;
        }
        case 15: {
          msg.neg_inf_double = reader.readDouble();
          break;
        }
        case 16: {
          msg.nan_double = reader.readDouble();
          break;
        }
        case 17: {
          msg.inf_float = reader.readFloat();
          break;
        }
        case 18: {
          msg.neg_inf_float = reader.readFloat();
          break;
        }
        case 19: {
          msg.nan_float = reader.readFloat();
          break;
        }
        case 20: {
          msg.cpp_trigraph = reader.readString();
          break;
        }
        case 23: {
          msg.string_with_zero = reader.readString();
          break;
        }
        case 24: {
          msg.bytes_with_zero = reader.readBytes();
          break;
        }
        case 25: {
          msg.string_piece_with_zero = reader.readString();
          break;
        }
        case 26: {
          msg.cord_with_zero = reader.readString();
          break;
        }
        case 27: {
          msg.replacement_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (sparseEnumMessage: Partial<SparseEnumMessage>): Uint8Array {
    return SparseEnumMessage._writeMessage(
      sparseEnumMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes: ByteSource): SparseEnumMessage {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparse_enum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SparseEnumMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sparse_enum) {
      writer.writeEnum(1, msg.sparse_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    reader: BinaryReader
  ): SparseEnumMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparse_enum = reader.readEnum() as TestSparseEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (oneString: Partial<OneString>): Uint8Array {
    return OneString._writeMessage(
      oneString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes: ByteSource): OneString {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, reader: BinaryReader): OneString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (moreString: Partial<MoreString>): Uint8Array {
    return MoreString._writeMessage(
      moreString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes: ByteSource): MoreString {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, reader: BinaryReader): MoreString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (oneBytes: Partial<OneBytes>): Uint8Array {
    return OneBytes._writeMessage(
      oneBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes: ByteSource): OneBytes {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, reader: BinaryReader): OneBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (moreBytes: Partial<MoreBytes>): Uint8Array {
    return MoreBytes._writeMessage(
      moreBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes: ByteSource): MoreBytes {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, reader: BinaryReader): MoreBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (int32Message: Partial<Int32Message>): Uint8Array {
    return Int32Message._writeMessage(
      int32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int32Message {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int32Message,
    reader: BinaryReader
  ): Int32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (uint32Message: Partial<Uint32Message>): Uint8Array {
    return Uint32Message._writeMessage(
      uint32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint32Message {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint32Message,
    reader: BinaryReader
  ): Uint32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (int64Message: Partial<Int64Message>): Uint8Array {
    return Int64Message._writeMessage(
      int64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int64Message {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int64Message,
    reader: BinaryReader
  ): Int64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (uint64Message: Partial<Uint64Message>): Uint8Array {
    return Uint64Message._writeMessage(
      uint64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint64Message {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint64Message,
    reader: BinaryReader
  ): Uint64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (boolMessage: Partial<BoolMessage>): Uint8Array {
    return BoolMessage._writeMessage(
      boolMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes: ByteSource): BoolMessage {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BoolMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, reader: BinaryReader): BoolMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (testOneof: Partial<TestOneof>): Uint8Array {
    return TestOneof._writeMessage(
      testOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      foo_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, reader: BinaryReader): TestOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.foo_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (fooGroup: Partial<TestOneof.FooGroup>): Uint8Array {
      return TestOneof.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      reader: BinaryReader
    ): TestOneof.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (
    testOneofBackwardsCompatible: Partial<TestOneofBackwardsCompatible>
  ): Uint8Array {
    return TestOneofBackwardsCompatible._writeMessage(
      testOneofBackwardsCompatible,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      foo_int: 0,
      foo_string: \\"\\",
      foo_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foo_int) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    reader: BinaryReader
  ): TestOneofBackwardsCompatible {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.foo_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (
      fooGroup: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Uint8Array {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      reader: BinaryReader
    ): TestOneofBackwardsCompatible.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      foo_message: TestOneof2.NestedMessage.initialize(),
      foo_lazy_message: TestOneof2.NestedMessage.initialize(),
      baz_int: 0,
      baz_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_cord != undefined) {
      writer.writeString(3, msg.foo_cord);
    }
    if (msg.foo_string_piece != undefined) {
      writer.writeString(4, msg.foo_string_piece);
    }
    if (msg.foo_bytes != undefined) {
      writer.writeBytes(5, msg.foo_bytes);
    }
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        7,
        msg.foo_message,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.foo_lazy_message != undefined) {
      writer.writeMessage(
        11,
        msg.foo_lazy_message,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.bar_int != undefined) {
      writer.writeInt32(12, msg.bar_int);
    }
    if (msg.bar_string != undefined) {
      writer.writeString(13, msg.bar_string);
    }
    if (msg.bar_cord != undefined) {
      writer.writeString(14, msg.bar_cord);
    }
    if (msg.bar_string_piece != undefined) {
      writer.writeString(15, msg.bar_string_piece);
    }
    if (msg.bar_bytes != undefined) {
      writer.writeBytes(16, msg.bar_bytes);
    }
    if (msg.bar_enum != undefined) {
      writer.writeEnum(17, msg.bar_enum);
    }
    if (msg.bar_string_with_empty_default != undefined) {
      writer.writeString(20, msg.bar_string_with_empty_default);
    }
    if (msg.bar_cord_with_empty_default != undefined) {
      writer.writeString(21, msg.bar_cord_with_empty_default);
    }
    if (msg.bar_string_piece_with_empty_default != undefined) {
      writer.writeString(22, msg.bar_string_piece_with_empty_default);
    }
    if (msg.bar_bytes_with_empty_default != undefined) {
      writer.writeBytes(23, msg.bar_bytes_with_empty_default);
    }
    if (msg.baz_int) {
      writer.writeInt32(18, msg.baz_int);
    }
    if (msg.baz_string) {
      writer.writeString(19, msg.baz_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          msg.foo_cord = reader.readString();
          break;
        }
        case 4: {
          msg.foo_string_piece = reader.readString();
          break;
        }
        case 5: {
          msg.foo_bytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.foo_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 7: {
          reader.readMessage(
            msg.foo_message,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.foo_lazy_message,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.bar_int = reader.readInt32();
          break;
        }
        case 13: {
          msg.bar_string = reader.readString();
          break;
        }
        case 14: {
          msg.bar_cord = reader.readString();
          break;
        }
        case 15: {
          msg.bar_string_piece = reader.readString();
          break;
        }
        case 16: {
          msg.bar_bytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.bar_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 20: {
          msg.bar_string_with_empty_default = reader.readString();
          break;
        }
        case 21: {
          msg.bar_cord_with_empty_default = reader.readString();
          break;
        }
        case 22: {
          msg.bar_string_piece_with_empty_default = reader.readString();
          break;
        }
        case 23: {
          msg.bar_bytes_with_empty_default = reader.readBytes();
          break;
        }
        case 18: {
          msg.baz_int = reader.readInt32();
          break;
        }
        case 19: {
          msg.baz_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 } as const,

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (fooGroup: Partial<TestOneof2.FooGroup>): Uint8Array {
      return TestOneof2.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      reader: BinaryReader
    ): TestOneof2.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestOneof2.NestedMessage>
    ): Uint8Array {
      return TestOneof2.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        qux_int: \\"\\",
        corge_int: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.qux_int) {
        writer.writeInt64String(1, msg.qux_int);
      }
      if (msg.corge_int?.length) {
        writer.writeRepeatedInt32(2, msg.corge_int);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      reader: BinaryReader
    ): TestOneof2.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.qux_int = reader.readInt64String();
            break;
          }
          case 2: {
            msg.corge_int.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (testRequiredOneof: Partial<TestRequiredOneof>): Uint8Array {
    return TestRequiredOneof._writeMessage(
      testRequiredOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredOneof {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      foo_message: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        3,
        msg.foo_message,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    reader: BinaryReader
  ): TestRequiredOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.foo_message,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestRequiredOneof.NestedMessage>
    ): Uint8Array {
      return TestRequiredOneof.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        required_double: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.required_double) {
        writer.writeDouble(1, msg.required_double);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      reader: BinaryReader
    ): TestRequiredOneof.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.required_double = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpacked_int32: [],
      unpacked_int64: [],
      unpacked_uint32: [],
      unpacked_uint64: [],
      unpacked_sint32: [],
      unpacked_sint64: [],
      unpacked_fixed32: [],
      unpacked_fixed64: [],
      unpacked_sfixed32: [],
      unpacked_sfixed64: [],
      unpacked_float: [],
      unpacked_double: [],
      unpacked_bool: [],
      unpacked_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.unpacked_int32?.length) {
      writer.writeRepeatedInt32(90, msg.unpacked_int32);
    }
    if (msg.unpacked_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpacked_int64);
    }
    if (msg.unpacked_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpacked_uint32);
    }
    if (msg.unpacked_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpacked_uint64);
    }
    if (msg.unpacked_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpacked_sint32);
    }
    if (msg.unpacked_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpacked_sint64);
    }
    if (msg.unpacked_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpacked_fixed32);
    }
    if (msg.unpacked_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpacked_fixed64);
    }
    if (msg.unpacked_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpacked_sfixed32);
    }
    if (msg.unpacked_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpacked_sfixed64);
    }
    if (msg.unpacked_float?.length) {
      writer.writeRepeatedFloat(100, msg.unpacked_float);
    }
    if (msg.unpacked_double?.length) {
      writer.writeRepeatedDouble(101, msg.unpacked_double);
    }
    if (msg.unpacked_bool?.length) {
      writer.writeRepeatedBool(102, msg.unpacked_bool);
    }
    if (msg.unpacked_enum?.length) {
      writer.writeRepeatedEnum(103, msg.unpacked_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpacked_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpacked_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.unpacked_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpacked_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.unpacked_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpacked_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.unpacked_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpacked_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.unpacked_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpacked_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.unpacked_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpacked_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpacked_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpacked_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */
  encode: function (
    testPackedExtensions: Partial<TestPackedExtensions>
  ): Uint8Array {
    return TestPackedExtensions._writeMessage(
      testPackedExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedExtensions {
    return TestPackedExtensions._readMessage(
      TestPackedExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedExtensions,
    reader: BinaryReader
  ): TestPackedExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */
  encode: function (
    testUnpackedExtensions: Partial<TestUnpackedExtensions>
  ): Uint8Array {
    return TestUnpackedExtensions._writeMessage(
      testUnpackedExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedExtensions {
    return TestUnpackedExtensions._readMessage(
      TestUnpackedExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedExtensions,
    reader: BinaryReader
  ): TestUnpackedExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (
    testDynamicExtensions: Partial<TestDynamicExtensions>
  ): Uint8Array {
    return TestDynamicExtensions._writeMessage(
      testDynamicExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestDynamicExtensions {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalar_extension: 0,
      enum_extension: 0,
      dynamic_enum_extension: 0,
      message_extension: ForeignMessage.initialize(),
      dynamic_message_extension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeated_extension: [],
      packed_extension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDynamicExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.scalar_extension) {
      writer.writeFixed32(2000, msg.scalar_extension);
    }
    if (msg.enum_extension) {
      writer.writeEnum(2001, msg.enum_extension);
    }
    if (msg.dynamic_enum_extension) {
      writer.writeEnum(2002, msg.dynamic_enum_extension);
    }
    if (msg.message_extension) {
      writer.writeMessage(
        2003,
        msg.message_extension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamic_message_extension) {
      writer.writeMessage(
        2004,
        msg.dynamic_message_extension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeated_extension?.length) {
      writer.writeRepeatedString(2005, msg.repeated_extension);
    }
    if (msg.packed_extension?.length) {
      writer.writeRepeatedSint32(2006, msg.packed_extension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    reader: BinaryReader
  ): TestDynamicExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalar_extension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enum_extension = reader.readEnum() as ForeignEnum;
          break;
        }
        case 2002: {
          msg.dynamic_enum_extension =
            reader.readEnum() as TestDynamicExtensions.DynamicEnumType;
          break;
        }
        case 2003: {
          reader.readMessage(
            msg.message_extension,
            ForeignMessage._readMessage
          );
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamic_message_extension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeated_extension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packed_extension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: 2200,
    DYNAMIC_BAR: 2201,
    DYNAMIC_BAZ: 2202,
  } as const,

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (
      dynamicMessageType: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Uint8Array {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        dynamicMessageType,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamic_field: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.dynamic_field) {
        writer.writeInt32(2100, msg.dynamic_field);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      reader: BinaryReader
    ): TestDynamicExtensions.DynamicMessageType {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamic_field = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (
    testRepeatedScalarDifferentTagSizes: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Uint8Array {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      testRepeatedScalarDifferentTagSizes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes: ByteSource): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeated_fixed32: [],
      repeated_int32: [],
      repeated_fixed64: [],
      repeated_int64: [],
      repeated_float: [],
      repeated_uint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeated_fixed32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(13, msg.repeated_int32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeated_fixed64);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeated_int64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(262142, msg.repeated_float);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeated_uint64);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    reader: BinaryReader
  ): TestRepeatedScalarDifferentTagSizes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 2047: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 262142: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (testParsingMerge: Partial<TestParsingMerge>): Uint8Array {
    return TestParsingMerge._writeMessage(
      testParsingMerge,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes: ByteSource): TestParsingMerge {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      required_all_types: TestAllTypes.initialize(),
      optional_all_types: TestAllTypes.initialize(),
      repeated_all_types: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestParsingMerge>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.required_all_types) {
      writer.writeMessage(
        1,
        msg.required_all_types,
        TestAllTypes._writeMessage
      );
    }
    if (msg.optional_all_types) {
      writer.writeMessage(
        2,
        msg.optional_all_types,
        TestAllTypes._writeMessage
      );
    }
    if (msg.repeated_all_types?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_all_types as any,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestParsingMerge,
    reader: BinaryReader
  ): TestParsingMerge {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.required_all_types, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optional_all_types, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          msg.repeated_all_types.push(
            reader.readMessage(
              TestAllTypes.initialize(),
              TestAllTypes._readMessage
            )
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (
      repeatedFieldsGenerator: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Uint8Array {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        repeatedFieldsGenerator,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.field1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.field2 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(
          3,
          msg.field3 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(
          1000,
          msg.ext1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(
          1001,
          msg.ext2 as any,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedFieldsGenerator {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.field1.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 2: {
            msg.field2.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 3: {
            msg.field3.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 1000: {
            msg.ext1.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 1001: {
            msg.ext2.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (
        group1: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          group1,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (
        group2: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          group2,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestParsingMerge.OptionalGroup>
    ): Uint8Array {
      return TestParsingMerge.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optional_group_all_types: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.optional_group_all_types) {
        writer.writeMessage(
          11,
          msg.optional_group_all_types,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      reader: BinaryReader
    ): TestParsingMerge.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optional_group_all_types,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (
      repeatedGroup: Partial<TestParsingMerge.RepeatedGroup>
    ): Uint8Array {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeated_group_all_types: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.repeated_group_all_types) {
        writer.writeMessage(
          21,
          msg.repeated_group_all_types,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeated_group_all_types,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (
    testCommentInjectionMessage: Partial<TestCommentInjectionMessage>
  ): Uint8Array {
    return TestCommentInjectionMessage._writeMessage(
      testCommentInjectionMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    reader: BinaryReader
  ): TestCommentInjectionMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */
  encode: function (fooRequest: Partial<FooRequest>): Uint8Array {
    return FooRequest._writeMessage(
      fooRequest,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */
  decode: function (bytes: ByteSource): FooRequest {
    return FooRequest._readMessage(
      FooRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FooRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooRequest, reader: BinaryReader): FooRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */
  encode: function (fooResponse: Partial<FooResponse>): Uint8Array {
    return FooResponse._writeMessage(
      fooResponse,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */
  decode: function (bytes: ByteSource): FooResponse {
    return FooResponse._readMessage(
      FooResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FooResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooResponse, reader: BinaryReader): FooResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */
  encode: function (fooClientMessage: Partial<FooClientMessage>): Uint8Array {
    return FooClientMessage._writeMessage(
      fooClientMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */
  decode: function (bytes: ByteSource): FooClientMessage {
    return FooClientMessage._readMessage(
      FooClientMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FooClientMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FooClientMessage,
    reader: BinaryReader
  ): FooClientMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */
  encode: function (fooServerMessage: Partial<FooServerMessage>): Uint8Array {
    return FooServerMessage._writeMessage(
      fooServerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */
  decode: function (bytes: ByteSource): FooServerMessage {
    return FooServerMessage._readMessage(
      FooServerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FooServerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FooServerMessage,
    reader: BinaryReader
  ): FooServerMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */
  encode: function (barRequest: Partial<BarRequest>): Uint8Array {
    return BarRequest._writeMessage(
      barRequest,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */
  decode: function (bytes: ByteSource): BarRequest {
    return BarRequest._readMessage(
      BarRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BarRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BarRequest, reader: BinaryReader): BarRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */
  encode: function (barResponse: Partial<BarResponse>): Uint8Array {
    return BarResponse._writeMessage(
      barResponse,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */
  decode: function (bytes: ByteSource): BarResponse {
    return BarResponse._readMessage(
      BarResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BarResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BarResponse, reader: BinaryReader): BarResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (testJsonName: Partial<TestJsonName>): Uint8Array {
    return TestJsonName._writeMessage(
      testJsonName,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes: ByteSource): TestJsonName {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      field_name1: 0,
      fieldName2: 0,
      FieldName3: 0,
      _field_name4: 0,
      FIELD_NAME5: 0,
      field_name6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestJsonName>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.field_name1) {
      writer.writeInt32(1, msg.field_name1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg._field_name4) {
      writer.writeInt32(4, msg._field_name4);
    }
    if (msg.FIELD_NAME5) {
      writer.writeInt32(5, msg.FIELD_NAME5);
    }
    if (msg.field_name6) {
      writer.writeInt32(6, msg.field_name6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestJsonName,
    reader: BinaryReader
  ): TestJsonName {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field_name1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg._field_name4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELD_NAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field_name6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (
    testHugeFieldNumbers: Partial<TestHugeFieldNumbers>
  ): Uint8Array {
    return TestHugeFieldNumbers._writeMessage(
      testHugeFieldNumbers,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes: ByteSource): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optional_int32: 0,
      fixed_32: 0,
      repeated_int32: [],
      packed_int32: [],
      optional_enum: 0,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_message: ForeignMessage.initialize(),
      string_string_map: {},
      oneof_test_all_types: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_int32) {
      writer.writeInt32(536870000, msg.optional_int32);
    }
    if (msg.fixed_32) {
      writer.writeInt32(536870001, msg.fixed_32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeated_int32);
    }
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packed_int32);
    }
    if (msg.optional_enum) {
      writer.writeEnum(536870004, msg.optional_enum);
    }
    if (msg.optional_string) {
      writer.writeString(536870005, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(536870006, msg.optional_bytes);
    }
    if (msg.optional_message) {
      writer.writeMessage(
        536870007,
        msg.optional_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.string_string_map) {
      for (const key in msg.string_string_map) {
        writer.writeMessage(536870010, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeString(2, msg.string_string_map![key]);
        });
      }
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(536870011, msg.oneof_uint32);
    }
    if (msg.oneof_test_all_types != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneof_test_all_types,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(536870013, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(536870014, msg.oneof_bytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    reader: BinaryReader
  ): TestHugeFieldNumbers {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed_32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optional_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 536870005: {
          msg.optional_string = reader.readString();
          break;
        }
        case 536870006: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optional_message, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.string_string_map[key] = value;
            }
          });
          break;
        }
        case 536870011: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(
            msg.oneof_test_all_types,
            TestAllTypes._readMessage
          );
          break;
        }
        case 536870013: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Uint8Array {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        group_a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.group_a) {
        writer.writeInt32(536870009, msg.group_a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      reader: BinaryReader
    ): TestHugeFieldNumbers.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.group_a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (
    testExtensionInsideTable: Partial<TestExtensionInsideTable>
  ): Uint8Array {
    return TestExtensionInsideTable._writeMessage(
      testExtensionInsideTable,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    reader: BinaryReader
  ): TestExtensionInsideTable {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (
    testExtensionRangeSerialize: Partial<TestExtensionRangeSerialize>
  ): Uint8Array {
    return TestExtensionRangeSerialize._writeMessage(
      testExtensionRangeSerialize,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      foo_one: 0,
      foo_two: 0,
      foo_three: 0,
      foo_four: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foo_one) {
      writer.writeInt32(1, msg.foo_one);
    }
    if (msg.foo_two) {
      writer.writeInt32(6, msg.foo_two);
    }
    if (msg.foo_three) {
      writer.writeInt32(7, msg.foo_three);
    }
    if (msg.foo_four) {
      writer.writeInt32(13, msg.foo_four);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    reader: BinaryReader
  ): TestExtensionRangeSerialize {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_one = reader.readInt32();
          break;
        }
        case 6: {
          msg.foo_two = reader.readInt32();
          break;
        }
        case 7: {
          msg.foo_three = reader.readInt32();
          break;
        }
        case 13: {
          msg.foo_four = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/map_unittest.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type MapEnum = typeof MapEnum[keyof typeof MapEnum];

/**
 * Tests maps.
 */
export interface TestMap {
  map_int32_int32: Record<number, number | undefined>;
  map_int64_int64: Record<string, string | undefined>;
  map_uint32_uint32: Record<number, number | undefined>;
  map_uint64_uint64: Record<string, string | undefined>;
  map_sint32_sint32: Record<number, number | undefined>;
  map_sint64_sint64: Record<string, string | undefined>;
  map_fixed32_fixed32: Record<number, number | undefined>;
  map_fixed64_fixed64: Record<string, string | undefined>;
  map_sfixed32_sfixed32: Record<number, number | undefined>;
  map_sfixed64_sfixed64: Record<string, string | undefined>;
  map_int32_float: Record<number, number | undefined>;
  map_int32_double: Record<number, number | undefined>;
  map_bool_bool: Record<boolean, boolean | undefined>;
  map_string_string: Record<string, string | undefined>;
  map_int32_bytes: Record<number, Uint8Array | undefined>;
  map_int32_enum: Record<number, MapEnum | undefined>;
  map_int32_foreign_message: Record<number, ForeignMessage | undefined>;
  map_string_foreign_message: Record<string, ForeignMessage | undefined>;
  map_int32_all_types: Record<number, TestAllTypes | undefined>;
}

export interface TestMapSubmessage {
  test_map: TestMap;
}

export interface TestMessageMap {
  map_int32_message: Record<number, TestAllTypes | undefined>;
}

/**
 * Two map fields share the same entry default instance.
 */
export interface TestSameTypeMap {
  map1: Record<number, number | undefined>;
  map2: Record<number, number | undefined>;
}

/**
 * Test embedded message with required fields
 */
export interface TestRequiredMessageMap {
  map_field: Record<number, TestRequired | undefined>;
}

export interface TestArenaMap {
  map_int32_int32: Record<number, number | undefined>;
  map_int64_int64: Record<string, string | undefined>;
  map_uint32_uint32: Record<number, number | undefined>;
  map_uint64_uint64: Record<string, string | undefined>;
  map_sint32_sint32: Record<number, number | undefined>;
  map_sint64_sint64: Record<string, string | undefined>;
  map_fixed32_fixed32: Record<number, number | undefined>;
  map_fixed64_fixed64: Record<string, string | undefined>;
  map_sfixed32_sfixed32: Record<number, number | undefined>;
  map_sfixed64_sfixed64: Record<string, string | undefined>;
  map_int32_float: Record<number, number | undefined>;
  map_int32_double: Record<number, number | undefined>;
  map_bool_bool: Record<boolean, boolean | undefined>;
  map_string_string: Record<string, string | undefined>;
  map_int32_bytes: Record<number, Uint8Array | undefined>;
  map_int32_enum: Record<number, MapEnum | undefined>;
  map_int32_foreign_message: Record<number, ForeignMessage | undefined>;
}

/**
 * Previously, message cannot contain map field called \\"entry\\".
 */
export interface MessageContainingMapCalledEntry {
  entry: Record<number, number | undefined>;
}

export interface TestRecursiveMapMessage {
  a: Record<string, TestRecursiveMapMessage | undefined>;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: 0,
  MAP_ENUM_BAR: 1,
  MAP_ENUM_BAZ: 2,
} as const;

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (testMap: Partial<TestMap>): Uint8Array {
    return TestMap._writeMessage(testMap, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMap {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
      map_string_foreign_message: {},
      map_int32_all_types: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.map_int32_int32![key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key as unknown as string);
          mapWriter.writeInt64String(2, msg.map_int64_int64![key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key as unknown as number);
          mapWriter.writeUint32(2, msg.map_uint32_uint32![key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key as unknown as string);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64![key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key as unknown as number);
          mapWriter.writeSint32(2, msg.map_sint32_sint32![key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key as unknown as string);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64![key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key as unknown as number);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32![key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key as unknown as string);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64![key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key as unknown as number);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32![key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key as unknown as string);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64![key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeFloat(2, msg.map_int32_float![key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeDouble(2, msg.map_int32_double![key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key as unknown as boolean);
          mapWriter.writeBool(2, msg.map_bool_bool![key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeString(2, msg.map_string_string![key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeBytes(2, msg.map_int32_bytes![key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeEnum(2, msg.map_int32_enum![key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message![key]);
        });
      }
    }
    if (msg.map_string_foreign_message) {
      for (const key in msg.map_string_foreign_message) {
        writer.writeMessage(18, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeMessage(2, msg.map_string_foreign_message![key]);
        });
      }
    }
    if (msg.map_int32_all_types) {
      for (const key in msg.map_int32_all_types) {
        writer.writeMessage(19, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.map_int32_all_types![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, reader: BinaryReader): TestMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int64_int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint32_uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint64_uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint32_sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint64_sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed32_fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed64_fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed32_sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed64_sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean | undefined;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.map_bool_bool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.map_string_string[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_foreign_message[key] = value;
            }
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_string_foreign_message[key] = value;
            }
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_all_types[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (testMapSubmessage: Partial<TestMapSubmessage>): Uint8Array {
    return TestMapSubmessage._writeMessage(
      testMapSubmessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestMapSubmessage {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      test_map: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMapSubmessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.test_map) {
      writer.writeMessage(1, msg.test_map, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    reader: BinaryReader
  ): TestMapSubmessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.test_map, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (testMessageMap: Partial<TestMessageMap>): Uint8Array {
    return TestMessageMap._writeMessage(
      testMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageMap {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      map_int32_message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map_int32_message) {
      for (const key in msg.map_int32_message) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.map_int32_message![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageMap,
    reader: BinaryReader
  ): TestMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (testSameTypeMap: Partial<TestSameTypeMap>): Uint8Array {
    return TestSameTypeMap._writeMessage(
      testSameTypeMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestSameTypeMap {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestSameTypeMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map1) {
      for (const key in msg.map1) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.map1![key]);
        });
      }
    }
    if (msg.map2) {
      for (const key in msg.map2) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.map2![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestSameTypeMap,
    reader: BinaryReader
  ): TestSameTypeMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map1[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map2[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (
    testRequiredMessageMap: Partial<TestRequiredMessageMap>
  ): Uint8Array {
    return TestRequiredMessageMap._writeMessage(
      testRequiredMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      map_field: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map_field) {
      for (const key in msg.map_field) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.map_field![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    reader: BinaryReader
  ): TestRequiredMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_field[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (testArenaMap: Partial<TestArenaMap>): Uint8Array {
    return TestArenaMap._writeMessage(
      testArenaMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestArenaMap {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestArenaMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.map_int32_int32![key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key as unknown as string);
          mapWriter.writeInt64String(2, msg.map_int64_int64![key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key as unknown as number);
          mapWriter.writeUint32(2, msg.map_uint32_uint32![key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key as unknown as string);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64![key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key as unknown as number);
          mapWriter.writeSint32(2, msg.map_sint32_sint32![key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key as unknown as string);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64![key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key as unknown as number);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32![key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key as unknown as string);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64![key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key as unknown as number);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32![key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key as unknown as string);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64![key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeFloat(2, msg.map_int32_float![key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeDouble(2, msg.map_int32_double![key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key as unknown as boolean);
          mapWriter.writeBool(2, msg.map_bool_bool![key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeString(2, msg.map_string_string![key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeBytes(2, msg.map_int32_bytes![key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeEnum(2, msg.map_int32_enum![key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestArenaMap,
    reader: BinaryReader
  ): TestArenaMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int64_int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint32_uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint64_uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint32_sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint64_sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed32_fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed64_fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed32_sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed64_sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean | undefined;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.map_bool_bool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.map_string_string[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_foreign_message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (
    messageContainingMapCalledEntry: Partial<MessageContainingMapCalledEntry>
  ): Uint8Array {
    return MessageContainingMapCalledEntry._writeMessage(
      messageContainingMapCalledEntry,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes: ByteSource): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.entry) {
      for (const key in msg.entry) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.entry![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    reader: BinaryReader
  ): MessageContainingMapCalledEntry {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.entry[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (
    testRecursiveMapMessage: Partial<TestRecursiveMapMessage>
  ): Uint8Array {
    return TestRecursiveMapMessage._writeMessage(
      testRecursiveMapMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      for (const key in msg.a) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeMessage(2, msg.a![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    reader: BinaryReader
  ): TestRecursiveMapMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.a[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_proto3.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optional_int32: number;
  optional_int64: string;
  optional_uint32: number;
  optional_uint64: string;
  optional_sint32: number;
  optional_sint64: string;
  optional_fixed32: number;
  optional_fixed64: string;
  optional_sfixed32: number;
  optional_sfixed64: string;
  optional_float: number;
  optional_double: number;
  optional_bool: boolean;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_nested_message: TestAllTypes.NestedMessage;
  optional_foreign_message: ForeignMessage;
  optional_import_message: ImportMessage;
  optional_nested_enum: TestAllTypes.NestedEnum;
  optional_foreign_enum: ForeignEnum;
  optional_string_piece: string;
  optional_cord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optional_public_import_message: PublicImportMessage;
  optional_lazy_message: TestAllTypes.NestedMessage;
  optional_lazy_import_message: ImportMessage;
  /**
   * Repeated
   */
  repeated_int32: number[];
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_string: string[];
  repeated_bytes: Uint8Array[];
  repeated_nested_message: TestAllTypes.NestedMessage[];
  repeated_foreign_message: ForeignMessage[];
  repeated_import_message: ImportMessage[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
  repeated_foreign_enum: ForeignEnum[];
  repeated_string_piece: string[];
  repeated_cord: string[];
  repeated_lazy_message: TestAllTypes.NestedMessage[];
  oneof_uint32?: number;
  oneof_nested_message?: TestAllTypes.NestedMessage;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packed_int32: number[];
  packed_int64: string[];
  packed_uint32: number[];
  packed_uint64: string[];
  packed_sint32: number[];
  packed_sint64: string[];
  packed_fixed32: number[];
  packed_fixed64: string[];
  packed_sfixed32: number[];
  packed_sfixed64: string[];
  packed_float: number[];
  packed_double: number[];
  packed_bool: boolean[];
  packed_enum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeated_int32: number[];
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  foo_enum?: TestOneof2.NestedEnum;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.initialize(),
      optional_foreign_message: ForeignMessage.initialize(),
      optional_import_message: ImportMessage.initialize(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.initialize(),
      optional_lazy_message: TestAllTypes.NestedMessage.initialize(),
      optional_lazy_import_message: ImportMessage.initialize(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      oneof_nested_message: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optional_lazy_import_message) {
      writer.writeMessage(
        115,
        msg.optional_lazy_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optional_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optional_foreign_message,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optional_import_message,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optional_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optional_public_import_message,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optional_lazy_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optional_lazy_import_message,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          msg.repeated_nested_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 49: {
          msg.repeated_foreign_message.push(
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            )
          );
          break;
        }
        case 50: {
          msg.repeated_import_message.push(
            reader.readMessage(
              ImportMessage.initialize(),
              ImportMessage._readMessage
            )
          );
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          msg.repeated_lazy_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneof_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_nested_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(1, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(11, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(12, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(13, msg.repeated_bool);
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(14, msg.repeated_nested_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (testEmptyMessage: Partial<TestEmptyMessage>): Uint8Array {
    return TestEmptyMessage._writeMessage(
      testEmptyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEmptyMessage {
    return TestEmptyMessage._readMessage(
      TestEmptyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEmptyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEmptyMessage,
    reader: BinaryReader
  ): TestEmptyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (
    testMessageWithDummy: Partial<TestMessageWithDummy>
  ): Uint8Array {
    return TestMessageWithDummy._writeMessage(
      testMessageWithDummy,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageWithDummy {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageWithDummy>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    reader: BinaryReader
  ): TestMessageWithDummy {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.foo_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 } as const,
};
",
      ],
    ],
  ],
  "arrayIndexOffset_": -1,
  "convertedPrimitiveFields_": Object {},
  "messageId_": undefined,
  "pivot_": 1.7976931348623157e+308,
  "wrappers_": Object {
    "15": Array [
      Object {
        "array": Array [
          "google/protobuf/unittest_import_public.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export interface PublicImportMessage {
  e: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (
    publicImportMessage: Partial<PublicImportMessage>
  ): Uint8Array {
    return PublicImportMessage._writeMessage(
      publicImportMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): PublicImportMessage {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PublicImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PublicImportMessage,
    reader: BinaryReader
  ): PublicImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_import.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = typeof ImportEnum[keyof typeof ImportEnum];

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap =
  typeof ImportEnumForMap[keyof typeof ImportEnumForMap];

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: 7,
  IMPORT_BAR: 8,
  IMPORT_BAZ: 9,
} as const;

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 } as const;

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (importMessage: Partial<ImportMessage>): Uint8Array {
    return ImportMessage._writeMessage(
      importMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ImportMessage {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ImportMessage,
    reader: BinaryReader
  ): ImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await JSONrequest<FooResponse>(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await JSONrequest<BarResponse>(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

//========================================//
//          TestService Service           //
//========================================//

export interface TestServiceService<Context = unknown> {
  Foo: (
    fooRequest: FooRequest,
    context: Context
  ) => Promise<FooResponse> | FooResponse;
  Bar: (
    barRequest: BarRequest,
    context: Context
  ) => Promise<BarResponse> | BarResponse;
}

export function createTestServiceHandler<Context>(
  service: TestServiceService<Context>
) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * Test an enum that has multiple values with the same number.
 */
export type TestEnumWithDupValue =
  typeof TestEnumWithDupValue[keyof typeof TestEnumWithDupValue];

/**
 * Test an enum with large, unordered values.
 */
export type TestSparseEnum = typeof TestSparseEnum[keyof typeof TestSparseEnum];

export type VeryLargeEnum = typeof VeryLargeEnum[keyof typeof VeryLargeEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optional_int32: number;
  optional_int64: string;
  optional_uint32: number;
  optional_uint64: string;
  optional_sint32: number;
  optional_sint64: string;
  optional_fixed32: number;
  optional_fixed64: string;
  optional_sfixed32: number;
  optional_sfixed64: string;
  optional_float: number;
  optional_double: number;
  optional_bool: boolean;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_nested_message: TestAllTypes.NestedMessage;
  optional_foreign_message: ForeignMessage;
  optional_import_message: ImportMessage;
  optional_nested_enum: TestAllTypes.NestedEnum;
  optional_foreign_enum: ForeignEnum;
  optional_import_enum: ImportEnum;
  optional_string_piece: string;
  optional_cord: string;
  optional_public_import_message: PublicImportMessage;
  /**
   * Defined in unittest_import_public.proto
   */
  optional_lazy_message: TestAllTypes.NestedMessage;
  repeated_int32: number[];
  /**
   * Repeated
   */
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_string: string[];
  repeated_bytes: Uint8Array[];
  repeated_nested_message: TestAllTypes.NestedMessage[];
  repeated_foreign_message: ForeignMessage[];
  repeated_import_message: ImportMessage[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
  repeated_foreign_enum: ForeignEnum[];
  repeated_import_enum: ImportEnum[];
  repeated_string_piece: string[];
  repeated_cord: string[];
  repeated_lazy_message: TestAllTypes.NestedMessage[];
  default_int32: number;
  default_int64: string;
  /**
   * Singular with defaults
   */
  default_uint32: number;
  default_uint64: string;
  default_sint32: number;
  default_sint64: string;
  default_fixed32: number;
  default_fixed64: string;
  default_sfixed32: number;
  default_sfixed64: string;
  default_float: number;
  default_double: number;
  default_bool: boolean;
  default_string: string;
  default_bytes: Uint8Array;
  default_nested_enum: TestAllTypes.NestedEnum;
  default_foreign_enum: ForeignEnum;
  default_import_enum: ImportEnum;
  default_string_piece: string;
  default_cord: string;
  oneof_uint32?: number;
  oneof_nested_message?: TestAllTypes.NestedMessage;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }

  export interface OptionalGroup {
    a: number;
  }

  export interface RepeatedGroup {
    a: number;
  }
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
  repeated_child: NestedTestAllTypes[];
}

export interface TestDeprecatedFields {
  deprecated_int32: number;
  deprecated_int32_in_oneof?: number;
}

export interface TestDeprecatedMessage {}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
  d: number;
}

export interface TestReservedFields {}

export interface TestAllExtensions {}

export interface OptionalGroup_extension {
  a: number;
}

export interface RepeatedGroup_extension {
  a: number;
}

export interface TestGroup {
  optional_foreign_enum: ForeignEnum;
}

export namespace TestGroup {
  export interface OptionalGroup {
    a: number;
  }
}

export interface TestGroupExtension {}

export interface TestNestedExtension {}

export namespace TestNestedExtension {
  export interface OptionalGroup_extension {
    a: number;
  }
}

export interface TestChildExtension {
  a: string;
  b: string;
  optional_extension: TestAllExtensions;
}

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 */
export interface TestRequired {
  a: number;
  dummy2: number;
  b: number;
  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   */
  dummy4: number;
  dummy5: number;
  dummy6: number;
  dummy7: number;
  dummy8: number;
  dummy9: number;
  dummy10: number;
  dummy11: number;
  dummy12: number;
  dummy13: number;
  dummy14: number;
  dummy15: number;
  dummy16: number;
  dummy17: number;
  dummy18: number;
  dummy19: number;
  dummy20: number;
  dummy21: number;
  dummy22: number;
  dummy23: number;
  dummy24: number;
  dummy25: number;
  dummy26: number;
  dummy27: number;
  dummy28: number;
  dummy29: number;
  dummy30: number;
  dummy31: number;
  dummy32: number;
  c: number;
}

export interface TestRequiredForeign {
  optional_message: TestRequired;
  repeated_message: TestRequired[];
  dummy: number;
}

export interface TestRequiredMessage {
  optional_message: TestRequired;
  repeated_message: TestRequired[];
  required_message: TestRequired;
}

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 */
export interface TestForeignNested {
  foreign_nested: TestAllTypes.NestedMessage;
}

/**
 * TestEmptyMessage is used to test unknown field support.
 */
export interface TestEmptyMessage {}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 */
export interface TestEmptyMessageWithExtensions {}

/**
 * Needed for a Python test.
 */
export interface TestPickleNestedMessage {}

export namespace TestPickleNestedMessage {
  export interface NestedMessage {
    bb: number;
  }

  export namespace NestedMessage {
    export interface NestedNestedMessage {
      cc: number;
    }
  }
}

export interface TestMultipleExtensionRanges {}

/**
 * Test that really large tag numbers don't break anything.
 */
export interface TestReallyLargeTagNumber {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   */
  a: number;
  bb: number;
}

export interface TestRecursiveMessage {
  a: TestRecursiveMessage;
  i: number;
}

/**
 * Test that mutual recursion works.
 */
export interface TestMutualRecursionA {
  bb: TestMutualRecursionB;
}

export namespace TestMutualRecursionA {
  export interface SubMessage {
    b: TestMutualRecursionB;
  }

  export interface SubGroup {
    sub_message: TestMutualRecursionA.SubMessage;
    not_in_this_scc: TestAllTypes;
  }
}

export interface TestMutualRecursionB {
  a: TestMutualRecursionA;
  optional_int32: number;
}

export interface TestIsInitialized {
  sub_message: TestIsInitialized.SubMessage;
}

export namespace TestIsInitialized {
  export interface SubMessage {}

  export namespace SubMessage {
    export interface SubGroup {
      i: number;
    }
  }
}

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 */
export interface TestDupFieldNumber {
  a: number;
}

export namespace TestDupFieldNumber {
  export interface Foo {
    a: number;
  }

  export interface Bar {
    a: number;
  }
}

/**
 * Additional messages for testing lazy fields.
 */
export interface TestEagerMessage {
  sub_message: TestAllTypes;
}

export interface TestLazyMessage {
  sub_message: TestAllTypes;
}

/**
 * Needed for a Python test.
 */
export interface TestNestedMessageHasBits {
  optional_nested_message: TestNestedMessageHasBits.NestedMessage;
}

export namespace TestNestedMessageHasBits {
  export interface NestedMessage {
    nestedmessage_repeated_int32: number[];
    nestedmessage_repeated_foreignmessage: ForeignMessage[];
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 */
export interface TestCamelCaseFieldNames {
  PrimitiveField: number;
  StringField: string;
  EnumField: ForeignEnum;
  MessageField: ForeignMessage;
  StringPieceField: string;
  CordField: string;
  RepeatedPrimitiveField: number[];
  RepeatedStringField: string[];
  RepeatedEnumField: ForeignEnum[];
  RepeatedMessageField: ForeignMessage[];
  RepeatedStringPieceField: string[];
  RepeatedCordField: string[];
}

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 */
export interface TestFieldOrderings {
  my_string: string;
  my_int: string;
  my_float: number;
  optional_nested_message: TestFieldOrderings.NestedMessage;
}

export namespace TestFieldOrderings {
  export interface NestedMessage {
    oo: string;
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestExtensionOrderings1 {
  my_string: string;
}

export interface TestExtensionOrderings2 {
  my_string: string;
}

export namespace TestExtensionOrderings2 {
  export interface TestExtensionOrderings3 {
    my_string: string;
  }
}

export interface TestExtremeDefaultValues {
  escaped_bytes: Uint8Array;
  large_uint32: number;
  large_uint64: string;
  small_int32: number;
  small_int64: string;
  really_small_int32: number;
  really_small_int64: string;
  /**
   * The default value here is UTF-8 for \\"\\\\u1234\\".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   */
  utf8_string: string;
  /**
   * Tests for single-precision floating-point values.
   */
  zero_float: number;
  one_float: number;
  small_float: number;
  negative_one_float: number;
  negative_float: number;
  /**
   * Using exponents
   */
  large_float: number;
  small_negative_float: number;
  /**
   * Text for nonfinite floating-point values.
   */
  inf_double: number;
  neg_inf_double: number;
  nan_double: number;
  inf_float: number;
  neg_inf_float: number;
  nan_float: number;
  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, \\"\\\\?\\" is a valid way to escape ? in string
   * literals.
   */
  cpp_trigraph: string;
  /**
   * String defaults containing the character '\\\\000'
   */
  string_with_zero: string;
  bytes_with_zero: Uint8Array;
  string_piece_with_zero: string;
  cord_with_zero: string;
  replacement_string: string;
}

export interface SparseEnumMessage {
  sparse_enum: TestSparseEnum;
}

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 */
export interface OneString {
  data: string;
}

export interface MoreString {
  data: string[];
}

export interface OneBytes {
  data: Uint8Array;
}

export interface MoreBytes {
  data: Uint8Array[];
}

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 */
export interface Int32Message {
  data: number;
}

export interface Uint32Message {
  data: number;
}

export interface Int64Message {
  data: string;
}

export interface Uint64Message {
  data: string;
}

export interface BoolMessage {
  data: boolean;
}

/**
 * Test oneofs.
 */
export interface TestOneof {
  foo_int?: number;
  foo_string?: string;
  foo_message?: TestAllTypes;
}

export namespace TestOneof {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneofBackwardsCompatible {
  foo_int: number;
  foo_string: string;
  foo_message: TestAllTypes;
}

export namespace TestOneofBackwardsCompatible {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneof2 {
  foo_int?: number;
  foo_string?: string;
  foo_cord?: string;
  foo_string_piece?: string;
  foo_bytes?: Uint8Array;
  foo_enum?: TestOneof2.NestedEnum;
  foo_message?: TestOneof2.NestedMessage;
  foo_lazy_message?: TestOneof2.NestedMessage;
  bar_int?: number;
  bar_string?: string;
  bar_cord?: string;
  bar_string_piece?: string;
  bar_bytes?: Uint8Array;
  bar_enum?: TestOneof2.NestedEnum;
  bar_string_with_empty_default?: string;
  bar_cord_with_empty_default?: string;
  bar_string_piece_with_empty_default?: string;
  bar_bytes_with_empty_default?: Uint8Array;
  baz_int: number;
  baz_string: string;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];

  export interface FooGroup {
    a: number;
    b: string;
  }

  export interface NestedMessage {
    qux_int: string;
    corge_int: number[];
  }
}

export interface TestRequiredOneof {
  foo_int?: number;
  foo_string?: string;
  foo_message?: TestRequiredOneof.NestedMessage;
}

export namespace TestRequiredOneof {
  export interface NestedMessage {
    required_double: number;
  }
}

export interface TestPackedTypes {
  packed_int32: number[];
  packed_int64: string[];
  packed_uint32: number[];
  packed_uint64: string[];
  packed_sint32: number[];
  packed_sint64: string[];
  packed_fixed32: number[];
  packed_fixed64: string[];
  packed_sfixed32: number[];
  packed_sfixed64: string[];
  packed_float: number[];
  packed_double: number[];
  packed_bool: boolean[];
  packed_enum: ForeignEnum[];
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 */
export interface TestUnpackedTypes {
  unpacked_int32: number[];
  unpacked_int64: string[];
  unpacked_uint32: number[];
  unpacked_uint64: string[];
  unpacked_sint32: number[];
  unpacked_sint64: string[];
  unpacked_fixed32: number[];
  unpacked_fixed64: string[];
  unpacked_sfixed32: number[];
  unpacked_sfixed64: string[];
  unpacked_float: number[];
  unpacked_double: number[];
  unpacked_bool: boolean[];
  unpacked_enum: ForeignEnum[];
}

export interface TestPackedExtensions {}

export interface TestUnpackedExtensions {}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 */
export interface TestDynamicExtensions {
  scalar_extension: number;
  enum_extension: ForeignEnum;
  dynamic_enum_extension: TestDynamicExtensions.DynamicEnumType;
  message_extension: ForeignMessage;
  dynamic_message_extension: TestDynamicExtensions.DynamicMessageType;
  repeated_extension: string[];
  packed_extension: number[];
}

export namespace TestDynamicExtensions {
  export type DynamicEnumType =
    typeof TestDynamicExtensions.DynamicEnumType[keyof typeof TestDynamicExtensions.DynamicEnumType];

  export interface DynamicMessageType {
    dynamic_field: number;
  }
}

export interface TestRepeatedScalarDifferentTagSizes {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   */
  repeated_fixed32: number[];
  /**
   * Check for a varint type, just for good measure.
   */
  repeated_int32: number[];
  /**
   * These have two-byte tags.
   */
  repeated_fixed64: string[];
  repeated_int64: string[];
  /**
   * Three byte tags.
   */
  repeated_float: number[];
  repeated_uint64: string[];
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 */
export interface TestParsingMerge {
  required_all_types: TestAllTypes;
  optional_all_types: TestAllTypes;
  repeated_all_types: TestAllTypes[];
}

export namespace TestParsingMerge {
  /**
   * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
   * except that all fields are repeated. In the tests, we will serialize the
   * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
   * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
   * the corresponding required/optional fields in TestParsingMerge.
   */
  export interface RepeatedFieldsGenerator {
    field1: TestAllTypes[];
    field2: TestAllTypes[];
    field3: TestAllTypes[];
    ext1: TestAllTypes[];
    ext2: TestAllTypes[];
  }

  export namespace RepeatedFieldsGenerator {
    export interface Group1 {
      field1: TestAllTypes;
    }

    export interface Group2 {
      field1: TestAllTypes;
    }
  }

  export interface OptionalGroup {
    optional_group_all_types: TestAllTypes;
  }

  export interface RepeatedGroup {
    repeated_group_all_types: TestAllTypes;
  }
}

export interface TestCommentInjectionMessage {
  /**
   * *\\\\/ <- This should not close the generated doc comment
   */
  a: string;
}

/**
 * Test that RPC services work.
 */
export interface FooRequest {}

export interface FooResponse {}

export interface FooClientMessage {}

export interface FooServerMessage {}

export interface BarRequest {}

export interface BarResponse {}

export interface TestJsonName {
  field_name1: number;
  fieldName2: number;
  FieldName3: number;
  _field_name4: number;
  FIELD_NAME5: number;
  field_name6: number;
  fieldname7: number;
}

export interface TestHugeFieldNumbers {
  optional_int32: number;
  fixed_32: number;
  repeated_int32: number[];
  packed_int32: number[];
  optional_enum: ForeignEnum;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_message: ForeignMessage;
  string_string_map: Record<string, string | undefined>;
  oneof_uint32?: number;
  oneof_test_all_types?: TestAllTypes;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestHugeFieldNumbers {
  export interface OptionalGroup {
    group_a: number;
  }
}

export interface TestExtensionInsideTable {
  field1: number;
  field2: number;
  field3: number;
  field4: number;
  field6: number;
  field7: number;
  field8: number;
  field9: number;
  field10: number;
}

export interface TestExtensionRangeSerialize {
  foo_one: number;
  foo_two: number;
  foo_three: number;
  foo_four: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
} as const;

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
} as const;

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
} as const;

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.initialize(),
      optional_foreign_message: ForeignMessage.initialize(),
      optional_import_message: ImportMessage.initialize(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_import_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.initialize(),
      optional_lazy_message: TestAllTypes.NestedMessage.initialize(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_import_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      default_int32: 0,
      default_int64: \\"\\",
      default_uint32: 0,
      default_uint64: \\"\\",
      default_sint32: 0,
      default_sint64: \\"\\",
      default_fixed32: 0,
      default_fixed64: \\"\\",
      default_sfixed32: 0,
      default_sfixed64: \\"\\",
      default_float: 0,
      default_double: 0,
      default_bool: false,
      default_string: \\"\\",
      default_bytes: new Uint8Array(),
      default_nested_enum: 0,
      default_foreign_enum: 0,
      default_import_enum: 0,
      default_string_piece: \\"\\",
      default_cord: \\"\\",
      oneof_nested_message: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_import_enum) {
      writer.writeEnum(23, msg.optional_import_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_import_enum?.length) {
      writer.writeRepeatedEnum(53, msg.repeated_import_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.default_int32) {
      writer.writeInt32(61, msg.default_int32);
    }
    if (msg.default_int64) {
      writer.writeInt64String(62, msg.default_int64);
    }
    if (msg.default_uint32) {
      writer.writeUint32(63, msg.default_uint32);
    }
    if (msg.default_uint64) {
      writer.writeUint64String(64, msg.default_uint64);
    }
    if (msg.default_sint32) {
      writer.writeSint32(65, msg.default_sint32);
    }
    if (msg.default_sint64) {
      writer.writeSint64String(66, msg.default_sint64);
    }
    if (msg.default_fixed32) {
      writer.writeFixed32(67, msg.default_fixed32);
    }
    if (msg.default_fixed64) {
      writer.writeFixed64String(68, msg.default_fixed64);
    }
    if (msg.default_sfixed32) {
      writer.writeSfixed32(69, msg.default_sfixed32);
    }
    if (msg.default_sfixed64) {
      writer.writeSfixed64(70, msg.default_sfixed64);
    }
    if (msg.default_float) {
      writer.writeFloat(71, msg.default_float);
    }
    if (msg.default_double) {
      writer.writeDouble(72, msg.default_double);
    }
    if (msg.default_bool) {
      writer.writeBool(73, msg.default_bool);
    }
    if (msg.default_string) {
      writer.writeString(74, msg.default_string);
    }
    if (msg.default_bytes) {
      writer.writeBytes(75, msg.default_bytes);
    }
    if (msg.default_nested_enum) {
      writer.writeEnum(81, msg.default_nested_enum);
    }
    if (msg.default_foreign_enum) {
      writer.writeEnum(82, msg.default_foreign_enum);
    }
    if (msg.default_import_enum) {
      writer.writeEnum(83, msg.default_import_enum);
    }
    if (msg.default_string_piece) {
      writer.writeString(84, msg.default_string_piece);
    }
    if (msg.default_cord) {
      writer.writeString(85, msg.default_cord);
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optional_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optional_foreign_message,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optional_import_message,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optional_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 23: {
          msg.optional_import_enum = reader.readEnum() as ImportEnum;
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optional_public_import_message,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optional_lazy_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          msg.repeated_nested_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 49: {
          msg.repeated_foreign_message.push(
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            )
          );
          break;
        }
        case 50: {
          msg.repeated_import_message.push(
            reader.readMessage(
              ImportMessage.initialize(),
              ImportMessage._readMessage
            )
          );
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 53: {
          msg.repeated_import_enum.push(reader.readEnum() as ImportEnum);
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          msg.repeated_lazy_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 61: {
          msg.default_int32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.default_int64 = reader.readInt64String();
          break;
        }
        case 63: {
          msg.default_uint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.default_uint64 = reader.readUint64String();
          break;
        }
        case 65: {
          msg.default_sint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.default_sint64 = reader.readSint64();
          break;
        }
        case 67: {
          msg.default_fixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.default_fixed64 = reader.readFixed64String();
          break;
        }
        case 69: {
          msg.default_sfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.default_sfixed64 = reader.readSfixed64();
          break;
        }
        case 71: {
          msg.default_float = reader.readFloat();
          break;
        }
        case 72: {
          msg.default_double = reader.readDouble();
          break;
        }
        case 73: {
          msg.default_bool = reader.readBool();
          break;
        }
        case 74: {
          msg.default_string = reader.readString();
          break;
        }
        case 75: {
          msg.default_bytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.default_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 82: {
          msg.default_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 83: {
          msg.default_import_enum = reader.readEnum() as ImportEnum;
          break;
        }
        case 84: {
          msg.default_string_piece = reader.readString();
          break;
        }
        case 85: {
          msg.default_cord = reader.readString();
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneof_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestAllTypes.OptionalGroup>
    ): Uint8Array {
      return TestAllTypes.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      reader: BinaryReader
    ): TestAllTypes.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (
      repeatedGroup: Partial<TestAllTypes.RepeatedGroup>
    ): Uint8Array {
      return TestAllTypes.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      reader: BinaryReader
    ): TestAllTypes.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeated_child: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeated_child?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_child as any,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          msg.repeated_child.push(
            reader.readMessage(
              NestedTestAllTypes.initialize(),
              NestedTestAllTypes._readMessage
            )
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (
    testDeprecatedFields: Partial<TestDeprecatedFields>
  ): Uint8Array {
    return TestDeprecatedFields._writeMessage(
      testDeprecatedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes: ByteSource): TestDeprecatedFields {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecated_int32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.deprecated_int32) {
      writer.writeInt32(1, msg.deprecated_int32);
    }
    if (msg.deprecated_int32_in_oneof != undefined) {
      writer.writeInt32(2, msg.deprecated_int32_in_oneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    reader: BinaryReader
  ): TestDeprecatedFields {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecated_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecated_int32_in_oneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */
  encode: function (
    testDeprecatedMessage: Partial<TestDeprecatedMessage>
  ): Uint8Array {
    return TestDeprecatedMessage._writeMessage(
      testDeprecatedMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestDeprecatedMessage {
    return TestDeprecatedMessage._readMessage(
      TestDeprecatedMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedMessage,
    reader: BinaryReader
  ): TestDeprecatedMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */
  encode: function (
    testReservedFields: Partial<TestReservedFields>
  ): Uint8Array {
    return TestReservedFields._writeMessage(
      testReservedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */
  decode: function (bytes: ByteSource): TestReservedFields {
    return TestReservedFields._readMessage(
      TestReservedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReservedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReservedFields,
    reader: BinaryReader
  ): TestReservedFields {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */
  encode: function (testAllExtensions: Partial<TestAllExtensions>): Uint8Array {
    return TestAllExtensions._writeMessage(
      testAllExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllExtensions {
    return TestAllExtensions._readMessage(
      TestAllExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllExtensions,
    reader: BinaryReader
  ): TestAllExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (
    optionalGroup_extension: Partial<OptionalGroup_extension>
  ): Uint8Array {
    return OptionalGroup_extension._writeMessage(
      optionalGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): OptionalGroup_extension {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OptionalGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    reader: BinaryReader
  ): OptionalGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (
    repeatedGroup_extension: Partial<RepeatedGroup_extension>
  ): Uint8Array {
    return RepeatedGroup_extension._writeMessage(
      repeatedGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    reader: BinaryReader
  ): RepeatedGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (testGroup: Partial<TestGroup>): Uint8Array {
    return TestGroup._writeMessage(
      testGroup,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes: ByteSource): TestGroup {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optional_foreign_enum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestGroup>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, reader: BinaryReader): TestGroup {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestGroup.OptionalGroup>
    ): Uint8Array {
      return TestGroup.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      reader: BinaryReader
    ): TestGroup.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */
  encode: function (
    testGroupExtension: Partial<TestGroupExtension>
  ): Uint8Array {
    return TestGroupExtension._writeMessage(
      testGroupExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestGroupExtension {
    return TestGroupExtension._readMessage(
      TestGroupExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestGroupExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestGroupExtension,
    reader: BinaryReader
  ): TestGroupExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */
  encode: function (
    testNestedExtension: Partial<TestNestedExtension>
  ): Uint8Array {
    return TestNestedExtension._writeMessage(
      testNestedExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestNestedExtension {
    return TestNestedExtension._readMessage(
      TestNestedExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedExtension,
    reader: BinaryReader
  ): TestNestedExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (
      optionalGroup_extension: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Uint8Array {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        optionalGroup_extension,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      reader: BinaryReader
    ): TestNestedExtension.OptionalGroup_extension {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (
    testChildExtension: Partial<TestChildExtension>
  ): Uint8Array {
    return TestChildExtension._writeMessage(
      testChildExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestChildExtension {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: \\"\\",
      b: \\"\\",
      optional_extension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestChildExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optional_extension) {
      writer.writeMessage(
        3,
        msg.optional_extension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    reader: BinaryReader
  ): TestChildExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optional_extension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (testRequired: Partial<TestRequired>): Uint8Array {
    return TestRequired._writeMessage(
      testRequired,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequired {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequired>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequired,
    reader: BinaryReader
  ): TestRequired {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (
    testRequiredForeign: Partial<TestRequiredForeign>
  ): Uint8Array {
    return TestRequiredForeign._writeMessage(
      testRequiredForeign,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredForeign {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optional_message: TestRequired.initialize(),
      repeated_message: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredForeign>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired._writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message as any,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    reader: BinaryReader
  ): TestRequiredForeign {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optional_message, TestRequired._readMessage);
          break;
        }
        case 2: {
          msg.repeated_message.push(
            reader.readMessage(
              TestRequired.initialize(),
              TestRequired._readMessage
            )
          );
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (
    testRequiredMessage: Partial<TestRequiredMessage>
  ): Uint8Array {
    return TestRequiredMessage._writeMessage(
      testRequiredMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessage {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optional_message: TestRequired.initialize(),
      repeated_message: [],
      required_message: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired._writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message as any,
        TestRequired._writeMessage
      );
    }
    if (msg.required_message) {
      writer.writeMessage(3, msg.required_message, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    reader: BinaryReader
  ): TestRequiredMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optional_message, TestRequired._readMessage);
          break;
        }
        case 2: {
          msg.repeated_message.push(
            reader.readMessage(
              TestRequired.initialize(),
              TestRequired._readMessage
            )
          );
          break;
        }
        case 3: {
          reader.readMessage(msg.required_message, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (testForeignNested: Partial<TestForeignNested>): Uint8Array {
    return TestForeignNested._writeMessage(
      testForeignNested,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes: ByteSource): TestForeignNested {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreign_nested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestForeignNested>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foreign_nested) {
      writer.writeMessage(
        1,
        msg.foreign_nested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    reader: BinaryReader
  ): TestForeignNested {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreign_nested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (testEmptyMessage: Partial<TestEmptyMessage>): Uint8Array {
    return TestEmptyMessage._writeMessage(
      testEmptyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEmptyMessage {
    return TestEmptyMessage._readMessage(
      TestEmptyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEmptyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEmptyMessage,
    reader: BinaryReader
  ): TestEmptyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (
    testEmptyMessageWithExtensions: Partial<TestEmptyMessageWithExtensions>
  ): Uint8Array {
    return TestEmptyMessageWithExtensions._writeMessage(
      testEmptyMessageWithExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestEmptyMessageWithExtensions {
    return TestEmptyMessageWithExtensions._readMessage(
      TestEmptyMessageWithExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEmptyMessageWithExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEmptyMessageWithExtensions,
    reader: BinaryReader
  ): TestEmptyMessageWithExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */
  encode: function (
    testPickleNestedMessage: Partial<TestPickleNestedMessage>
  ): Uint8Array {
    return TestPickleNestedMessage._writeMessage(
      testPickleNestedMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestPickleNestedMessage {
    return TestPickleNestedMessage._readMessage(
      TestPickleNestedMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPickleNestedMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPickleNestedMessage,
    reader: BinaryReader
  ): TestPickleNestedMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestPickleNestedMessage.NestedMessage>
    ): Uint8Array {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      reader: BinaryReader
    ): TestPickleNestedMessage.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (
        nestedNestedMessage: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Uint8Array {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          nestedNestedMessage,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        reader: BinaryReader
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */
  encode: function (
    testMultipleExtensionRanges: Partial<TestMultipleExtensionRanges>
  ): Uint8Array {
    return TestMultipleExtensionRanges._writeMessage(
      testMultipleExtensionRanges,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */
  decode: function (bytes: ByteSource): TestMultipleExtensionRanges {
    return TestMultipleExtensionRanges._readMessage(
      TestMultipleExtensionRanges.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMultipleExtensionRanges>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMultipleExtensionRanges,
    reader: BinaryReader
  ): TestMultipleExtensionRanges {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (
    testReallyLargeTagNumber: Partial<TestReallyLargeTagNumber>
  ): Uint8Array {
    return TestReallyLargeTagNumber._writeMessage(
      testReallyLargeTagNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    reader: BinaryReader
  ): TestReallyLargeTagNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (
    testRecursiveMessage: Partial<TestRecursiveMessage>
  ): Uint8Array {
    return TestRecursiveMessage._writeMessage(
      testRecursiveMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMessage {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    reader: BinaryReader
  ): TestRecursiveMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (
    testMutualRecursionA: Partial<TestMutualRecursionA>
  ): Uint8Array {
    return TestMutualRecursionA._writeMessage(
      testMutualRecursionA,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionA {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionA>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    reader: BinaryReader
  ): TestMutualRecursionA {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (
      subMessage: Partial<TestMutualRecursionA.SubMessage>
    ): Uint8Array {
      return TestMutualRecursionA.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      reader: BinaryReader
    ): TestMutualRecursionA.SubMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (
      subGroup: Partial<TestMutualRecursionA.SubGroup>
    ): Uint8Array {
      return TestMutualRecursionA.SubGroup._writeMessage(
        subGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        sub_message: TestMutualRecursionA.SubMessage.initialize(),
        not_in_this_scc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.sub_message) {
        writer.writeMessage(
          3,
          msg.sub_message,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.not_in_this_scc) {
        writer.writeMessage(4, msg.not_in_this_scc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      reader: BinaryReader
    ): TestMutualRecursionA.SubGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.sub_message,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.not_in_this_scc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (
    testMutualRecursionB: Partial<TestMutualRecursionB>
  ): Uint8Array {
    return TestMutualRecursionB._writeMessage(
      testMutualRecursionB,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionB {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionA.initialize(),
      optional_int32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionB>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optional_int32) {
      writer.writeInt32(2, msg.optional_int32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    reader: BinaryReader
  ): TestMutualRecursionB {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (testIsInitialized: Partial<TestIsInitialized>): Uint8Array {
    return TestIsInitialized._writeMessage(
      testIsInitialized,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes: ByteSource): TestIsInitialized {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      sub_message: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestIsInitialized>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sub_message) {
      writer.writeMessage(
        1,
        msg.sub_message,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    reader: BinaryReader
  ): TestIsInitialized {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.sub_message,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (
      subMessage: Partial<TestIsInitialized.SubMessage>
    ): Uint8Array {
      return TestIsInitialized.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestIsInitialized.SubMessage {
      return TestIsInitialized.SubMessage._readMessage(
        TestIsInitialized.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestIsInitialized.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestIsInitialized.SubMessage,
      reader: BinaryReader
    ): TestIsInitialized.SubMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (
        subGroup: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Uint8Array {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          subGroup,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        reader: BinaryReader
      ): TestIsInitialized.SubMessage.SubGroup {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (
    testDupFieldNumber: Partial<TestDupFieldNumber>
  ): Uint8Array {
    return TestDupFieldNumber._writeMessage(
      testDupFieldNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestDupFieldNumber {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDupFieldNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    reader: BinaryReader
  ): TestDupFieldNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (foo: Partial<TestDupFieldNumber.Foo>): Uint8Array {
      return TestDupFieldNumber.Foo._writeMessage(
        foo,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      reader: BinaryReader
    ): TestDupFieldNumber.Foo {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (bar: Partial<TestDupFieldNumber.Bar>): Uint8Array {
      return TestDupFieldNumber.Bar._writeMessage(
        bar,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      reader: BinaryReader
    ): TestDupFieldNumber.Bar {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (testEagerMessage: Partial<TestEagerMessage>): Uint8Array {
    return TestEagerMessage._writeMessage(
      testEagerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEagerMessage {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      sub_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEagerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEagerMessage,
    reader: BinaryReader
  ): TestEagerMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.sub_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (testLazyMessage: Partial<TestLazyMessage>): Uint8Array {
    return TestLazyMessage._writeMessage(
      testLazyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestLazyMessage {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      sub_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestLazyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestLazyMessage,
    reader: BinaryReader
  ): TestLazyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.sub_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (
    testNestedMessageHasBits: Partial<TestNestedMessageHasBits>
  ): Uint8Array {
    return TestNestedMessageHasBits._writeMessage(
      testNestedMessageHasBits,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes: ByteSource): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optional_nested_message:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_nested_message) {
      writer.writeMessage(
        1,
        msg.optional_nested_message,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    reader: BinaryReader
  ): TestNestedMessageHasBits {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optional_nested_message,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Uint8Array {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessage_repeated_int32: [],
        nestedmessage_repeated_foreignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.nestedmessage_repeated_int32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessage_repeated_int32);
      }
      if (msg.nestedmessage_repeated_foreignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessage_repeated_foreignmessage as any,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      reader: BinaryReader
    ): TestNestedMessageHasBits.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessage_repeated_int32.push(reader.readInt32());
            break;
          }
          case 2: {
            msg.nestedmessage_repeated_foreignmessage.push(
              reader.readMessage(
                ForeignMessage.initialize(),
                ForeignMessage._readMessage
              )
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (
    testCamelCaseFieldNames: Partial<TestCamelCaseFieldNames>
  ): Uint8Array {
    return TestCamelCaseFieldNames._writeMessage(
      testCamelCaseFieldNames,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes: ByteSource): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    reader: BinaryReader
  ): TestCamelCaseFieldNames {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum() as ForeignEnum;
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 10: {
          msg.RepeatedMessageField.push(
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            )
          );
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (
    testFieldOrderings: Partial<TestFieldOrderings>
  ): Uint8Array {
    return TestFieldOrderings._writeMessage(
      testFieldOrderings,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes: ByteSource): TestFieldOrderings {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      my_string: \\"\\",
      my_int: \\"\\",
      my_float: 0,
      optional_nested_message: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestFieldOrderings>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.my_string) {
      writer.writeString(11, msg.my_string);
    }
    if (msg.my_int) {
      writer.writeInt64String(1, msg.my_int);
    }
    if (msg.my_float) {
      writer.writeFloat(101, msg.my_float);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        200,
        msg.optional_nested_message,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    reader: BinaryReader
  ): TestFieldOrderings {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.my_string = reader.readString();
          break;
        }
        case 1: {
          msg.my_int = reader.readInt64String();
          break;
        }
        case 101: {
          msg.my_float = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optional_nested_message,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestFieldOrderings.NestedMessage>
    ): Uint8Array {
      return TestFieldOrderings.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: \\"\\",
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      reader: BinaryReader
    ): TestFieldOrderings.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = reader.readInt64String();
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (
    testExtensionOrderings1: Partial<TestExtensionOrderings1>
  ): Uint8Array {
    return TestExtensionOrderings1._writeMessage(
      testExtensionOrderings1,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      my_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    reader: BinaryReader
  ): TestExtensionOrderings1 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (
    testExtensionOrderings2: Partial<TestExtensionOrderings2>
  ): Uint8Array {
    return TestExtensionOrderings2._writeMessage(
      testExtensionOrderings2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      my_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    reader: BinaryReader
  ): TestExtensionOrderings2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (
      testExtensionOrderings3: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Uint8Array {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        testExtensionOrderings3,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        my_string: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.my_string) {
        writer.writeString(1, msg.my_string);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      reader: BinaryReader
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.my_string = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (
    testExtremeDefaultValues: Partial<TestExtremeDefaultValues>
  ): Uint8Array {
    return TestExtremeDefaultValues._writeMessage(
      testExtremeDefaultValues,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escaped_bytes: new Uint8Array(),
      large_uint32: 0,
      large_uint64: \\"\\",
      small_int32: 0,
      small_int64: \\"\\",
      really_small_int32: 0,
      really_small_int64: \\"\\",
      utf8_string: \\"\\",
      zero_float: 0,
      one_float: 0,
      small_float: 0,
      negative_one_float: 0,
      negative_float: 0,
      large_float: 0,
      small_negative_float: 0,
      inf_double: 0,
      neg_inf_double: 0,
      nan_double: 0,
      inf_float: 0,
      neg_inf_float: 0,
      nan_float: 0,
      cpp_trigraph: \\"\\",
      string_with_zero: \\"\\",
      bytes_with_zero: new Uint8Array(),
      string_piece_with_zero: \\"\\",
      cord_with_zero: \\"\\",
      replacement_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.escaped_bytes) {
      writer.writeBytes(1, msg.escaped_bytes);
    }
    if (msg.large_uint32) {
      writer.writeUint32(2, msg.large_uint32);
    }
    if (msg.large_uint64) {
      writer.writeUint64String(3, msg.large_uint64);
    }
    if (msg.small_int32) {
      writer.writeInt32(4, msg.small_int32);
    }
    if (msg.small_int64) {
      writer.writeInt64String(5, msg.small_int64);
    }
    if (msg.really_small_int32) {
      writer.writeInt32(21, msg.really_small_int32);
    }
    if (msg.really_small_int64) {
      writer.writeInt64String(22, msg.really_small_int64);
    }
    if (msg.utf8_string) {
      writer.writeString(6, msg.utf8_string);
    }
    if (msg.zero_float) {
      writer.writeFloat(7, msg.zero_float);
    }
    if (msg.one_float) {
      writer.writeFloat(8, msg.one_float);
    }
    if (msg.small_float) {
      writer.writeFloat(9, msg.small_float);
    }
    if (msg.negative_one_float) {
      writer.writeFloat(10, msg.negative_one_float);
    }
    if (msg.negative_float) {
      writer.writeFloat(11, msg.negative_float);
    }
    if (msg.large_float) {
      writer.writeFloat(12, msg.large_float);
    }
    if (msg.small_negative_float) {
      writer.writeFloat(13, msg.small_negative_float);
    }
    if (msg.inf_double) {
      writer.writeDouble(14, msg.inf_double);
    }
    if (msg.neg_inf_double) {
      writer.writeDouble(15, msg.neg_inf_double);
    }
    if (msg.nan_double) {
      writer.writeDouble(16, msg.nan_double);
    }
    if (msg.inf_float) {
      writer.writeFloat(17, msg.inf_float);
    }
    if (msg.neg_inf_float) {
      writer.writeFloat(18, msg.neg_inf_float);
    }
    if (msg.nan_float) {
      writer.writeFloat(19, msg.nan_float);
    }
    if (msg.cpp_trigraph) {
      writer.writeString(20, msg.cpp_trigraph);
    }
    if (msg.string_with_zero) {
      writer.writeString(23, msg.string_with_zero);
    }
    if (msg.bytes_with_zero) {
      writer.writeBytes(24, msg.bytes_with_zero);
    }
    if (msg.string_piece_with_zero) {
      writer.writeString(25, msg.string_piece_with_zero);
    }
    if (msg.cord_with_zero) {
      writer.writeString(26, msg.cord_with_zero);
    }
    if (msg.replacement_string) {
      writer.writeString(27, msg.replacement_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    reader: BinaryReader
  ): TestExtremeDefaultValues {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escaped_bytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.large_uint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.large_uint64 = reader.readUint64String();
          break;
        }
        case 4: {
          msg.small_int32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.small_int64 = reader.readInt64String();
          break;
        }
        case 21: {
          msg.really_small_int32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.really_small_int64 = reader.readInt64String();
          break;
        }
        case 6: {
          msg.utf8_string = reader.readString();
          break;
        }
        case 7: {
          msg.zero_float = reader.readFloat();
          break;
        }
        case 8: {
          msg.one_float = reader.readFloat();
          break;
        }
        case 9: {
          msg.small_float = reader.readFloat();
          break;
        }
        case 10: {
          msg.negative_one_float = reader.readFloat();
          break;
        }
        case 11: {
          msg.negative_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.large_float = reader.readFloat();
          break;
        }
        case 13: {
          msg.small_negative_float = reader.readFloat();
          break;
        }
        case 14: {
          msg.inf_double = reader.readDouble();
          break;
        }
        case 15: {
          msg.neg_inf_double = reader.readDouble();
          break;
        }
        case 16: {
          msg.nan_double = reader.readDouble();
          break;
        }
        case 17: {
          msg.inf_float = reader.readFloat();
          break;
        }
        case 18: {
          msg.neg_inf_float = reader.readFloat();
          break;
        }
        case 19: {
          msg.nan_float = reader.readFloat();
          break;
        }
        case 20: {
          msg.cpp_trigraph = reader.readString();
          break;
        }
        case 23: {
          msg.string_with_zero = reader.readString();
          break;
        }
        case 24: {
          msg.bytes_with_zero = reader.readBytes();
          break;
        }
        case 25: {
          msg.string_piece_with_zero = reader.readString();
          break;
        }
        case 26: {
          msg.cord_with_zero = reader.readString();
          break;
        }
        case 27: {
          msg.replacement_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (sparseEnumMessage: Partial<SparseEnumMessage>): Uint8Array {
    return SparseEnumMessage._writeMessage(
      sparseEnumMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes: ByteSource): SparseEnumMessage {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparse_enum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SparseEnumMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sparse_enum) {
      writer.writeEnum(1, msg.sparse_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    reader: BinaryReader
  ): SparseEnumMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparse_enum = reader.readEnum() as TestSparseEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (oneString: Partial<OneString>): Uint8Array {
    return OneString._writeMessage(
      oneString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes: ByteSource): OneString {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, reader: BinaryReader): OneString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (moreString: Partial<MoreString>): Uint8Array {
    return MoreString._writeMessage(
      moreString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes: ByteSource): MoreString {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, reader: BinaryReader): MoreString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (oneBytes: Partial<OneBytes>): Uint8Array {
    return OneBytes._writeMessage(
      oneBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes: ByteSource): OneBytes {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, reader: BinaryReader): OneBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (moreBytes: Partial<MoreBytes>): Uint8Array {
    return MoreBytes._writeMessage(
      moreBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes: ByteSource): MoreBytes {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, reader: BinaryReader): MoreBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (int32Message: Partial<Int32Message>): Uint8Array {
    return Int32Message._writeMessage(
      int32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int32Message {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int32Message,
    reader: BinaryReader
  ): Int32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (uint32Message: Partial<Uint32Message>): Uint8Array {
    return Uint32Message._writeMessage(
      uint32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint32Message {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint32Message,
    reader: BinaryReader
  ): Uint32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (int64Message: Partial<Int64Message>): Uint8Array {
    return Int64Message._writeMessage(
      int64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int64Message {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int64Message,
    reader: BinaryReader
  ): Int64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (uint64Message: Partial<Uint64Message>): Uint8Array {
    return Uint64Message._writeMessage(
      uint64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint64Message {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint64Message,
    reader: BinaryReader
  ): Uint64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (boolMessage: Partial<BoolMessage>): Uint8Array {
    return BoolMessage._writeMessage(
      boolMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes: ByteSource): BoolMessage {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BoolMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, reader: BinaryReader): BoolMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (testOneof: Partial<TestOneof>): Uint8Array {
    return TestOneof._writeMessage(
      testOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      foo_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, reader: BinaryReader): TestOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.foo_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (fooGroup: Partial<TestOneof.FooGroup>): Uint8Array {
      return TestOneof.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      reader: BinaryReader
    ): TestOneof.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (
    testOneofBackwardsCompatible: Partial<TestOneofBackwardsCompatible>
  ): Uint8Array {
    return TestOneofBackwardsCompatible._writeMessage(
      testOneofBackwardsCompatible,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      foo_int: 0,
      foo_string: \\"\\",
      foo_message: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foo_int) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    reader: BinaryReader
  ): TestOneofBackwardsCompatible {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.foo_message, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (
      fooGroup: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Uint8Array {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      reader: BinaryReader
    ): TestOneofBackwardsCompatible.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      foo_message: TestOneof2.NestedMessage.initialize(),
      foo_lazy_message: TestOneof2.NestedMessage.initialize(),
      baz_int: 0,
      baz_string: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_cord != undefined) {
      writer.writeString(3, msg.foo_cord);
    }
    if (msg.foo_string_piece != undefined) {
      writer.writeString(4, msg.foo_string_piece);
    }
    if (msg.foo_bytes != undefined) {
      writer.writeBytes(5, msg.foo_bytes);
    }
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        7,
        msg.foo_message,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.foo_lazy_message != undefined) {
      writer.writeMessage(
        11,
        msg.foo_lazy_message,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.bar_int != undefined) {
      writer.writeInt32(12, msg.bar_int);
    }
    if (msg.bar_string != undefined) {
      writer.writeString(13, msg.bar_string);
    }
    if (msg.bar_cord != undefined) {
      writer.writeString(14, msg.bar_cord);
    }
    if (msg.bar_string_piece != undefined) {
      writer.writeString(15, msg.bar_string_piece);
    }
    if (msg.bar_bytes != undefined) {
      writer.writeBytes(16, msg.bar_bytes);
    }
    if (msg.bar_enum != undefined) {
      writer.writeEnum(17, msg.bar_enum);
    }
    if (msg.bar_string_with_empty_default != undefined) {
      writer.writeString(20, msg.bar_string_with_empty_default);
    }
    if (msg.bar_cord_with_empty_default != undefined) {
      writer.writeString(21, msg.bar_cord_with_empty_default);
    }
    if (msg.bar_string_piece_with_empty_default != undefined) {
      writer.writeString(22, msg.bar_string_piece_with_empty_default);
    }
    if (msg.bar_bytes_with_empty_default != undefined) {
      writer.writeBytes(23, msg.bar_bytes_with_empty_default);
    }
    if (msg.baz_int) {
      writer.writeInt32(18, msg.baz_int);
    }
    if (msg.baz_string) {
      writer.writeString(19, msg.baz_string);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          msg.foo_cord = reader.readString();
          break;
        }
        case 4: {
          msg.foo_string_piece = reader.readString();
          break;
        }
        case 5: {
          msg.foo_bytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.foo_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 7: {
          reader.readMessage(
            msg.foo_message,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.foo_lazy_message,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.bar_int = reader.readInt32();
          break;
        }
        case 13: {
          msg.bar_string = reader.readString();
          break;
        }
        case 14: {
          msg.bar_cord = reader.readString();
          break;
        }
        case 15: {
          msg.bar_string_piece = reader.readString();
          break;
        }
        case 16: {
          msg.bar_bytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.bar_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 20: {
          msg.bar_string_with_empty_default = reader.readString();
          break;
        }
        case 21: {
          msg.bar_cord_with_empty_default = reader.readString();
          break;
        }
        case 22: {
          msg.bar_string_piece_with_empty_default = reader.readString();
          break;
        }
        case 23: {
          msg.bar_bytes_with_empty_default = reader.readBytes();
          break;
        }
        case 18: {
          msg.baz_int = reader.readInt32();
          break;
        }
        case 19: {
          msg.baz_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 } as const,

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (fooGroup: Partial<TestOneof2.FooGroup>): Uint8Array {
      return TestOneof2.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      reader: BinaryReader
    ): TestOneof2.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestOneof2.NestedMessage>
    ): Uint8Array {
      return TestOneof2.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        qux_int: \\"\\",
        corge_int: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.qux_int) {
        writer.writeInt64String(1, msg.qux_int);
      }
      if (msg.corge_int?.length) {
        writer.writeRepeatedInt32(2, msg.corge_int);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      reader: BinaryReader
    ): TestOneof2.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.qux_int = reader.readInt64String();
            break;
          }
          case 2: {
            msg.corge_int.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (testRequiredOneof: Partial<TestRequiredOneof>): Uint8Array {
    return TestRequiredOneof._writeMessage(
      testRequiredOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredOneof {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      foo_message: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        3,
        msg.foo_message,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    reader: BinaryReader
  ): TestRequiredOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.foo_message,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestRequiredOneof.NestedMessage>
    ): Uint8Array {
      return TestRequiredOneof.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        required_double: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.required_double) {
        writer.writeDouble(1, msg.required_double);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      reader: BinaryReader
    ): TestRequiredOneof.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.required_double = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpacked_int32: [],
      unpacked_int64: [],
      unpacked_uint32: [],
      unpacked_uint64: [],
      unpacked_sint32: [],
      unpacked_sint64: [],
      unpacked_fixed32: [],
      unpacked_fixed64: [],
      unpacked_sfixed32: [],
      unpacked_sfixed64: [],
      unpacked_float: [],
      unpacked_double: [],
      unpacked_bool: [],
      unpacked_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.unpacked_int32?.length) {
      writer.writeRepeatedInt32(90, msg.unpacked_int32);
    }
    if (msg.unpacked_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpacked_int64);
    }
    if (msg.unpacked_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpacked_uint32);
    }
    if (msg.unpacked_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpacked_uint64);
    }
    if (msg.unpacked_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpacked_sint32);
    }
    if (msg.unpacked_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpacked_sint64);
    }
    if (msg.unpacked_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpacked_fixed32);
    }
    if (msg.unpacked_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpacked_fixed64);
    }
    if (msg.unpacked_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpacked_sfixed32);
    }
    if (msg.unpacked_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpacked_sfixed64);
    }
    if (msg.unpacked_float?.length) {
      writer.writeRepeatedFloat(100, msg.unpacked_float);
    }
    if (msg.unpacked_double?.length) {
      writer.writeRepeatedDouble(101, msg.unpacked_double);
    }
    if (msg.unpacked_bool?.length) {
      writer.writeRepeatedBool(102, msg.unpacked_bool);
    }
    if (msg.unpacked_enum?.length) {
      writer.writeRepeatedEnum(103, msg.unpacked_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpacked_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpacked_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.unpacked_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpacked_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.unpacked_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpacked_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.unpacked_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpacked_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.unpacked_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpacked_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.unpacked_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpacked_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpacked_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpacked_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */
  encode: function (
    testPackedExtensions: Partial<TestPackedExtensions>
  ): Uint8Array {
    return TestPackedExtensions._writeMessage(
      testPackedExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedExtensions {
    return TestPackedExtensions._readMessage(
      TestPackedExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedExtensions,
    reader: BinaryReader
  ): TestPackedExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */
  encode: function (
    testUnpackedExtensions: Partial<TestUnpackedExtensions>
  ): Uint8Array {
    return TestUnpackedExtensions._writeMessage(
      testUnpackedExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedExtensions {
    return TestUnpackedExtensions._readMessage(
      TestUnpackedExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedExtensions,
    reader: BinaryReader
  ): TestUnpackedExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (
    testDynamicExtensions: Partial<TestDynamicExtensions>
  ): Uint8Array {
    return TestDynamicExtensions._writeMessage(
      testDynamicExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestDynamicExtensions {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalar_extension: 0,
      enum_extension: 0,
      dynamic_enum_extension: 0,
      message_extension: ForeignMessage.initialize(),
      dynamic_message_extension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeated_extension: [],
      packed_extension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDynamicExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.scalar_extension) {
      writer.writeFixed32(2000, msg.scalar_extension);
    }
    if (msg.enum_extension) {
      writer.writeEnum(2001, msg.enum_extension);
    }
    if (msg.dynamic_enum_extension) {
      writer.writeEnum(2002, msg.dynamic_enum_extension);
    }
    if (msg.message_extension) {
      writer.writeMessage(
        2003,
        msg.message_extension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamic_message_extension) {
      writer.writeMessage(
        2004,
        msg.dynamic_message_extension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeated_extension?.length) {
      writer.writeRepeatedString(2005, msg.repeated_extension);
    }
    if (msg.packed_extension?.length) {
      writer.writeRepeatedSint32(2006, msg.packed_extension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    reader: BinaryReader
  ): TestDynamicExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalar_extension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enum_extension = reader.readEnum() as ForeignEnum;
          break;
        }
        case 2002: {
          msg.dynamic_enum_extension =
            reader.readEnum() as TestDynamicExtensions.DynamicEnumType;
          break;
        }
        case 2003: {
          reader.readMessage(
            msg.message_extension,
            ForeignMessage._readMessage
          );
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamic_message_extension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeated_extension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packed_extension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: 2200,
    DYNAMIC_BAR: 2201,
    DYNAMIC_BAZ: 2202,
  } as const,

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (
      dynamicMessageType: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Uint8Array {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        dynamicMessageType,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamic_field: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.dynamic_field) {
        writer.writeInt32(2100, msg.dynamic_field);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      reader: BinaryReader
    ): TestDynamicExtensions.DynamicMessageType {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamic_field = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (
    testRepeatedScalarDifferentTagSizes: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Uint8Array {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      testRepeatedScalarDifferentTagSizes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes: ByteSource): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeated_fixed32: [],
      repeated_int32: [],
      repeated_fixed64: [],
      repeated_int64: [],
      repeated_float: [],
      repeated_uint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeated_fixed32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(13, msg.repeated_int32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeated_fixed64);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeated_int64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(262142, msg.repeated_float);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeated_uint64);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    reader: BinaryReader
  ): TestRepeatedScalarDifferentTagSizes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 2047: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 262142: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (testParsingMerge: Partial<TestParsingMerge>): Uint8Array {
    return TestParsingMerge._writeMessage(
      testParsingMerge,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes: ByteSource): TestParsingMerge {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      required_all_types: TestAllTypes.initialize(),
      optional_all_types: TestAllTypes.initialize(),
      repeated_all_types: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestParsingMerge>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.required_all_types) {
      writer.writeMessage(
        1,
        msg.required_all_types,
        TestAllTypes._writeMessage
      );
    }
    if (msg.optional_all_types) {
      writer.writeMessage(
        2,
        msg.optional_all_types,
        TestAllTypes._writeMessage
      );
    }
    if (msg.repeated_all_types?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_all_types as any,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestParsingMerge,
    reader: BinaryReader
  ): TestParsingMerge {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.required_all_types, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optional_all_types, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          msg.repeated_all_types.push(
            reader.readMessage(
              TestAllTypes.initialize(),
              TestAllTypes._readMessage
            )
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (
      repeatedFieldsGenerator: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Uint8Array {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        repeatedFieldsGenerator,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.field1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.field2 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(
          3,
          msg.field3 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(
          1000,
          msg.ext1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(
          1001,
          msg.ext2 as any,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedFieldsGenerator {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.field1.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 2: {
            msg.field2.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 3: {
            msg.field3.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 1000: {
            msg.ext1.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          case 1001: {
            msg.ext2.push(
              reader.readMessage(
                TestAllTypes.initialize(),
                TestAllTypes._readMessage
              )
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (
        group1: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          group1,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (
        group2: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          group2,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestParsingMerge.OptionalGroup>
    ): Uint8Array {
      return TestParsingMerge.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optional_group_all_types: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.optional_group_all_types) {
        writer.writeMessage(
          11,
          msg.optional_group_all_types,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      reader: BinaryReader
    ): TestParsingMerge.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optional_group_all_types,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (
      repeatedGroup: Partial<TestParsingMerge.RepeatedGroup>
    ): Uint8Array {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeated_group_all_types: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.repeated_group_all_types) {
        writer.writeMessage(
          21,
          msg.repeated_group_all_types,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeated_group_all_types,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (
    testCommentInjectionMessage: Partial<TestCommentInjectionMessage>
  ): Uint8Array {
    return TestCommentInjectionMessage._writeMessage(
      testCommentInjectionMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    reader: BinaryReader
  ): TestCommentInjectionMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */
  encode: function (fooRequest: Partial<FooRequest>): Uint8Array {
    return FooRequest._writeMessage(
      fooRequest,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */
  decode: function (bytes: ByteSource): FooRequest {
    return FooRequest._readMessage(
      FooRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FooRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooRequest, reader: BinaryReader): FooRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */
  encode: function (fooResponse: Partial<FooResponse>): Uint8Array {
    return FooResponse._writeMessage(
      fooResponse,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */
  decode: function (bytes: ByteSource): FooResponse {
    return FooResponse._readMessage(
      FooResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FooResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooResponse, reader: BinaryReader): FooResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */
  encode: function (fooClientMessage: Partial<FooClientMessage>): Uint8Array {
    return FooClientMessage._writeMessage(
      fooClientMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */
  decode: function (bytes: ByteSource): FooClientMessage {
    return FooClientMessage._readMessage(
      FooClientMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FooClientMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FooClientMessage,
    reader: BinaryReader
  ): FooClientMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */
  encode: function (fooServerMessage: Partial<FooServerMessage>): Uint8Array {
    return FooServerMessage._writeMessage(
      fooServerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */
  decode: function (bytes: ByteSource): FooServerMessage {
    return FooServerMessage._readMessage(
      FooServerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FooServerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FooServerMessage,
    reader: BinaryReader
  ): FooServerMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */
  encode: function (barRequest: Partial<BarRequest>): Uint8Array {
    return BarRequest._writeMessage(
      barRequest,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */
  decode: function (bytes: ByteSource): BarRequest {
    return BarRequest._readMessage(
      BarRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BarRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BarRequest, reader: BinaryReader): BarRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */
  encode: function (barResponse: Partial<BarResponse>): Uint8Array {
    return BarResponse._writeMessage(
      barResponse,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */
  decode: function (bytes: ByteSource): BarResponse {
    return BarResponse._readMessage(
      BarResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BarResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BarResponse, reader: BinaryReader): BarResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (testJsonName: Partial<TestJsonName>): Uint8Array {
    return TestJsonName._writeMessage(
      testJsonName,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes: ByteSource): TestJsonName {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      field_name1: 0,
      fieldName2: 0,
      FieldName3: 0,
      _field_name4: 0,
      FIELD_NAME5: 0,
      field_name6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestJsonName>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.field_name1) {
      writer.writeInt32(1, msg.field_name1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg._field_name4) {
      writer.writeInt32(4, msg._field_name4);
    }
    if (msg.FIELD_NAME5) {
      writer.writeInt32(5, msg.FIELD_NAME5);
    }
    if (msg.field_name6) {
      writer.writeInt32(6, msg.field_name6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestJsonName,
    reader: BinaryReader
  ): TestJsonName {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field_name1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg._field_name4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELD_NAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field_name6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (
    testHugeFieldNumbers: Partial<TestHugeFieldNumbers>
  ): Uint8Array {
    return TestHugeFieldNumbers._writeMessage(
      testHugeFieldNumbers,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes: ByteSource): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optional_int32: 0,
      fixed_32: 0,
      repeated_int32: [],
      packed_int32: [],
      optional_enum: 0,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_message: ForeignMessage.initialize(),
      string_string_map: {},
      oneof_test_all_types: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_int32) {
      writer.writeInt32(536870000, msg.optional_int32);
    }
    if (msg.fixed_32) {
      writer.writeInt32(536870001, msg.fixed_32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeated_int32);
    }
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packed_int32);
    }
    if (msg.optional_enum) {
      writer.writeEnum(536870004, msg.optional_enum);
    }
    if (msg.optional_string) {
      writer.writeString(536870005, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(536870006, msg.optional_bytes);
    }
    if (msg.optional_message) {
      writer.writeMessage(
        536870007,
        msg.optional_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.string_string_map) {
      for (const key in msg.string_string_map) {
        writer.writeMessage(536870010, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeString(2, msg.string_string_map![key]);
        });
      }
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(536870011, msg.oneof_uint32);
    }
    if (msg.oneof_test_all_types != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneof_test_all_types,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(536870013, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(536870014, msg.oneof_bytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    reader: BinaryReader
  ): TestHugeFieldNumbers {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed_32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optional_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 536870005: {
          msg.optional_string = reader.readString();
          break;
        }
        case 536870006: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optional_message, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.string_string_map[key] = value;
            }
          });
          break;
        }
        case 536870011: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(
            msg.oneof_test_all_types,
            TestAllTypes._readMessage
          );
          break;
        }
        case 536870013: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Uint8Array {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        group_a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.group_a) {
        writer.writeInt32(536870009, msg.group_a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      reader: BinaryReader
    ): TestHugeFieldNumbers.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.group_a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (
    testExtensionInsideTable: Partial<TestExtensionInsideTable>
  ): Uint8Array {
    return TestExtensionInsideTable._writeMessage(
      testExtensionInsideTable,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    reader: BinaryReader
  ): TestExtensionInsideTable {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (
    testExtensionRangeSerialize: Partial<TestExtensionRangeSerialize>
  ): Uint8Array {
    return TestExtensionRangeSerialize._writeMessage(
      testExtensionRangeSerialize,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      foo_one: 0,
      foo_two: 0,
      foo_three: 0,
      foo_four: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foo_one) {
      writer.writeInt32(1, msg.foo_one);
    }
    if (msg.foo_two) {
      writer.writeInt32(6, msg.foo_two);
    }
    if (msg.foo_three) {
      writer.writeInt32(7, msg.foo_three);
    }
    if (msg.foo_four) {
      writer.writeInt32(13, msg.foo_four);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    reader: BinaryReader
  ): TestExtensionRangeSerialize {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_one = reader.readInt32();
          break;
        }
        case 6: {
          msg.foo_two = reader.readInt32();
          break;
        }
        case 7: {
          msg.foo_three = reader.readInt32();
          break;
        }
        case 13: {
          msg.foo_four = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/map_unittest.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type MapEnum = typeof MapEnum[keyof typeof MapEnum];

/**
 * Tests maps.
 */
export interface TestMap {
  map_int32_int32: Record<number, number | undefined>;
  map_int64_int64: Record<string, string | undefined>;
  map_uint32_uint32: Record<number, number | undefined>;
  map_uint64_uint64: Record<string, string | undefined>;
  map_sint32_sint32: Record<number, number | undefined>;
  map_sint64_sint64: Record<string, string | undefined>;
  map_fixed32_fixed32: Record<number, number | undefined>;
  map_fixed64_fixed64: Record<string, string | undefined>;
  map_sfixed32_sfixed32: Record<number, number | undefined>;
  map_sfixed64_sfixed64: Record<string, string | undefined>;
  map_int32_float: Record<number, number | undefined>;
  map_int32_double: Record<number, number | undefined>;
  map_bool_bool: Record<boolean, boolean | undefined>;
  map_string_string: Record<string, string | undefined>;
  map_int32_bytes: Record<number, Uint8Array | undefined>;
  map_int32_enum: Record<number, MapEnum | undefined>;
  map_int32_foreign_message: Record<number, ForeignMessage | undefined>;
  map_string_foreign_message: Record<string, ForeignMessage | undefined>;
  map_int32_all_types: Record<number, TestAllTypes | undefined>;
}

export interface TestMapSubmessage {
  test_map: TestMap;
}

export interface TestMessageMap {
  map_int32_message: Record<number, TestAllTypes | undefined>;
}

/**
 * Two map fields share the same entry default instance.
 */
export interface TestSameTypeMap {
  map1: Record<number, number | undefined>;
  map2: Record<number, number | undefined>;
}

/**
 * Test embedded message with required fields
 */
export interface TestRequiredMessageMap {
  map_field: Record<number, TestRequired | undefined>;
}

export interface TestArenaMap {
  map_int32_int32: Record<number, number | undefined>;
  map_int64_int64: Record<string, string | undefined>;
  map_uint32_uint32: Record<number, number | undefined>;
  map_uint64_uint64: Record<string, string | undefined>;
  map_sint32_sint32: Record<number, number | undefined>;
  map_sint64_sint64: Record<string, string | undefined>;
  map_fixed32_fixed32: Record<number, number | undefined>;
  map_fixed64_fixed64: Record<string, string | undefined>;
  map_sfixed32_sfixed32: Record<number, number | undefined>;
  map_sfixed64_sfixed64: Record<string, string | undefined>;
  map_int32_float: Record<number, number | undefined>;
  map_int32_double: Record<number, number | undefined>;
  map_bool_bool: Record<boolean, boolean | undefined>;
  map_string_string: Record<string, string | undefined>;
  map_int32_bytes: Record<number, Uint8Array | undefined>;
  map_int32_enum: Record<number, MapEnum | undefined>;
  map_int32_foreign_message: Record<number, ForeignMessage | undefined>;
}

/**
 * Previously, message cannot contain map field called \\"entry\\".
 */
export interface MessageContainingMapCalledEntry {
  entry: Record<number, number | undefined>;
}

export interface TestRecursiveMapMessage {
  a: Record<string, TestRecursiveMapMessage | undefined>;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: 0,
  MAP_ENUM_BAR: 1,
  MAP_ENUM_BAZ: 2,
} as const;

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (testMap: Partial<TestMap>): Uint8Array {
    return TestMap._writeMessage(testMap, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMap {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
      map_string_foreign_message: {},
      map_int32_all_types: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.map_int32_int32![key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key as unknown as string);
          mapWriter.writeInt64String(2, msg.map_int64_int64![key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key as unknown as number);
          mapWriter.writeUint32(2, msg.map_uint32_uint32![key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key as unknown as string);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64![key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key as unknown as number);
          mapWriter.writeSint32(2, msg.map_sint32_sint32![key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key as unknown as string);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64![key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key as unknown as number);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32![key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key as unknown as string);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64![key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key as unknown as number);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32![key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key as unknown as string);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64![key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeFloat(2, msg.map_int32_float![key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeDouble(2, msg.map_int32_double![key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key as unknown as boolean);
          mapWriter.writeBool(2, msg.map_bool_bool![key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeString(2, msg.map_string_string![key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeBytes(2, msg.map_int32_bytes![key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeEnum(2, msg.map_int32_enum![key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message![key]);
        });
      }
    }
    if (msg.map_string_foreign_message) {
      for (const key in msg.map_string_foreign_message) {
        writer.writeMessage(18, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeMessage(2, msg.map_string_foreign_message![key]);
        });
      }
    }
    if (msg.map_int32_all_types) {
      for (const key in msg.map_int32_all_types) {
        writer.writeMessage(19, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.map_int32_all_types![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, reader: BinaryReader): TestMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int64_int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint32_uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint64_uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint32_sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint64_sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed32_fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed64_fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed32_sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed64_sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean | undefined;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.map_bool_bool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.map_string_string[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_foreign_message[key] = value;
            }
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_string_foreign_message[key] = value;
            }
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_all_types[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (testMapSubmessage: Partial<TestMapSubmessage>): Uint8Array {
    return TestMapSubmessage._writeMessage(
      testMapSubmessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestMapSubmessage {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      test_map: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMapSubmessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.test_map) {
      writer.writeMessage(1, msg.test_map, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    reader: BinaryReader
  ): TestMapSubmessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.test_map, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (testMessageMap: Partial<TestMessageMap>): Uint8Array {
    return TestMessageMap._writeMessage(
      testMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageMap {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      map_int32_message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map_int32_message) {
      for (const key in msg.map_int32_message) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.map_int32_message![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageMap,
    reader: BinaryReader
  ): TestMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (testSameTypeMap: Partial<TestSameTypeMap>): Uint8Array {
    return TestSameTypeMap._writeMessage(
      testSameTypeMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestSameTypeMap {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestSameTypeMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map1) {
      for (const key in msg.map1) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.map1![key]);
        });
      }
    }
    if (msg.map2) {
      for (const key in msg.map2) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.map2![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestSameTypeMap,
    reader: BinaryReader
  ): TestSameTypeMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map1[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map2[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (
    testRequiredMessageMap: Partial<TestRequiredMessageMap>
  ): Uint8Array {
    return TestRequiredMessageMap._writeMessage(
      testRequiredMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      map_field: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map_field) {
      for (const key in msg.map_field) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.map_field![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    reader: BinaryReader
  ): TestRequiredMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_field[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (testArenaMap: Partial<TestArenaMap>): Uint8Array {
    return TestArenaMap._writeMessage(
      testArenaMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestArenaMap {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestArenaMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.map_int32_int32![key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key as unknown as string);
          mapWriter.writeInt64String(2, msg.map_int64_int64![key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key as unknown as number);
          mapWriter.writeUint32(2, msg.map_uint32_uint32![key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key as unknown as string);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64![key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key as unknown as number);
          mapWriter.writeSint32(2, msg.map_sint32_sint32![key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key as unknown as string);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64![key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key as unknown as number);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32![key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key as unknown as string);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64![key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key as unknown as number);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32![key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key as unknown as string);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64![key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeFloat(2, msg.map_int32_float![key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeDouble(2, msg.map_int32_double![key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key as unknown as boolean);
          mapWriter.writeBool(2, msg.map_bool_bool![key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeString(2, msg.map_string_string![key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeBytes(2, msg.map_int32_bytes![key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeEnum(2, msg.map_int32_enum![key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestArenaMap,
    reader: BinaryReader
  ): TestArenaMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int64_int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint32_uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_uint64_uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint32_sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sint64_sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed32_fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.map_fixed64_fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed32_sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.map_sfixed64_sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean | undefined;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.map_bool_bool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.map_string_string[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.map_int32_foreign_message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (
    messageContainingMapCalledEntry: Partial<MessageContainingMapCalledEntry>
  ): Uint8Array {
    return MessageContainingMapCalledEntry._writeMessage(
      messageContainingMapCalledEntry,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes: ByteSource): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.entry) {
      for (const key in msg.entry) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.entry![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    reader: BinaryReader
  ): MessageContainingMapCalledEntry {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.entry[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (
    testRecursiveMapMessage: Partial<TestRecursiveMapMessage>
  ): Uint8Array {
    return TestRecursiveMapMessage._writeMessage(
      testRecursiveMapMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      for (const key in msg.a) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeMessage(2, msg.a![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    reader: BinaryReader
  ): TestRecursiveMapMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.a[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_proto3.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optional_int32: number;
  optional_int64: string;
  optional_uint32: number;
  optional_uint64: string;
  optional_sint32: number;
  optional_sint64: string;
  optional_fixed32: number;
  optional_fixed64: string;
  optional_sfixed32: number;
  optional_sfixed64: string;
  optional_float: number;
  optional_double: number;
  optional_bool: boolean;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_nested_message: TestAllTypes.NestedMessage;
  optional_foreign_message: ForeignMessage;
  optional_import_message: ImportMessage;
  optional_nested_enum: TestAllTypes.NestedEnum;
  optional_foreign_enum: ForeignEnum;
  optional_string_piece: string;
  optional_cord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optional_public_import_message: PublicImportMessage;
  optional_lazy_message: TestAllTypes.NestedMessage;
  optional_lazy_import_message: ImportMessage;
  /**
   * Repeated
   */
  repeated_int32: number[];
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_string: string[];
  repeated_bytes: Uint8Array[];
  repeated_nested_message: TestAllTypes.NestedMessage[];
  repeated_foreign_message: ForeignMessage[];
  repeated_import_message: ImportMessage[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
  repeated_foreign_enum: ForeignEnum[];
  repeated_string_piece: string[];
  repeated_cord: string[];
  repeated_lazy_message: TestAllTypes.NestedMessage[];
  oneof_uint32?: number;
  oneof_nested_message?: TestAllTypes.NestedMessage;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packed_int32: number[];
  packed_int64: string[];
  packed_uint32: number[];
  packed_uint64: string[];
  packed_sint32: number[];
  packed_sint64: string[];
  packed_fixed32: number[];
  packed_fixed64: string[];
  packed_sfixed32: number[];
  packed_sfixed64: string[];
  packed_float: number[];
  packed_double: number[];
  packed_bool: boolean[];
  packed_enum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeated_int32: number[];
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  foo_enum?: TestOneof2.NestedEnum;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.initialize(),
      optional_foreign_message: ForeignMessage.initialize(),
      optional_import_message: ImportMessage.initialize(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.initialize(),
      optional_lazy_message: TestAllTypes.NestedMessage.initialize(),
      optional_lazy_import_message: ImportMessage.initialize(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      oneof_nested_message: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optional_lazy_import_message) {
      writer.writeMessage(
        115,
        msg.optional_lazy_import_message,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optional_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optional_foreign_message,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optional_import_message,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optional_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optional_public_import_message,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optional_lazy_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optional_lazy_import_message,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          msg.repeated_nested_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 49: {
          msg.repeated_foreign_message.push(
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            )
          );
          break;
        }
        case 50: {
          msg.repeated_import_message.push(
            reader.readMessage(
              ImportMessage.initialize(),
              ImportMessage._readMessage
            )
          );
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          msg.repeated_lazy_message.push(
            reader.readMessage(
              TestAllTypes.NestedMessage.initialize(),
              TestAllTypes.NestedMessage._readMessage
            )
          );
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneof_nested_message,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_nested_enum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(1, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(11, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(12, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(13, msg.repeated_bool);
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(14, msg.repeated_nested_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (testEmptyMessage: Partial<TestEmptyMessage>): Uint8Array {
    return TestEmptyMessage._writeMessage(
      testEmptyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEmptyMessage {
    return TestEmptyMessage._readMessage(
      TestEmptyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEmptyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEmptyMessage,
    reader: BinaryReader
  ): TestEmptyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (
    testMessageWithDummy: Partial<TestMessageWithDummy>
  ): Uint8Array {
    return TestMessageWithDummy._writeMessage(
      testMessageWithDummy,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageWithDummy {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageWithDummy>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    reader: BinaryReader
  ): TestMessageWithDummy {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.foo_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 } as const,
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
    ],
  },
}
`;
