// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Generated by TwirpScript v0.0.35
// Source: 34/address.proto

import type { ByteSource } from "twirpscript";
import { BinaryReader, BinaryWriter } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

export interface GetUserResponse {
  user_id: string;
  addresses: GetUserResponse.AddressList;
}

export namespace GetUserResponse {
  export interface Address {
    id: string;
    value: AddressValue;
  }

  export interface AddressList {
    address: GetUserResponse.Address[];
    primary: GetUserResponse.Address;
  }
}

export interface AddressValue {
  address_line1?: string;
  address_line2?: string;
  country_code?: string;
  postcode?: string;
  state?: string;
  suburb?: string;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const GetUserResponse = {
  writeMessage: function (msg: GetUserResponse, writer: BinaryWriter): void {
    if (msg.user_id) {
      writer.writeString(1, msg.user_id);
    }
    if (msg.addresses) {
      writer.writeMessage(
        2,
        msg.addresses,
        GetUserResponse.AddressList.writeMessage
      );
    }
  },

  encode: function (getUserResponse: GetUserResponse): Uint8Array {
    const writer = new BinaryWriter();
    GetUserResponse.writeMessage(getUserResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<GetUserResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.user_id = reader.readString();
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, GetUserResponse.AddressList.readMessage);
          msg.addresses = message as GetUserResponse.AddressList;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.user_id) {
      msg.user_id = "";
    }
    if (!msg.addresses) {
      msg.addresses = GetUserResponse.AddressList.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): GetUserResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    GetUserResponse.readMessage(message, reader);
    return message as GetUserResponse;
  },

  defaultValue: function (): GetUserResponse {
    return {
      user_id: "",
      addresses: GetUserResponse.AddressList.defaultValue(),
    };
  },

  Address: {
    writeMessage: function (
      msg: GetUserResponse.Address,
      writer: BinaryWriter
    ): void {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, AddressValue.writeMessage);
      }
    },

    encode: function (address: GetUserResponse.Address): Uint8Array {
      const writer = new BinaryWriter();
      GetUserResponse.Address.writeMessage(address, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<GetUserResponse.Address>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, AddressValue.readMessage);
            msg.value = message as AddressValue;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.id) {
        msg.id = "";
      }
      if (!msg.value) {
        msg.value = AddressValue.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): GetUserResponse.Address {
      const reader = new BinaryReader(bytes);
      const message = {};
      GetUserResponse.Address.readMessage(message, reader);
      return message as GetUserResponse.Address;
    },

    defaultValue: function (): GetUserResponse.Address {
      return {
        id: "",
        value: AddressValue.defaultValue(),
      };
    },
  },

  AddressList: {
    writeMessage: function (
      msg: GetUserResponse.AddressList,
      writer: BinaryWriter
    ): void {
      if (msg.address.length > 0) {
        writer.writeRepeatedMessage(
          1,
          msg.address as any,
          GetUserResponse.Address.writeMessage
        );
      }
      if (msg.primary) {
        writer.writeMessage(
          2,
          msg.primary,
          GetUserResponse.Address.writeMessage
        );
      }
    },

    encode: function (addressList: GetUserResponse.AddressList): Uint8Array {
      const writer = new BinaryWriter();
      GetUserResponse.AddressList.writeMessage(addressList, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<GetUserResponse.AddressList>,
      reader: BinaryReader
    ): void {
      msg.address = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const message = {};
            reader.readMessage(message, GetUserResponse.Address.readMessage);
            msg.address.push(message as GetUserResponse.Address);
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, GetUserResponse.Address.readMessage);
            msg.primary = message as GetUserResponse.Address;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.primary) {
        msg.primary = GetUserResponse.Address.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): GetUserResponse.AddressList {
      const reader = new BinaryReader(bytes);
      const message = {};
      GetUserResponse.AddressList.readMessage(message, reader);
      return message as GetUserResponse.AddressList;
    },

    defaultValue: function (): GetUserResponse.AddressList {
      return {
        address: [],
        primary: GetUserResponse.Address.defaultValue(),
      };
    },
  },
};

export const AddressValue = {
  writeMessage: function (msg: AddressValue, writer: BinaryWriter): void {
    if (msg.address_line1 != undefined) {
      writer.writeString(1, msg.address_line1);
    }
    if (msg.address_line2 != undefined) {
      writer.writeString(2, msg.address_line2);
    }
    if (msg.country_code != undefined) {
      writer.writeString(3, msg.country_code);
    }
    if (msg.postcode != undefined) {
      writer.writeString(4, msg.postcode);
    }
    if (msg.state != undefined) {
      writer.writeString(5, msg.state);
    }
    if (msg.suburb != undefined) {
      writer.writeString(6, msg.suburb);
    }
  },

  encode: function (addressValue: AddressValue): Uint8Array {
    const writer = new BinaryWriter();
    AddressValue.writeMessage(addressValue, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<AddressValue>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.address_line1 = reader.readString();
          break;
        }
        case 2: {
          msg.address_line2 = reader.readString();
          break;
        }
        case 3: {
          msg.country_code = reader.readString();
          break;
        }
        case 4: {
          msg.postcode = reader.readString();
          break;
        }
        case 5: {
          msg.state = reader.readString();
          break;
        }
        case 6: {
          msg.suburb = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): AddressValue {
    const reader = new BinaryReader(bytes);
    const message = {};
    AddressValue.readMessage(message, reader);
    return message as AddressValue;
  },

  defaultValue: function (): AddressValue {
    return {};
  },
};
